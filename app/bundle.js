var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends2;
  var __assign;
  var __rest;
  var __decorate2;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata2;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends2 = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate2 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata2 = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate2);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata2);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = () => {
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
  };
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS((exports) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  function lruMemoize(f3) {
    var cache = [];
    return function(input) {
      for (var i4 = 0;i4 < cache.length; i4++) {
        if (cache[i4].input === input) {
          var temp = cache[0];
          cache[0] = cache[i4];
          cache[i4] = temp;
          return cache[0].result;
        }
      }
      var result = f3(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  }
  var normalize2 = lruMemoize(function normalize(aPath) {
    var path2 = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path2 = url.path;
    }
    var isAbsolute = exports.isAbsolute(path2);
    var parts = [];
    var start2 = 0;
    var i4 = 0;
    while (true) {
      start2 = i4;
      i4 = path2.indexOf("/", start2);
      if (i4 === -1) {
        parts.push(path2.slice(start2));
        break;
      } else {
        parts.push(path2.slice(start2, i4));
        while (i4 < path2.length && path2[i4] === "/") {
          i4++;
        }
      }
    }
    for (var part, up = 0, i4 = parts.length - 1;i4 >= 0; i4--) {
      part = parts[i4];
      if (part === ".") {
        parts.splice(i4, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i4 + 1, up);
          up = 0;
        } else {
          parts.splice(i4, 2);
          up--;
        }
      }
    }
    path2 = parts.join("/");
    if (path2 === "") {
      path2 = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path2;
      return urlGenerate(url);
    }
    return path2;
  });
  exports.normalize = normalize2;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level2 = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level2;
    }
    return Array(level2 + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s3) {
    return s3;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s3) {
    if (!s3) {
      return false;
    }
    var length = s3.length;
    if (length < 9) {
      return false;
    }
    if (s3.charCodeAt(length - 1) !== 95 || s3.charCodeAt(length - 2) !== 95 || s3.charCodeAt(length - 3) !== 111 || s3.charCodeAt(length - 4) !== 116 || s3.charCodeAt(length - 5) !== 111 || s3.charCodeAt(length - 6) !== 114 || s3.charCodeAt(length - 7) !== 112 || s3.charCodeAt(length - 8) !== 95 || s3.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i4 = length - 10;i4 >= 0; i4--) {
      if (s3.charCodeAt(i4) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;
  function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize2(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var util = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set2 = new ArraySet;
    for (var i4 = 0, len = aArray.length;i4 < len; i4++) {
      set2.add(aArray[i4], aAllowDuplicates);
    }
    return set2;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var util = require_util();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var modules_default = import_tslib.default;

// node_modules/@nativescript/core/timer/index.android.js
var exports_index_android = {};
__export(exports_index_android, {
  setTimeout: () => setTimeout2,
  setInterval: () => setInterval,
  clearTimeout: () => clearTimeout2,
  clearInterval: () => clearInterval
});
var timeoutHandler;
var timeoutCallbacks = {};
var timeoutCallbacksCb = {};
var timerId = 0;
function createHandlerAndGetId() {
  if (!timeoutHandler) {
    timeoutHandler = new android.os.Handler(android.os.Looper.myLooper());
  }
  timerId++;
  return timerId;
}
function setTimeout2(callback, milliseconds = 0, ...args) {
  milliseconds += 0;
  const id = createHandlerAndGetId();
  const invoke = () => callback(...args);
  const zoneBound = zonedCallback(invoke);
  const runnable = new java.lang.Runnable({
    run: () => {
      zoneBound();
      if (timeoutCallbacks[id]) {
        delete timeoutCallbacks[id];
        delete timeoutCallbacksCb[id];
      }
    }
  });
  if (!timeoutCallbacks[id]) {
    timeoutCallbacks[id] = runnable;
    timeoutCallbacksCb[id] = callback;
  }
  timeoutHandler.postDelayed(runnable, long(milliseconds));
  return id;
}
function clearTimeout2(id) {
  const index = id;
  if (timeoutCallbacks[index]) {
    timeoutHandler.removeCallbacks(timeoutCallbacks[index]);
    delete timeoutCallbacks[index];
    delete timeoutCallbacksCb[index];
  }
}
function setInterval(callback, milliseconds = 0, ...args) {
  milliseconds += 0;
  const id = createHandlerAndGetId();
  const handler = timeoutHandler;
  const invoke = () => callback(...args);
  const zoneBound = zonedCallback(invoke);
  let nextDueTime = Date.now() + milliseconds;
  const runnable = new java.lang.Runnable({
    run: () => {
      const executionStart = Date.now();
      zoneBound();
      if (timeoutCallbacks[id]) {
        const executionTime = Date.now() - executionStart;
        nextDueTime += milliseconds;
        const now = Date.now();
        if (nextDueTime <= now) {
          const missedIntervals = Math.floor((now - nextDueTime) / milliseconds);
          nextDueTime += (missedIntervals + 1) * milliseconds;
        }
        const delay = Math.max(0, nextDueTime - now);
        handler.postDelayed(runnable, long(delay));
      }
    }
  });
  if (!timeoutCallbacks[id]) {
    timeoutCallbacks[id] = runnable;
    timeoutCallbacksCb[id] = callback;
  }
  handler.postDelayed(runnable, long(milliseconds));
  return id;
}
var clearInterval = clearTimeout2;

// node_modules/@nativescript/core/animation-frame/index.js
var exports_animation_frame = {};
__export(exports_animation_frame, {
  requestAnimationFrame: () => requestAnimationFrame2,
  cancelAnimationFrame: () => cancelAnimationFrame2
});

// node_modules/@nativescript/core/trace/index.js
var enabled = false;
var _categories = {};
var _writers = [];
var _eventListeners = [];
var _errorHandler;
var Trace;
(function(Trace2) {
  function enable() {
    enabled = true;
  }
  Trace2.enable = enable;
  function disable() {
    enabled = false;
  }
  Trace2.disable = disable;
  function isEnabled() {
    return enabled;
  }
  Trace2.isEnabled = isEnabled;
  function addWriter(writer) {
    _writers.push(writer);
  }
  Trace2.addWriter = addWriter;
  function removeWriter(writer) {
    const index = _writers.indexOf(writer);
    if (index >= 0) {
      _writers.splice(index, 1);
    }
  }
  Trace2.removeWriter = removeWriter;
  function clearWriters() {
    if (_writers.length > 0) {
      _writers.splice(0, _writers.length);
    }
  }
  Trace2.clearWriters = clearWriters;
  function setCategories(categories2) {
    _categories = {};
    addCategories(categories2);
  }
  Trace2.setCategories = setCategories;
  function addCategories(categories2) {
    const split = categories2.split(",");
    for (let i = 0;i < split.length; i++) {
      _categories[split[i].trim()] = true;
    }
  }
  Trace2.addCategories = addCategories;
  function isCategorySet(category) {
    return category in _categories;
  }
  Trace2.isCategorySet = isCategorySet;
  function write(message, category, type) {
    let i;
    if (type === messageType.error) {
      for (i = 0;i < _writers.length; i++) {
        _writers[i].write(message, category, type);
      }
      return;
    }
    if (!enabled) {
      return;
    }
    if (!(category in _categories)) {
      return;
    }
    for (i = 0;i < _writers.length; i++) {
      _writers[i].write(message, category, type);
    }
  }
  Trace2.write = write;
  function notifyEvent(object, name, data) {
    if (!enabled) {
      return;
    }
    let i, listener, filters;
    for (i = 0;i < _eventListeners.length; i++) {
      listener = _eventListeners[i];
      if (listener.filter) {
        filters = listener.filter.split(",");
        filters.forEach((value) => {
          if (value.trim() === name) {
            listener.on(object, name, data);
          }
        });
      } else {
        listener.on(object, name, data);
      }
    }
  }
  Trace2.notifyEvent = notifyEvent;
  function addEventListener2(listener) {
    _eventListeners.push(listener);
  }
  Trace2.addEventListener = addEventListener2;
  function removeEventListener2(listener) {
    const index = _eventListeners.indexOf(listener);
    if (index >= 0) {
      _eventListeners.splice(index, 1);
    }
  }
  Trace2.removeEventListener = removeEventListener2;
  let messageType;
  (function(messageType2) {
    messageType2.log = 0;
    messageType2.info = 1;
    messageType2.warn = 2;
    messageType2.error = 3;
  })(messageType = Trace2.messageType || (Trace2.messageType = {}));
  let categories;
  (function(categories2) {
    categories2.Accessibility = "Accessibility";
    categories2.VisualTreeEvents = "VisualTreeEvents";
    categories2.Layout = "Layout";
    categories2.Style = "Style";
    categories2.ViewHierarchy = "ViewHierarchy";
    categories2.NativeLifecycle = "NativeLifecycle";
    categories2.Debug = "Debug";
    categories2.Navigation = "Navigation";
    categories2.Test = "Test";
    categories2.Binding = "Binding";
    categories2.BindingError = "BindingError";
    categories2.Error = "Error";
    categories2.Animation = "Animation";
    categories2.Transition = "Transition";
    categories2.Livesync = "Livesync";
    categories2.ModuleNameResolver = "ModuleNameResolver";
    categories2.MediaQuery = "MediaQuery";
    categories2.separator = ",";
    categories2.All = [categories2.VisualTreeEvents, categories2.Layout, categories2.Style, categories2.ViewHierarchy, categories2.NativeLifecycle, categories2.Debug, categories2.Navigation, categories2.Test, categories2.Binding, categories2.Error, categories2.Animation, categories2.Transition, categories2.Livesync, categories2.ModuleNameResolver, categories2.MediaQuery].join(categories2.separator);
    function concat(...args) {
      let result;
      for (let i = 0;i < args.length; i++) {
        if (!result) {
          result = args[i];
          continue;
        }
        result = result.concat(categories2.separator, args[i]);
      }
      return result;
    }
    categories2.concat = concat;
  })(categories = Trace2.categories || (Trace2.categories = {}));

  class ConsoleWriter {
    write(message, category, type) {
      if (!console) {
        return;
      }
      let msgType;
      if (type === undefined) {
        msgType = messageType.log;
      } else {
        msgType = type;
      }
      switch (msgType) {
        case messageType.log:
          console.log(category + ": " + message);
          break;
        case messageType.info:
          console.info(category + ": " + message);
          break;
        case messageType.warn:
          console.warn(category + ": " + message);
          break;
        case messageType.error:
          console.error(category + ": " + message);
          break;
      }
    }
  }
  addWriter(new ConsoleWriter);

  class DefaultErrorHandler {
    handlerError(error2) {
      throw error2;
    }
  }
  Trace2.DefaultErrorHandler = DefaultErrorHandler;
  setErrorHandler(new DefaultErrorHandler);
  function getErrorHandler() {
    return _errorHandler;
  }
  Trace2.getErrorHandler = getErrorHandler;
  function setErrorHandler(handler) {
    _errorHandler = handler;
  }
  Trace2.setErrorHandler = setErrorHandler;
  function error(error2) {
    if (!_errorHandler) {
      return;
    }
    if (typeof error2 === "string") {
      error2 = new Error(error2);
    }
    _errorHandler.handlerError(error2);
  }
  Trace2.error = error;
})(Trace || (Trace = {}));

// node_modules/@nativescript/core/utils/platform-check.js
function platformCheck(parent) {
  if (__DEV__) {
    return new Proxy({}, {
      get(_, prop) {
        const propPretty = [parent, prop.toString()].join(".");
        const hintPlatformCheck = __ANDROID__ ? "__IOS__" : "__ANDROID__";
        const errorMsg = [
          `Trying to access "${propPretty}" without checking platform first.`,
          `Hint: Use "${hintPlatformCheck}" to check platform before accessing "${propPretty}".`
        ].join(`
`);
        throw new Error(errorMsg);
      }
    });
  }
  return;
}

// node_modules/@nativescript/core/utils/types.js
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isFunction(value) {
  if (!value) {
    return false;
  }
  return typeof value === "function";
}
function isObject(value) {
  if (!value) {
    return false;
  }
  return typeof value === "object";
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isDefined(value) {
  return typeof value !== "undefined";
}
function isNullOrUndefined(value) {
  return typeof value === "undefined" || value === null;
}
function verifyCallback(value) {
  if (value && !isFunction(value)) {
    throw new TypeError("Callback must be a valid function.");
  }
}
function numberHasDecimals(value) {
  return !(value % 1 === 0);
}
function numberIs64Bit(value) {
  return value < -Math.pow(2, 31) + 1 || value > Math.pow(2, 31) - 1;
}
var classInfosMap = new Map;
var funcNameRegex = /(?:function|class)\s+(\w+).*/;
function getClass(object) {
  return getClassInfo(object).name;
}
function getClassInfo(object) {
  const constructor = object.constructor;
  let result = classInfosMap.get(constructor);
  if (!result) {
    result = new ClassInfo(constructor);
    classInfosMap.set(constructor, result);
  }
  return result;
}
function getBaseClasses(object) {
  const result = [];
  let info = getClassInfo(object);
  while (info) {
    result.push(info.name);
    info = info.baseClassInfo;
  }
  return result;
}

class ClassInfo {
  constructor(typeConstructor) {
    this._typeConstructor = typeConstructor;
  }
  get name() {
    if (!this._name) {
      if (this._typeConstructor.name) {
        this._name = this._typeConstructor.name;
      } else {
        const results = funcNameRegex.exec(this._typeConstructor.toString());
        this._name = results && results.length > 1 ? results[1] : "";
      }
    }
    return this._name;
  }
  get baseClassInfo() {
    if (isUndefined(this._baseClassInfo)) {
      this._baseClassInfo = ClassInfo._getBase(this);
      if (this._baseClassInfo && this._baseClassInfo.name === this.name) {
        this._baseClassInfo = ClassInfo._getBase(this._baseClassInfo);
      }
    }
    return this._baseClassInfo;
  }
  static _getBase(info) {
    let result = null;
    const constructorProto = info._typeConstructor.prototype;
    if (constructorProto.__proto__) {
      result = getClassInfo(constructorProto.__proto__);
    }
    return result;
  }
}
function toUIString(obj) {
  return isNullOrUndefined(obj) ? "" : obj + "";
}

// node_modules/@nativescript/core/color/known-colors.js
var _allColors = {};
function registerColor(name, value) {
  if (Array.isArray(name)) {
    name.forEach((n) => _allColors[n.toLowerCase()] = value);
  } else {
    _allColors[name.toLowerCase()] = value;
  }
  return value;
}
function isKnownName(name) {
  if (!name) {
    return;
  }
  return name.toLowerCase() in _allColors;
}
function getKnownColor(name) {
  if (!name) {
    return;
  }
  return _allColors[name.toLowerCase()];
}
var Transparent = registerColor("Transparent", 0);
var AliceBlue = registerColor("AliceBlue", 4293982463);
var AntiqueWhite = registerColor("AntiqueWhite", 4294634455);
var Aqua = registerColor("Aqua", 4278255615);
var Aquamarine = registerColor("Aquamarine", 4286578644);
var Azure = registerColor("Azure", 4293984255);
var Beige = registerColor("Beige", 4294309340);
var Bisque = registerColor("Bisque", 4294960324);
var Black = registerColor("Black", 4278190080);
var BlanchedAlmond = registerColor("BlanchedAlmond", 4294962125);
var Blue = registerColor("Blue", 4278190335);
var BlueViolet = registerColor("BlueViolet", 4287245282);
var Brown = registerColor("Brown", 4289014314);
var BurlyWood = registerColor("BurlyWood", 4292786311);
var CadetBlue = registerColor("CadetBlue", 4284456608);
var Chartreuse = registerColor("Chartreuse", 4286578432);
var Chocolate = registerColor("Chocolate", 4291979550);
var Coral = registerColor("Coral", 4294934352);
var CornflowerBlue = registerColor("CornflowerBlue", 4284782061);
var Cornsilk = registerColor("Cornsilk", 4294965468);
var Crimson = registerColor("Crimson", 4292613180);
var Cyan = registerColor("Cyan", 4278255615);
var DarkBlue = registerColor("DarkBlue", 4278190219);
var DarkCyan = registerColor("DarkCyan", 4278225803);
var DarkGoldenRod = registerColor("DarkGoldenRod", 4290283019);
var DarkGray = registerColor(["DarkGray", "DarkGrey"], 4289309097);
var DarkGreen = registerColor("DarkGreen", 4278215680);
var DarkKhaki = registerColor("DarkKhaki", 4290623339);
var DarkMagenta = registerColor("DarkMagenta", 4287299723);
var DarkOliveGreen = registerColor("DarkOliveGreen", 4283788079);
var DarkOrange = registerColor("DarkOrange", 4294937600);
var DarkOrchid = registerColor("DarkOrchid", 4288230092);
var DarkRed = registerColor("DarkRed", 4287299584);
var DarkSalmon = registerColor("DarkSalmon", 4293498490);
var DarkSeaGreen = registerColor("DarkSeaGreen", 4287609999);
var DarkSlateBlue = registerColor("DarkSlateBlue", 4282924427);
var DarkSlateGray = registerColor(["DarkSlateGray", "DarkSlateGrey"], 4281290575);
var DarkTurquoise = registerColor("DarkTurquoise", 4278243025);
var DarkViolet = registerColor("DarkViolet", 4287889619);
var DeepPink = registerColor("DeepPink", 4294907027);
var DeepSkyBlue = registerColor("DeepSkyBlue", 4278239231);
var DimGray = registerColor(["DimGray", "DimGrey"], 4285098345);
var DodgerBlue = registerColor("DodgerBlue", 4280193279);
var FireBrick = registerColor("FireBrick", 4289864226);
var FloralWhite = registerColor("FloralWhite", 4294966000);
var ForestGreen = registerColor("ForestGreen", 4280453922);
var Fuchsia = registerColor("Fuchsia", 4294902015);
var Gainsboro = registerColor("Gainsboro", 4292664540);
var GhostWhite = registerColor("GhostWhite", 4294506751);
var Gold = registerColor("Gold", 4294956800);
var GoldenRod = registerColor("GoldenRod", 4292519200);
var Gray = registerColor(["Gray", "Grey"], 4286611584);
var Green = registerColor("Green", 4278222848);
var GreenYellow = registerColor("GreenYellow", 4289593135);
var HoneyDew = registerColor("HoneyDew", 4293984240);
var HotPink = registerColor("HotPink", 4294928820);
var IndianRed = registerColor("IndianRed", 4291648604);
var Indigo = registerColor("Indigo", 4283105410);
var Ivory = registerColor("Ivory", 4294967280);
var Khaki = registerColor("Khaki", 4293977740);
var Lavender = registerColor("Lavender", 4293322490);
var LavenderBlush = registerColor("LavenderBlush", 4294963445);
var LawnGreen = registerColor("LawnGreen", 4286381056);
var LemonChiffon = registerColor("LemonChiffon", 4294965965);
var LightBlue = registerColor("LightBlue", 4289583334);
var LightCoral = registerColor("LightCoral", 4293951616);
var LightCyan = registerColor("LightCyan", 4292935679);
var LightGoldenRodYellow = registerColor("LightGoldenRodYellow", 4294638290);
var LightGray = registerColor(["LightGray", "LightGrey"], 4292072403);
var LightGreen = registerColor("LightGreen", 4287688336);
var LightPink = registerColor("LightPink", 4294948545);
var LightSalmon = registerColor("LightSalmon", 4294942842);
var LightSeaGreen = registerColor("LightSeaGreen", 4280332970);
var LightSkyBlue = registerColor("LightSkyBlue", 4287090426);
var LightSlateGray = registerColor(["LightSlateGray", "LightSlateGrey"], 4286023833);
var LightSteelBlue = registerColor("LightSteelBlue", 4289774814);
var LightYellow = registerColor("LightYellow", 4294967264);
var Lime = registerColor("Lime", 4278255360);
var LimeGreen = registerColor("LimeGreen", 4281519410);
var Linen = registerColor("Linen", 4294635750);
var Magenta = registerColor("Magenta", 4294902015);
var Maroon = registerColor("Maroon", 4286578688);
var MediumAquaMarine = registerColor("MediumAquaMarine", 4284927402);
var MediumBlue = registerColor("MediumBlue", 4278190285);
var MediumOrchid = registerColor("MediumOrchid", 4290401747);
var MediumPurple = registerColor("MediumPurple", 4287852763);
var MediumSeaGreen = registerColor("MediumSeaGreen", 4282168177);
var MediumSlateBlue = registerColor("MediumSlateBlue", 4286277870);
var MediumSpringGreen = registerColor("MediumSpringGreen", 4278254234);
var MediumTurquoise = registerColor("MediumTurquoise", 4282962380);
var MediumVioletRed = registerColor("MediumVioletRed", 4291237253);
var MidnightBlue = registerColor("MidnightBlue", 4279834992);
var MintCream = registerColor("MintCream", 4294311930);
var MistyRose = registerColor("MistyRose", 4294960353);
var Moccasin = registerColor("Moccasin", 4294960309);
var NavajoWhite = registerColor("NavajoWhite", 4294958765);
var Navy = registerColor("Navy", 4278190208);
var OldLace = registerColor("OldLace", 4294833638);
var Olive = registerColor("Olive", 4286611456);
var OliveDrab = registerColor("OliveDrab", 4285238819);
var Orange = registerColor("Orange", 4294944000);
var OrangeRed = registerColor("OrangeRed", 4294919424);
var Orchid = registerColor("Orchid", 4292505814);
var PaleGoldenRod = registerColor("PaleGoldenRod", 4293847210);
var PaleGreen = registerColor("PaleGreen", 4288215960);
var PaleTurquoise = registerColor("PaleTurquoise", 4289720046);
var PaleVioletRed = registerColor("PaleVioletRed", 4292571283);
var PapayaWhip = registerColor("PapayaWhip", 4294963157);
var PeachPuff = registerColor("PeachPuff", 4294957753);
var Peru = registerColor("Peru", 4291659071);
var Pink = registerColor("Pink", 4294951115);
var Plum = registerColor("Plum", 4292714717);
var PowderBlue = registerColor("PowderBlue", 4289781990);
var Purple = registerColor("Purple", 4286578816);
var RebeccaPurple = registerColor("RebeccaPurple", 4284887961);
var Red = registerColor("Red", 4294901760);
var RosyBrown = registerColor("RosyBrown", 4290547599);
var RoyalBlue = registerColor("RoyalBlue", 4282477025);
var SaddleBrown = registerColor("SaddleBrown", 4287317267);
var Salmon = registerColor("Salmon", 4294606962);
var SandyBrown = registerColor("SandyBrown", 4294222944);
var SeaGreen = registerColor("SeaGreen", 4281240407);
var SeaShell = registerColor("SeaShell", 4294964718);
var Sienna = registerColor("Sienna", 4288696877);
var Silver = registerColor("Silver", 4290822336);
var SkyBlue = registerColor("SkyBlue", 4287090411);
var SlateBlue = registerColor("SlateBlue", 4285160141);
var SlateGray = registerColor(["SlateGray", "SlateGrey"], 4285563024);
var Snow = registerColor("Snow", 4294966010);
var SpringGreen = registerColor("SpringGreen", 4278255487);
var SteelBlue = registerColor("SteelBlue", 4282811060);
var Tan = registerColor("Tan", 4291998860);
var Teal = registerColor("Teal", 4278222976);
var Thistle = registerColor("Thistle", 4292394968);
var Tomato = registerColor("Tomato", 4294927175);
var Turquoise = registerColor("Turquoise", 4282441936);
var Violet = registerColor("Violet", 4293821166);
var Wheat = registerColor("Wheat", 4294303411);
var White = registerColor("White", 4294967295);
var WhiteSmoke = registerColor("WhiteSmoke", 4294309365);
var Yellow = registerColor("Yellow", 4294967040);
var YellowGreen = registerColor("YellowGreen", 4288335154);

// node_modules/@csstools/css-tokenizer/dist/index.mjs
class ParseError extends Error {
  sourceStart;
  sourceEnd;
  parserState;
  constructor(e, n, t, o) {
    super(e), this.name = "ParseError", this.sourceStart = n, this.sourceEnd = t, this.parserState = o;
  }
}

class ParseErrorWithToken extends ParseError {
  token;
  constructor(e, n, t, o, r) {
    super(e, n, t, o), this.token = r;
  }
}
var e = { UnexpectedNewLineInString: "Unexpected newline while consuming a string token.", UnexpectedEOFInString: "Unexpected EOF while consuming a string token.", UnexpectedEOFInComment: "Unexpected EOF while consuming a comment.", UnexpectedEOFInURL: "Unexpected EOF while consuming a url token.", UnexpectedEOFInEscapedCodePoint: "Unexpected EOF while consuming an escaped code point.", UnexpectedCharacterInURL: "Unexpected character while consuming a url token.", InvalidEscapeSequenceInURL: "Invalid escape sequence while consuming a url token.", InvalidEscapeSequenceAfterBackslash: 'Invalid escape sequence after "\\"' };
var n = typeof globalThis != "undefined" && "structuredClone" in globalThis;
function stringify(...e2) {
  let n2 = "";
  for (let t = 0;t < e2.length; t++)
    n2 += e2[t][1];
  return n2;
}
var t = 13;
var o = 45;
var r = 10;
var i = 43;
var s = 65533;
function checkIfFourCodePointsWouldStartCDO(e2) {
  return e2.source.codePointAt(e2.cursor) === 60 && e2.source.codePointAt(e2.cursor + 1) === 33 && e2.source.codePointAt(e2.cursor + 2) === o && e2.source.codePointAt(e2.cursor + 3) === o;
}
function isDigitCodePoint(e2) {
  return e2 >= 48 && e2 <= 57;
}
function isUppercaseLetterCodePoint(e2) {
  return e2 >= 65 && e2 <= 90;
}
function isLowercaseLetterCodePoint(e2) {
  return e2 >= 97 && e2 <= 122;
}
function isHexDigitCodePoint(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 97 && e2 <= 102 || e2 >= 65 && e2 <= 70;
}
function isLetterCodePoint(e2) {
  return isLowercaseLetterCodePoint(e2) || isUppercaseLetterCodePoint(e2);
}
function isIdentStartCodePoint(e2) {
  return isLetterCodePoint(e2) || isNonASCII_IdentCodePoint(e2) || e2 === 95;
}
function isIdentCodePoint(e2) {
  return isIdentStartCodePoint(e2) || isDigitCodePoint(e2) || e2 === o;
}
function isNonASCII_IdentCodePoint(e2) {
  return e2 === 183 || e2 === 8204 || e2 === 8205 || e2 === 8255 || e2 === 8256 || e2 === 8204 || (192 <= e2 && e2 <= 214 || 216 <= e2 && e2 <= 246 || 248 <= e2 && e2 <= 893 || 895 <= e2 && e2 <= 8191 || 8304 <= e2 && e2 <= 8591 || 11264 <= e2 && e2 <= 12271 || 12289 <= e2 && e2 <= 55295 || 63744 <= e2 && e2 <= 64975 || 65008 <= e2 && e2 <= 65533 || (e2 === 0 || (!!isSurrogate(e2) || e2 >= 65536)));
}
function isNewLine(e2) {
  return e2 === r || e2 === t || e2 === 12;
}
function isWhitespace(e2) {
  return e2 === 32 || e2 === r || e2 === 9 || e2 === t || e2 === 12;
}
function isSurrogate(e2) {
  return e2 >= 55296 && e2 <= 57343;
}
function checkIfTwoCodePointsAreAValidEscape(e2) {
  return e2.source.codePointAt(e2.cursor) === 92 && !isNewLine(e2.source.codePointAt(e2.cursor + 1) ?? -1);
}
function checkIfThreeCodePointsWouldStartAnIdentSequence(e2, n2) {
  return n2.source.codePointAt(n2.cursor) === o ? n2.source.codePointAt(n2.cursor + 1) === o || (!!isIdentStartCodePoint(n2.source.codePointAt(n2.cursor + 1) ?? -1) || n2.source.codePointAt(n2.cursor + 1) === 92 && !isNewLine(n2.source.codePointAt(n2.cursor + 2) ?? -1)) : !!isIdentStartCodePoint(n2.source.codePointAt(n2.cursor) ?? -1) || checkIfTwoCodePointsAreAValidEscape(n2);
}
function checkIfThreeCodePointsWouldStartANumber(e2) {
  return e2.source.codePointAt(e2.cursor) === i || e2.source.codePointAt(e2.cursor) === o ? !!isDigitCodePoint(e2.source.codePointAt(e2.cursor + 1) ?? -1) || e2.source.codePointAt(e2.cursor + 1) === 46 && isDigitCodePoint(e2.source.codePointAt(e2.cursor + 2) ?? -1) : e2.source.codePointAt(e2.cursor) === 46 ? isDigitCodePoint(e2.source.codePointAt(e2.cursor + 1) ?? -1) : isDigitCodePoint(e2.source.codePointAt(e2.cursor) ?? -1);
}
function checkIfTwoCodePointsStartAComment(e2) {
  return e2.source.codePointAt(e2.cursor) === 47 && e2.source.codePointAt(e2.cursor + 1) === 42;
}
function checkIfThreeCodePointsWouldStartCDC(e2) {
  return e2.source.codePointAt(e2.cursor) === o && e2.source.codePointAt(e2.cursor + 1) === o && e2.source.codePointAt(e2.cursor + 2) === 62;
}
var c;
var a;
var u;
function mirrorVariantType(e2) {
  switch (e2) {
    case c.OpenParen:
      return c.CloseParen;
    case c.CloseParen:
      return c.OpenParen;
    case c.OpenCurly:
      return c.CloseCurly;
    case c.CloseCurly:
      return c.OpenCurly;
    case c.OpenSquare:
      return c.CloseSquare;
    case c.CloseSquare:
      return c.OpenSquare;
    default:
      return null;
  }
}
function mirrorVariant(e2) {
  switch (e2[0]) {
    case c.OpenParen:
      return [c.CloseParen, ")", -1, -1, undefined];
    case c.CloseParen:
      return [c.OpenParen, "(", -1, -1, undefined];
    case c.OpenCurly:
      return [c.CloseCurly, "}", -1, -1, undefined];
    case c.CloseCurly:
      return [c.OpenCurly, "{", -1, -1, undefined];
    case c.OpenSquare:
      return [c.CloseSquare, "]", -1, -1, undefined];
    case c.CloseSquare:
      return [c.OpenSquare, "[", -1, -1, undefined];
    default:
      return null;
  }
}
function consumeComment(n2, t2) {
  for (t2.advanceCodePoint(2);; ) {
    const o2 = t2.readCodePoint();
    if (o2 === undefined) {
      const o3 = [c.Comment, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, undefined];
      return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInComment, t2.representationStart, t2.representationEnd, ["4.3.2. Consume comments", "Unexpected EOF"], o3)), o3;
    }
    if (o2 === 42 && (t2.source.codePointAt(t2.cursor) !== undefined && t2.source.codePointAt(t2.cursor) === 47)) {
      t2.advanceCodePoint();
      break;
    }
  }
  return [c.Comment, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, undefined];
}
function consumeEscapedCodePoint(n2, o2) {
  const i2 = o2.readCodePoint();
  if (i2 === undefined)
    return n2.onParseError(new ParseError(e.UnexpectedEOFInEscapedCodePoint, o2.representationStart, o2.representationEnd, ["4.3.7. Consume an escaped code point", "Unexpected EOF"])), s;
  if (isHexDigitCodePoint(i2)) {
    const e2 = [i2];
    let n3;
    for (;(n3 = o2.source.codePointAt(o2.cursor)) !== undefined && isHexDigitCodePoint(n3) && e2.length < 6; )
      e2.push(n3), o2.advanceCodePoint();
    isWhitespace(o2.source.codePointAt(o2.cursor) ?? -1) && (o2.source.codePointAt(o2.cursor) === t && o2.source.codePointAt(o2.cursor + 1) === r && o2.advanceCodePoint(), o2.advanceCodePoint());
    const c2 = parseInt(String.fromCodePoint(...e2), 16);
    return c2 === 0 || isSurrogate(c2) || c2 > 1114111 ? s : c2;
  }
  return i2 === 0 || isSurrogate(i2) ? s : i2;
}
function consumeIdentSequence(e2, n2) {
  const t2 = [];
  for (;; ) {
    const o2 = n2.source.codePointAt(n2.cursor) ?? -1;
    if (o2 === 0 || isSurrogate(o2))
      t2.push(s), n2.advanceCodePoint(+(o2 > 65535) + 1);
    else if (isIdentCodePoint(o2))
      t2.push(o2), n2.advanceCodePoint(+(o2 > 65535) + 1);
    else {
      if (!checkIfTwoCodePointsAreAValidEscape(n2))
        return t2;
      n2.advanceCodePoint(), t2.push(consumeEscapedCodePoint(e2, n2));
    }
  }
}
function consumeHashToken(e2, n2) {
  n2.advanceCodePoint();
  const t2 = n2.source.codePointAt(n2.cursor);
  if (t2 !== undefined && (isIdentCodePoint(t2) || checkIfTwoCodePointsAreAValidEscape(n2))) {
    let t3 = u.Unrestricted;
    checkIfThreeCodePointsWouldStartAnIdentSequence(0, n2) && (t3 = u.ID);
    const o2 = consumeIdentSequence(e2, n2);
    return [c.Hash, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...o2), type: t3 }];
  }
  return [c.Delim, "#", n2.representationStart, n2.representationEnd, { value: "#" }];
}
function consumeNumber(e2, n2) {
  let t2 = a.Integer;
  for (n2.source.codePointAt(n2.cursor) !== i && n2.source.codePointAt(n2.cursor) !== o || n2.advanceCodePoint();isDigitCodePoint(n2.source.codePointAt(n2.cursor) ?? -1); )
    n2.advanceCodePoint();
  if (n2.source.codePointAt(n2.cursor) === 46 && isDigitCodePoint(n2.source.codePointAt(n2.cursor + 1) ?? -1))
    for (n2.advanceCodePoint(2), t2 = a.Number;isDigitCodePoint(n2.source.codePointAt(n2.cursor) ?? -1); )
      n2.advanceCodePoint();
  if (n2.source.codePointAt(n2.cursor) === 101 || n2.source.codePointAt(n2.cursor) === 69) {
    if (isDigitCodePoint(n2.source.codePointAt(n2.cursor + 1) ?? -1))
      n2.advanceCodePoint(2);
    else {
      if (n2.source.codePointAt(n2.cursor + 1) !== o && n2.source.codePointAt(n2.cursor + 1) !== i || !isDigitCodePoint(n2.source.codePointAt(n2.cursor + 2) ?? -1))
        return t2;
      n2.advanceCodePoint(3);
    }
    for (t2 = a.Number;isDigitCodePoint(n2.source.codePointAt(n2.cursor) ?? -1); )
      n2.advanceCodePoint();
  }
  return t2;
}
function consumeNumericToken(e2, n2) {
  let t2;
  {
    const e3 = n2.source.codePointAt(n2.cursor);
    e3 === o ? t2 = "-" : e3 === i && (t2 = "+");
  }
  const r2 = consumeNumber(0, n2), s2 = parseFloat(n2.source.slice(n2.representationStart, n2.representationEnd + 1));
  if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, n2)) {
    const o2 = consumeIdentSequence(e2, n2);
    return [c.Dimension, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: s2, signCharacter: t2, type: r2, unit: String.fromCodePoint(...o2) }];
  }
  return n2.source.codePointAt(n2.cursor) === 37 ? (n2.advanceCodePoint(), [c.Percentage, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: s2, signCharacter: t2 }]) : [c.Number, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: s2, signCharacter: t2, type: r2 }];
}
function consumeWhiteSpace(e2) {
  for (;isWhitespace(e2.source.codePointAt(e2.cursor) ?? -1); )
    e2.advanceCodePoint();
  return [c.Whitespace, e2.source.slice(e2.representationStart, e2.representationEnd + 1), e2.representationStart, e2.representationEnd, undefined];
}
(function(e2) {
  e2.Comment = "comment", e2.AtKeyword = "at-keyword-token", e2.BadString = "bad-string-token", e2.BadURL = "bad-url-token", e2.CDC = "CDC-token", e2.CDO = "CDO-token", e2.Colon = "colon-token", e2.Comma = "comma-token", e2.Delim = "delim-token", e2.Dimension = "dimension-token", e2.EOF = "EOF-token", e2.Function = "function-token", e2.Hash = "hash-token", e2.Ident = "ident-token", e2.Number = "number-token", e2.Percentage = "percentage-token", e2.Semicolon = "semicolon-token", e2.String = "string-token", e2.URL = "url-token", e2.Whitespace = "whitespace-token", e2.OpenParen = "(-token", e2.CloseParen = ")-token", e2.OpenSquare = "[-token", e2.CloseSquare = "]-token", e2.OpenCurly = "{-token", e2.CloseCurly = "}-token", e2.UnicodeRange = "unicode-range-token";
})(c || (c = {})), function(e2) {
  e2.Integer = "integer", e2.Number = "number";
}(a || (a = {})), function(e2) {
  e2.Unrestricted = "unrestricted", e2.ID = "id";
}(u || (u = {}));

class Reader {
  cursor = 0;
  source = "";
  representationStart = 0;
  representationEnd = -1;
  constructor(e2) {
    this.source = e2;
  }
  advanceCodePoint(e2 = 1) {
    this.cursor = this.cursor + e2, this.representationEnd = this.cursor - 1;
  }
  readCodePoint() {
    const e2 = this.source.codePointAt(this.cursor);
    if (e2 !== undefined)
      return this.cursor = this.cursor + 1, this.representationEnd = this.cursor - 1, e2;
  }
  unreadCodePoint(e2 = 1) {
    this.cursor = this.cursor - e2, this.representationEnd = this.cursor - 1;
  }
  resetRepresentation() {
    this.representationStart = this.cursor, this.representationEnd = -1;
  }
}
function consumeStringToken(n2, o2) {
  let i2 = "";
  const a2 = o2.readCodePoint();
  for (;; ) {
    const u2 = o2.readCodePoint();
    if (u2 === undefined) {
      const t2 = [c.String, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, { value: i2 }];
      return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInString, o2.representationStart, o2.representationEnd, ["4.3.5. Consume a string token", "Unexpected EOF"], t2)), t2;
    }
    if (isNewLine(u2)) {
      o2.unreadCodePoint();
      const i3 = [c.BadString, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, undefined];
      return n2.onParseError(new ParseErrorWithToken(e.UnexpectedNewLineInString, o2.representationStart, o2.source.codePointAt(o2.cursor) === t && o2.source.codePointAt(o2.cursor + 1) === r ? o2.representationEnd + 2 : o2.representationEnd + 1, ["4.3.5. Consume a string token", "Unexpected newline"], i3)), i3;
    }
    if (u2 === a2)
      return [c.String, o2.source.slice(o2.representationStart, o2.representationEnd + 1), o2.representationStart, o2.representationEnd, { value: i2 }];
    if (u2 !== 92)
      u2 === 0 || isSurrogate(u2) ? i2 += String.fromCodePoint(s) : i2 += String.fromCodePoint(u2);
    else {
      if (o2.source.codePointAt(o2.cursor) === undefined)
        continue;
      if (isNewLine(o2.source.codePointAt(o2.cursor) ?? -1)) {
        o2.source.codePointAt(o2.cursor) === t && o2.source.codePointAt(o2.cursor + 1) === r && o2.advanceCodePoint(), o2.advanceCodePoint();
        continue;
      }
      i2 += String.fromCodePoint(consumeEscapedCodePoint(n2, o2));
    }
  }
}
function checkIfCodePointsMatchURLIdent(e2) {
  return !(e2.length !== 3 || e2[0] !== 117 && e2[0] !== 85 || e2[1] !== 114 && e2[1] !== 82 || e2[2] !== 108 && e2[2] !== 76);
}
function consumeBadURL(e2, n2) {
  for (;; ) {
    const t2 = n2.source.codePointAt(n2.cursor);
    if (t2 === undefined)
      return;
    if (t2 === 41)
      return void n2.advanceCodePoint();
    checkIfTwoCodePointsAreAValidEscape(n2) ? (n2.advanceCodePoint(), consumeEscapedCodePoint(e2, n2)) : n2.advanceCodePoint();
  }
}
function consumeUrlToken(n2, t2) {
  for (;isWhitespace(t2.source.codePointAt(t2.cursor) ?? -1); )
    t2.advanceCodePoint();
  let o2 = "";
  for (;; ) {
    if (t2.source.codePointAt(t2.cursor) === undefined) {
      const r3 = [c.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: o2 }];
      return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", "Unexpected EOF"], r3)), r3;
    }
    if (t2.source.codePointAt(t2.cursor) === 41)
      return t2.advanceCodePoint(), [c.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: o2 }];
    if (isWhitespace(t2.source.codePointAt(t2.cursor) ?? -1)) {
      for (t2.advanceCodePoint();isWhitespace(t2.source.codePointAt(t2.cursor) ?? -1); )
        t2.advanceCodePoint();
      if (t2.source.codePointAt(t2.cursor) === undefined) {
        const r3 = [c.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: o2 }];
        return n2.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", "Consume as much whitespace as possible", "Unexpected EOF"], r3)), r3;
      }
      return t2.source.codePointAt(t2.cursor) === 41 ? (t2.advanceCodePoint(), [c.URL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, { value: o2 }]) : (consumeBadURL(n2, t2), [c.BadURL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, undefined]);
    }
    const i2 = t2.source.codePointAt(t2.cursor);
    if (i2 === 34 || i2 === 39 || i2 === 40 || ((r2 = i2 ?? -1) === 11 || r2 === 127 || 0 <= r2 && r2 <= 8 || 14 <= r2 && r2 <= 31)) {
      consumeBadURL(n2, t2);
      const o3 = [c.BadURL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, undefined];
      return n2.onParseError(new ParseErrorWithToken(e.UnexpectedCharacterInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", `Unexpected U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point`], o3)), o3;
    }
    if (i2 === 92) {
      if (checkIfTwoCodePointsAreAValidEscape(t2)) {
        t2.advanceCodePoint(), o2 += String.fromCodePoint(consumeEscapedCodePoint(n2, t2));
        continue;
      }
      consumeBadURL(n2, t2);
      const r3 = [c.BadURL, t2.source.slice(t2.representationStart, t2.representationEnd + 1), t2.representationStart, t2.representationEnd, undefined];
      return n2.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceInURL, t2.representationStart, t2.representationEnd, ["4.3.6. Consume a url token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"], r3)), r3;
    }
    t2.source.codePointAt(t2.cursor) === 0 || isSurrogate(t2.source.codePointAt(t2.cursor) ?? -1) ? (o2 += String.fromCodePoint(s), t2.advanceCodePoint()) : (o2 += t2.source[t2.cursor], t2.advanceCodePoint());
  }
  var r2;
}
function consumeIdentLikeToken(e2, n2) {
  const t2 = consumeIdentSequence(e2, n2);
  if (n2.source.codePointAt(n2.cursor) !== 40)
    return [c.Ident, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2) }];
  if (checkIfCodePointsMatchURLIdent(t2)) {
    n2.advanceCodePoint();
    let o2 = 0;
    for (;; ) {
      const e3 = isWhitespace(n2.source.codePointAt(n2.cursor) ?? -1), r2 = isWhitespace(n2.source.codePointAt(n2.cursor + 1) ?? -1);
      if (e3 && r2) {
        o2 += 1, n2.advanceCodePoint(1);
        continue;
      }
      const i2 = e3 ? n2.source.codePointAt(n2.cursor + 1) : n2.source.codePointAt(n2.cursor);
      if (i2 === 34 || i2 === 39)
        return o2 > 0 && n2.unreadCodePoint(o2), [c.Function, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2) }];
      break;
    }
    return consumeUrlToken(e2, n2);
  }
  return n2.advanceCodePoint(), [c.Function, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { value: String.fromCodePoint(...t2) }];
}
function checkIfThreeCodePointsWouldStartAUnicodeRange(e2) {
  return !(e2.source.codePointAt(e2.cursor) !== 117 && e2.source.codePointAt(e2.cursor) !== 85 || e2.source.codePointAt(e2.cursor + 1) !== i || e2.source.codePointAt(e2.cursor + 2) !== 63 && !isHexDigitCodePoint(e2.source.codePointAt(e2.cursor + 2) ?? -1));
}
function consumeUnicodeRangeToken(e2, n2) {
  n2.advanceCodePoint(2);
  const t2 = [], r2 = [];
  let i2;
  for (;(i2 = n2.source.codePointAt(n2.cursor)) !== undefined && t2.length < 6 && isHexDigitCodePoint(i2); )
    t2.push(i2), n2.advanceCodePoint();
  for (;(i2 = n2.source.codePointAt(n2.cursor)) !== undefined && t2.length < 6 && i2 === 63; )
    r2.length === 0 && r2.push(...t2), t2.push(48), r2.push(70), n2.advanceCodePoint();
  if (!r2.length && n2.source.codePointAt(n2.cursor) === o && isHexDigitCodePoint(n2.source.codePointAt(n2.cursor + 1) ?? -1))
    for (n2.advanceCodePoint();(i2 = n2.source.codePointAt(n2.cursor)) !== undefined && r2.length < 6 && isHexDigitCodePoint(i2); )
      r2.push(i2), n2.advanceCodePoint();
  if (!r2.length) {
    const e3 = parseInt(String.fromCodePoint(...t2), 16);
    return [c.UnicodeRange, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { startOfRange: e3, endOfRange: e3 }];
  }
  const s2 = parseInt(String.fromCodePoint(...t2), 16), a2 = parseInt(String.fromCodePoint(...r2), 16);
  return [c.UnicodeRange, n2.source.slice(n2.representationStart, n2.representationEnd + 1), n2.representationStart, n2.representationEnd, { startOfRange: s2, endOfRange: a2 }];
}
function tokenize(e2, n2) {
  const t2 = tokenizer(e2, n2), o2 = [];
  for (;!t2.endOfFile(); )
    o2.push(t2.nextToken());
  return o2.push(t2.nextToken()), o2;
}
function tokenizer(n2, s2) {
  const a2 = n2.css.valueOf(), u2 = n2.unicodeRangesAllowed ?? false, d = new Reader(a2), p = { onParseError: s2?.onParseError ?? noop };
  return { nextToken: function nextToken() {
    d.resetRepresentation();
    const n3 = d.source.codePointAt(d.cursor);
    if (n3 === undefined)
      return [c.EOF, "", -1, -1, undefined];
    if (n3 === 47 && checkIfTwoCodePointsStartAComment(d))
      return consumeComment(p, d);
    if (u2 && (n3 === 117 || n3 === 85) && checkIfThreeCodePointsWouldStartAUnicodeRange(d))
      return consumeUnicodeRangeToken(0, d);
    if (isIdentStartCodePoint(n3))
      return consumeIdentLikeToken(p, d);
    if (isDigitCodePoint(n3))
      return consumeNumericToken(p, d);
    switch (n3) {
      case 44:
        return d.advanceCodePoint(), [c.Comma, ",", d.representationStart, d.representationEnd, undefined];
      case 58:
        return d.advanceCodePoint(), [c.Colon, ":", d.representationStart, d.representationEnd, undefined];
      case 59:
        return d.advanceCodePoint(), [c.Semicolon, ";", d.representationStart, d.representationEnd, undefined];
      case 40:
        return d.advanceCodePoint(), [c.OpenParen, "(", d.representationStart, d.representationEnd, undefined];
      case 41:
        return d.advanceCodePoint(), [c.CloseParen, ")", d.representationStart, d.representationEnd, undefined];
      case 91:
        return d.advanceCodePoint(), [c.OpenSquare, "[", d.representationStart, d.representationEnd, undefined];
      case 93:
        return d.advanceCodePoint(), [c.CloseSquare, "]", d.representationStart, d.representationEnd, undefined];
      case 123:
        return d.advanceCodePoint(), [c.OpenCurly, "{", d.representationStart, d.representationEnd, undefined];
      case 125:
        return d.advanceCodePoint(), [c.CloseCurly, "}", d.representationStart, d.representationEnd, undefined];
      case 39:
      case 34:
        return consumeStringToken(p, d);
      case 35:
        return consumeHashToken(p, d);
      case i:
      case 46:
        return checkIfThreeCodePointsWouldStartANumber(d) ? consumeNumericToken(p, d) : (d.advanceCodePoint(), [c.Delim, d.source[d.representationStart], d.representationStart, d.representationEnd, { value: d.source[d.representationStart] }]);
      case r:
      case t:
      case 12:
      case 9:
      case 32:
        return consumeWhiteSpace(d);
      case o:
        return checkIfThreeCodePointsWouldStartANumber(d) ? consumeNumericToken(p, d) : checkIfThreeCodePointsWouldStartCDC(d) ? (d.advanceCodePoint(3), [c.CDC, "-->", d.representationStart, d.representationEnd, undefined]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, d) ? consumeIdentLikeToken(p, d) : (d.advanceCodePoint(), [c.Delim, "-", d.representationStart, d.representationEnd, { value: "-" }]);
      case 60:
        return checkIfFourCodePointsWouldStartCDO(d) ? (d.advanceCodePoint(4), [c.CDO, "<!--", d.representationStart, d.representationEnd, undefined]) : (d.advanceCodePoint(), [c.Delim, "<", d.representationStart, d.representationEnd, { value: "<" }]);
      case 64:
        if (d.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, d)) {
          const e2 = consumeIdentSequence(p, d);
          return [c.AtKeyword, d.source.slice(d.representationStart, d.representationEnd + 1), d.representationStart, d.representationEnd, { value: String.fromCodePoint(...e2) }];
        }
        return [c.Delim, "@", d.representationStart, d.representationEnd, { value: "@" }];
      case 92: {
        if (checkIfTwoCodePointsAreAValidEscape(d))
          return consumeIdentLikeToken(p, d);
        d.advanceCodePoint();
        const n4 = [c.Delim, "\\", d.representationStart, d.representationEnd, { value: "\\" }];
        return p.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceAfterBackslash, d.representationStart, d.representationEnd, ["4.3.1. Consume a token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"], n4)), n4;
      }
    }
    return d.advanceCodePoint(), [c.Delim, d.source[d.representationStart], d.representationStart, d.representationEnd, { value: d.source[d.representationStart] }];
  }, endOfFile: function endOfFile() {
    return d.source.codePointAt(d.cursor) === undefined;
  } };
}
function noop() {}
function mutateUnit(e2, n2) {
  const t2 = [];
  for (const e3 of n2)
    t2.push(e3.codePointAt(0));
  const o2 = serializeIdent(t2);
  o2[0] === 101 && insertEscapedCodePoint(o2, 0, o2[0]);
  const r2 = String.fromCodePoint(...o2), i2 = e2[4].signCharacter === "+" ? e2[4].signCharacter : "", s2 = e2[4].value.toString();
  e2[1] = `${i2}${s2}${r2}`, e2[4].unit = n2;
}
function serializeIdent(e2) {
  let n2 = 0;
  if (e2[0] === 0)
    e2.splice(0, 1, s), n2 = 1;
  else if (e2[0] === o && e2[1] === o)
    n2 = 2;
  else if (e2[0] === o && e2[1])
    n2 = 2, isIdentStartCodePoint(e2[1]) || (n2 += insertEscapedCodePoint(e2, 1, e2[1]));
  else {
    if (e2[0] === o && !e2[1])
      return [92, e2[0]];
    isIdentStartCodePoint(e2[0]) ? n2 = 1 : (n2 = 1, n2 += insertEscapedCodePoint(e2, 0, e2[0]));
  }
  for (let t2 = n2;t2 < e2.length; t2++)
    e2[t2] !== 0 ? isIdentCodePoint(e2[t2]) || (t2 += insertEscapedCharacter(e2, t2, e2[t2])) : (e2.splice(t2, 1, s), t2++);
  return e2;
}
function insertEscapedCharacter(e2, n2, t2) {
  return e2.splice(n2, 1, 92, t2), 1;
}
function insertEscapedCodePoint(e2, n2, t2) {
  const o2 = t2.toString(16), r2 = [];
  for (const e3 of o2)
    r2.push(e3.codePointAt(0));
  return e2.splice(n2, 1, 92, ...r2, 32), 1 + r2.length;
}
var d = Object.values(c);
function isToken(e2) {
  return !!Array.isArray(e2) && (!(e2.length < 4) && (!!d.includes(e2[0]) && (typeof e2[1] == "string" && (typeof e2[2] == "number" && typeof e2[3] == "number"))));
}
function isTokenNumeric(e2) {
  if (!e2)
    return false;
  switch (e2[0]) {
    case c.Dimension:
    case c.Number:
    case c.Percentage:
      return true;
    default:
      return false;
  }
}
function isTokenWhiteSpaceOrComment(e2) {
  if (!e2)
    return false;
  switch (e2[0]) {
    case c.Whitespace:
    case c.Comment:
      return true;
    default:
      return false;
  }
}
function isTokenComma(e2) {
  return !!e2 && e2[0] === c.Comma;
}
function isTokenComment(e2) {
  return !!e2 && e2[0] === c.Comment;
}
function isTokenDelim(e2) {
  return !!e2 && e2[0] === c.Delim;
}
function isTokenDimension(e2) {
  return !!e2 && e2[0] === c.Dimension;
}
function isTokenEOF(e2) {
  return !!e2 && e2[0] === c.EOF;
}
function isTokenFunction(e2) {
  return !!e2 && e2[0] === c.Function;
}
function isTokenHash(e2) {
  return !!e2 && e2[0] === c.Hash;
}
function isTokenIdent(e2) {
  return !!e2 && e2[0] === c.Ident;
}
function isTokenNumber(e2) {
  return !!e2 && e2[0] === c.Number;
}
function isTokenPercentage(e2) {
  return !!e2 && e2[0] === c.Percentage;
}
function isTokenWhitespace(e2) {
  return !!e2 && e2[0] === c.Whitespace;
}
function isTokenOpenParen(e2) {
  return !!e2 && e2[0] === c.OpenParen;
}
function isTokenCloseParen(e2) {
  return !!e2 && e2[0] === c.CloseParen;
}
function isTokenOpenSquare(e2) {
  return !!e2 && e2[0] === c.OpenSquare;
}
function isTokenOpenCurly(e2) {
  return !!e2 && e2[0] === c.OpenCurly;
}

// node_modules/@csstools/color-helpers/dist/index.mjs
function multiplyMatrices(t2, n2) {
  return [t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2], t2[3] * n2[0] + t2[4] * n2[1] + t2[5] * n2[2], t2[6] * n2[0] + t2[7] * n2[1] + t2[8] * n2[2]];
}
var t2 = [0.955473421488075, -0.02309845494876471, 0.06325924320057072, -0.0283697093338637, 1.0099953980813041, 0.021041441191917323, 0.012314014864481998, -0.020507649298898964, 1.330365926242124];
function D50_to_D65(n2) {
  return multiplyMatrices(t2, n2);
}
var n2 = [1.0479297925449969, 0.022946870601609652, -0.05019226628920524, 0.02962780877005599, 0.9904344267538799, -0.017073799063418826, -0.009243040646204504, 0.015055191490298152, 0.7518742814281371];
function D65_to_D50(t3) {
  return multiplyMatrices(n2, t3);
}
function HSL_to_sRGB(t3) {
  let n3 = t3[0] % 360;
  const _ = t3[1] / 100, o2 = t3[2] / 100;
  return n3 < 0 && (n3 += 360), [HSL_to_sRGB_channel(0, n3, _, o2), HSL_to_sRGB_channel(8, n3, _, o2), HSL_to_sRGB_channel(4, n3, _, o2)];
}
function HSL_to_sRGB_channel(t3, n3, _, o2) {
  const e2 = (t3 + n3 / 30) % 12;
  return o2 - _ * Math.min(o2, 1 - o2) * Math.max(-1, Math.min(e2 - 3, 9 - e2, 1));
}
function HWB_to_sRGB(t3) {
  const n3 = t3[0], _ = t3[1] / 100, o2 = t3[2] / 100;
  if (_ + o2 >= 1) {
    const t4 = _ / (_ + o2);
    return [t4, t4, t4];
  }
  const e2 = HSL_to_sRGB([n3, 100, 50]), a2 = 1 - _ - o2;
  return [e2[0] * a2 + _, e2[1] * a2 + _, e2[2] * a2 + _];
}
function LCH_to_Lab(t3) {
  const n3 = t3[2] * Math.PI / 180;
  return [t3[0], t3[1] * Math.cos(n3), t3[1] * Math.sin(n3)];
}
function Lab_to_LCH(t3) {
  const n3 = 180 * Math.atan2(t3[2], t3[1]) / Math.PI;
  return [t3[0], Math.sqrt(Math.pow(t3[1], 2) + Math.pow(t3[2], 2)), n3 >= 0 ? n3 : n3 + 360];
}
var _ = [0.3457 / 0.3585, 1, 0.2958 / 0.3585];
function Lab_to_XYZ(t3) {
  const n3 = 24389 / 27, o2 = 216 / 24389, e2 = (t3[0] + 16) / 116, a2 = t3[1] / 500 + e2, r2 = e2 - t3[2] / 200;
  return [(Math.pow(a2, 3) > o2 ? Math.pow(a2, 3) : (116 * a2 - 16) / n3) * _[0], (t3[0] > 8 ? Math.pow((t3[0] + 16) / 116, 3) : t3[0] / n3) * _[1], (Math.pow(r2, 3) > o2 ? Math.pow(r2, 3) : (116 * r2 - 16) / n3) * _[2]];
}
function OKLCH_to_OKLab(t3) {
  const n3 = t3[2] * Math.PI / 180;
  return [t3[0], t3[1] * Math.cos(n3), t3[1] * Math.sin(n3)];
}
function OKLab_to_OKLCH(t3) {
  const n3 = 180 * Math.atan2(t3[2], t3[1]) / Math.PI;
  return [t3[0], Math.sqrt(t3[1] ** 2 + t3[2] ** 2), n3 >= 0 ? n3 : n3 + 360];
}
var o2 = [1.2268798758459243, -0.5578149944602171, 0.2813910456659647, -0.0405757452148008, 1.112286803280317, -0.0717110580655164, -0.0763729366746601, -0.4214933324022432, 1.5869240198367816];
var e2 = [1, 0.3963377773761749, 0.2158037573099136, 1, -0.1055613458156586, -0.0638541728258133, 1, -0.0894841775298119, -1.2914855480194092];
function OKLab_to_XYZ(t3) {
  const n3 = multiplyMatrices(e2, t3);
  return multiplyMatrices(o2, [n3[0] ** 3, n3[1] ** 3, n3[2] ** 3]);
}
function XYZ_to_Lab(t3) {
  const n3 = compute_f(t3[0] / _[0]), o3 = compute_f(t3[1] / _[1]);
  return [116 * o3 - 16, 500 * (n3 - o3), 200 * (o3 - compute_f(t3[2] / _[2]))];
}
var a2 = 216 / 24389;
var r2 = 24389 / 27;
function compute_f(t3) {
  return t3 > a2 ? Math.cbrt(t3) : (r2 * t3 + 16) / 116;
}
var l = [0.819022437996703, 0.3619062600528904, -0.1288737815209879, 0.0329836539323885, 0.9292868615863434, 0.0361446663506424, 0.0481771893596242, 0.2642395317527308, 0.6335478284694309];
var i2 = [0.210454268309314, 0.7936177747023054, -0.0040720430116193, 1.9779985324311684, -2.42859224204858, 0.450593709617411, 0.0259040424655478, 0.7827717124575296, -0.8086757549230774];
function XYZ_to_OKLab(t3) {
  const n3 = multiplyMatrices(l, t3);
  return multiplyMatrices(i2, [Math.cbrt(n3[0]), Math.cbrt(n3[1]), Math.cbrt(n3[2])]);
}
var c2 = [30757411 / 17917100, -6372589 / 17917100, -4539589 / 17917100, -0.666684351832489, 1.616481236634939, 467509 / 29648200, 792561 / 44930125, -1921689 / 44930125, 0.942103121235474];
var u2 = [446124 / 178915, -333277 / 357830, -72051 / 178915, -14852 / 17905, 63121 / 35810, 423 / 17905, 11844 / 330415, -50337 / 660830, 316169 / 330415];
function XYZ_to_lin_P3(t3) {
  return multiplyMatrices(u2, t3);
}
var s2 = [1.3457868816471583, -0.25557208737979464, -0.05110186497554526, -0.5446307051249019, 1.5082477428451468, 0.02052744743642139, 0, 0, 1.2119675456389452];
var h = [1829569 / 896150, -506331 / 896150, -308931 / 896150, -851781 / 878810, 1648619 / 878810, 36519 / 878810, 16779 / 1248040, -147721 / 1248040, 1266979 / 1248040];
var m = [12831 / 3959, -329 / 214, -1974 / 3959, -851781 / 878810, 1648619 / 878810, 36519 / 878810, 705 / 12673, -2585 / 12673, 705 / 667];
function XYZ_to_lin_sRGB(t3) {
  return multiplyMatrices(m, t3);
}
var D = 1.09929682680944;
var b = 0.018053968510807;
function gam_2020_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return _2 > b ? n3 * (D * Math.pow(_2, 0.45) - (D - 1)) : 4.5 * t3;
}
function gam_sRGB(t3) {
  return [gam_sRGB_channel(t3[0]), gam_sRGB_channel(t3[1]), gam_sRGB_channel(t3[2])];
}
function gam_sRGB_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return _2 > 0.0031308 ? n3 * (1.055 * Math.pow(_2, 1 / 2.4) - 0.055) : 12.92 * t3;
}
function gam_P3(t3) {
  return gam_sRGB(t3);
}
var g = 1 / 512;
function gam_ProPhoto_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return _2 >= g ? n3 * Math.pow(_2, 1 / 1.8) : 16 * t3;
}
function gam_a98rgb_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return n3 * Math.pow(_2, 256 / 563);
}
var X = 1.09929682680944;
var Y = 0.018053968510807;
function lin_2020_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return _2 < 4.5 * Y ? t3 / 4.5 : n3 * Math.pow((_2 + X - 1) / X, 1 / 0.45);
}
var Z = [63426534 / 99577255, 20160776 / 139408157, 47086771 / 278816314, 26158966 / 99577255, 0.677998071518871, 8267143 / 139408157, 0, 19567812 / 697040785, 1.0609850577107909];
function lin_sRGB(t3) {
  return [lin_sRGB_channel(t3[0]), lin_sRGB_channel(t3[1]), lin_sRGB_channel(t3[2])];
}
function lin_sRGB_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return _2 <= 0.04045 ? t3 / 12.92 : n3 * Math.pow((_2 + 0.055) / 1.055, 2.4);
}
function lin_P3(t3) {
  return lin_sRGB(t3);
}
var f = [608311 / 1250200, 189793 / 714400, 198249 / 1000160, 35783 / 156275, 247089 / 357200, 198249 / 2500400, 0, 32229 / 714400, 5220557 / 5000800];
function lin_P3_to_XYZ(t3) {
  return multiplyMatrices(f, t3);
}
var M = 16 / 512;
function lin_ProPhoto_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return _2 <= M ? t3 / 16 : n3 * Math.pow(_2, 1.8);
}
var p = [0.7977666449006423, 0.13518129740053308, 0.0313477341283922, 0.2880748288194013, 0.711835234241873, 0.00008993693872564, 0, 0, 0.8251046025104602];
function lin_a98rgb_channel(t3) {
  const n3 = t3 < 0 ? -1 : 1, _2 = Math.abs(t3);
  return n3 * Math.pow(_2, 563 / 256);
}
var d2 = [573536 / 994567, 263643 / 1420810, 187206 / 994567, 591459 / 1989134, 6239551 / 9945670, 374412 / 4972835, 53769 / 1989134, 351524 / 4972835, 4929758 / 4972835];
var L = [506752 / 1228815, 87881 / 245763, 12673 / 70218, 87098 / 409605, 175762 / 245763, 12673 / 175545, 7918 / 409605, 87881 / 737289, 1001167 / 1053270];
function lin_sRGB_to_XYZ(t3) {
  return multiplyMatrices(L, t3);
}
function sRGB_to_HSL(t3) {
  const n3 = t3[0], _2 = t3[1], o3 = t3[2], e3 = Math.max(n3, _2, o3), a3 = Math.min(n3, _2, o3), r3 = (a3 + e3) / 2, l2 = e3 - a3;
  let i3 = Number.NaN, c3 = 0;
  if (Math.round(1e5 * l2) !== 0) {
    const t4 = Math.round(1e5 * r3);
    switch (c3 = t4 === 0 || t4 === 1e5 ? 0 : (e3 - r3) / Math.min(r3, 1 - r3), e3) {
      case n3:
        i3 = (_2 - o3) / l2 + (_2 < o3 ? 6 : 0);
        break;
      case _2:
        i3 = (o3 - n3) / l2 + 2;
        break;
      case o3:
        i3 = (n3 - _2) / l2 + 4;
    }
    i3 *= 60;
  }
  return c3 < 0 && (i3 += 180, c3 = Math.abs(c3)), i3 >= 360 && (i3 -= 360), [i3, 100 * c3, 100 * r3];
}
function sRGB_to_Hue(t3) {
  const n3 = t3[0], _2 = t3[1], o3 = t3[2], e3 = Math.max(n3, _2, o3), a3 = Math.min(n3, _2, o3);
  let r3 = Number.NaN;
  const l2 = e3 - a3;
  if (l2 !== 0) {
    switch (e3) {
      case n3:
        r3 = (_2 - o3) / l2 + (_2 < o3 ? 6 : 0);
        break;
      case _2:
        r3 = (o3 - n3) / l2 + 2;
        break;
      case o3:
        r3 = (n3 - _2) / l2 + 4;
    }
    r3 *= 60;
  }
  return r3 >= 360 && (r3 -= 360), r3;
}
function sRGB_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = lin_sRGB(n3), n3 = lin_sRGB_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_sRGB(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_lin_sRGB(n3), n3 = gam_sRGB(n3), n3;
}
function HSL_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = HSL_to_sRGB(n3), n3 = lin_sRGB(n3), n3 = lin_sRGB_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_HSL(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_lin_sRGB(n3), n3 = gam_sRGB(n3), n3 = sRGB_to_HSL(n3), n3;
}
function HWB_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = HWB_to_sRGB(n3), n3 = lin_sRGB(n3), n3 = lin_sRGB_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_HWB(t3) {
  let n3 = t3;
  n3 = D50_to_D65(n3), n3 = XYZ_to_lin_sRGB(n3);
  const _2 = gam_sRGB(n3), o3 = Math.min(_2[0], _2[1], _2[2]), e3 = 1 - Math.max(_2[0], _2[1], _2[2]);
  return [sRGB_to_Hue(_2), 100 * o3, 100 * e3];
}
function Lab_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = Lab_to_XYZ(n3), n3;
}
function XYZ_D50_to_Lab(t3) {
  let n3 = t3;
  return n3 = XYZ_to_Lab(n3), n3;
}
function LCH_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = LCH_to_Lab(n3), n3 = Lab_to_XYZ(n3), n3;
}
function XYZ_D50_to_LCH(t3) {
  let n3 = t3;
  return n3 = XYZ_to_Lab(n3), n3 = Lab_to_LCH(n3), n3;
}
function OKLab_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = OKLab_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_OKLab(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_OKLab(n3), n3;
}
function OKLCH_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = OKLCH_to_OKLab(n3), n3 = OKLab_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_OKLCH(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_OKLab(n3), n3 = OKLab_to_OKLCH(n3), n3;
}
function lin_sRGB_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = lin_sRGB_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_lin_sRGB(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_lin_sRGB(n3), n3;
}
function a98_RGB_to_XYZ_D50(t3) {
  let n3 = t3;
  var _2;
  return n3 = [lin_a98rgb_channel((_2 = n3)[0]), lin_a98rgb_channel(_2[1]), lin_a98rgb_channel(_2[2])], n3 = multiplyMatrices(d2, n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_a98_RGB(t3) {
  let n3 = t3;
  var _2;
  return n3 = D50_to_D65(n3), n3 = multiplyMatrices(h, n3), n3 = [gam_a98rgb_channel((_2 = n3)[0]), gam_a98rgb_channel(_2[1]), gam_a98rgb_channel(_2[2])], n3;
}
function P3_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = lin_P3(n3), n3 = lin_P3_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_P3(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_lin_P3(n3), n3 = gam_P3(n3), n3;
}
function lin_P3_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = lin_P3_to_XYZ(n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_lin_P3(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3 = XYZ_to_lin_P3(n3), n3;
}
function rec_2020_to_XYZ_D50(t3) {
  let n3 = t3;
  var _2;
  return n3 = [lin_2020_channel((_2 = n3)[0]), lin_2020_channel(_2[1]), lin_2020_channel(_2[2])], n3 = multiplyMatrices(Z, n3), n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_rec_2020(t3) {
  let n3 = t3;
  var _2;
  return n3 = D50_to_D65(n3), n3 = multiplyMatrices(c2, n3), n3 = [gam_2020_channel((_2 = n3)[0]), gam_2020_channel(_2[1]), gam_2020_channel(_2[2])], n3;
}
function ProPhoto_RGB_to_XYZ_D50(t3) {
  let n3 = t3;
  var _2;
  return n3 = [lin_ProPhoto_channel((_2 = n3)[0]), lin_ProPhoto_channel(_2[1]), lin_ProPhoto_channel(_2[2])], n3 = multiplyMatrices(p, n3), n3;
}
function XYZ_D50_to_ProPhoto(t3) {
  let n3 = t3;
  var _2;
  return n3 = multiplyMatrices(s2, n3), n3 = [gam_ProPhoto_channel((_2 = n3)[0]), gam_ProPhoto_channel(_2[1]), gam_ProPhoto_channel(_2[2])], n3;
}
function XYZ_D65_to_XYZ_D50(t3) {
  let n3 = t3;
  return n3 = D65_to_D50(n3), n3;
}
function XYZ_D50_to_XYZ_D65(t3) {
  let n3 = t3;
  return n3 = D50_to_D65(n3), n3;
}
function XYZ_D50_to_XYZ_D50(t3) {
  return t3;
}
function inGamut(t3) {
  return t3[0] >= -0.0001 && t3[0] <= 1.0001 && t3[1] >= -0.0001 && t3[1] <= 1.0001 && t3[2] >= -0.0001 && t3[2] <= 1.0001;
}
function clip(t3) {
  return [t3[0] < 0 ? 0 : t3[0] > 1 ? 1 : t3[0], t3[1] < 0 ? 0 : t3[1] > 1 ? 1 : t3[1], t3[2] < 0 ? 0 : t3[2] > 1 ? 1 : t3[2]];
}
function mapGamutRayTrace(t3, n3, _2) {
  const o3 = t3[0], e3 = t3[2];
  let a3 = n3(t3);
  const r3 = n3([o3, 0, e3]);
  for (let t4 = 0;t4 < 4; t4++) {
    if (t4 > 0) {
      const t5 = _2(a3);
      t5[0] = o3, t5[2] = e3, a3 = n3(t5);
    }
    const l2 = rayTraceBox(r3, a3);
    if (!l2)
      break;
    a3 = l2;
  }
  return clip(a3);
}
function rayTraceBox(t3, n3) {
  let _2 = 1 / 0, o3 = -1 / 0;
  const e3 = [0, 0, 0];
  for (let a3 = 0;a3 < 3; a3++) {
    const r3 = t3[a3], l2 = n3[a3] - r3;
    e3[a3] = l2;
    const i3 = 0, c3 = 1;
    if (l2) {
      const t4 = 1 / l2, n4 = (i3 - r3) * t4, e4 = (c3 - r3) * t4;
      o3 = Math.max(Math.min(n4, e4), o3), _2 = Math.min(Math.max(n4, e4), _2);
    } else if (r3 < i3 || r3 > c3)
      return false;
  }
  return !(o3 > _2 || _2 < 0) && (o3 < 0 && (o3 = _2), !!isFinite(o3) && [t3[0] + e3[0] * o3, t3[1] + e3[1] * o3, t3[2] + e3[2] * o3]);
}
var R = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
function luminance(t3) {
  const [n3, _2, o3] = t3.map((t4) => t4 <= 0.03928 ? t4 / 12.92 : Math.pow((t4 + 0.055) / 1.055, 2.4));
  return 0.2126 * n3 + 0.7152 * _2 + 0.0722 * o3;
}
function contrast_ratio_wcag_2_1(t3, n3) {
  const _2 = luminance(t3), o3 = luminance(n3);
  return (Math.max(_2, o3) + 0.05) / (Math.min(_2, o3) + 0.05);
}

// node_modules/@csstools/css-parser-algorithms/dist/index.mjs
var f2;
function walkerIndexGenerator(e3) {
  let n3 = e3.slice();
  return (e4, t3, o3) => {
    let s3 = -1;
    for (let i3 = n3.indexOf(t3);i3 < n3.length && (s3 = e4.indexOf(n3[i3]), s3 === -1 || s3 < o3); i3++)
      ;
    return s3 === -1 || s3 === o3 && t3 === e4[o3] && (s3++, s3 >= e4.length) ? -1 : (n3 = e4.slice(), s3);
  };
}
function consumeComponentValue(e3, n3) {
  const t3 = n3[0];
  if (isTokenOpenParen(t3) || isTokenOpenCurly(t3) || isTokenOpenSquare(t3)) {
    const t4 = consumeSimpleBlock(e3, n3);
    return { advance: t4.advance, node: t4.node };
  }
  if (isTokenFunction(t3)) {
    const t4 = consumeFunction(e3, n3);
    return { advance: t4.advance, node: t4.node };
  }
  if (isTokenWhitespace(t3)) {
    const t4 = consumeWhitespace(e3, n3);
    return { advance: t4.advance, node: t4.node };
  }
  if (isTokenComment(t3)) {
    const t4 = consumeComment2(e3, n3);
    return { advance: t4.advance, node: t4.node };
  }
  return { advance: 1, node: new TokenNode(t3) };
}
(function(e3) {
  e3.Function = "function", e3.SimpleBlock = "simple-block", e3.Whitespace = "whitespace", e3.Comment = "comment", e3.Token = "token";
})(f2 || (f2 = {}));

class ContainerNodeBaseClass {
  value = [];
  indexOf(e3) {
    return this.value.indexOf(e3);
  }
  at(e3) {
    if (typeof e3 == "number")
      return e3 < 0 && (e3 = this.value.length + e3), this.value[e3];
  }
  forEach(e3, n3) {
    if (this.value.length === 0)
      return;
    const t3 = walkerIndexGenerator(this.value);
    let o3 = 0;
    for (;o3 < this.value.length; ) {
      const s3 = this.value[o3];
      let i3;
      if (n3 && (i3 = { ...n3 }), e3({ node: s3, parent: this, state: i3 }, o3) === false)
        return false;
      if (o3 = t3(this.value, s3, o3), o3 === -1)
        break;
    }
  }
  walk(e3, n3) {
    this.value.length !== 0 && this.forEach((n4, t3) => e3(n4, t3) !== false && ((!("walk" in n4.node) || !this.value.includes(n4.node) || n4.node.walk(e3, n4.state) !== false) && undefined), n3);
  }
}

class FunctionNode extends ContainerNodeBaseClass {
  type = f2.Function;
  name;
  endToken;
  constructor(e3, n3, t3) {
    super(), this.name = e3, this.endToken = n3, this.value = t3;
  }
  getName() {
    return this.name[4].value;
  }
  normalize() {
    isTokenEOF(this.endToken) && (this.endToken = [c.CloseParen, ")", -1, -1, undefined]);
  }
  tokens() {
    return isTokenEOF(this.endToken) ? [this.name, ...this.value.flatMap((e3) => e3.tokens())] : [this.name, ...this.value.flatMap((e3) => e3.tokens()), this.endToken];
  }
  toString() {
    const e3 = this.value.map((e4) => isToken(e4) ? stringify(e4) : e4.toString()).join("");
    return stringify(this.name) + e3 + stringify(this.endToken);
  }
  toJSON() {
    return { type: this.type, name: this.getName(), tokens: this.tokens(), value: this.value.map((e3) => e3.toJSON()) };
  }
  isFunctionNode() {
    return FunctionNode.isFunctionNode(this);
  }
  static isFunctionNode(e3) {
    return !!e3 && (e3 instanceof FunctionNode && e3.type === f2.Function);
  }
}
function consumeFunction(n3, t3) {
  const o3 = [];
  let s3 = 1;
  for (;; ) {
    const i3 = t3[s3];
    if (!i3 || isTokenEOF(i3))
      return n3.onParseError(new ParseError("Unexpected EOF while consuming a function.", t3[0][2], t3[t3.length - 1][3], ["5.4.9. Consume a function", "Unexpected EOF"])), { advance: t3.length, node: new FunctionNode(t3[0], i3, o3) };
    if (isTokenCloseParen(i3))
      return { advance: s3 + 1, node: new FunctionNode(t3[0], i3, o3) };
    if (isTokenWhiteSpaceOrComment(i3)) {
      const e3 = consumeAllCommentsAndWhitespace(n3, t3.slice(s3));
      s3 += e3.advance, o3.push(...e3.nodes);
      continue;
    }
    const r3 = consumeComponentValue(n3, t3.slice(s3));
    s3 += r3.advance, o3.push(r3.node);
  }
}

class SimpleBlockNode extends ContainerNodeBaseClass {
  type = f2.SimpleBlock;
  startToken;
  endToken;
  constructor(e3, n3, t3) {
    super(), this.startToken = e3, this.endToken = n3, this.value = t3;
  }
  normalize() {
    if (isTokenEOF(this.endToken)) {
      const e3 = mirrorVariant(this.startToken);
      e3 && (this.endToken = e3);
    }
  }
  tokens() {
    return isTokenEOF(this.endToken) ? [this.startToken, ...this.value.flatMap((e3) => e3.tokens())] : [this.startToken, ...this.value.flatMap((e3) => e3.tokens()), this.endToken];
  }
  toString() {
    const e3 = this.value.map((e4) => isToken(e4) ? stringify(e4) : e4.toString()).join("");
    return stringify(this.startToken) + e3 + stringify(this.endToken);
  }
  toJSON() {
    return { type: this.type, startToken: this.startToken, tokens: this.tokens(), value: this.value.map((e3) => e3.toJSON()) };
  }
  isSimpleBlockNode() {
    return SimpleBlockNode.isSimpleBlockNode(this);
  }
  static isSimpleBlockNode(e3) {
    return !!e3 && (e3 instanceof SimpleBlockNode && e3.type === f2.SimpleBlock);
  }
}
function consumeSimpleBlock(n3, t3) {
  const o3 = mirrorVariantType(t3[0][0]);
  if (!o3)
    throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
  const s3 = [];
  let i3 = 1;
  for (;; ) {
    const r3 = t3[i3];
    if (!r3 || isTokenEOF(r3))
      return n3.onParseError(new ParseError("Unexpected EOF while consuming a simple block.", t3[0][2], t3[t3.length - 1][3], ["5.4.8. Consume a simple block", "Unexpected EOF"])), { advance: t3.length, node: new SimpleBlockNode(t3[0], r3, s3) };
    if (r3[0] === o3)
      return { advance: i3 + 1, node: new SimpleBlockNode(t3[0], r3, s3) };
    if (isTokenWhiteSpaceOrComment(r3)) {
      const e3 = consumeAllCommentsAndWhitespace(n3, t3.slice(i3));
      i3 += e3.advance, s3.push(...e3.nodes);
      continue;
    }
    const a3 = consumeComponentValue(n3, t3.slice(i3));
    i3 += a3.advance, s3.push(a3.node);
  }
}

class WhitespaceNode {
  type = f2.Whitespace;
  value;
  constructor(e3) {
    this.value = e3;
  }
  tokens() {
    return this.value;
  }
  toString() {
    return stringify(...this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isWhitespaceNode() {
    return WhitespaceNode.isWhitespaceNode(this);
  }
  static isWhitespaceNode(e3) {
    return !!e3 && (e3 instanceof WhitespaceNode && e3.type === f2.Whitespace);
  }
}
function consumeWhitespace(e3, n3) {
  let t3 = 0;
  for (;; ) {
    const e4 = n3[t3];
    if (!isTokenWhitespace(e4))
      return { advance: t3, node: new WhitespaceNode(n3.slice(0, t3)) };
    t3++;
  }
}

class CommentNode {
  type = f2.Comment;
  value;
  constructor(e3) {
    this.value = e3;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return stringify(this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isCommentNode() {
    return CommentNode.isCommentNode(this);
  }
  static isCommentNode(e3) {
    return !!e3 && (e3 instanceof CommentNode && e3.type === f2.Comment);
  }
}
function consumeComment2(e3, n3) {
  return { advance: 1, node: new CommentNode(n3[0]) };
}
function consumeAllCommentsAndWhitespace(e3, n3) {
  const t3 = [];
  let o3 = 0;
  for (;; )
    if (isTokenWhitespace(n3[o3])) {
      const e4 = consumeWhitespace(0, n3.slice(o3));
      o3 += e4.advance, t3.push(e4.node);
    } else {
      if (!isTokenComment(n3[o3]))
        return { advance: o3, nodes: t3 };
      t3.push(new CommentNode(n3[o3])), o3++;
    }
}

class TokenNode {
  type = f2.Token;
  value;
  constructor(e3) {
    this.value = e3;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return this.value[1];
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isTokenNode() {
    return TokenNode.isTokenNode(this);
  }
  static isTokenNode(e3) {
    return !!e3 && (e3 instanceof TokenNode && e3.type === f2.Token);
  }
}
function parseComponentValue(t3, o3) {
  const s3 = { onParseError: o3?.onParseError ?? (() => {}) }, i3 = [...t3];
  isTokenEOF(i3[i3.length - 1]) && i3.push([c.EOF, "", i3[i3.length - 1][2], i3[i3.length - 1][3], undefined]);
  const r3 = consumeComponentValue(s3, i3);
  if (isTokenEOF(i3[Math.min(r3.advance, i3.length - 1)]))
    return r3.node;
  s3.onParseError(new ParseError("Expected EOF after parsing a component value.", t3[0][2], t3[t3.length - 1][3], ["5.3.9. Parse a component value", "Expected EOF"]));
}
function parseCommaSeparatedListOfComponentValues(t3, o3) {
  const s3 = { onParseError: o3?.onParseError ?? (() => {}) }, i3 = [...t3];
  if (t3.length === 0)
    return [];
  isTokenEOF(i3[i3.length - 1]) && i3.push([c.EOF, "", i3[i3.length - 1][2], i3[i3.length - 1][3], undefined]);
  const r3 = [];
  let a3 = [], c3 = 0;
  for (;; ) {
    if (!i3[c3] || isTokenEOF(i3[c3]))
      return a3.length && r3.push(a3), r3;
    if (isTokenComma(i3[c3])) {
      r3.push(a3), a3 = [], c3++;
      continue;
    }
    const n3 = consumeComponentValue(s3, t3.slice(c3));
    a3.push(n3.node), c3 += n3.advance;
  }
}
function forEach(e3, n3, t3) {
  if (e3.length === 0)
    return;
  const o3 = walkerIndexGenerator(e3);
  let s3 = 0;
  for (;s3 < e3.length; ) {
    const i3 = e3[s3];
    let r3;
    if (t3 && (r3 = { ...t3 }), n3({ node: i3, parent: { value: e3 }, state: r3 }, s3) === false)
      return false;
    if (s3 = o3(e3, i3, s3), s3 === -1)
      break;
  }
}
function walk(e3, n3, t3) {
  e3.length !== 0 && forEach(e3, (t4, o3) => n3(t4, o3) !== false && ((!("walk" in t4.node) || !e3.includes(t4.node) || t4.node.walk(n3, t4.state) !== false) && undefined), t3);
}
function replaceComponentValues(e3, n3) {
  for (let t3 = 0;t3 < e3.length; t3++) {
    walk(e3[t3], (e4, t4) => {
      if (typeof t4 != "number")
        return;
      const o3 = n3(e4.node);
      o3 && (Array.isArray(o3) ? e4.parent.value.splice(t4, 1, ...o3) : e4.parent.value.splice(t4, 1, o3));
    });
  }
  return e3;
}
function isSimpleBlockNode(e3) {
  return SimpleBlockNode.isSimpleBlockNode(e3);
}
function isFunctionNode(e3) {
  return FunctionNode.isFunctionNode(e3);
}
function isWhitespaceNode(e3) {
  return WhitespaceNode.isWhitespaceNode(e3);
}
function isCommentNode(e3) {
  return CommentNode.isCommentNode(e3);
}
function isWhiteSpaceOrCommentNode(e3) {
  return isWhitespaceNode(e3) || isCommentNode(e3);
}
function isTokenNode(e3) {
  return TokenNode.isTokenNode(e3);
}

// node_modules/@csstools/css-calc/dist/index.mjs
var E = /[A-Z]/g;
function toLowerCaseAZ(e3) {
  return e3.replace(E, (e4) => String.fromCharCode(e4.charCodeAt(0) + 32));
}
var I = { cm: "px", in: "px", mm: "px", pc: "px", pt: "px", px: "px", q: "px", deg: "deg", grad: "deg", rad: "deg", turn: "deg", ms: "s", s: "s", hz: "hz", khz: "hz" };
var S = new Map([["cm", (e3) => e3], ["mm", (e3) => 10 * e3], ["q", (e3) => 40 * e3], ["in", (e3) => e3 / 2.54], ["pc", (e3) => e3 / 2.54 * 6], ["pt", (e3) => e3 / 2.54 * 72], ["px", (e3) => e3 / 2.54 * 96]]);
var y = new Map([["deg", (e3) => e3], ["grad", (e3) => e3 / 0.9], ["rad", (e3) => e3 / 180 * Math.PI], ["turn", (e3) => e3 / 360]]);
var M2 = new Map([["deg", (e3) => 0.9 * e3], ["grad", (e3) => e3], ["rad", (e3) => 0.9 * e3 / 180 * Math.PI], ["turn", (e3) => 0.9 * e3 / 360]]);
var T = new Map([["hz", (e3) => e3], ["khz", (e3) => e3 / 1000]]);
var x = new Map([["cm", (e3) => 2.54 * e3], ["mm", (e3) => 25.4 * e3], ["q", (e3) => 25.4 * e3 * 4], ["in", (e3) => e3], ["pc", (e3) => 6 * e3], ["pt", (e3) => 72 * e3], ["px", (e3) => 96 * e3]]);
var k = new Map([["hz", (e3) => 1000 * e3], ["khz", (e3) => e3]]);
var P = new Map([["cm", (e3) => e3 / 10], ["mm", (e3) => e3], ["q", (e3) => 4 * e3], ["in", (e3) => e3 / 25.4], ["pc", (e3) => e3 / 25.4 * 6], ["pt", (e3) => e3 / 25.4 * 72], ["px", (e3) => e3 / 25.4 * 96]]);
var O = new Map([["ms", (e3) => e3], ["s", (e3) => e3 / 1000]]);
var W = new Map([["cm", (e3) => e3 / 6 * 2.54], ["mm", (e3) => e3 / 6 * 25.4], ["q", (e3) => e3 / 6 * 25.4 * 4], ["in", (e3) => e3 / 6], ["pc", (e3) => e3], ["pt", (e3) => e3 / 6 * 72], ["px", (e3) => e3 / 6 * 96]]);
var L2 = new Map([["cm", (e3) => e3 / 72 * 2.54], ["mm", (e3) => e3 / 72 * 25.4], ["q", (e3) => e3 / 72 * 25.4 * 4], ["in", (e3) => e3 / 72], ["pc", (e3) => e3 / 72 * 6], ["pt", (e3) => e3], ["px", (e3) => e3 / 72 * 96]]);
var U = new Map([["cm", (e3) => e3 / 96 * 2.54], ["mm", (e3) => e3 / 96 * 25.4], ["q", (e3) => e3 / 96 * 25.4 * 4], ["in", (e3) => e3 / 96], ["pc", (e3) => e3 / 96 * 6], ["pt", (e3) => e3 / 96 * 72], ["px", (e3) => e3]]);
var $ = new Map([["cm", (e3) => e3 / 4 / 10], ["mm", (e3) => e3 / 4], ["q", (e3) => e3], ["in", (e3) => e3 / 4 / 25.4], ["pc", (e3) => e3 / 4 / 25.4 * 6], ["pt", (e3) => e3 / 4 / 25.4 * 72], ["px", (e3) => e3 / 4 / 25.4 * 96]]);
var Z2 = new Map([["deg", (e3) => 180 * e3 / Math.PI], ["grad", (e3) => 180 * e3 / Math.PI / 0.9], ["rad", (e3) => e3], ["turn", (e3) => 180 * e3 / Math.PI / 360]]);
var z = new Map([["ms", (e3) => 1000 * e3], ["s", (e3) => e3]]);
var q = new Map([["deg", (e3) => 360 * e3], ["grad", (e3) => 360 * e3 / 0.9], ["rad", (e3) => 360 * e3 / 180 * Math.PI], ["turn", (e3) => e3]]);
var G = new Map([["cm", S], ["mm", P], ["q", $], ["in", x], ["pc", W], ["pt", L2], ["px", U], ["ms", O], ["s", z], ["deg", y], ["grad", M2], ["rad", Z2], ["turn", q], ["hz", T], ["khz", k]]);
function convertUnit(e3, n3) {
  if (!isTokenDimension(e3))
    return n3;
  if (!isTokenDimension(n3))
    return n3;
  const t3 = toLowerCaseAZ(e3[4].unit), r3 = toLowerCaseAZ(n3[4].unit);
  if (t3 === r3)
    return n3;
  const a3 = G.get(r3);
  if (!a3)
    return n3;
  const u3 = a3.get(t3);
  if (!u3)
    return n3;
  const i3 = u3(n3[4].value), o3 = [c.Dimension, "", n3[2], n3[3], { ...n3[4], signCharacter: i3 < 0 ? "-" : undefined, type: Number.isInteger(i3) ? a.Integer : a.Number, value: i3 }];
  return mutateUnit(o3, e3[4].unit), o3;
}
function toCanonicalUnit(e3) {
  if (!isTokenDimension(e3))
    return e3;
  const n3 = toLowerCaseAZ(e3[4].unit), t3 = I[n3];
  if (n3 === t3)
    return e3;
  const r3 = G.get(n3);
  if (!r3)
    return e3;
  const a3 = r3.get(t3);
  if (!a3)
    return e3;
  const u3 = a3(e3[4].value), i3 = [c.Dimension, "", e3[2], e3[3], { ...e3[4], signCharacter: u3 < 0 ? "-" : undefined, type: Number.isInteger(u3) ? a.Integer : a.Number, value: u3 }];
  return mutateUnit(i3, t3), i3;
}
function addition(n3) {
  if (n3.length !== 2)
    return -1;
  const t3 = n3[0].value;
  let r3 = n3[1].value;
  if (isTokenNumber(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value + r3[4].value;
    return new TokenNode([c.Number, n4.toString(), t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number }]);
  }
  if (isTokenPercentage(t3) && isTokenPercentage(r3)) {
    const n4 = t3[4].value + r3[4].value;
    return new TokenNode([c.Percentage, n4.toString() + "%", t3[2], r3[3], { value: n4 }]);
  }
  if (isTokenDimension(t3) && isTokenDimension(r3) && (r3 = convertUnit(t3, r3), toLowerCaseAZ(t3[4].unit) === toLowerCaseAZ(r3[4].unit))) {
    const n4 = t3[4].value + r3[4].value;
    return new TokenNode([c.Dimension, n4.toString() + t3[4].unit, t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number, unit: t3[4].unit }]);
  }
  return -1;
}
function division(n3) {
  if (n3.length !== 2)
    return -1;
  const t3 = n3[0].value, r3 = n3[1].value;
  if (isTokenNumber(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value / r3[4].value;
    return new TokenNode([c.Number, n4.toString(), t3[2], r3[3], { value: n4, type: Number.isInteger(n4) ? a.Integer : a.Number }]);
  }
  if (isTokenPercentage(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value / r3[4].value;
    return new TokenNode([c.Percentage, n4.toString() + "%", t3[2], r3[3], { value: n4 }]);
  }
  if (isTokenDimension(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value / r3[4].value;
    return new TokenNode([c.Dimension, n4.toString() + t3[4].unit, t3[2], r3[3], { value: n4, type: Number.isInteger(n4) ? a.Integer : a.Number, unit: t3[4].unit }]);
  }
  return -1;
}
function isCalculation(e3) {
  return !!e3 && typeof e3 == "object" && "inputs" in e3 && Array.isArray(e3.inputs) && "operation" in e3;
}
function solve(e3) {
  if (e3 === -1)
    return -1;
  const t3 = [];
  for (let r3 = 0;r3 < e3.inputs.length; r3++) {
    const a3 = e3.inputs[r3];
    if (isTokenNode(a3)) {
      t3.push(a3);
      continue;
    }
    const u3 = solve(a3);
    if (u3 === -1)
      return -1;
    t3.push(u3);
  }
  return e3.operation(t3);
}
function multiplication(n3) {
  if (n3.length !== 2)
    return -1;
  const t3 = n3[0].value, r3 = n3[1].value;
  if (isTokenNumber(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value * r3[4].value;
    return new TokenNode([c.Number, n4.toString(), t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number }]);
  }
  if (isTokenPercentage(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value * r3[4].value;
    return new TokenNode([c.Percentage, n4.toString() + "%", t3[2], r3[3], { value: n4 }]);
  }
  if (isTokenNumber(t3) && isTokenPercentage(r3)) {
    const n4 = t3[4].value * r3[4].value;
    return new TokenNode([c.Percentage, n4.toString() + "%", t3[2], r3[3], { value: n4 }]);
  }
  if (isTokenDimension(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value * r3[4].value;
    return new TokenNode([c.Dimension, n4.toString() + t3[4].unit, t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number, unit: t3[4].unit }]);
  }
  if (isTokenNumber(t3) && isTokenDimension(r3)) {
    const n4 = t3[4].value * r3[4].value;
    return new TokenNode([c.Dimension, n4.toString() + r3[4].unit, t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number, unit: r3[4].unit }]);
  }
  return -1;
}
function resolveGlobalsAndConstants(t3, r3) {
  for (let a3 = 0;a3 < t3.length; a3++) {
    const u3 = t3[a3];
    if (!isTokenNode(u3))
      continue;
    const i3 = u3.value;
    if (!isTokenIdent(i3))
      continue;
    const o3 = toLowerCaseAZ(i3[4].value);
    switch (o3) {
      case "e":
        t3.splice(a3, 1, new TokenNode([c.Number, Math.E.toString(), i3[2], i3[3], { value: Math.E, type: a.Number }]));
        break;
      case "pi":
        t3.splice(a3, 1, new TokenNode([c.Number, Math.PI.toString(), i3[2], i3[3], { value: Math.PI, type: a.Number }]));
        break;
      case "infinity":
        t3.splice(a3, 1, new TokenNode([c.Number, "infinity", i3[2], i3[3], { value: 1 / 0, type: a.Number }]));
        break;
      case "-infinity":
        t3.splice(a3, 1, new TokenNode([c.Number, "-infinity", i3[2], i3[3], { value: -1 / 0, type: a.Number }]));
        break;
      case "nan":
        t3.splice(a3, 1, new TokenNode([c.Number, "NaN", i3[2], i3[3], { value: Number.NaN, type: a.Number }]));
        break;
      default:
        if (r3.has(o3)) {
          const n3 = r3.get(o3);
          t3.splice(a3, 1, new TokenNode(n3));
        }
    }
  }
  return t3;
}
function unary(e3) {
  if (e3.length !== 1)
    return -1;
  const n3 = e3[0].value;
  return isTokenNumeric(n3) ? e3[0] : -1;
}
function resultToCalculation(e3, n3, t3) {
  return isTokenDimension(n3) ? dimensionToCalculation(e3, n3[4].unit, t3) : isTokenPercentage(n3) ? percentageToCalculation(e3, t3) : isTokenNumber(n3) ? numberToCalculation(e3, t3) : -1;
}
function dimensionToCalculation(n3, t3, r3) {
  const a3 = n3.tokens();
  return { inputs: [new TokenNode([c.Dimension, r3.toString() + t3, a3[0][2], a3[a3.length - 1][3], { value: r3, type: Number.isInteger(r3) ? a.Integer : a.Number, unit: t3 }])], operation: unary };
}
function percentageToCalculation(n3, t3) {
  const r3 = n3.tokens();
  return { inputs: [new TokenNode([c.Percentage, t3.toString() + "%", r3[0][2], r3[r3.length - 1][3], { value: t3 }])], operation: unary };
}
function numberToCalculation(n3, t3) {
  const r3 = n3.tokens();
  return { inputs: [new TokenNode([c.Number, t3.toString(), r3[0][2], r3[r3.length - 1][3], { value: t3, type: Number.isInteger(t3) ? a.Integer : a.Number }])], operation: unary };
}
function solveACos(e3, n3) {
  const t3 = n3.value;
  if (!isTokenNumber(t3))
    return -1;
  return dimensionToCalculation(e3, "rad", Math.acos(t3[4].value));
}
function solveASin(e3, n3) {
  const t3 = n3.value;
  if (!isTokenNumber(t3))
    return -1;
  return dimensionToCalculation(e3, "rad", Math.asin(t3[4].value));
}
function solveATan(e3, n3) {
  const t3 = n3.value;
  if (!isTokenNumber(t3))
    return -1;
  return dimensionToCalculation(e3, "rad", Math.atan(t3[4].value));
}
function isDimensionOrNumber(e3) {
  return isTokenDimension(e3) || isTokenNumber(e3);
}
function arrayOfSameNumeric(e3) {
  if (e3.length === 0)
    return true;
  const n3 = e3[0];
  if (!isTokenNumeric(n3))
    return false;
  if (e3.length === 1)
    return true;
  if (isTokenDimension(n3)) {
    const t3 = toLowerCaseAZ(n3[4].unit);
    for (let r3 = 1;r3 < e3.length; r3++) {
      const a3 = e3[r3];
      if (n3[0] !== a3[0])
        return false;
      if (t3 !== toLowerCaseAZ(a3[4].unit))
        return false;
    }
    return true;
  }
  for (let t3 = 1;t3 < e3.length; t3++) {
    const r3 = e3[t3];
    if (n3[0] !== r3[0])
      return false;
  }
  return true;
}
function twoOfSameNumeric(e3, n3) {
  return !!isTokenNumeric(e3) && (isTokenDimension(e3) ? e3[0] === n3[0] && toLowerCaseAZ(e3[4].unit) === toLowerCaseAZ(n3[4].unit) : e3[0] === n3[0]);
}
function solveATan2(e3, n3, t3) {
  const r3 = n3.value;
  if (!isDimensionOrNumber(r3))
    return -1;
  const a3 = convertUnit(r3, t3.value);
  if (!twoOfSameNumeric(r3, a3))
    return -1;
  return dimensionToCalculation(e3, "rad", Math.atan2(r3[4].value, a3[4].value));
}
function solveAbs(e3, n3, t3) {
  const r3 = n3.value;
  if (!isTokenNumeric(r3))
    return -1;
  if (!t3.rawPercentages && isTokenPercentage(r3))
    return -1;
  return resultToCalculation(e3, r3, Math.abs(r3[4].value));
}
function solveClamp(e3, t3, r3, a3, u3) {
  if (!isTokenNode(t3) || !isTokenNode(r3) || !isTokenNode(a3))
    return -1;
  const i3 = t3.value;
  if (!isTokenNumeric(i3))
    return -1;
  if (!u3.rawPercentages && isTokenPercentage(i3))
    return -1;
  const o3 = convertUnit(i3, r3.value);
  if (!twoOfSameNumeric(i3, o3))
    return -1;
  const l2 = convertUnit(i3, a3.value);
  if (!twoOfSameNumeric(i3, l2))
    return -1;
  return resultToCalculation(e3, i3, Math.max(i3[4].value, Math.min(o3[4].value, l2[4].value)));
}
function solveCos(e3, n3) {
  const t3 = n3.value;
  if (!isDimensionOrNumber(t3))
    return -1;
  let r3 = t3[4].value;
  if (isTokenDimension(t3))
    switch (t3[4].unit.toLowerCase()) {
      case "rad":
        break;
      case "deg":
        r3 = y.get("rad")(t3[4].value);
        break;
      case "grad":
        r3 = M2.get("rad")(t3[4].value);
        break;
      case "turn":
        r3 = q.get("rad")(t3[4].value);
        break;
      default:
        return -1;
    }
  return r3 = Math.cos(r3), numberToCalculation(e3, r3);
}
function solveExp(e3, n3) {
  const t3 = n3.value;
  if (!isTokenNumber(t3))
    return -1;
  return numberToCalculation(e3, Math.exp(t3[4].value));
}
function solveHypot(e3, t3, r3) {
  if (!t3.every(isTokenNode))
    return -1;
  const a3 = t3[0].value;
  if (!isTokenNumeric(a3))
    return -1;
  if (!r3.rawPercentages && isTokenPercentage(a3))
    return -1;
  const u3 = t3.map((e4) => convertUnit(a3, e4.value));
  if (!arrayOfSameNumeric(u3))
    return -1;
  const i3 = u3.map((e4) => e4[4].value), o3 = Math.hypot(...i3);
  return resultToCalculation(e3, a3, o3);
}
function solveMax(e3, t3, r3) {
  if (!t3.every(isTokenNode))
    return -1;
  const a3 = t3[0].value;
  if (!isTokenNumeric(a3))
    return -1;
  if (!r3.rawPercentages && isTokenPercentage(a3))
    return -1;
  const u3 = t3.map((e4) => convertUnit(a3, e4.value));
  if (!arrayOfSameNumeric(u3))
    return -1;
  const i3 = u3.map((e4) => e4[4].value), o3 = Math.max(...i3);
  return resultToCalculation(e3, a3, o3);
}
function solveMin(e3, t3, r3) {
  if (!t3.every(isTokenNode))
    return -1;
  const a3 = t3[0].value;
  if (!isTokenNumeric(a3))
    return -1;
  if (!r3.rawPercentages && isTokenPercentage(a3))
    return -1;
  const u3 = t3.map((e4) => convertUnit(a3, e4.value));
  if (!arrayOfSameNumeric(u3))
    return -1;
  const i3 = u3.map((e4) => e4[4].value), o3 = Math.min(...i3);
  return resultToCalculation(e3, a3, o3);
}
function solveMod(e3, n3, t3) {
  const r3 = n3.value;
  if (!isTokenNumeric(r3))
    return -1;
  const a3 = convertUnit(r3, t3.value);
  if (!twoOfSameNumeric(r3, a3))
    return -1;
  let u3;
  return u3 = a3[4].value === 0 ? Number.NaN : Number.isFinite(r3[4].value) && (Number.isFinite(a3[4].value) || (a3[4].value !== Number.POSITIVE_INFINITY || r3[4].value !== Number.NEGATIVE_INFINITY && !Object.is(0 * r3[4].value, -0)) && (a3[4].value !== Number.NEGATIVE_INFINITY || r3[4].value !== Number.POSITIVE_INFINITY && !Object.is(0 * r3[4].value, 0))) ? Number.isFinite(a3[4].value) ? (r3[4].value % a3[4].value + a3[4].value) % a3[4].value : r3[4].value : Number.NaN, resultToCalculation(e3, r3, u3);
}
function solvePow(e3, n3, t3) {
  const r3 = n3.value, a3 = t3.value;
  if (!isTokenNumber(r3))
    return -1;
  if (!twoOfSameNumeric(r3, a3))
    return -1;
  return numberToCalculation(e3, Math.pow(r3[4].value, a3[4].value));
}
function solveRem(e3, n3, t3) {
  const r3 = n3.value;
  if (!isTokenNumeric(r3))
    return -1;
  const a3 = convertUnit(r3, t3.value);
  if (!twoOfSameNumeric(r3, a3))
    return -1;
  let u3;
  return u3 = a3[4].value === 0 ? Number.NaN : Number.isFinite(r3[4].value) ? Number.isFinite(a3[4].value) ? r3[4].value % a3[4].value : r3[4].value : Number.NaN, resultToCalculation(e3, r3, u3);
}
function solveRound(e3, n3, t3, r3, a3) {
  const u3 = t3.value;
  if (!isTokenNumeric(u3))
    return -1;
  if (!a3.rawPercentages && isTokenPercentage(u3))
    return -1;
  const i3 = convertUnit(u3, r3.value);
  if (!twoOfSameNumeric(u3, i3))
    return -1;
  let o3;
  if (i3[4].value === 0)
    o3 = Number.NaN;
  else if (Number.isFinite(u3[4].value) || Number.isFinite(i3[4].value))
    if (!Number.isFinite(u3[4].value) && Number.isFinite(i3[4].value))
      o3 = u3[4].value;
    else if (Number.isFinite(u3[4].value) && !Number.isFinite(i3[4].value))
      switch (n3) {
        case "down":
          o3 = u3[4].value < 0 ? -1 / 0 : Object.is(-0, 0 * u3[4].value) ? -0 : 0;
          break;
        case "up":
          o3 = u3[4].value > 0 ? 1 / 0 : Object.is(0, 0 * u3[4].value) ? 0 : -0;
          break;
        default:
          o3 = Object.is(0, 0 * u3[4].value) ? 0 : -0;
      }
    else if (Number.isFinite(i3[4].value))
      switch (n3) {
        case "down":
          o3 = Math.floor(u3[4].value / i3[4].value) * i3[4].value;
          break;
        case "up":
          o3 = Math.ceil(u3[4].value / i3[4].value) * i3[4].value;
          break;
        case "to-zero":
          o3 = Math.trunc(u3[4].value / i3[4].value) * i3[4].value;
          break;
        default: {
          let e4 = Math.floor(u3[4].value / i3[4].value) * i3[4].value, n4 = Math.ceil(u3[4].value / i3[4].value) * i3[4].value;
          if (e4 > n4) {
            const t5 = e4;
            e4 = n4, n4 = t5;
          }
          const t4 = Math.abs(u3[4].value - e4), r4 = Math.abs(u3[4].value - n4);
          o3 = t4 === r4 ? n4 : t4 < r4 ? e4 : n4;
          break;
        }
      }
    else
      o3 = u3[4].value;
  else
    o3 = Number.NaN;
  return resultToCalculation(e3, u3, o3);
}
function solveSign(e3, n3, t3) {
  const r3 = n3.value;
  if (!isTokenNumeric(r3))
    return -1;
  if (!t3.rawPercentages && isTokenPercentage(r3))
    return -1;
  return numberToCalculation(e3, Math.sign(r3[4].value));
}
function solveSin(e3, n3) {
  const t3 = n3.value;
  if (!isDimensionOrNumber(t3))
    return -1;
  let r3 = t3[4].value;
  if (isTokenDimension(t3))
    switch (toLowerCaseAZ(t3[4].unit)) {
      case "rad":
        break;
      case "deg":
        r3 = y.get("rad")(t3[4].value);
        break;
      case "grad":
        r3 = M2.get("rad")(t3[4].value);
        break;
      case "turn":
        r3 = q.get("rad")(t3[4].value);
        break;
      default:
        return -1;
    }
  return r3 = Math.sin(r3), numberToCalculation(e3, r3);
}
function solveSqrt(e3, n3) {
  const t3 = n3.value;
  if (!isTokenNumber(t3))
    return -1;
  return numberToCalculation(e3, Math.sqrt(t3[4].value));
}
function solveTan(e3, n3) {
  const t3 = n3.value;
  if (!isDimensionOrNumber(t3))
    return -1;
  const r3 = t3[4].value;
  let a3 = 0, u3 = t3[4].value;
  if (isTokenDimension(t3))
    switch (toLowerCaseAZ(t3[4].unit)) {
      case "rad":
        a3 = Z2.get("deg")(r3);
        break;
      case "deg":
        a3 = r3, u3 = y.get("rad")(r3);
        break;
      case "grad":
        a3 = M2.get("deg")(r3), u3 = M2.get("rad")(r3);
        break;
      case "turn":
        a3 = q.get("deg")(r3), u3 = q.get("rad")(r3);
        break;
      default:
        return -1;
    }
  const i3 = a3 / 90;
  return u3 = a3 % 90 == 0 && i3 % 2 != 0 ? i3 > 0 ? 1 / 0 : -1 / 0 : Math.tan(u3), numberToCalculation(e3, u3);
}
function subtraction(n3) {
  if (n3.length !== 2)
    return -1;
  const t3 = n3[0].value;
  let r3 = n3[1].value;
  if (isTokenNumber(t3) && isTokenNumber(r3)) {
    const n4 = t3[4].value - r3[4].value;
    return new TokenNode([c.Number, n4.toString(), t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number }]);
  }
  if (isTokenPercentage(t3) && isTokenPercentage(r3)) {
    const n4 = t3[4].value - r3[4].value;
    return new TokenNode([c.Percentage, n4.toString() + "%", t3[2], r3[3], { value: n4 }]);
  }
  if (isTokenDimension(t3) && isTokenDimension(r3) && (r3 = convertUnit(t3, r3), toLowerCaseAZ(t3[4].unit) === toLowerCaseAZ(r3[4].unit))) {
    const n4 = t3[4].value - r3[4].value;
    return new TokenNode([c.Dimension, n4.toString() + t3[4].unit, t3[2], r3[3], { value: n4, type: t3[4].type === a.Integer && r3[4].type === a.Integer ? a.Integer : a.Number, unit: t3[4].unit }]);
  }
  return -1;
}
function solveLog(e3, t3) {
  if (t3.length === 1) {
    const r3 = t3[0];
    if (!r3 || !isTokenNode(r3))
      return -1;
    const a3 = r3.value;
    if (!isTokenNumber(a3))
      return -1;
    return numberToCalculation(e3, Math.log(a3[4].value));
  }
  if (t3.length === 2) {
    const r3 = t3[0];
    if (!r3 || !isTokenNode(r3))
      return -1;
    const a3 = r3.value;
    if (!isTokenNumber(a3))
      return -1;
    const u3 = t3[1];
    if (!u3 || !isTokenNode(u3))
      return -1;
    const i3 = u3.value;
    if (!isTokenNumber(i3))
      return -1;
    return numberToCalculation(e3, Math.log(a3[4].value) / Math.log(i3[4].value));
  }
  return -1;
}
var R2 = /^none$/i;
function isNone(e3) {
  if (Array.isArray(e3)) {
    const n3 = e3.filter((e4) => !(isWhitespaceNode(e4) && isCommentNode(e4)));
    return n3.length === 1 && isNone(n3[0]);
  }
  if (!isTokenNode(e3))
    return false;
  const a3 = e3.value;
  return !!isTokenIdent(a3) && R2.test(a3[4].value);
}
var V = String.fromCodePoint(0);
function solveRandom(e3, n3, t3, r3, a3, u3) {
  if (n3.fixed === -1 && !u3.randomCaching)
    return -1;
  u3.randomCaching || (u3.randomCaching = { propertyName: "", propertyN: 0, elementID: "", documentID: "" }), u3.randomCaching && !u3.randomCaching.propertyN && (u3.randomCaching.propertyN = 0);
  const i3 = t3.value;
  if (!isTokenNumeric(i3))
    return -1;
  const o3 = convertUnit(i3, r3.value);
  if (!twoOfSameNumeric(i3, o3))
    return -1;
  let l2 = null;
  if (a3 && (l2 = convertUnit(i3, a3.value), !twoOfSameNumeric(i3, l2)))
    return -1;
  if (!Number.isFinite(i3[4].value))
    return resultToCalculation(e3, i3, Number.NaN);
  if (!Number.isFinite(o3[4].value))
    return resultToCalculation(e3, i3, Number.NaN);
  if (!Number.isFinite(o3[4].value - i3[4].value))
    return resultToCalculation(e3, i3, Number.NaN);
  if (l2 && !Number.isFinite(l2[4].value))
    return resultToCalculation(e3, i3, i3[4].value);
  const c3 = n3.fixed === -1 ? sfc32(crc32([n3.dashedIdent ? n3.dashedIdent : `${u3.randomCaching?.propertyName} ${u3.randomCaching.propertyN++}`, n3.elementShared ? "" : u3.randomCaching.elementID, u3.randomCaching.documentID].join(V))) : () => n3.fixed;
  let s3 = i3[4].value, v = o3[4].value;
  if (s3 > v && ([s3, v] = [v, s3]), l2 && (l2[4].value <= 0 || Math.abs(s3 - v) / l2[4].value > 10000000000) && (l2 = null), l2) {
    const n4 = Math.max(l2[4].value / 1000, 0.000000001), t4 = [s3];
    let r4 = 0;
    for (;; ) {
      r4 += l2[4].value;
      const e4 = s3 + r4;
      if (!(e4 + n4 < v)) {
        t4.push(v);
        break;
      }
      if (t4.push(e4), e4 + l2[4].value - n4 > v)
        break;
    }
    const a4 = c3();
    return resultToCalculation(e3, i3, Number(t4[Math.floor(t4.length * a4)].toFixed(5)));
  }
  const f3 = c3();
  return resultToCalculation(e3, i3, Number((f3 * (v - s3) + s3).toFixed(5)));
}
function sfc32(e3 = 0.34944106645296036, n3 = 0.19228640875738723, t3 = 0.8784393832007205, r3 = 0.04850964319275053) {
  return () => {
    const a3 = ((e3 |= 0) + (n3 |= 0) | 0) + (r3 |= 0) | 0;
    return r3 = r3 + 1 | 0, e3 = n3 ^ n3 >>> 9, n3 = (t3 |= 0) + (t3 << 3) | 0, t3 = (t3 = t3 << 21 | t3 >>> 11) + a3 | 0, (a3 >>> 0) / 4294967296;
  };
}
function crc32(e3) {
  let n3 = 0, t3 = 0, r3 = 0;
  n3 ^= -1;
  for (let a3 = 0, u3 = e3.length;a3 < u3; a3++)
    r3 = 255 & (n3 ^ e3.charCodeAt(a3)), t3 = Number("0x" + "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".substring(9 * r3, 9 * r3 + 8)), n3 = n3 >>> 8 ^ t3;
  return (-1 ^ n3) >>> 0;
}
var j = new Map([["abs", function abs(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveAbs);
}], ["acos", function acos(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveACos);
}], ["asin", function asin(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveASin);
}], ["atan", function atan(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveATan);
}], ["atan2", function atan2(e3, n3, t3) {
  return twoCommaSeparatedNodesSolver(e3, n3, t3, solveATan2);
}], ["calc", calc$1], ["clamp", function clamp(t3, r3, u3) {
  const i3 = resolveGlobalsAndConstants([...t3.value.filter((e3) => !isWhiteSpaceOrCommentNode(e3))], r3), l2 = [], c3 = [], s3 = [];
  {
    let e3 = l2;
    for (let t4 = 0;t4 < i3.length; t4++) {
      const r4 = i3[t4];
      if (isTokenNode(r4) && isTokenComma(r4.value)) {
        if (e3 === s3)
          return -1;
        if (e3 === c3) {
          e3 = s3;
          continue;
        }
        if (e3 === l2) {
          e3 = c3;
          continue;
        }
        return -1;
      }
      e3.push(r4);
    }
  }
  const v = isNone(l2), m2 = isNone(s3);
  if (v && m2)
    return calc$1(calcWrapper(c3), r3, u3);
  const p2 = solve(calc$1(calcWrapper(c3), r3, u3));
  if (p2 === -1)
    return -1;
  if (v) {
    const n3 = solve(calc$1(calcWrapper(s3), r3, u3));
    return n3 === -1 ? -1 : solveMin((C = p2, g2 = n3, new FunctionNode([c.Function, "min(", -1, -1, { value: "min" }], [c.CloseParen, ")", -1, -1, undefined], [C, new TokenNode([c.Comma, ",", -1, -1, undefined]), g2])), [p2, n3], u3);
  }
  if (m2) {
    const e3 = solve(calc$1(calcWrapper(l2), r3, u3));
    return e3 === -1 ? -1 : solveMax(maxWrapper(e3, p2), [e3, p2], u3);
  }
  var C, g2;
  const d3 = solve(calc$1(calcWrapper(l2), r3, u3));
  if (d3 === -1)
    return -1;
  const D2 = solve(calc$1(calcWrapper(s3), r3, u3));
  if (D2 === -1)
    return -1;
  return solveClamp(t3, d3, p2, D2, u3);
}], ["cos", function cos(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveCos);
}], ["exp", function exp(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveExp);
}], ["hypot", function hypot(e3, n3, t3) {
  return variadicNodesSolver(e3, e3.value, n3, t3, solveHypot);
}], ["log", function log(e3, n3, t3) {
  return variadicNodesSolver(e3, e3.value, n3, t3, solveLog);
}], ["max", function max(e3, n3, t3) {
  return variadicNodesSolver(e3, e3.value, n3, t3, solveMax);
}], ["min", function min(e3, n3, t3) {
  return variadicNodesSolver(e3, e3.value, n3, t3, solveMin);
}], ["mod", function mod(e3, n3, t3) {
  return twoCommaSeparatedNodesSolver(e3, n3, t3, solveMod);
}], ["pow", function pow(e3, n3, t3) {
  return twoCommaSeparatedNodesSolver(e3, n3, t3, solvePow);
}], ["random", function random(e3, n3, t3) {
  const r3 = parseRandomValueSharing(e3.value.filter((e4) => !isWhiteSpaceOrCommentNode(e4)), n3, t3);
  if (r3 === -1)
    return -1;
  const [u3, i3] = r3, o3 = variadicArguments(i3, n3, t3);
  if (o3 === -1)
    return -1;
  const [l2, c3, s3] = o3;
  if (!l2 || !c3)
    return -1;
  return solveRandom(e3, u3, l2, c3, s3, t3);
}], ["rem", function rem(e3, n3, t3) {
  return twoCommaSeparatedNodesSolver(e3, n3, t3, solveRem);
}], ["round", function round(t3, r3, u3) {
  const i3 = resolveGlobalsAndConstants([...t3.value.filter((e3) => !isWhiteSpaceOrCommentNode(e3))], r3);
  let o3 = "", l2 = false;
  const c3 = [], s3 = [];
  {
    let e3 = c3;
    for (let t4 = 0;t4 < i3.length; t4++) {
      const r4 = i3[t4];
      if (!o3 && c3.length === 0 && s3.length === 0 && isTokenNode(r4) && isTokenIdent(r4.value)) {
        const e4 = r4.value[4].value.toLowerCase();
        if (Y2.has(e4)) {
          o3 = e4;
          continue;
        }
      }
      if (isTokenNode(r4) && isTokenComma(r4.value)) {
        if (e3 === s3)
          return -1;
        if (e3 === c3 && o3 && c3.length === 0)
          continue;
        if (e3 === c3) {
          l2 = true, e3 = s3;
          continue;
        }
        return -1;
      }
      e3.push(r4);
    }
  }
  const v = solve(calc$1(calcWrapper(c3), r3, u3));
  if (v === -1)
    return -1;
  l2 || s3.length !== 0 || s3.push(new TokenNode([c.Number, "1", -1, -1, { value: 1, type: a.Integer }]));
  const p2 = solve(calc$1(calcWrapper(s3), r3, u3));
  if (p2 === -1)
    return -1;
  o3 || (o3 = "nearest");
  return solveRound(t3, o3, v, p2, u3);
}], ["sign", function sign(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveSign);
}], ["sin", function sin(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveSin);
}], ["sqrt", function sqrt(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveSqrt);
}], ["tan", function tan(e3, n3, t3) {
  return singleNodeSolver(e3, n3, t3, solveTan);
}]]);
function calc$1(e3, t3, r3) {
  const o3 = resolveGlobalsAndConstants([...e3.value.filter((e4) => !isWhiteSpaceOrCommentNode(e4))], t3);
  if (o3.length === 1 && isTokenNode(o3[0]))
    return { inputs: [o3[0]], operation: unary };
  let l2 = 0;
  for (;l2 < o3.length; ) {
    const e4 = o3[l2];
    if (isSimpleBlockNode(e4) && isTokenOpenParen(e4.startToken)) {
      const n3 = calc$1(e4, t3, r3);
      if (n3 === -1)
        return -1;
      o3.splice(l2, 1, n3);
    } else if (isFunctionNode(e4)) {
      const n3 = j.get(e4.getName().toLowerCase());
      if (!n3)
        return -1;
      const a3 = n3(e4, t3, r3);
      if (a3 === -1)
        return -1;
      o3.splice(l2, 1, a3);
    } else
      l2++;
  }
  if (l2 = 0, o3.length === 1 && isCalculation(o3[0]))
    return o3[0];
  for (;l2 < o3.length; ) {
    const e4 = o3[l2];
    if (!e4 || !isTokenNode(e4) && !isCalculation(e4)) {
      l2++;
      continue;
    }
    const t4 = o3[l2 + 1];
    if (!t4 || !isTokenNode(t4)) {
      l2++;
      continue;
    }
    const r4 = t4.value;
    if (!isTokenDelim(r4) || r4[4].value !== "*" && r4[4].value !== "/") {
      l2++;
      continue;
    }
    const a3 = o3[l2 + 2];
    if (!a3 || !isTokenNode(a3) && !isCalculation(a3))
      return -1;
    r4[4].value !== "*" ? r4[4].value !== "/" ? l2++ : o3.splice(l2, 3, { inputs: [e4, a3], operation: division }) : o3.splice(l2, 3, { inputs: [e4, a3], operation: multiplication });
  }
  if (l2 = 0, o3.length === 1 && isCalculation(o3[0]))
    return o3[0];
  for (;l2 < o3.length; ) {
    const e4 = o3[l2];
    if (!e4 || !isTokenNode(e4) && !isCalculation(e4)) {
      l2++;
      continue;
    }
    const t4 = o3[l2 + 1];
    if (!t4 || !isTokenNode(t4)) {
      l2++;
      continue;
    }
    const r4 = t4.value;
    if (!isTokenDelim(r4) || r4[4].value !== "+" && r4[4].value !== "-") {
      l2++;
      continue;
    }
    const a3 = o3[l2 + 2];
    if (!a3 || !isTokenNode(a3) && !isCalculation(a3))
      return -1;
    r4[4].value !== "+" ? r4[4].value !== "-" ? l2++ : o3.splice(l2, 3, { inputs: [e4, a3], operation: subtraction }) : o3.splice(l2, 3, { inputs: [e4, a3], operation: addition });
  }
  return o3.length === 1 && isCalculation(o3[0]) ? o3[0] : -1;
}
function singleNodeSolver(e3, n3, t3, r3) {
  const a3 = singleArgument(e3.value, n3, t3);
  return a3 === -1 ? -1 : r3(e3, a3, t3);
}
function singleArgument(e3, n3, t3) {
  const r3 = solve(calc$1(calcWrapper(resolveGlobalsAndConstants([...e3.filter((e4) => !isWhiteSpaceOrCommentNode(e4))], n3)), n3, t3));
  return r3 === -1 ? -1 : r3;
}
function twoCommaSeparatedNodesSolver(e3, n3, t3, r3) {
  const a3 = twoCommaSeparatedArguments(e3.value, n3, t3);
  if (a3 === -1)
    return -1;
  const [u3, i3] = a3;
  return r3(e3, u3, i3, t3);
}
function twoCommaSeparatedArguments(e3, t3, r3) {
  const u3 = resolveGlobalsAndConstants([...e3.filter((e4) => !isWhiteSpaceOrCommentNode(e4))], t3), i3 = [], o3 = [];
  {
    let e4 = i3;
    for (let t4 = 0;t4 < u3.length; t4++) {
      const r4 = u3[t4];
      if (isTokenNode(r4) && isTokenComma(r4.value)) {
        if (e4 === o3)
          return -1;
        if (e4 === i3) {
          e4 = o3;
          continue;
        }
        return -1;
      }
      e4.push(r4);
    }
  }
  const l2 = solve(calc$1(calcWrapper(i3), t3, r3));
  if (l2 === -1)
    return -1;
  const c3 = solve(calc$1(calcWrapper(o3), t3, r3));
  return c3 === -1 ? -1 : [l2, c3];
}
function variadicNodesSolver(e3, n3, t3, r3, a3) {
  const u3 = variadicArguments(e3.value, t3, r3);
  return u3 === -1 ? -1 : a3(e3, u3, r3);
}
function variadicArguments(e3, t3, r3) {
  const u3 = resolveGlobalsAndConstants([...e3.filter((e4) => !isWhiteSpaceOrCommentNode(e4))], t3), i3 = [];
  {
    const e4 = [];
    let a3 = [];
    for (let t4 = 0;t4 < u3.length; t4++) {
      const r4 = u3[t4];
      isTokenNode(r4) && isTokenComma(r4.value) ? (e4.push(a3), a3 = []) : a3.push(r4);
    }
    e4.push(a3);
    for (let n3 = 0;n3 < e4.length; n3++) {
      if (e4[n3].length === 0)
        return -1;
      const a4 = solve(calc$1(calcWrapper(e4[n3]), t3, r3));
      if (a4 === -1)
        return -1;
      i3.push(a4);
    }
  }
  return i3;
}
var Y2 = new Set(["nearest", "up", "down", "to-zero"]);
function parseRandomValueSharing(e3, t3, r3) {
  const a3 = { isAuto: false, dashedIdent: "", fixed: -1, elementShared: false }, u3 = e3[0];
  if (!isTokenNode(u3) || !isTokenIdent(u3.value))
    return [a3, e3];
  for (let u4 = 0;u4 < e3.length; u4++) {
    const i3 = e3[u4];
    if (!isTokenNode(i3))
      return -1;
    if (isTokenComma(i3.value))
      return [a3, e3.slice(u4 + 1)];
    if (!isTokenIdent(i3.value))
      return -1;
    const o3 = i3.value[4].value.toLowerCase();
    if (o3 !== "element-shared")
      if (o3 !== "fixed")
        if (o3 !== "auto")
          if (o3.startsWith("--")) {
            if (a3.fixed !== -1 || a3.isAuto)
              return -1;
            a3.dashedIdent = o3;
          } else
            ;
        else {
          if (a3.fixed !== -1 || a3.dashedIdent)
            return -1;
          a3.isAuto = true;
        }
      else {
        if (a3.elementShared || a3.dashedIdent || a3.isAuto)
          return -1;
        u4++;
        const n3 = e3[u4];
        if (!n3)
          return -1;
        const i4 = solve(calc$1(calcWrapper([n3]), t3, r3));
        if (i4 === -1)
          return -1;
        if (!isTokenNumber(i4.value))
          return -1;
        if (i4.value[4].value < 0 || i4.value[4].value > 1)
          return -1;
        a3.fixed = Math.max(0, Math.min(i4.value[4].value, 1 - 0.000000001));
      }
    else {
      if (a3.fixed !== -1)
        return -1;
      a3.elementShared = true;
    }
  }
  return -1;
}
function calcWrapper(e3) {
  return new FunctionNode([c.Function, "calc(", -1, -1, { value: "calc" }], [c.CloseParen, ")", -1, -1, undefined], e3);
}
function maxWrapper(n3, t3) {
  return new FunctionNode([c.Function, "max(", -1, -1, { value: "max" }], [c.CloseParen, ")", -1, -1, undefined], [n3, new TokenNode([c.Comma, ",", -1, -1, undefined]), t3]);
}
function patchNaN(n3) {
  if (n3 === -1)
    return -1;
  if (isFunctionNode(n3))
    return n3;
  const t3 = n3.value;
  return isTokenNumeric(t3) && Number.isNaN(t3[4].value) ? isTokenNumber(t3) ? new FunctionNode([c.Function, "calc(", t3[2], t3[3], { value: "calc" }], [c.CloseParen, ")", t3[2], t3[3], undefined], [new TokenNode([c.Ident, "NaN", t3[2], t3[3], { value: "NaN" }])]) : isTokenDimension(t3) ? new FunctionNode([c.Function, "calc(", t3[2], t3[3], { value: "calc" }], [c.CloseParen, ")", t3[2], t3[3], undefined], [new TokenNode([c.Ident, "NaN", t3[2], t3[3], { value: "NaN" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Delim, "*", t3[2], t3[3], { value: "*" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Dimension, "1" + t3[4].unit, t3[2], t3[3], { value: 1, type: a.Integer, unit: t3[4].unit }])]) : isTokenPercentage(t3) ? new FunctionNode([c.Function, "calc(", t3[2], t3[3], { value: "calc" }], [c.CloseParen, ")", t3[2], t3[3], undefined], [new TokenNode([c.Ident, "NaN", t3[2], t3[3], { value: "NaN" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Delim, "*", t3[2], t3[3], { value: "*" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Percentage, "1%", t3[2], t3[3], { value: 1 }])]) : -1 : n3;
}
function patchInfinity(n3) {
  if (n3 === -1)
    return -1;
  if (isFunctionNode(n3))
    return n3;
  const t3 = n3.value;
  if (!isTokenNumeric(t3))
    return n3;
  if (Number.isFinite(t3[4].value) || Number.isNaN(t3[4].value))
    return n3;
  let r3 = "";
  return Number.NEGATIVE_INFINITY === t3[4].value && (r3 = "-"), isTokenNumber(t3) ? new FunctionNode([c.Function, "calc(", t3[2], t3[3], { value: "calc" }], [c.CloseParen, ")", t3[2], t3[3], undefined], [new TokenNode([c.Ident, r3 + "infinity", t3[2], t3[3], { value: r3 + "infinity" }])]) : isTokenDimension(t3) ? new FunctionNode([c.Function, "calc(", t3[2], t3[3], { value: "calc" }], [c.CloseParen, ")", t3[2], t3[3], undefined], [new TokenNode([c.Ident, r3 + "infinity", t3[2], t3[3], { value: r3 + "infinity" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Delim, "*", t3[2], t3[3], { value: "*" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Dimension, "1" + t3[4].unit, t3[2], t3[3], { value: 1, type: a.Integer, unit: t3[4].unit }])]) : new FunctionNode([c.Function, "calc(", t3[2], t3[3], { value: "calc" }], [c.CloseParen, ")", t3[2], t3[3], undefined], [new TokenNode([c.Ident, r3 + "infinity", t3[2], t3[3], { value: r3 + "infinity" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Delim, "*", t3[2], t3[3], { value: "*" }]), new WhitespaceNode([[c.Whitespace, " ", t3[2], t3[3], undefined]]), new TokenNode([c.Percentage, "1%", t3[2], t3[3], { value: 1 }])]);
}
function patchMinusZero(e3) {
  if (e3 === -1)
    return -1;
  if (isFunctionNode(e3))
    return e3;
  const n3 = e3.value;
  return isTokenNumeric(n3) && Object.is(-0, n3[4].value) ? (n3[1] === "-0" || (isTokenPercentage(n3) ? n3[1] = "-0%" : isTokenDimension(n3) ? n3[1] = "-0" + n3[4].unit : n3[1] = "-0"), e3) : e3;
}
function patchPrecision(e3, n3 = 13) {
  if (e3 === -1)
    return -1;
  if (n3 <= 0)
    return e3;
  if (isFunctionNode(e3))
    return e3;
  const t3 = e3.value;
  if (!isTokenNumeric(t3))
    return e3;
  if (Number.isInteger(t3[4].value))
    return e3;
  const r3 = Number(t3[4].value.toFixed(n3)).toString();
  return isTokenNumber(t3) ? t3[1] = r3 : isTokenPercentage(t3) ? t3[1] = r3 + "%" : isTokenDimension(t3) && (t3[1] = r3 + t3[4].unit), e3;
}
function patchCanonicalUnit(e3) {
  return e3 === -1 ? -1 : isFunctionNode(e3) ? e3 : isTokenDimension(e3.value) ? (e3.value = toCanonicalUnit(e3.value), e3) : e3;
}
function patchCalcResult(e3, n3) {
  let t3 = e3;
  return n3?.toCanonicalUnits && (t3 = patchCanonicalUnit(t3)), t3 = patchPrecision(t3, n3?.precision), t3 = patchMinusZero(t3), n3?.censorIntoStandardRepresentableValues || (t3 = patchNaN(t3), t3 = patchInfinity(t3)), t3;
}
function tokenizeGlobals(e3) {
  const n3 = new Map;
  if (!e3)
    return n3;
  for (const [t3, r3] of e3)
    if (isToken(r3))
      n3.set(t3, r3);
    else if (typeof r3 != "string")
      ;
    else {
      const e4 = tokenizer({ css: r3 }), a3 = e4.nextToken();
      if (e4.nextToken(), !e4.endOfFile())
        continue;
      if (!isTokenNumeric(a3))
        continue;
      n3.set(t3, a3);
    }
  return n3;
}
function calc(e3, n3) {
  return calcFromComponentValues(parseCommaSeparatedListOfComponentValues(tokenize({ css: e3 }), {}), n3).map((e4) => e4.map((e5) => stringify(...e5.tokens())).join("")).join(",");
}
function calcFromComponentValues(e3, n3) {
  const t3 = tokenizeGlobals(n3?.globals);
  return replaceComponentValues(e3, (e4) => {
    if (!isFunctionNode(e4))
      return;
    const r3 = j.get(e4.getName().toLowerCase());
    if (!r3)
      return;
    const a3 = patchCalcResult(solve(r3(e4, t3, n3 ?? {})), n3);
    return a3 !== -1 ? a3 : undefined;
  });
}
var _2 = new Set(j.keys());

// node_modules/@csstools/css-color-parser/dist/index.mjs
var he;
var me;
function convertNaNToZero(e3) {
  return [Number.isNaN(e3[0]) ? 0 : e3[0], Number.isNaN(e3[1]) ? 0 : e3[1], Number.isNaN(e3[2]) ? 0 : e3[2]];
}
function colorData_to_XYZ_D50(e3) {
  switch (e3.colorNotation) {
    case he.HEX:
    case he.RGB:
    case he.sRGB:
      return { ...e3, colorNotation: he.XYZ_D50, channels: sRGB_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.Linear_sRGB:
      return { ...e3, colorNotation: he.XYZ_D50, channels: lin_sRGB_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.Display_P3:
      return { ...e3, colorNotation: he.XYZ_D50, channels: P3_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.Linear_Display_P3:
      return { ...e3, colorNotation: he.XYZ_D50, channels: lin_P3_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.Rec2020:
      return { ...e3, colorNotation: he.XYZ_D50, channels: rec_2020_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.A98_RGB:
      return { ...e3, colorNotation: he.XYZ_D50, channels: a98_RGB_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.ProPhoto_RGB:
      return { ...e3, colorNotation: he.XYZ_D50, channels: ProPhoto_RGB_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.HSL:
      return { ...e3, colorNotation: he.XYZ_D50, channels: HSL_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.HWB:
      return { ...e3, colorNotation: he.XYZ_D50, channels: HWB_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.Lab:
      return { ...e3, colorNotation: he.XYZ_D50, channels: Lab_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.OKLab:
      return { ...e3, colorNotation: he.XYZ_D50, channels: OKLab_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.LCH:
      return { ...e3, colorNotation: he.XYZ_D50, channels: LCH_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.OKLCH:
      return { ...e3, colorNotation: he.XYZ_D50, channels: OKLCH_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.XYZ_D50:
      return { ...e3, colorNotation: he.XYZ_D50, channels: XYZ_D50_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    case he.XYZ_D65:
      return { ...e3, colorNotation: he.XYZ_D50, channels: XYZ_D65_to_XYZ_D50(convertNaNToZero(e3.channels)) };
    default:
      throw new Error("Unsupported color notation");
  }
}
(function(e3) {
  e3.A98_RGB = "a98-rgb", e3.Display_P3 = "display-p3", e3.Linear_Display_P3 = "display-p3-linear", e3.HEX = "hex", e3.HSL = "hsl", e3.HWB = "hwb", e3.LCH = "lch", e3.Lab = "lab", e3.Linear_sRGB = "srgb-linear", e3.OKLCH = "oklch", e3.OKLab = "oklab", e3.ProPhoto_RGB = "prophoto-rgb", e3.RGB = "rgb", e3.sRGB = "srgb", e3.Rec2020 = "rec2020", e3.XYZ_D50 = "xyz-d50", e3.XYZ_D65 = "xyz-d65";
})(he || (he = {})), function(e3) {
  e3.ColorKeyword = "color-keyword", e3.HasAlpha = "has-alpha", e3.HasDimensionValues = "has-dimension-values", e3.HasNoneKeywords = "has-none-keywords", e3.HasNumberValues = "has-number-values", e3.HasPercentageAlpha = "has-percentage-alpha", e3.HasPercentageValues = "has-percentage-values", e3.HasVariableAlpha = "has-variable-alpha", e3.Hex = "hex", e3.LegacyHSL = "legacy-hsl", e3.LegacyRGB = "legacy-rgb", e3.NamedColor = "named-color", e3.RelativeColorSyntax = "relative-color-syntax", e3.ColorMix = "color-mix", e3.ColorMixVariadic = "color-mix-variadic", e3.ContrastColor = "contrast-color", e3.RelativeAlphaSyntax = "relative-alpha-syntax", e3.Experimental = "experimental";
}(me || (me = {}));
var pe = new Set([he.A98_RGB, he.Display_P3, he.Linear_Display_P3, he.HEX, he.Linear_sRGB, he.ProPhoto_RGB, he.RGB, he.sRGB, he.Rec2020, he.XYZ_D50, he.XYZ_D65]);
function colorDataTo(e3, a3) {
  const n3 = { ...e3 };
  if (e3.colorNotation !== a3) {
    const e4 = colorData_to_XYZ_D50(n3);
    switch (a3) {
      case he.HEX:
      case he.RGB:
        n3.colorNotation = he.RGB, n3.channels = XYZ_D50_to_sRGB(e4.channels);
        break;
      case he.sRGB:
        n3.colorNotation = he.sRGB, n3.channels = XYZ_D50_to_sRGB(e4.channels);
        break;
      case he.Linear_sRGB:
        n3.colorNotation = he.Linear_sRGB, n3.channels = XYZ_D50_to_lin_sRGB(e4.channels);
        break;
      case he.Display_P3:
        n3.colorNotation = he.Display_P3, n3.channels = XYZ_D50_to_P3(e4.channels);
        break;
      case he.Linear_Display_P3:
        n3.colorNotation = he.Linear_Display_P3, n3.channels = XYZ_D50_to_lin_P3(e4.channels);
        break;
      case he.Rec2020:
        n3.colorNotation = he.Rec2020, n3.channels = XYZ_D50_to_rec_2020(e4.channels);
        break;
      case he.ProPhoto_RGB:
        n3.colorNotation = he.ProPhoto_RGB, n3.channels = XYZ_D50_to_ProPhoto(e4.channels);
        break;
      case he.A98_RGB:
        n3.colorNotation = he.A98_RGB, n3.channels = XYZ_D50_to_a98_RGB(e4.channels);
        break;
      case he.HSL:
        n3.colorNotation = he.HSL, n3.channels = XYZ_D50_to_HSL(e4.channels);
        break;
      case he.HWB:
        n3.colorNotation = he.HWB, n3.channels = XYZ_D50_to_HWB(e4.channels);
        break;
      case he.Lab:
        n3.colorNotation = he.Lab, n3.channels = XYZ_D50_to_Lab(e4.channels);
        break;
      case he.LCH:
        n3.colorNotation = he.LCH, n3.channels = XYZ_D50_to_LCH(e4.channels);
        break;
      case he.OKLCH:
        n3.colorNotation = he.OKLCH, n3.channels = XYZ_D50_to_OKLCH(e4.channels);
        break;
      case he.OKLab:
        n3.colorNotation = he.OKLab, n3.channels = XYZ_D50_to_OKLab(e4.channels);
        break;
      case he.XYZ_D50:
        n3.colorNotation = he.XYZ_D50, n3.channels = XYZ_D50_to_XYZ_D50(e4.channels);
        break;
      case he.XYZ_D65:
        n3.colorNotation = he.XYZ_D65, n3.channels = XYZ_D50_to_XYZ_D65(e4.channels);
        break;
      default:
        throw new Error("Unsupported color notation");
    }
  } else
    n3.channels = convertNaNToZero(e3.channels);
  if (a3 === e3.colorNotation)
    n3.channels = carryForwardMissingComponents(e3.channels, [0, 1, 2], n3.channels, [0, 1, 2]);
  else if (pe.has(a3) && pe.has(e3.colorNotation))
    n3.channels = carryForwardMissingComponents(e3.channels, [0, 1, 2], n3.channels, [0, 1, 2]);
  else
    switch (a3) {
      case he.HSL:
        switch (e3.colorNotation) {
          case he.HWB:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [0]);
            break;
          case he.Lab:
          case he.OKLab:
            n3.channels = carryForwardMissingComponents(e3.channels, [2], n3.channels, [0]);
            break;
          case he.LCH:
          case he.OKLCH:
            n3.channels = carryForwardMissingComponents(e3.channels, [0, 1, 2], n3.channels, [2, 1, 0]);
        }
        break;
      case he.HWB:
        switch (e3.colorNotation) {
          case he.HSL:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [0]);
            break;
          case he.LCH:
          case he.OKLCH:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [2]);
        }
        break;
      case he.Lab:
      case he.OKLab:
        switch (e3.colorNotation) {
          case he.HSL:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [2]);
            break;
          case he.Lab:
          case he.OKLab:
            n3.channels = carryForwardMissingComponents(e3.channels, [0, 1, 2], n3.channels, [0, 1, 2]);
            break;
          case he.LCH:
          case he.OKLCH:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [0]);
        }
        break;
      case he.LCH:
      case he.OKLCH:
        switch (e3.colorNotation) {
          case he.HSL:
            n3.channels = carryForwardMissingComponents(e3.channels, [0, 1, 2], n3.channels, [2, 1, 0]);
            break;
          case he.HWB:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [2]);
            break;
          case he.Lab:
          case he.OKLab:
            n3.channels = carryForwardMissingComponents(e3.channels, [0], n3.channels, [0]);
            break;
          case he.LCH:
          case he.OKLCH:
            n3.channels = carryForwardMissingComponents(e3.channels, [0, 1, 2], n3.channels, [0, 1, 2]);
        }
    }
  return n3.channels = convertPowerlessComponentsToMissingComponents(n3.channels, a3), n3;
}
function convertPowerlessComponentsToMissingComponents(e3, a3) {
  const n3 = [...e3];
  switch (a3) {
    case he.HSL:
      !Number.isNaN(n3[1]) && reducePrecision(n3[1], 4) <= 0 && (n3[0] = Number.NaN);
      break;
    case he.HWB:
      Math.max(0, reducePrecision(n3[1], 4)) + Math.max(0, reducePrecision(n3[2], 4)) >= 100 && (n3[0] = Number.NaN);
      break;
    case he.LCH:
      !Number.isNaN(n3[1]) && reducePrecision(n3[1], 4) <= 0 && (n3[2] = Number.NaN);
      break;
    case he.OKLCH:
      !Number.isNaN(n3[1]) && reducePrecision(n3[1], 6) <= 0 && (n3[2] = Number.NaN);
  }
  return n3;
}
function convertPowerlessComponentsToZeroValuesForDisplay(e3, a3) {
  const n3 = [...e3];
  switch (a3) {
    case he.HSL:
      (reducePrecision(n3[2]) <= 0 || reducePrecision(n3[2]) >= 100) && (n3[0] = Number.NaN, n3[1] = Number.NaN), reducePrecision(n3[1]) <= 0 && (n3[0] = Number.NaN);
      break;
    case he.HWB:
      Math.max(0, reducePrecision(n3[1])) + Math.max(0, reducePrecision(n3[2])) >= 100 && (n3[0] = Number.NaN);
      break;
    case he.Lab:
      (reducePrecision(n3[0]) <= 0 || reducePrecision(n3[0]) >= 100) && (n3[1] = Number.NaN, n3[2] = Number.NaN);
      break;
    case he.LCH:
      reducePrecision(n3[1]) <= 0 && (n3[2] = Number.NaN), (reducePrecision(n3[0]) <= 0 || reducePrecision(n3[0]) >= 100) && (n3[1] = Number.NaN, n3[2] = Number.NaN);
      break;
    case he.OKLab:
      (reducePrecision(n3[0]) <= 0 || reducePrecision(n3[0]) >= 1) && (n3[1] = Number.NaN, n3[2] = Number.NaN);
      break;
    case he.OKLCH:
      reducePrecision(n3[1]) <= 0 && (n3[2] = Number.NaN), (reducePrecision(n3[0]) <= 0 || reducePrecision(n3[0]) >= 1) && (n3[1] = Number.NaN, n3[2] = Number.NaN);
  }
  return n3;
}
function carryForwardMissingComponents(e3, a3, n3, r3) {
  const o3 = [...n3];
  for (const n4 of a3)
    Number.isNaN(e3[a3[n4]]) && (o3[r3[n4]] = Number.NaN);
  return o3;
}
function normalizeRelativeColorDataChannels(e3) {
  const a3 = new Map;
  switch (e3.colorNotation) {
    case he.RGB:
    case he.HEX:
      a3.set("r", dummyNumberToken(255 * e3.channels[0])), a3.set("g", dummyNumberToken(255 * e3.channels[1])), a3.set("b", dummyNumberToken(255 * e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
      break;
    case he.HSL:
      a3.set("h", dummyNumberToken(e3.channels[0])), a3.set("s", dummyNumberToken(e3.channels[1])), a3.set("l", dummyNumberToken(e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
      break;
    case he.HWB:
      a3.set("h", dummyNumberToken(e3.channels[0])), a3.set("w", dummyNumberToken(e3.channels[1])), a3.set("b", dummyNumberToken(e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
      break;
    case he.Lab:
    case he.OKLab:
      a3.set("l", dummyNumberToken(e3.channels[0])), a3.set("a", dummyNumberToken(e3.channels[1])), a3.set("b", dummyNumberToken(e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
      break;
    case he.LCH:
    case he.OKLCH:
      a3.set("l", dummyNumberToken(e3.channels[0])), a3.set("c", dummyNumberToken(e3.channels[1])), a3.set("h", dummyNumberToken(e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
      break;
    case he.sRGB:
    case he.A98_RGB:
    case he.Display_P3:
    case he.Linear_Display_P3:
    case he.Rec2020:
    case he.Linear_sRGB:
    case he.ProPhoto_RGB:
      a3.set("r", dummyNumberToken(e3.channels[0])), a3.set("g", dummyNumberToken(e3.channels[1])), a3.set("b", dummyNumberToken(e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
      break;
    case he.XYZ_D50:
    case he.XYZ_D65:
      a3.set("x", dummyNumberToken(e3.channels[0])), a3.set("y", dummyNumberToken(e3.channels[1])), a3.set("z", dummyNumberToken(e3.channels[2])), typeof e3.alpha == "number" && a3.set("alpha", dummyNumberToken(e3.alpha));
  }
  return a3;
}
function noneToZeroInRelativeColorDataChannels(e3) {
  const a3 = new Map(e3);
  for (const [n3, r3] of e3)
    Number.isNaN(r3[4].value) && a3.set(n3, dummyNumberToken(0));
  return a3;
}
function dummyNumberToken(n3) {
  return Number.isNaN(n3) ? [c.Number, "none", -1, -1, { value: Number.NaN, type: a.Number }] : [c.Number, n3.toString(), -1, -1, { value: n3, type: a.Number }];
}
function reducePrecision(e3, a3 = 7) {
  if (Number.isNaN(e3))
    return 0;
  const n3 = Math.pow(10, a3);
  return Math.round(e3 * n3) / n3;
}
function normalize(e3, a3, n3, r3) {
  return Math.min(Math.max(e3 / a3, n3), r3);
}
var Ne = /[A-Z]/g;
function toLowerCaseAZ2(e3) {
  return e3.replace(Ne, (e4) => String.fromCharCode(e4.charCodeAt(0) + 32));
}
function normalize_Color_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (isTokenPercentage(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = normalize(t3[4].value, 100, -2147483647, 2147483647);
    return l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = normalize(t3[4].value, 1, -2147483647, 2147483647);
    return l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
var be = new Set(["srgb", "srgb-linear", "display-p3", "display-p3-linear", "a98-rgb", "prophoto-rgb", "rec2020", "xyz", "xyz-d50", "xyz-d65"]);
function color$1(e3, a3) {
  const r3 = [], s3 = [], u3 = [], i3 = [];
  let c3, h2, m2 = false, p2 = false;
  const N = { colorNotation: he.sRGB, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set([]) };
  let b2 = r3;
  for (let o3 = 0;o3 < e3.value.length; o3++) {
    let v2 = e3.value[o3];
    if (isWhitespaceNode(v2) || isCommentNode(v2))
      for (;isWhitespaceNode(e3.value[o3 + 1]) || isCommentNode(e3.value[o3 + 1]); )
        o3++;
    else if (b2 === r3 && r3.length && (b2 = s3), b2 === s3 && s3.length && (b2 = u3), isTokenNode(v2) && isTokenDelim(v2.value) && v2.value[4].value === "/") {
      if (b2 === i3)
        return false;
      b2 = i3;
    } else {
      if (isFunctionNode(v2)) {
        if (b2 === i3 && toLowerCaseAZ2(v2.getName()) === "var") {
          N.syntaxFlags.add(me.HasVariableAlpha), b2.push(v2);
          continue;
        }
        if (!_2.has(toLowerCaseAZ2(v2.getName())))
          return false;
        const [[e4]] = calcFromComponentValues([[v2]], { censorIntoStandardRepresentableValues: true, globals: h2, precision: -1, toCanonicalUnits: true, rawPercentages: true });
        if (!e4 || !isTokenNode(e4) || !isTokenNumeric(e4.value))
          return false;
        Number.isNaN(e4.value[4].value) && (e4.value[4].value = 0), v2 = e4;
      }
      if (b2 === r3 && r3.length === 0 && isTokenNode(v2) && isTokenIdent(v2.value) && be.has(toLowerCaseAZ2(v2.value[4].value))) {
        if (m2)
          return false;
        m2 = toLowerCaseAZ2(v2.value[4].value), N.colorNotation = colorSpaceNameToColorNotation(m2), p2 && (p2.colorNotation !== N.colorNotation && (p2 = colorDataTo(p2, N.colorNotation)), c3 = normalizeRelativeColorDataChannels(p2), h2 = noneToZeroInRelativeColorDataChannels(c3));
      } else if (b2 === r3 && r3.length === 0 && isTokenNode(v2) && isTokenIdent(v2.value) && toLowerCaseAZ2(v2.value[4].value) === "from") {
        if (p2)
          return false;
        if (m2)
          return false;
        for (;isWhitespaceNode(e3.value[o3 + 1]) || isCommentNode(e3.value[o3 + 1]); )
          o3++;
        if (o3++, v2 = e3.value[o3], p2 = a3(v2), p2 === false)
          return false;
        p2.syntaxFlags.has(me.Experimental) && N.syntaxFlags.add(me.Experimental), N.syntaxFlags.add(me.RelativeColorSyntax);
      } else {
        if (!isTokenNode(v2))
          return false;
        if (isTokenIdent(v2.value) && c3 && c3.has(toLowerCaseAZ2(v2.value[4].value))) {
          b2.push(new TokenNode(c3.get(toLowerCaseAZ2(v2.value[4].value))));
          continue;
        }
        b2.push(v2);
      }
    }
  }
  if (!m2)
    return false;
  if (b2.length !== 1)
    return false;
  if (r3.length !== 1 || s3.length !== 1 || u3.length !== 1)
    return false;
  if (!isTokenNode(r3[0]) || !isTokenNode(s3[0]) || !isTokenNode(u3[0]))
    return false;
  if (c3 && !c3.has("alpha"))
    return false;
  const v = normalize_Color_ChannelValues(r3[0].value, 0, N);
  if (!v || !isTokenNumber(v))
    return false;
  const g2 = normalize_Color_ChannelValues(s3[0].value, 1, N);
  if (!g2 || !isTokenNumber(g2))
    return false;
  const f3 = normalize_Color_ChannelValues(u3[0].value, 2, N);
  if (!f3 || !isTokenNumber(f3))
    return false;
  const d3 = [v, g2, f3];
  if (i3.length === 1)
    if (N.syntaxFlags.add(me.HasAlpha), isTokenNode(i3[0])) {
      const e4 = normalize_Color_ChannelValues(i3[0].value, 3, N);
      if (!e4 || !isTokenNumber(e4))
        return false;
      d3.push(e4);
    } else
      N.alpha = i3[0];
  else if (c3 && c3.has("alpha")) {
    const e4 = normalize_Color_ChannelValues(c3.get("alpha"), 3, N);
    if (!e4 || !isTokenNumber(e4))
      return false;
    d3.push(e4);
  }
  return N.channels = [d3[0][4].value, d3[1][4].value, d3[2][4].value], d3.length === 4 && (N.alpha = d3[3][4].value), N;
}
function colorSpaceNameToColorNotation(e3) {
  switch (e3) {
    case "srgb":
      return he.sRGB;
    case "srgb-linear":
      return he.Linear_sRGB;
    case "display-p3":
      return he.Display_P3;
    case "display-p3-linear":
      return he.Linear_Display_P3;
    case "a98-rgb":
      return he.A98_RGB;
    case "prophoto-rgb":
      return he.ProPhoto_RGB;
    case "rec2020":
      return he.Rec2020;
    case "xyz":
    case "xyz-d65":
      return he.XYZ_D65;
    case "xyz-d50":
      return he.XYZ_D50;
    default:
      throw new Error("Unknown color space name: " + e3);
  }
}
var ve = new Set(["srgb", "srgb-linear", "display-p3", "display-p3-linear", "a98-rgb", "prophoto-rgb", "rec2020", "lab", "oklab", "xyz", "xyz-d50", "xyz-d65"]);
var ge = new Set(["hsl", "hwb", "lch", "oklch"]);
var fe = new Set(["shorter", "longer", "increasing", "decreasing"]);
function colorMix(e3, a3) {
  let r3 = null, o3 = null, t3 = null, l2 = false;
  for (let u3 = 0;u3 < e3.value.length; u3++) {
    const i3 = e3.value[u3];
    if (!isWhiteSpaceOrCommentNode(i3)) {
      if (!(r3 || isTokenNode(i3) && isTokenIdent(i3.value) && toLowerCaseAZ2(i3.value[4].value) === "in"))
        return colorMixRectangular("oklab", colorMixComponents(e3.value, a3));
      if (isTokenNode(i3) && isTokenIdent(i3.value)) {
        if (!r3 && toLowerCaseAZ2(i3.value[4].value) === "in") {
          r3 = i3;
          continue;
        }
        if (r3 && !o3) {
          o3 = toLowerCaseAZ2(i3.value[4].value);
          continue;
        }
        if (r3 && o3 && !t3 && ge.has(o3)) {
          t3 = toLowerCaseAZ2(i3.value[4].value);
          continue;
        }
        if (r3 && o3 && t3 && !l2 && toLowerCaseAZ2(i3.value[4].value) === "hue") {
          l2 = true;
          continue;
        }
        return false;
      }
      return !(!isTokenNode(i3) || !isTokenComma(i3.value)) && (!!o3 && (t3 || l2 ? !!(o3 && t3 && l2 && ge.has(o3) && fe.has(t3)) && colorMixPolar(o3, t3, colorMixComponents(e3.value.slice(u3 + 1), a3)) : ve.has(o3) ? colorMixRectangular(o3, colorMixComponents(e3.value.slice(u3 + 1), a3)) : !!ge.has(o3) && colorMixPolar(o3, "shorter", colorMixComponents(e3.value.slice(u3 + 1), a3))));
    }
  }
  return false;
}
function colorMixComponents(e3, a3) {
  const n3 = [];
  let o3 = 1, t3 = false, u3 = false;
  for (let o4 = 0;o4 < e3.length; o4++) {
    let i4 = e3[o4];
    if (!isWhiteSpaceOrCommentNode(i4)) {
      if (!isTokenNode(i4) || !isTokenComma(i4.value)) {
        if (!t3) {
          const e4 = a3(i4);
          if (e4) {
            t3 = e4;
            continue;
          }
        }
        if (!u3) {
          if (isFunctionNode(i4) && _2.has(toLowerCaseAZ2(i4.getName()))) {
            if ([[i4]] = calcFromComponentValues([[i4]], { censorIntoStandardRepresentableValues: true, precision: -1, toCanonicalUnits: true, rawPercentages: true }), !i4 || !isTokenNode(i4) || !isTokenNumeric(i4.value))
              return false;
            Number.isNaN(i4.value[4].value) && (i4.value[4].value = 0);
          }
          if (isTokenNode(i4) && isTokenPercentage(i4.value) && i4.value[4].value >= 0) {
            u3 = i4.value[4].value;
            continue;
          }
        }
        return false;
      }
      if (!t3)
        return false;
      n3.push({ color: t3, percentage: u3 }), t3 = false, u3 = false;
    }
  }
  if (!t3)
    return false;
  n3.push({ color: t3, percentage: u3 });
  let i3 = 0, c3 = 0;
  for (let e4 = 0;e4 < n3.length; e4++) {
    const a4 = n3[e4].percentage;
    if (a4 !== false) {
      if (a4 < 0 || a4 > 100)
        return false;
      i3 += a4;
    } else
      c3++;
  }
  const h2 = Math.max(0, 100 - i3);
  i3 = 0;
  for (let e4 = 0;e4 < n3.length; e4++)
    n3[e4].percentage === false && (n3[e4].percentage = h2 / c3), i3 += n3[e4].percentage;
  if (i3 === 0)
    return { colors: [{ color: { channels: [0, 0, 0], colorNotation: he.sRGB, alpha: 0, syntaxFlags: new Set }, percentage: 0 }], alphaMultiplier: 0 };
  if (i3 > 100)
    for (let e4 = 0;e4 < n3.length; e4++) {
      let a4 = n3[e4].percentage;
      a4 = a4 / i3 * 100, n3[e4].percentage = a4;
    }
  if (i3 < 100) {
    o3 = i3 / 100;
    for (let e4 = 0;e4 < n3.length; e4++) {
      let a4 = n3[e4].percentage;
      a4 = a4 / i3 * 100, n3[e4].percentage = a4;
    }
  }
  return { colors: n3, alphaMultiplier: o3 };
}
function colorMixRectangular(e3, a3) {
  if (!a3 || !a3.colors.length)
    return false;
  const n3 = a3.colors.slice();
  n3.reverse();
  let r3 = he.RGB;
  switch (e3) {
    case "srgb":
      r3 = he.RGB;
      break;
    case "srgb-linear":
      r3 = he.Linear_sRGB;
      break;
    case "display-p3":
      r3 = he.Display_P3;
      break;
    case "display-p3-linear":
      r3 = he.Linear_Display_P3;
      break;
    case "a98-rgb":
      r3 = he.A98_RGB;
      break;
    case "prophoto-rgb":
      r3 = he.ProPhoto_RGB;
      break;
    case "rec2020":
      r3 = he.Rec2020;
      break;
    case "lab":
      r3 = he.Lab;
      break;
    case "oklab":
      r3 = he.OKLab;
      break;
    case "xyz-d50":
      r3 = he.XYZ_D50;
      break;
    case "xyz":
    case "xyz-d65":
      r3 = he.XYZ_D65;
      break;
    default:
      return false;
  }
  if (n3.length === 1) {
    const e4 = colorDataTo(n3[0].color, r3);
    return e4.colorNotation = r3, e4.syntaxFlags.add(me.ColorMixVariadic), typeof e4.alpha != "number" ? false : (e4.alpha = e4.alpha * a3.alphaMultiplier, e4);
  }
  for (;n3.length >= 2; ) {
    const e4 = n3.pop(), a4 = n3.pop();
    if (!e4 || !a4)
      return false;
    const o4 = colorMixRectangularPair(r3, e4.color, e4.percentage, a4.color, a4.percentage);
    if (!o4)
      return false;
    n3.push({ color: o4, percentage: e4.percentage + a4.percentage });
  }
  const o3 = n3[0]?.color;
  return !!o3 && (a3.colors.some((e4) => e4.color.syntaxFlags.has(me.Experimental)) && o3.syntaxFlags.add(me.Experimental), typeof o3.alpha == "number" && (o3.alpha = o3.alpha * a3.alphaMultiplier, a3.colors.length !== 2 && o3.syntaxFlags.add(me.ColorMixVariadic), o3));
}
function colorMixRectangularPair(e3, a3, n3, r3, o3) {
  const t3 = n3 / (n3 + o3);
  let l2 = a3.alpha;
  if (typeof l2 != "number")
    return false;
  let s3 = r3.alpha;
  if (typeof s3 != "number")
    return false;
  l2 = Number.isNaN(l2) ? s3 : l2, s3 = Number.isNaN(s3) ? l2 : s3;
  const u3 = colorDataTo(a3, e3).channels, i3 = colorDataTo(r3, e3).channels;
  u3[0] = fillInMissingComponent(u3[0], i3[0]), i3[0] = fillInMissingComponent(i3[0], u3[0]), u3[1] = fillInMissingComponent(u3[1], i3[1]), i3[1] = fillInMissingComponent(i3[1], u3[1]), u3[2] = fillInMissingComponent(u3[2], i3[2]), i3[2] = fillInMissingComponent(i3[2], u3[2]), u3[0] = premultiply(u3[0], l2), u3[1] = premultiply(u3[1], l2), u3[2] = premultiply(u3[2], l2), i3[0] = premultiply(i3[0], s3), i3[1] = premultiply(i3[1], s3), i3[2] = premultiply(i3[2], s3);
  const c3 = interpolate(l2, s3, t3);
  return { colorNotation: e3, channels: [un_premultiply(interpolate(u3[0], i3[0], t3), c3), un_premultiply(interpolate(u3[1], i3[1], t3), c3), un_premultiply(interpolate(u3[2], i3[2], t3), c3)], alpha: c3, syntaxFlags: new Set([me.ColorMix]) };
}
function colorMixPolar(e3, a3, n3) {
  if (!n3 || !n3.colors.length)
    return false;
  const r3 = n3.colors.slice();
  r3.reverse();
  let o3 = he.HSL;
  switch (e3) {
    case "hsl":
      o3 = he.HSL;
      break;
    case "hwb":
      o3 = he.HWB;
      break;
    case "lch":
      o3 = he.LCH;
      break;
    case "oklch":
      o3 = he.OKLCH;
      break;
    default:
      return false;
  }
  if (r3.length === 1) {
    const e4 = colorDataTo(r3[0].color, o3);
    return e4.colorNotation = o3, e4.syntaxFlags.add(me.ColorMixVariadic), typeof e4.alpha != "number" ? false : (e4.alpha = e4.alpha * n3.alphaMultiplier, e4);
  }
  for (;r3.length >= 2; ) {
    const e4 = r3.pop(), n4 = r3.pop();
    if (!e4 || !n4)
      return false;
    const t4 = colorMixPolarPair(o3, a3, e4.color, e4.percentage, n4.color, n4.percentage);
    if (!t4)
      return false;
    r3.push({ color: t4, percentage: e4.percentage + n4.percentage });
  }
  const t3 = r3[0]?.color;
  return !!t3 && (n3.colors.some((e4) => e4.color.syntaxFlags.has(me.Experimental)) && t3.syntaxFlags.add(me.Experimental), typeof t3.alpha == "number" && (t3.alpha = t3.alpha * n3.alphaMultiplier, n3.colors.length !== 2 && t3.syntaxFlags.add(me.ColorMixVariadic), t3));
}
function colorMixPolarPair(e3, a3, n3, r3, o3, t3) {
  const l2 = r3 / (r3 + t3);
  let s3 = 0, u3 = 0, i3 = 0, c3 = 0, h2 = 0, m2 = 0, p2 = n3.alpha;
  if (typeof p2 != "number")
    return false;
  let N = o3.alpha;
  if (typeof N != "number")
    return false;
  p2 = Number.isNaN(p2) ? N : p2, N = Number.isNaN(N) ? p2 : N;
  const b2 = colorDataTo(n3, e3).channels, v = colorDataTo(o3, e3).channels;
  switch (e3) {
    case he.HSL:
    case he.HWB:
      s3 = b2[0], u3 = v[0], i3 = b2[1], c3 = v[1], h2 = b2[2], m2 = v[2];
      break;
    case he.LCH:
    case he.OKLCH:
      i3 = b2[0], c3 = v[0], h2 = b2[1], m2 = v[1], s3 = b2[2], u3 = v[2];
  }
  s3 = fillInMissingComponent(s3, u3), Number.isNaN(s3) && (s3 = 0), u3 = fillInMissingComponent(u3, s3), Number.isNaN(u3) && (u3 = 0), i3 = fillInMissingComponent(i3, c3), c3 = fillInMissingComponent(c3, i3), h2 = fillInMissingComponent(h2, m2), m2 = fillInMissingComponent(m2, h2);
  const g2 = u3 - s3;
  switch (a3) {
    case "shorter":
      g2 > 180 ? s3 += 360 : g2 < -180 && (u3 += 360);
      break;
    case "longer":
      -180 < g2 && g2 < 180 && (g2 > 0 ? s3 += 360 : u3 += 360);
      break;
    case "increasing":
      g2 < 0 && (u3 += 360);
      break;
    case "decreasing":
      g2 > 0 && (s3 += 360);
      break;
    default:
      throw new Error("Unknown hue interpolation method");
  }
  i3 = premultiply(i3, p2), h2 = premultiply(h2, p2), c3 = premultiply(c3, N), m2 = premultiply(m2, N);
  let f3 = [0, 0, 0];
  const d3 = interpolate(p2, N, l2);
  switch (e3) {
    case he.HSL:
    case he.HWB:
      f3 = [interpolate(s3, u3, l2), un_premultiply(interpolate(i3, c3, l2), d3), un_premultiply(interpolate(h2, m2, l2), d3)];
      break;
    case he.LCH:
    case he.OKLCH:
      f3 = [un_premultiply(interpolate(i3, c3, l2), d3), un_premultiply(interpolate(h2, m2, l2), d3), interpolate(s3, u3, l2)];
  }
  return { colorNotation: e3, channels: f3, alpha: d3, syntaxFlags: new Set([me.ColorMix]) };
}
function fillInMissingComponent(e3, a3) {
  return Number.isNaN(e3) ? a3 : e3;
}
function interpolate(e3, a3, n3) {
  return e3 * n3 + a3 * (1 - n3);
}
function premultiply(e3, a3) {
  return Number.isNaN(a3) ? e3 : Number.isNaN(e3) ? Number.NaN : e3 * a3;
}
function un_premultiply(e3, a3) {
  return a3 === 0 || Number.isNaN(a3) ? e3 : Number.isNaN(e3) ? Number.NaN : e3 / a3;
}
function hex(e3) {
  const a3 = toLowerCaseAZ2(e3[4].value);
  if (a3.match(/[^a-f0-9]/))
    return false;
  const n3 = { colorNotation: he.HEX, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set([me.Hex]) }, r3 = a3.length;
  if (r3 === 3) {
    const e4 = a3[0], r4 = a3[1], o3 = a3[2];
    return n3.channels = [parseInt(e4 + e4, 16) / 255, parseInt(r4 + r4, 16) / 255, parseInt(o3 + o3, 16) / 255], n3;
  }
  if (r3 === 6) {
    const e4 = a3[0] + a3[1], r4 = a3[2] + a3[3], o3 = a3[4] + a3[5];
    return n3.channels = [parseInt(e4, 16) / 255, parseInt(r4, 16) / 255, parseInt(o3, 16) / 255], n3;
  }
  if (r3 === 4) {
    const e4 = a3[0], r4 = a3[1], o3 = a3[2], t3 = a3[3];
    return n3.channels = [parseInt(e4 + e4, 16) / 255, parseInt(r4 + r4, 16) / 255, parseInt(o3 + o3, 16) / 255], n3.alpha = parseInt(t3 + t3, 16) / 255, n3.syntaxFlags.add(me.HasAlpha), n3;
  }
  if (r3 === 8) {
    const e4 = a3[0] + a3[1], r4 = a3[2] + a3[3], o3 = a3[4] + a3[5], t3 = a3[6] + a3[7];
    return n3.channels = [parseInt(e4, 16) / 255, parseInt(r4, 16) / 255, parseInt(o3, 16) / 255], n3.alpha = parseInt(t3, 16) / 255, n3.syntaxFlags.add(me.HasAlpha), n3;
  }
  return false;
}
function normalizeHue(n3) {
  if (isTokenNumber(n3))
    return n3[4].value = n3[4].value % 360, n3[1] = n3[4].value.toString(), n3;
  if (isTokenDimension(n3)) {
    let r3 = n3[4].value;
    switch (toLowerCaseAZ2(n3[4].unit)) {
      case "deg":
        break;
      case "rad":
        r3 = 180 * n3[4].value / Math.PI;
        break;
      case "grad":
        r3 = 0.9 * n3[4].value;
        break;
      case "turn":
        r3 = 360 * n3[4].value;
        break;
      default:
        return false;
    }
    return r3 %= 360, [c.Number, r3.toString(), n3[2], n3[3], { value: r3, type: a.Number }];
  }
  return false;
}
function normalize_legacy_HSL_ChannelValues(n3, t3, l2) {
  if (t3 === 0) {
    const e3 = normalizeHue(n3);
    return e3 !== false && (isTokenDimension(n3) && l2.syntaxFlags.add(me.HasDimensionValues), e3);
  }
  if (isTokenPercentage(n3)) {
    t3 === 3 ? l2.syntaxFlags.add(me.HasPercentageAlpha) : l2.syntaxFlags.add(me.HasPercentageValues);
    let r3 = normalize(n3[4].value, 1, 0, 100);
    return t3 === 3 && (r3 = normalize(n3[4].value, 100, 0, 1)), [c.Number, r3.toString(), n3[2], n3[3], { value: r3, type: a.Number }];
  }
  if (isTokenNumber(n3)) {
    if (t3 !== 3)
      return false;
    let r3 = normalize(n3[4].value, 1, 0, 100);
    return t3 === 3 && (r3 = normalize(n3[4].value, 1, 0, 1)), [c.Number, r3.toString(), n3[2], n3[3], { value: r3, type: a.Number }];
  }
  return false;
}
function normalize_modern_HSL_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (l2 === 0) {
    const e3 = normalizeHue(t3);
    return e3 !== false && (isTokenDimension(t3) && s3.syntaxFlags.add(me.HasDimensionValues), e3);
  }
  if (isTokenPercentage(t3)) {
    l2 === 3 ? s3.syntaxFlags.add(me.HasPercentageAlpha) : s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = t3[4].value;
    return l2 === 3 ? n3 = normalize(t3[4].value, 100, 0, 1) : l2 === 1 && (n3 = normalize(t3[4].value, 1, 0, 2147483647)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = t3[4].value;
    return l2 === 3 ? n3 = normalize(t3[4].value, 1, 0, 1) : l2 === 1 && (n3 = normalize(t3[4].value, 1, 0, 2147483647)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function threeChannelLegacySyntax(e3, a3, n3, r3) {
  const t3 = [], u3 = [], i3 = [], c3 = [], h2 = { colorNotation: n3, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set(r3) };
  let m2 = t3;
  for (let a4 = 0;a4 < e3.value.length; a4++) {
    let n4 = e3.value[a4];
    if (!isWhitespaceNode(n4) && !isCommentNode(n4)) {
      if (isTokenNode(n4) && isTokenComma(n4.value)) {
        if (m2 === t3) {
          m2 = u3;
          continue;
        }
        if (m2 === u3) {
          m2 = i3;
          continue;
        }
        if (m2 === i3) {
          m2 = c3;
          continue;
        }
        if (m2 === c3)
          return false;
      }
      if (isFunctionNode(n4)) {
        if (m2 === c3 && n4.getName().toLowerCase() === "var") {
          h2.syntaxFlags.add(me.HasVariableAlpha), m2.push(n4);
          continue;
        }
        if (!_2.has(n4.getName().toLowerCase()))
          return false;
        const [[e4]] = calcFromComponentValues([[n4]], { censorIntoStandardRepresentableValues: true, precision: -1, toCanonicalUnits: true, rawPercentages: true });
        if (!e4 || !isTokenNode(e4) || !isTokenNumeric(e4.value))
          return false;
        Number.isNaN(e4.value[4].value) && (e4.value[4].value = 0), n4 = e4;
      }
      if (!isTokenNode(n4))
        return false;
      m2.push(n4);
    }
  }
  if (m2.length !== 1)
    return false;
  if (t3.length !== 1 || u3.length !== 1 || i3.length !== 1)
    return false;
  if (!isTokenNode(t3[0]) || !isTokenNode(u3[0]) || !isTokenNode(i3[0]))
    return false;
  const p2 = a3(t3[0].value, 0, h2);
  if (!p2 || !isTokenNumber(p2))
    return false;
  const N = a3(u3[0].value, 1, h2);
  if (!N || !isTokenNumber(N))
    return false;
  const b2 = a3(i3[0].value, 2, h2);
  if (!b2 || !isTokenNumber(b2))
    return false;
  const v = [p2, N, b2];
  if (c3.length === 1)
    if (h2.syntaxFlags.add(me.HasAlpha), isTokenNode(c3[0])) {
      const e4 = a3(c3[0].value, 3, h2);
      if (!e4 || !isTokenNumber(e4))
        return false;
      v.push(e4);
    } else
      h2.alpha = c3[0];
  return h2.channels = [v[0][4].value, v[1][4].value, v[2][4].value], v.length === 4 && (h2.alpha = v[3][4].value), h2;
}
function threeChannelSpaceSeparated(e3, a3, r3, s3, u3) {
  const i3 = [], c3 = [], h2 = [], m2 = [];
  let p2, N, b2 = false;
  const v = { colorNotation: r3, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set(s3) };
  let g2 = i3;
  for (let a4 = 0;a4 < e3.value.length; a4++) {
    let o3 = e3.value[a4];
    if (isWhitespaceNode(o3) || isCommentNode(o3))
      for (;isWhitespaceNode(e3.value[a4 + 1]) || isCommentNode(e3.value[a4 + 1]); )
        a4++;
    else if (g2 === i3 && i3.length && (g2 = c3), g2 === c3 && c3.length && (g2 = h2), isTokenNode(o3) && isTokenDelim(o3.value) && o3.value[4].value === "/") {
      if (g2 === m2)
        return false;
      g2 = m2;
    } else {
      if (isFunctionNode(o3)) {
        if (g2 === m2 && o3.getName().toLowerCase() === "var") {
          v.syntaxFlags.add(me.HasVariableAlpha), g2.push(o3);
          continue;
        }
        if (!_2.has(o3.getName().toLowerCase()))
          return false;
        const [[e4]] = calcFromComponentValues([[o3]], { censorIntoStandardRepresentableValues: true, globals: N, precision: -1, toCanonicalUnits: true, rawPercentages: true });
        if (!e4 || !isTokenNode(e4) || !isTokenNumeric(e4.value))
          return false;
        Number.isNaN(e4.value[4].value) && (e4.value[4].value = 0), o3 = e4;
      }
      if (g2 === i3 && i3.length === 0 && isTokenNode(o3) && isTokenIdent(o3.value) && o3.value[4].value.toLowerCase() === "from") {
        if (b2)
          return false;
        for (;isWhitespaceNode(e3.value[a4 + 1]) || isCommentNode(e3.value[a4 + 1]); )
          a4++;
        if (a4++, o3 = e3.value[a4], b2 = u3(o3), b2 === false)
          return false;
        b2.syntaxFlags.has(me.Experimental) && v.syntaxFlags.add(me.Experimental), v.syntaxFlags.add(me.RelativeColorSyntax), b2.colorNotation !== r3 && (b2 = colorDataTo(b2, r3)), p2 = normalizeRelativeColorDataChannels(b2), N = noneToZeroInRelativeColorDataChannels(p2);
      } else {
        if (!isTokenNode(o3))
          return false;
        if (isTokenIdent(o3.value) && p2) {
          const e4 = o3.value[4].value.toLowerCase();
          if (p2.has(e4)) {
            g2.push(new TokenNode(p2.get(e4)));
            continue;
          }
        }
        g2.push(o3);
      }
    }
  }
  if (g2.length !== 1)
    return false;
  if (i3.length !== 1 || c3.length !== 1 || h2.length !== 1)
    return false;
  if (!isTokenNode(i3[0]) || !isTokenNode(c3[0]) || !isTokenNode(h2[0]))
    return false;
  if (p2 && !p2.has("alpha"))
    return false;
  const f3 = a3(i3[0].value, 0, v);
  if (!f3 || !isTokenNumber(f3))
    return false;
  const d3 = a3(c3[0].value, 1, v);
  if (!d3 || !isTokenNumber(d3))
    return false;
  const y2 = a3(h2[0].value, 2, v);
  if (!y2 || !isTokenNumber(y2))
    return false;
  const _3 = [f3, d3, y2];
  if (m2.length === 1)
    if (v.syntaxFlags.add(me.HasAlpha), isTokenNode(m2[0])) {
      const e4 = a3(m2[0].value, 3, v);
      if (!e4 || !isTokenNumber(e4))
        return false;
      _3.push(e4);
    } else
      v.alpha = m2[0];
  else if (p2 && p2.has("alpha")) {
    const e4 = a3(p2.get("alpha"), 3, v);
    if (!e4 || !isTokenNumber(e4))
      return false;
    _3.push(e4);
  }
  return v.channels = [_3[0][4].value, _3[1][4].value, _3[2][4].value], _3.length === 4 && (v.alpha = _3[3][4].value), v;
}
function hsl(e3, a3) {
  if (e3.value.some((e4) => isTokenNode(e4) && isTokenComma(e4.value))) {
    const a4 = hslCommaSeparated(e3);
    if (a4 !== false)
      return a4;
  }
  {
    const n3 = hslSpaceSeparated(e3, a3);
    if (n3 !== false)
      return n3;
  }
  return false;
}
function hslCommaSeparated(e3) {
  return threeChannelLegacySyntax(e3, normalize_legacy_HSL_ChannelValues, he.HSL, [me.LegacyHSL]);
}
function hslSpaceSeparated(e3, a3) {
  return threeChannelSpaceSeparated(e3, normalize_modern_HSL_ChannelValues, he.HSL, [], a3);
}
function normalize_HWB_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (l2 === 0) {
    const e3 = normalizeHue(t3);
    return e3 !== false && (isTokenDimension(t3) && s3.syntaxFlags.add(me.HasDimensionValues), e3);
  }
  if (isTokenPercentage(t3)) {
    l2 === 3 ? s3.syntaxFlags.add(me.HasPercentageAlpha) : s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = t3[4].value;
    return l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = t3[4].value;
    return l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function normalize_Lab_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (isTokenPercentage(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = normalize(t3[4].value, 1, 0, 100);
    return l2 === 1 || l2 === 2 ? n3 = normalize(t3[4].value, 0.8, -2147483647, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = normalize(t3[4].value, 1, 0, 100);
    return l2 === 1 || l2 === 2 ? n3 = normalize(t3[4].value, 1, -2147483647, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function lab(e3, a3) {
  return threeChannelSpaceSeparated(e3, normalize_Lab_ChannelValues, he.Lab, [], a3);
}
function normalize_LCH_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (l2 === 2) {
    const e3 = normalizeHue(t3);
    return e3 !== false && (isTokenDimension(t3) && s3.syntaxFlags.add(me.HasDimensionValues), e3);
  }
  if (isTokenPercentage(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = normalize(t3[4].value, 1, 0, 100);
    return l2 === 1 ? n3 = normalize(t3[4].value, 100 / 150, 0, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = normalize(t3[4].value, 1, 0, 100);
    return l2 === 1 ? n3 = normalize(t3[4].value, 1, 0, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function lch(e3, a3) {
  return threeChannelSpaceSeparated(e3, normalize_LCH_ChannelValues, he.LCH, [], a3);
}
var de = new Map;
for (const [e3, a3] of Object.entries(R))
  de.set(e3, a3);
function namedColor(e3) {
  const a3 = de.get(toLowerCaseAZ2(e3));
  return !!a3 && { colorNotation: he.RGB, channels: [a3[0] / 255, a3[1] / 255, a3[2] / 255], alpha: 1, syntaxFlags: new Set([me.ColorKeyword, me.NamedColor]) };
}
function normalize_OKLab_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (isTokenPercentage(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = normalize(t3[4].value, 100, 0, 1);
    return l2 === 1 || l2 === 2 ? n3 = normalize(t3[4].value, 250, -2147483647, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = normalize(t3[4].value, 1, 0, 1);
    return l2 === 1 || l2 === 2 ? n3 = normalize(t3[4].value, 1, -2147483647, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function oklab(e3, a3) {
  return threeChannelSpaceSeparated(e3, normalize_OKLab_ChannelValues, he.OKLab, [], a3);
}
function normalize_OKLCH_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && toLowerCaseAZ2(t3[4].value) === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (l2 === 2) {
    const e3 = normalizeHue(t3);
    return e3 !== false && (isTokenDimension(t3) && s3.syntaxFlags.add(me.HasDimensionValues), e3);
  }
  if (isTokenPercentage(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = normalize(t3[4].value, 100, 0, 1);
    return l2 === 1 ? n3 = normalize(t3[4].value, 250, 0, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = normalize(t3[4].value, 1, 0, 1);
    return l2 === 1 ? n3 = normalize(t3[4].value, 1, 0, 2147483647) : l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function oklch(e3, a3) {
  return threeChannelSpaceSeparated(e3, normalize_OKLCH_ChannelValues, he.OKLCH, [], a3);
}
function normalize_legacy_sRGB_ChannelValues(n3, t3, l2) {
  if (isTokenPercentage(n3)) {
    t3 === 3 ? l2.syntaxFlags.add(me.HasPercentageAlpha) : l2.syntaxFlags.add(me.HasPercentageValues);
    const r3 = normalize(n3[4].value, 100, 0, 1);
    return [c.Number, r3.toString(), n3[2], n3[3], { value: r3, type: a.Number }];
  }
  if (isTokenNumber(n3)) {
    t3 !== 3 && l2.syntaxFlags.add(me.HasNumberValues);
    let r3 = normalize(n3[4].value, 255, 0, 1);
    return t3 === 3 && (r3 = normalize(n3[4].value, 1, 0, 1)), [c.Number, r3.toString(), n3[2], n3[3], { value: r3, type: a.Number }];
  }
  return false;
}
function normalize_modern_sRGB_ChannelValues(t3, l2, s3) {
  if (isTokenIdent(t3) && t3[4].value.toLowerCase() === "none")
    return s3.syntaxFlags.add(me.HasNoneKeywords), [c.Number, "none", t3[2], t3[3], { value: Number.NaN, type: a.Number }];
  if (isTokenPercentage(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasPercentageValues);
    let n3 = normalize(t3[4].value, 100, -2147483647, 2147483647);
    return l2 === 3 && (n3 = normalize(t3[4].value, 100, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  if (isTokenNumber(t3)) {
    l2 !== 3 && s3.syntaxFlags.add(me.HasNumberValues);
    let n3 = normalize(t3[4].value, 255, -2147483647, 2147483647);
    return l2 === 3 && (n3 = normalize(t3[4].value, 1, 0, 1)), [c.Number, n3.toString(), t3[2], t3[3], { value: n3, type: a.Number }];
  }
  return false;
}
function rgb(e3, a3) {
  if (e3.value.some((e4) => isTokenNode(e4) && isTokenComma(e4.value))) {
    const a4 = rgbCommaSeparated(e3);
    if (a4 !== false)
      return (!a4.syntaxFlags.has(me.HasNumberValues) || !a4.syntaxFlags.has(me.HasPercentageValues)) && a4;
  } else {
    const n3 = rgbSpaceSeparated(e3, a3);
    if (n3 !== false)
      return n3;
  }
  return false;
}
function rgbCommaSeparated(e3) {
  return threeChannelLegacySyntax(e3, normalize_legacy_sRGB_ChannelValues, he.RGB, [me.LegacyRGB]);
}
function rgbSpaceSeparated(e3, a3) {
  return threeChannelSpaceSeparated(e3, normalize_modern_sRGB_ChannelValues, he.RGB, [], a3);
}
function XYZ_D50_to_sRGB_Gamut(e3) {
  const a3 = XYZ_D50_to_sRGB(e3);
  if (inGamut(a3))
    return clip(a3);
  let n3 = e3;
  return n3 = XYZ_D50_to_OKLCH(n3), n3[0] < 0.000001 && (n3 = [0, 0, 0]), n3[0] > 0.999999 && (n3 = [1, 0, 0]), gam_sRGB(mapGamutRayTrace(n3, oklch_to_lin_srgb, lin_srgb_to_oklch));
}
function oklch_to_lin_srgb(e3) {
  return e3 = OKLCH_to_OKLab(e3), e3 = OKLab_to_XYZ(e3), XYZ_to_lin_sRGB(e3);
}
function lin_srgb_to_oklch(e3) {
  return e3 = lin_sRGB_to_XYZ(e3), e3 = XYZ_to_OKLab(e3), OKLab_to_OKLCH(e3);
}
function contrastColor(e3, a3) {
  let n3 = false;
  for (let r4 = 0;r4 < e3.value.length; r4++) {
    const o4 = e3.value[r4];
    if (!isWhitespaceNode(o4) && !isCommentNode(o4) && (n3 || (n3 = a3(o4), !n3)))
      return false;
  }
  if (!n3)
    return false;
  n3.channels = convertNaNToZero(n3.channels), n3.channels = XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(n3).channels), n3.colorNotation = he.sRGB;
  const r3 = { colorNotation: he.sRGB, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set([me.ContrastColor, me.Experimental]) }, o3 = contrast_ratio_wcag_2_1(n3.channels, [1, 1, 1]), t3 = contrast_ratio_wcag_2_1(n3.channels, [0, 0, 0]);
  return r3.channels = o3 > t3 ? [1, 1, 1] : [0, 0, 0], r3;
}
function alpha(e3, a3) {
  let r3, s3, u3 = false, i3 = false, c3 = false;
  const h2 = { colorNotation: he.sRGB, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set([]) };
  for (let m2 = 0;m2 < e3.value.length; m2++) {
    let p2 = e3.value[m2];
    if (isWhitespaceNode(p2) || isCommentNode(p2))
      for (;isWhitespaceNode(e3.value[m2 + 1]) || isCommentNode(e3.value[m2 + 1]); )
        m2++;
    else if (c3 && !u3 && !i3 && isTokenNode(p2) && isTokenDelim(p2.value) && p2.value[4].value === "/")
      u3 = true;
    else {
      if (isFunctionNode(p2) && _2.has(toLowerCaseAZ2(p2.getName()))) {
        const [[e4]] = calcFromComponentValues([[p2]], { censorIntoStandardRepresentableValues: true, globals: s3, precision: -1, toCanonicalUnits: true, rawPercentages: true });
        if (!e4 || !isTokenNode(e4) || !isTokenNumeric(e4.value))
          return false;
        Number.isNaN(e4.value[4].value) && (e4.value[4].value = 0), p2 = e4;
      }
      if (u3 || i3 || !isTokenNode(p2) || !isTokenIdent(p2.value) || toLowerCaseAZ2(p2.value[4].value) !== "from") {
        if (!u3)
          return false;
        if (i3)
          return false;
        if (isTokenNode(p2)) {
          if (isTokenIdent(p2.value) && toLowerCaseAZ2(p2.value[4].value) === "alpha" && r3 && r3.has("alpha")) {
            h2.alpha = r3.get("alpha")[4].value, i3 = true;
            continue;
          }
          const e4 = normalize_Color_ChannelValues(p2.value, 3, h2);
          if (!e4 || !isTokenNumber(e4))
            return false;
          h2.alpha = new TokenNode(e4), i3 = true;
          continue;
        }
        if (isFunctionNode(p2)) {
          const e4 = replaceComponentValues([[p2]], (e5) => {
            if (isTokenNode(e5) && isTokenIdent(e5.value) && toLowerCaseAZ2(e5.value[4].value) === "alpha" && r3 && r3.has("alpha"))
              return new TokenNode(r3.get("alpha"));
          });
          h2.alpha = e4[0][0], i3 = true;
          continue;
        }
        return false;
      }
      if (c3)
        return false;
      for (;isWhitespaceNode(e3.value[m2 + 1]) || isCommentNode(e3.value[m2 + 1]); )
        m2++;
      if (m2++, p2 = e3.value[m2], c3 = a3(p2), c3 === false)
        return false;
      r3 = normalizeRelativeColorDataChannels(c3), s3 = noneToZeroInRelativeColorDataChannels(r3), h2.syntaxFlags = new Set(c3.syntaxFlags), h2.syntaxFlags.add(me.RelativeAlphaSyntax), h2.channels = [...c3.channels], h2.colorNotation = c3.colorNotation, h2.alpha = c3.alpha;
    }
  }
  return !!r3 && h2;
}
function toPrecision(e3, a3 = 7) {
  e3 = +e3, a3 = +a3;
  const n3 = (Math.floor(Math.abs(e3)) + "").length;
  if (a3 > n3)
    return +e3.toFixed(a3 - n3);
  {
    const r3 = 10 ** (n3 - a3);
    return Math.round(e3 / r3) * r3;
  }
}
function serializeRGB(n3, r3 = true) {
  n3.channels = convertPowerlessComponentsToZeroValuesForDisplay(n3.channels, n3.colorNotation);
  let o3 = n3.channels.map((e3) => Number.isNaN(e3) ? 0 : e3);
  o3 = r3 ? XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(n3).channels) : XYZ_D50_to_sRGB(colorData_to_XYZ_D50(n3).channels);
  const t3 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o3[0])))), l2 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o3[1])))), s3 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o3[2])))), u3 = [c.CloseParen, ")", -1, -1, undefined], i3 = [c.Whitespace, " ", -1, -1, undefined], c3 = [c.Comma, ",", -1, -1, undefined], h2 = [new TokenNode([c.Number, t3.toString(), -1, -1, { value: Math.min(255, 255 * Math.max(0, o3[0])), type: a.Integer }]), new TokenNode(c3), new WhitespaceNode([i3]), new TokenNode([c.Number, l2.toString(), -1, -1, { value: Math.min(255, 255 * Math.max(0, o3[1])), type: a.Integer }]), new TokenNode(c3), new WhitespaceNode([i3]), new TokenNode([c.Number, s3.toString(), -1, -1, { value: Math.min(255, 255 * Math.max(0, o3[2])), type: a.Integer }])];
  if (typeof n3.alpha == "number") {
    const r4 = Math.min(1, Math.max(0, toPrecision(Number.isNaN(n3.alpha) ? 0 : n3.alpha)));
    return toPrecision(r4, 4) === 1 ? new FunctionNode([c.Function, "rgb(", -1, -1, { value: "rgb" }], u3, h2) : new FunctionNode([c.Function, "rgba(", -1, -1, { value: "rgba" }], u3, [...h2, new TokenNode(c3), new WhitespaceNode([i3]), new TokenNode([c.Number, toPrecision(r4, 4).toString(), -1, -1, { value: n3.alpha, type: a.Number }])]);
  }
  return new FunctionNode([c.Function, "rgba(", -1, -1, { value: "rgba" }], u3, [...h2, new TokenNode(c3), new WhitespaceNode([i3]), n3.alpha]);
}
function color(e3) {
  if (isFunctionNode(e3)) {
    switch (toLowerCaseAZ2(e3.getName())) {
      case "rgb":
      case "rgba":
        return rgb(e3, color);
      case "hsl":
      case "hsla":
        return hsl(e3, color);
      case "hwb":
        return a3 = color, threeChannelSpaceSeparated(e3, normalize_HWB_ChannelValues, he.HWB, [], a3);
      case "lab":
        return lab(e3, color);
      case "lch":
        return lch(e3, color);
      case "oklab":
        return oklab(e3, color);
      case "oklch":
        return oklch(e3, color);
      case "color":
        return color$1(e3, color);
      case "color-mix":
        return colorMix(e3, color);
      case "contrast-color":
        return contrastColor(e3, color);
      case "alpha":
        return alpha(e3, color);
    }
  }
  var a3;
  if (isTokenNode(e3)) {
    if (isTokenHash(e3.value))
      return hex(e3.value);
    if (isTokenIdent(e3.value)) {
      const a4 = namedColor(e3.value[4].value);
      return a4 !== false ? a4 : toLowerCaseAZ2(e3.value[4].value) === "transparent" && { colorNotation: he.RGB, channels: [0, 0, 0], alpha: 0, syntaxFlags: new Set([me.ColorKeyword]) };
    }
  }
  return false;
}

// node_modules/@nativescript/core/color/color-utils.js
var HEX_REGEX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)|(^#[0-9A-F]{4}$)/i;
function isCssColorMixExpression(value) {
  return value.includes("color-mix(");
}
function argbFromColorMix(value) {
  const astComponentValue = parseComponentValue(tokenize({ css: value }));
  const colorData = color(astComponentValue);
  let argb;
  if (colorData) {
    const serialized = serializeRGB(colorData);
    argb = argbFromRgbOrRgba(serialized.toString());
  } else {
    argb = -1;
  }
  return argb;
}
function isRgbOrRgba(value) {
  return (value.startsWith("rgb(") || value.startsWith("rgba(")) && value.endsWith(")");
}
function isHslOrHsla(value) {
  return (value.startsWith("hsl") || value.startsWith("hsla(")) && value.endsWith(")");
}
function isHsvOrHsva(value) {
  return (value.startsWith("hsv") || value.startsWith("hsva(")) && value.endsWith(")");
}
function parseColorWithAlpha(value) {
  const separator = value.indexOf(",") !== -1 ? "," : " ";
  const parts = value.replace(/(rgb|hsl|hsv)a?\(/, "").replace(")", "").replace(/\//, " ").replace(/%/g, "").split(separator).filter((part) => Boolean(part.length));
  let f3 = 255;
  let s3 = 255;
  let t3 = 255;
  let a3 = 255;
  if (parts[0]) {
    f3 = parseFloat(parts[0].trim());
  }
  if (parts[1]) {
    s3 = parseFloat(parts[1].trim());
  }
  if (parts[2]) {
    t3 = parseFloat(parts[2].trim());
  }
  if (parts[3]) {
    a3 = Math.round(parseFloat(parts[3].trim()) * 255);
  }
  return { f: f3, s: s3, t: t3, a: a3 };
}
function argbFromString(hex2) {
  hex2 = hex2.substring(1);
  const length = hex2.length;
  if (length === 3) {
    hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
  } else if (length === 4) {
    hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2] + hex2[3] + hex2[3];
  }
  let intVal = parseInt(hex2, 16);
  if (hex2.length === 6) {
    intVal = (intVal & 16777215) + 4278190080;
  } else {
    const a3 = intVal / 1 & 255;
    intVal = (intVal >>> 8) + (a3 & 255) * 16777216;
  }
  return intVal;
}
function argbFromRgbOrRgba(value) {
  const { f: r3, s: g2, t: b2, a: a3 } = parseColorWithAlpha(value);
  return (a3 & 255) * 16777216 + (r3 & 255) * 65536 + (g2 & 255) * 256 + (b2 & 255);
}
function argbFromHslOrHsla(value) {
  const { f: h2, s: s3, t: l2, a: a3 } = parseColorWithAlpha(value);
  const { r: r3, g: g2, b: b2 } = hslToRgb(h2, s3, l2);
  return (a3 & 255) * 16777216 + (r3 & 255) * 65536 + (g2 & 255) * 256 + (b2 & 255);
}
function argbFromHsvOrHsva(value) {
  const { f: h2, s: s3, t: v, a: a3 } = parseColorWithAlpha(value);
  const { r: r3, g: g2, b: b2 } = hsvToRgb(h2, s3, v);
  return (a3 & 255) * 16777216 + (r3 & 255) * 65536 + (g2 & 255) * 256 + (b2 & 255);
}
function rgbToHsl(r3, g2, b2) {
  r3 /= 255;
  g2 /= 255;
  b2 /= 255;
  const max2 = Math.max(r3, g2, b2), min2 = Math.min(r3, g2, b2);
  let h2, s3;
  const l2 = (max2 + min2) / 2;
  if (max2 == min2) {
    h2 = s3 = 0;
  } else {
    const d3 = max2 - min2;
    s3 = l2 > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
    switch (max2) {
      case r3:
        h2 = (g2 - b2) / d3 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r3) / d3 + 2;
        break;
      case b2:
        h2 = (r3 - g2) / d3 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2 * 360, s: s3 * 100, l: l2 * 100 };
}
function hue2rgb(p2, q2, t3) {
  if (t3 < 0)
    t3 += 1;
  if (t3 > 1)
    t3 -= 1;
  if (t3 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t3;
  if (t3 < 1 / 2)
    return q2;
  if (t3 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t3) * 6;
  return p2;
}
function hslToRgb(h1, s1, l1) {
  const h2 = h1 % 360 / 360;
  const s3 = s1 / 100;
  const l2 = l1 / 100;
  let r3, g2, b2;
  if (s3 === 0) {
    r3 = g2 = b2 = l2;
  } else {
    const q2 = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3;
    const p2 = 2 * l2 - q2;
    r3 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: Math.round(r3 * 255), g: Math.round(g2 * 255), b: Math.round(b2 * 255) };
}
function rgbToHsv(r3, g2, b2) {
  r3 /= 255;
  g2 /= 255;
  b2 /= 255;
  const max2 = Math.max(r3, g2, b2), min2 = Math.min(r3, g2, b2);
  let h2;
  const v = max2;
  const d3 = max2 - min2;
  const s3 = max2 === 0 ? 0 : d3 / max2;
  if (max2 == min2) {
    h2 = 0;
  } else {
    switch (max2) {
      case r3:
        h2 = (g2 - b2) / d3 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r3) / d3 + 2;
        break;
      case b2:
        h2 = (r3 - g2) / d3 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2 * 360, s: s3 * 100, v: v * 100 };
}
function hsvToRgb(h1, s1, v1) {
  const h2 = h1 % 360 / 360 * 6;
  const s3 = s1 / 100;
  const v = v1 / 100;
  const i3 = Math.floor(h2), f3 = h2 - i3, p2 = v * (1 - s3), q2 = v * (1 - f3 * s3), t3 = v * (1 - (1 - f3) * s3), mod2 = i3 % 6, r3 = [v, q2, p2, p2, t3, v][mod2], g2 = [t3, v, v, q2, p2, p2][mod2], b2 = [p2, p2, t3, v, v, q2][mod2];
  return { r: r3 * 255, g: g2 * 255, b: b2 * 255 };
}

// node_modules/@nativescript/core/color/color-common.js
class ColorBase {
  constructor(...args) {
    if (args.length === 1) {
      const arg = args[0];
      if (isString(arg)) {
        const lowered = arg.toLowerCase();
        if (isRgbOrRgba(lowered)) {
          this._argb = argbFromRgbOrRgba(lowered);
        } else if (isHslOrHsla(lowered)) {
          this._argb = argbFromHslOrHsla(lowered);
        } else if (isHsvOrHsva(lowered)) {
          this._argb = argbFromHsvOrHsva(lowered);
        } else if (isKnownName(lowered)) {
          const argb = getKnownColor(lowered);
          this._name = arg;
          this._argb = argb;
        } else if (isCssColorMixExpression(lowered)) {
          this._argb = argbFromColorMix(lowered);
        } else if (arg[0].charAt(0) === "#" && (arg.length === 4 || arg.length === 5 || arg.length === 7 || arg.length === 9)) {
          this._argb = this._argbFromString(arg);
        } else {
          throw new Error("Invalid color: " + arg);
        }
      } else if (isNumber(arg)) {
        this._argb = arg >>> 0;
      } else if (arg && arg._argb) {
        this._argb = arg._argb >>> 0;
      } else {
        throw new Error("Expected 1 or 4 constructor parameters.");
      }
    } else if (args.length >= 4) {
      const a3 = args[0];
      switch (args[4]) {
        case "hsl": {
          const { r: r3, g: g2, b: b2 } = hslToRgb(args[1], args[2], args[3]);
          this._argb = (a3 & 255) * 16777216 + (r3 & 255) * 65536 + (g2 & 255) * 256 + (b2 & 255) * 1;
          break;
        }
        case "hsv": {
          const { r: r3, g: g2, b: b2 } = hsvToRgb(args[1], args[2], args[3]);
          this._argb = (a3 & 255) * 16777216 + (r3 & 255) * 65536 + (g2 & 255) * 256 + (b2 & 255) * 1;
          break;
        }
        default:
          this._argb = (a3 & 255) * 16777216 + (args[1] & 255) * 65536 + (args[2] & 255) * 256 + (args[3] & 255) * 1;
          break;
      }
    } else {
      throw new Error("Expected 1 or 4 constructor parameters.");
    }
  }
  get a() {
    return this._argb / 16777216 & 255;
  }
  get r() {
    return this._argb / 65536 & 255;
  }
  get g() {
    return this._argb / 256 & 255;
  }
  get b() {
    return this._argb / 1 & 255;
  }
  get argb() {
    return this._argb;
  }
  get hex() {
    let result = "#" + ("000000" + (this._argb & 16777215).toString(16)).toUpperCase().slice(-6);
    if (this.a !== 255) {
      return result += ("00" + this.a.toString(16).toUpperCase()).slice(-2);
    }
    return result;
  }
  get name() {
    return this._name;
  }
  get ios() {
    return;
  }
  get android() {
    return;
  }
  _argbFromString(hex2) {
    return argbFromString(hex2);
  }
  equals(value) {
    return value && this.argb === value.argb;
  }
  static equals(value1, value2) {
    if (!value1 && !value2) {
      return true;
    }
    if (!value1 || !value2) {
      return false;
    }
    return value1.equals(value2);
  }
  static isValid(value) {
    if (value instanceof ColorBase) {
      return true;
    }
    if (!isString(value)) {
      return false;
    }
    const lowered = value.toLowerCase();
    if (isKnownName(lowered)) {
      return true;
    }
    return HEX_REGEX.test(value) || isRgbOrRgba(lowered) || isHslOrHsla(lowered);
  }
  static fromHSL(a3, h2, s3, l2) {
    return new ColorBase(a3, h2, s3, l2, "hsl");
  }
  static fromHSV(a3, h2, s3, l2) {
    return new ColorBase(a3, h2, s3, l2, "hsv");
  }
  toString() {
    return this.hex;
  }
  static fromIosColor(value) {
    return;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  getBrightness() {
    return (this.r * 299 + this.g * 587 + this.b * 114) / 1000;
  }
  getLuminance() {
    let R3, G2, B;
    const RsRGB = this.r / 255;
    const GsRGB = this.g / 255;
    const BsRGB = this.b / 255;
    if (RsRGB <= 0.03928) {
      R3 = RsRGB / 12.92;
    } else {
      R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B = BsRGB / 12.92;
    } else {
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R3 + 0.7152 * G2 + 0.0722 * B;
  }
  setAlpha(a3) {
    return new ColorBase(a3, this.r, this.g, this.b);
  }
  toHsl() {
    return { ...rgbToHsl(this.r, this.g, this.b), a: this.a };
  }
  toHslString() {
    const hsl2 = rgbToHsl(this.r, this.g, this.b);
    const h2 = Math.round(hsl2.h), s3 = Math.round(hsl2.s), l2 = Math.round(hsl2.l);
    const a3 = this.a;
    return a3 == 255 ? "hsl(" + h2 + ", " + s3 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s3 + "%, " + l2 + "%, " + (a3 / 255).toFixed(2) + ")";
  }
  toHsv() {
    return { ...rgbToHsv(this.r, this.g, this.b), a: this.a };
  }
  toHsvString() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    const h2 = Math.round(hsv.h * 360), s3 = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    const a3 = this.a;
    return a3 == 255 ? "hsv(" + h2 + ", " + s3 + "%, " + v + "%)" : "hsva(" + h2 + ", " + s3 + "%, " + v + "%, " + (a3 / 255).toFixed(2) + ")";
  }
  toRgbString() {
    const a3 = this.a;
    return a3 == 1 ? "rgb(" + Math.round(this.r) + ", " + Math.round(this.g) + ", " + Math.round(this.b) + ")" : "rgba(" + Math.round(this.r) + ", " + Math.round(this.g) + ", " + Math.round(this.b) + ", " + (a3 / 255).toFixed(2) + ")";
  }
  desaturate(amount) {
    amount = amount === 0 ? 0 : amount || 10;
    const hsl2 = rgbToHsl(this.r, this.g, this.b);
    return ColorBase.fromHSL(this.a, hsl2.h, Math.min(100, Math.max(0, hsl2.s - amount)), hsl2.l);
  }
  saturate(amount) {
    amount = amount === 0 ? 0 : amount || 10;
    const hsl2 = rgbToHsl(this.r, this.g, this.b);
    return ColorBase.fromHSL(this.a, hsl2.h, Math.min(100, Math.max(0, hsl2.s + amount)), hsl2.l);
  }
  greyscale() {
    return this.desaturate(100);
  }
  lighten(amount) {
    amount = amount === 0 ? 0 : amount || 10;
    const hsl2 = rgbToHsl(this.r, this.g, this.b);
    return ColorBase.fromHSL(this.a, hsl2.h, hsl2.s, Math.min(100, Math.max(0, hsl2.l + amount)));
  }
  brighten(amount) {
    amount = amount === 0 ? 0 : amount || 10;
    const r3 = Math.max(0, Math.min(255, this.r - Math.round(255 * -(amount / 100))));
    const g2 = Math.max(0, Math.min(255, this.g - Math.round(255 * -(amount / 100))));
    const b2 = Math.max(0, Math.min(255, this.b - Math.round(255 * -(amount / 100))));
    return new ColorBase(this.a, r3, g2, b2);
  }
  darken(amount) {
    amount = amount === 0 ? 0 : amount || 10;
    const hsl2 = rgbToHsl(this.r, this.g, this.b);
    return ColorBase.fromHSL(this.a, hsl2.h, hsl2.s, Math.min(100, Math.max(0, hsl2.l - amount)));
  }
  spin(amount) {
    const hsl2 = this.toHsl();
    const hue = (hsl2.h + amount) % 360;
    hsl2.h = hue < 0 ? 360 + hue : hue;
    return ColorBase.fromHSL(this.a, hsl2.h, hsl2.s, hsl2.l);
  }
  complement() {
    const hsl2 = this.toHsl();
    hsl2.h = (hsl2.h + 180) % 360;
    return ColorBase.fromHSL(this.a, hsl2.h, hsl2.s, hsl2.l);
  }
  static mix(color1, color2, amount = 50) {
    const p2 = amount / 100;
    const rgba = {
      r: (color2.r - color1.r) * p2 + color1.r,
      g: (color2.g - color1.g) * p2 + color1.g,
      b: (color2.b - color1.b) * p2 + color1.b,
      a: (color2.a - color1.a) * p2 + color1.a
    };
    return new ColorBase(rgba.a, rgba.r, rgba.g, rgba.b);
  }
}

// node_modules/@nativescript/core/color/index.android.js
class Color extends ColorBase {
  get android() {
    return this.argb >> 0;
  }
}

// node_modules/@nativescript/core/application/helpers-common.js
var nativeApp;
function isEmbedded() {
  if (__APPLE__) {
    return !!NativeScriptEmbedder.sharedInstance().delegate;
  } else {
    return org.nativescript?.Bootstrap?.isEmbeddedNativeScript;
  }
}
function getNativeApp() {
  if (__ANDROID__) {
    if (!nativeApp) {
      if (com.tns.NativeScriptApplication) {
        nativeApp = com.tns.NativeScriptApplication.getInstance();
      }
      if (!nativeApp && isEmbedded()) {
        nativeApp = com.tns.embedding.ApplicationHolder.getInstance();
      }
      if (!nativeApp) {
        const clazz = java.lang.Class.forName("android.app.ActivityThread");
        if (clazz) {
          const method = clazz.getMethod("currentApplication", null);
          if (method) {
            nativeApp = method.invoke(null, null);
          }
        }
      }
    }
  }
  return nativeApp;
}
function setNativeApp(app) {
  nativeApp = app;
}
var rootView;
function getRootView() {
  return rootView;
}
function setRootView(view) {
  rootView = view;
}
var _appInBackground = false;
function isAppInBackground() {
  return _appInBackground;
}
function setAppInBackground(value) {
  _appInBackground = value;
}
var _appMainEntry;
function getAppMainEntry() {
  return _appMainEntry;
}
function setAppMainEntry(entry) {
  _appMainEntry = entry;
}
var _toggleApplicationEventListenersHandler;
function toggleApplicationEventListeners(toAdd, callback) {
  if (_toggleApplicationEventListenersHandler) {
    _toggleApplicationEventListenersHandler(toAdd, callback);
  }
}
function setToggleApplicationEventListenersCallback(callback) {
  _toggleApplicationEventListenersHandler = callback;
}
var _applicationPropertiesCallback;
function getApplicationProperties() {
  if (_applicationPropertiesCallback) {
    return _applicationPropertiesCallback();
  }
  return { orientation: "unknown", systemAppearance: null };
}
function setApplicationPropertiesCallback(callback) {
  _applicationPropertiesCallback = callback;
}
var _a11yUpdatePropertiesCallback;
function setA11yUpdatePropertiesCallback(callback) {
  _a11yUpdatePropertiesCallback = callback;
}
function updateA11yPropertiesCallback(view) {
  if (_a11yUpdatePropertiesCallback) {
    _a11yUpdatePropertiesCallback(view);
  }
}
var _imageFetcher;
function getImageFetcher() {
  return _imageFetcher;
}
function setImageFetcher(fetcher) {
  _imageFetcher = fetcher;
}
var CacheMode;
(function(CacheMode2) {
  CacheMode2[CacheMode2["none"] = 0] = "none";
  CacheMode2[CacheMode2["memory"] = 1] = "memory";
  CacheMode2[CacheMode2["diskAndMemory"] = 2] = "diskAndMemory";
})(CacheMode || (CacheMode = {}));
var _currentCacheMode;
function initImageCache(context, mode = CacheMode.diskAndMemory, memoryCacheSize = 0.25, diskCacheSize = 10 * 1024 * 1024) {
  if (_currentCacheMode === mode) {
    return;
  }
  _currentCacheMode = mode;
  if (!getImageFetcher()) {
    setImageFetcher(org.nativescript.widgets.image.Fetcher.getInstance(context));
  } else {
    getImageFetcher().clearCache();
  }
  const params = new org.nativescript.widgets.image.Cache.CacheParams;
  params.memoryCacheEnabled = mode !== CacheMode.none;
  params.setMemCacheSizePercent(memoryCacheSize);
  params.diskCacheEnabled = mode === CacheMode.diskAndMemory;
  params.diskCacheSize = diskCacheSize;
  const imageCache = org.nativescript.widgets.image.Cache.getInstance(params);
  getImageFetcher().addImageCache(imageCache);
  getImageFetcher().initCache();
}

// node_modules/@nativescript/core/data/observable/index.js
var _wrappedIndex = 0;

class WrappedValue {
  constructor(wrapped) {
    this.wrapped = wrapped;
  }
  static unwrap(value) {
    return value instanceof WrappedValue ? value.wrapped : value;
  }
  static wrap(value) {
    const w = _wrappedValues[_wrappedIndex++ % 5];
    w.wrapped = value;
    return w;
  }
}
var _wrappedValues = [new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null)];
var _globalEventHandlers = {};

class Observable {
  constructor() {
    this._observers = {};
  }
  get(name) {
    return this[name];
  }
  set(name, value) {
    const oldValue = this[name];
    if (this[name] === value) {
      return;
    }
    const newValue = WrappedValue.unwrap(value);
    this[name] = newValue;
    this.notifyPropertyChange(name, newValue, oldValue);
  }
  setProperty(name, value) {
    const oldValue = this[name];
    if (this[name] === value) {
      return;
    }
    this[name] = value;
    this.notifyPropertyChange(name, value, oldValue);
    const specificPropertyChangeEventName = name + "Change";
    if (this.hasListeners(specificPropertyChangeEventName)) {
      const eventData = this._createPropertyChangeData(name, value, oldValue);
      eventData.eventName = specificPropertyChangeEventName;
      this.notify(eventData);
    }
  }
  on(eventName, callback, thisArg) {
    this.addEventListener(eventName, callback, thisArg);
  }
  once(eventName, callback, thisArg) {
    this.addEventListener(eventName, callback, thisArg, true);
  }
  off(eventName, callback, thisArg) {
    this.removeEventListener(eventName, callback, thisArg);
  }
  addEventListener(eventName, callback, thisArg, once) {
    once = once || undefined;
    thisArg = thisArg || undefined;
    if (typeof eventName !== "string") {
      throw new TypeError("Event name must be a string.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Callback, if provided, must be a function.");
    }
    const list = this._getEventList(eventName, true);
    if (Observable._indexOfListener(list, callback, thisArg) !== -1) {
      return;
    }
    list.push({
      callback,
      thisArg,
      once
    });
  }
  removeEventListener(eventName, callback, thisArg) {
    thisArg = thisArg || undefined;
    if (typeof eventName !== "string") {
      throw new TypeError("Events name(s) must be string.");
    }
    if (callback && typeof callback !== "function") {
      throw new TypeError("callback must be function.");
    }
    const entries = this._observers[eventName];
    if (!entries) {
      return;
    }
    Observable.innerRemoveEventListener(entries, callback, thisArg);
    if (!entries.length) {
      delete this._observers[eventName];
    }
  }
  static on(eventName, callback, thisArg, once) {
    this.addEventListener(eventName, callback, thisArg, once);
  }
  static once(eventName, callback, thisArg) {
    this.addEventListener(eventName, callback, thisArg, true);
  }
  static off(eventName, callback, thisArg) {
    this.removeEventListener(eventName, callback, thisArg);
  }
  static innerRemoveEventListener(entries, callback, thisArg) {
    for (let i3 = 0;i3 < entries.length; i3++) {
      const entry = entries[i3];
      if (thisArg && (entry.callback !== callback || entry.thisArg !== thisArg)) {
        continue;
      }
      if (callback && entry.callback !== callback) {
        continue;
      }
      entries.splice(i3, 1);
      i3--;
    }
  }
  static removeEventListener(eventName, callback, thisArg) {
    thisArg = thisArg || undefined;
    if (typeof eventName !== "string") {
      throw new TypeError("Event name must be a string.");
    }
    if (callback && typeof callback !== "function") {
      throw new TypeError("Callback, if provided, must be function.");
    }
    const eventClass = this.name === "Observable" ? "*" : this.name;
    const entries = _globalEventHandlers?.[eventClass]?.[eventName];
    if (!entries) {
      return;
    }
    Observable.innerRemoveEventListener(entries, callback, thisArg);
    if (!entries.length) {
      delete _globalEventHandlers[eventClass][eventName];
    }
    const keys = Object.keys(_globalEventHandlers[eventClass]);
    if (keys.length === 0) {
      delete _globalEventHandlers[eventClass];
    }
  }
  static addEventListener(eventName, callback, thisArg, once) {
    once = once || undefined;
    thisArg = thisArg || undefined;
    if (typeof eventName !== "string") {
      throw new TypeError("Event name must be a string.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Callback must be a function.");
    }
    const eventClass = this.name === "Observable" ? "*" : this.name;
    if (!_globalEventHandlers[eventClass]) {
      _globalEventHandlers[eventClass] = {};
    }
    if (!_globalEventHandlers[eventClass][eventName]) {
      _globalEventHandlers[eventClass][eventName] = [];
    }
    if (Observable._indexOfListener(_globalEventHandlers[eventClass][eventName], callback, thisArg) !== -1) {
      return;
    }
    _globalEventHandlers[eventClass][eventName].push({ callback, thisArg, once });
  }
  _globalNotify(eventClass, eventType, data) {
    if (_globalEventHandlers[eventClass]) {
      const eventName = data.eventName + eventType;
      const entries = _globalEventHandlers[eventClass][eventName];
      if (entries) {
        Observable._fireEvent(entries, data);
      }
    }
    if (_globalEventHandlers["*"]) {
      const eventName = data.eventName + eventType;
      const entries = _globalEventHandlers["*"][eventName];
      if (entries) {
        Observable._fireEvent(entries, data);
      }
    }
  }
  notify(data) {
    data.object = data.object || this;
    const dataWithObject = data;
    const eventClass = this.constructor.name;
    this._globalNotify(eventClass, "First", dataWithObject);
    const observers = this._observers[data.eventName];
    if (observers) {
      Observable._fireEvent(observers, dataWithObject);
    }
    this._globalNotify(eventClass, "", dataWithObject);
  }
  static _fireEvent(observers, data) {
    const length = observers.length;
    if (!length) {
      return;
    }
    if (length === 1) {
      const index = 0;
      this._handleListenerEntry(observers[index], index, observers, data);
    } else {
      const observersCp = observers.slice();
      for (let i3 = 0;i3 < length; i3++) {
        const entry = observersCp[i3];
        this._handleListenerEntry(entry, i3, observers, data);
      }
    }
  }
  static _handleListenerEntry(entry, index, observers, data) {
    if (!entry) {
      return;
    }
    if (entry.once) {
      observers.splice(index, 1);
    }
    const returnValue = entry.thisArg ? entry.callback.apply(entry.thisArg, [data]) : entry.callback(data);
    if (returnValue instanceof Promise) {
      returnValue.catch((err) => {
        console.error(err);
      });
    }
  }
  notifyPropertyChange(name, value, oldValue) {
    this.notify(this._createPropertyChangeData(name, value, oldValue));
  }
  hasListeners(eventName) {
    return eventName in this._observers;
  }
  _createPropertyChangeData(propertyName, value, oldValue) {
    return {
      eventName: Observable.propertyChangeEvent,
      object: this,
      propertyName,
      value,
      oldValue
    };
  }
  _emit(eventName) {
    this.notify({ eventName, object: this });
  }
  _getEventList(eventName, createIfNeeded) {
    if (!eventName) {
      throw new TypeError("eventName must be a valid string.");
    }
    let list = this._observers[eventName];
    if (!list && createIfNeeded) {
      list = [];
      this._observers[eventName] = list;
    }
    return list;
  }
  static _indexOfListener(list, callback, thisArg) {
    thisArg = thisArg || undefined;
    return list.findIndex((entry) => entry.callback === callback && entry.thisArg === thisArg);
  }
}
Observable.propertyChangeEvent = "propertyChange";

// node_modules/@nativescript/core/accessibility/accessibility-common.js
var lastFocusedViewOnPageKeyName = "__lastFocusedViewOnPage";
var accessibilityBlurEvent = "accessibilityBlur";
var accessibilityFocusEvent = "accessibilityFocus";
var accessibilityFocusChangedEvent = "accessibilityFocusChanged";
var accessibilityPerformEscapeEvent = "accessibilityPerformEscape";
function notifyAccessibilityFocusState(view, receivedFocus, lostFocus) {
  if (!receivedFocus && !lostFocus) {
    return;
  }
  view.notify({
    eventName: accessibilityFocusChangedEvent,
    object: view,
    value: !!receivedFocus
  });
  if (receivedFocus) {
    if (view.page) {
      view.page[lastFocusedViewOnPageKeyName] = new WeakRef(view);
    }
    view.notify({
      eventName: accessibilityFocusEvent,
      object: view
    });
  } else if (lostFocus) {
    view.notify({
      eventName: accessibilityBlurEvent,
      object: view
    });
  }
}
function getLastFocusedViewOnPage(page) {
  try {
    const lastFocusedViewRef = page[lastFocusedViewOnPageKeyName];
    if (!lastFocusedViewRef) {
      return null;
    }
    const lastFocusedView = lastFocusedViewRef.deref();
    if (!lastFocusedView) {
      return null;
    }
    if (!lastFocusedView.parent || lastFocusedView.page !== page) {
      return null;
    }
    return lastFocusedView;
  } catch {} finally {
    delete page[lastFocusedViewOnPageKeyName];
  }
  return null;
}

class SharedA11YObservable extends Observable {
}
var AccessibilityServiceEnabledPropName = "accessibilityServiceEnabled";

class CommonA11YServiceEnabledObservable extends SharedA11YObservable {
  constructor(sharedA11YObservable) {
    super();
    const ref = new WeakRef(this);
    let lastValue;
    function callback() {
      const self2 = ref?.get();
      if (!self2) {
        sharedA11YObservable.off(Observable.propertyChangeEvent, callback);
        return;
      }
      const newValue = !!sharedA11YObservable.accessibilityServiceEnabled;
      if (newValue !== lastValue) {
        self2.set(AccessibilityServiceEnabledPropName, newValue);
        lastValue = newValue;
      }
    }
    sharedA11YObservable.on(Observable.propertyChangeEvent, callback);
    this.set(AccessibilityServiceEnabledPropName, !!sharedA11YObservable.accessibilityServiceEnabled);
  }
}
var a11yServiceEnabled;
function isA11yEnabled() {
  if (typeof a11yServiceEnabled === "boolean") {
    return a11yServiceEnabled;
  }
  return;
}
function setA11yEnabled(value) {
  a11yServiceEnabled = value;
}
var VALID_FONT_SCALES = __APPLE__ ? [0.5, 0.7, 0.85, 1, 1.15, 1.3, 1.5, 2, 2.5, 3, 3.5, 4] : [0.85, 1, 1.15, 1.3];
function getClosestValidFontScale(fontScale) {
  fontScale = Number(fontScale) || 1;
  return VALID_FONT_SCALES.sort((a3, b2) => Math.abs(fontScale - a3) - Math.abs(fontScale - b2))[0];
}
var FontScaleCategory;
(function(FontScaleCategory2) {
  FontScaleCategory2["ExtraSmall"] = "extra-small";
  FontScaleCategory2["Medium"] = "medium";
  FontScaleCategory2["ExtraLarge"] = "extra-large";
})(FontScaleCategory || (FontScaleCategory = {}));
var fontScaleExtraSmallCategoryClass = `a11y-fontscale-xs`;
var fontScaleMediumCategoryClass = `a11y-fontscale-m`;
var fontScaleExtraLargeCategoryClass = `a11y-fontscale-xl`;
var fontScaleCategoryClasses = [fontScaleExtraSmallCategoryClass, fontScaleMediumCategoryClass, fontScaleExtraLargeCategoryClass];
var a11yServiceEnabledClass = `a11y-service-enabled`;
var a11yServiceDisabledClass = `a11y-service-disabled`;
var a11yServiceClasses = [a11yServiceEnabledClass, a11yServiceDisabledClass];
var currentFontScale = null;
function setFontScale(scale) {
  currentFontScale = scale;
}
function getFontScale() {
  return currentFontScale;
}
function getFontScaleCategory() {
  if (__ANDROID__) {
    return FontScaleCategory.Medium;
  }
  if (getFontScale() < 0.85) {
    return FontScaleCategory.ExtraSmall;
  }
  if (getFontScale() > 1.5) {
    return FontScaleCategory.ExtraLarge;
  }
  return FontScaleCategory.Medium;
}
var initAccessibilityCssHelperCallback;
function setInitAccessibilityCssHelper(callback) {
  initAccessibilityCssHelperCallback = callback;
}
function readyInitAccessibilityCssHelper() {
  if (initAccessibilityCssHelperCallback) {
    initAccessibilityCssHelperCallback();
    initAccessibilityCssHelperCallback = null;
  }
}
var initFontScaleCallback;
function setInitFontScale(callback) {
  initFontScaleCallback = callback;
}
function readyInitFontScale() {
  if (initFontScaleCallback) {
    initFontScaleCallback();
    initFontScaleCallback = null;
  }
}
var fontScaleCssClasses;
function setFontScaleCssClasses(value) {
  fontScaleCssClasses = value;
}
function getFontScaleCssClasses() {
  return fontScaleCssClasses;
}
var currentFontScaleClass = "";
function setCurrentFontScaleClass(value) {
  currentFontScaleClass = value;
}
function getCurrentFontScaleClass() {
  return currentFontScaleClass;
}
var currentFontScaleCategory = "";
function setCurrentFontScaleCategory(value) {
  currentFontScaleCategory = value;
}
function getCurrentFontScaleCategory() {
  return currentFontScaleCategory;
}
var currentA11YServiceClass = "";
function setCurrentA11YServiceClass(value) {
  currentA11YServiceClass = value;
}
function getCurrentA11YServiceClass() {
  return currentA11YServiceClass;
}
var AccessibilityTrait;
(function(AccessibilityTrait2) {
  AccessibilityTrait2["AllowsDirectInteraction"] = "allowsDirectInteraction";
  AccessibilityTrait2["CausesPageTurn"] = "pageTurn";
  AccessibilityTrait2["NotEnabled"] = "disabled";
  AccessibilityTrait2["Selected"] = "selected";
  AccessibilityTrait2["UpdatesFrequently"] = "frequentUpdates";
})(AccessibilityTrait || (AccessibilityTrait = {}));
var AccessibilityRole;
(function(AccessibilityRole2) {
  AccessibilityRole2["Adjustable"] = "adjustable";
  AccessibilityRole2["Button"] = "button";
  AccessibilityRole2["Checkbox"] = "checkbox";
  AccessibilityRole2["Header"] = "header";
  AccessibilityRole2["Image"] = "image";
  AccessibilityRole2["ImageButton"] = "imageButton";
  AccessibilityRole2["KeyboardKey"] = "keyboardKey";
  AccessibilityRole2["Link"] = "link";
  AccessibilityRole2["None"] = "none";
  AccessibilityRole2["PlaysSound"] = "plays";
  AccessibilityRole2["ProgressBar"] = "progressBar";
  AccessibilityRole2["RadioButton"] = "radioButton";
  AccessibilityRole2["Search"] = "search";
  AccessibilityRole2["SpinButton"] = "spinButton";
  AccessibilityRole2["StartsMediaSession"] = "startsMedia";
  AccessibilityRole2["StaticText"] = "text";
  AccessibilityRole2["Summary"] = "summary";
  AccessibilityRole2["Switch"] = "switch";
})(AccessibilityRole || (AccessibilityRole = {}));
var AccessibilityState;
(function(AccessibilityState2) {
  AccessibilityState2["Selected"] = "selected";
  AccessibilityState2["Checked"] = "checked";
  AccessibilityState2["Unchecked"] = "unchecked";
  AccessibilityState2["Disabled"] = "disabled";
})(AccessibilityState || (AccessibilityState = {}));
var AccessibilityLiveRegion;
(function(AccessibilityLiveRegion2) {
  AccessibilityLiveRegion2["None"] = "none";
  AccessibilityLiveRegion2["Polite"] = "polite";
  AccessibilityLiveRegion2["Assertive"] = "assertive";
})(AccessibilityLiveRegion || (AccessibilityLiveRegion = {}));
var IOSPostAccessibilityNotificationType;
(function(IOSPostAccessibilityNotificationType2) {
  IOSPostAccessibilityNotificationType2["Announcement"] = "announcement";
  IOSPostAccessibilityNotificationType2["Screen"] = "screen";
  IOSPostAccessibilityNotificationType2["Layout"] = "layout";
})(IOSPostAccessibilityNotificationType || (IOSPostAccessibilityNotificationType = {}));
var AndroidAccessibilityEvent;
(function(AndroidAccessibilityEvent2) {
  AndroidAccessibilityEvent2["INVALID_POSITION"] = "invalid_position";
  AndroidAccessibilityEvent2["MAX_TEXT_LENGTH"] = "max_text_length";
  AndroidAccessibilityEvent2["VIEW_CLICKED"] = "view_clicked";
  AndroidAccessibilityEvent2["VIEW_LONG_CLICKED"] = "view_long_clicked";
  AndroidAccessibilityEvent2["VIEW_SELECTED"] = "view_selected";
  AndroidAccessibilityEvent2["VIEW_FOCUSED"] = "view_focused";
  AndroidAccessibilityEvent2["VIEW_TEXT_CHANGED"] = "view_text_changed";
  AndroidAccessibilityEvent2["WINDOW_STATE_CHANGED"] = "window_state_changed";
  AndroidAccessibilityEvent2["NOTIFICATION_STATE_CHANGED"] = "notification_state_changed";
  AndroidAccessibilityEvent2["VIEW_HOVER_ENTER"] = "view_hover_enter";
  AndroidAccessibilityEvent2["VIEW_HOVER_EXIT"] = "view_hover_exit";
  AndroidAccessibilityEvent2["TOUCH_EXPLORATION_GESTURE_START"] = "touch_exploration_gesture_start";
  AndroidAccessibilityEvent2["TOUCH_EXPLORATION_GESTURE_END"] = "touch_exploration_gesture_end";
  AndroidAccessibilityEvent2["WINDOW_CONTENT_CHANGED"] = "window_content_changed";
  AndroidAccessibilityEvent2["VIEW_SCROLLED"] = "view_scrolled";
  AndroidAccessibilityEvent2["VIEW_TEXT_SELECTION_CHANGED"] = "view_text_selection_changed";
  AndroidAccessibilityEvent2["ANNOUNCEMENT"] = "announcement";
  AndroidAccessibilityEvent2["VIEW_ACCESSIBILITY_FOCUSED"] = "view_accessibility_focused";
  AndroidAccessibilityEvent2["VIEW_ACCESSIBILITY_FOCUS_CLEARED"] = "view_accessibility_focus_cleared";
  AndroidAccessibilityEvent2["VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"] = "view_text_traversed_at_movement_granularity";
  AndroidAccessibilityEvent2["GESTURE_DETECTION_START"] = "gesture_detection_start";
  AndroidAccessibilityEvent2["GESTURE_DETECTION_END"] = "gesture_detection_end";
  AndroidAccessibilityEvent2["TOUCH_INTERACTION_START"] = "touch_interaction_start";
  AndroidAccessibilityEvent2["TOUCH_INTERACTION_END"] = "touch_interaction_end";
  AndroidAccessibilityEvent2["ALL_MASK"] = "all";
})(AndroidAccessibilityEvent || (AndroidAccessibilityEvent = {}));

// node_modules/@nativescript/core/application/helpers.android.js
var _startActivity;
var _foregroundActivity;
function androidGetCurrentActivity() {
  return _foregroundActivity || _startActivity;
}
function androidGetForegroundActivity() {
  return _foregroundActivity;
}
function androidSetForegroundActivity(activity) {
  _foregroundActivity = activity;
}
function androidGetStartActivity() {
  return _startActivity;
}
function androidSetStartActivity(activity) {
  _startActivity = activity;
}
function getApplicationContext() {
  return getNativeApp().getApplicationContext();
}
function updateContentDescription(view, forceUpdate) {
  if (!view.nativeViewProtected) {
    return;
  }
  return applyContentDescription(view, forceUpdate);
}
function applyContentDescription(view, forceUpdate) {
  let androidView = view.nativeViewProtected;
  if (!androidView || androidView instanceof android.widget.TextView && !view._androidContentDescriptionUpdated) {
    return null;
  }
  if (androidView instanceof androidx.appcompat.widget.Toolbar) {
    const numChildren = androidView.getChildCount();
    for (let i3 = 0;i3 < numChildren; i3 += 1) {
      const childAndroidView = androidView.getChildAt(i3);
      if (childAndroidView instanceof androidx.appcompat.widget.AppCompatTextView) {
        androidView = childAndroidView;
        break;
      }
    }
  }
  const cls = `applyContentDescription(${view})`;
  const titleValue = view["title"];
  const textValue = view["text"];
  if (!forceUpdate && view._androidContentDescriptionUpdated === false && textValue === view["_lastText"] && titleValue === view["_lastTitle"]) {
    return androidView.getContentDescription();
  }
  const contentDescriptionBuilder = new Array;
  if (view.accessibilityRole === AccessibilityRole.Switch) {
    const androidSwitch = new android.widget.Switch(getApplicationContext());
    if (view.accessibilityState === AccessibilityState.Checked) {
      contentDescriptionBuilder.push(androidSwitch.getTextOn());
    } else {
      contentDescriptionBuilder.push(androidSwitch.getTextOff());
    }
  }
  if (view.accessibilityLabel) {
    if (Trace.isEnabled()) {
      Trace.write(`${cls} - have accessibilityLabel`, Trace.categories.Accessibility);
    }
    contentDescriptionBuilder.push(`${view.accessibilityLabel}`);
  }
  if (view.accessibilityValue) {
    if (Trace.isEnabled()) {
      Trace.write(`${cls} - have accessibilityValue`, Trace.categories.Accessibility);
    }
    contentDescriptionBuilder.push(`${view.accessibilityValue}`);
  } else if (textValue) {
    if (textValue !== view.accessibilityLabel) {
      if (Trace.isEnabled()) {
        Trace.write(`${cls} - don't have accessibilityValue - use 'text' value`, Trace.categories.Accessibility);
      }
      contentDescriptionBuilder.push(`${textValue}`);
    }
  } else if (titleValue) {
    if (titleValue !== view.accessibilityLabel) {
      if (Trace.isEnabled()) {
        Trace.write(`${cls} - don't have accessibilityValue - use 'title' value`, Trace.categories.Accessibility);
      }
      contentDescriptionBuilder.push(`${titleValue}`);
    }
  }
  if (view.accessibilityHint) {
    if (Trace.isEnabled()) {
      Trace.write(`${cls} - have accessibilityHint`, Trace.categories.Accessibility);
    }
    contentDescriptionBuilder.push(`${view.accessibilityHint}`);
  }
  const contentDescription = contentDescriptionBuilder.join(". ").trim().replace(/^\.$/, "");
  if (contentDescription) {
    if (Trace.isEnabled()) {
      Trace.write(`${cls} - set to "${contentDescription}"`, Trace.categories.Accessibility);
    }
    androidView.setContentDescription(contentDescription);
  } else {
    if (Trace.isEnabled()) {
      Trace.write(`${cls} - remove value`, Trace.categories.Accessibility);
    }
    androidView.setContentDescription(null);
  }
  view["_lastTitle"] = titleValue;
  view["_lastText"] = textValue;
  view._androidContentDescriptionUpdated = false;
  return contentDescription;
}
function setupAccessibleView(view) {
  updateA11yPropertiesCallback(view);
}

// node_modules/@nativescript/core/ui/frame/frame-stack.js
var frameStack = [];
function topmost() {
  if (frameStack.length > 0) {
    return frameStack[frameStack.length - 1];
  }
  return;
}
function _isFrameStackEmpty() {
  return frameStack.length === 0;
}
function _pushInFrameStack(frame) {
  if (frame._isInFrameStack && frameStack[frameStack.length - 1] === frame) {
    return;
  }
  if (frame._isInFrameStack) {
    const indexOfFrame = frameStack.indexOf(frame);
    frameStack.splice(indexOfFrame, 1);
  }
  frameStack.push(frame);
  frame._isInFrameStack = true;
}
function _popFromFrameStack(frame) {
  if (!frame._isInFrameStack) {
    return;
  }
  const top = topmost();
  if (top !== frame) {
    throw new Error("Cannot pop a Frame which is not at the top of the navigation stack.");
  }
  frameStack.pop();
  frame._isInFrameStack = false;
}
function _removeFromFrameStack(frame) {
  if (!frame._isInFrameStack) {
    return;
  }
  const index = frameStack.indexOf(frame);
  frameStack.splice(index, 1);
  frame._isInFrameStack = false;
}

// node_modules/@nativescript/core/utils/native-helper-for-android.js
function dataDeserialize(nativeData) {
  if (nativeData === null || typeof nativeData !== "object") {
    return nativeData;
  }
  let store;
  switch (nativeData.getClass().getName()) {
    case "java.lang.String": {
      return String(nativeData);
    }
    case "java.lang.Boolean": {
      return String(nativeData) === "true";
    }
    case "java.lang.Float":
    case "java.lang.Integer":
    case "java.lang.Long":
    case "java.lang.Double":
    case "java.lang.Short": {
      return Number(nativeData);
    }
    case "org.json.JSONArray": {
      store = [];
      for (let j2 = 0;j2 < nativeData.length(); j2++) {
        store[j2] = dataDeserialize(nativeData.get(j2));
      }
      break;
    }
    case "org.json.JSONObject": {
      store = {};
      const i3 = nativeData.keys();
      let key;
      while (i3.hasNext()) {
        key = i3.next();
        store[key] = dataDeserialize(nativeData.get(key));
      }
      break;
    }
    case "androidx.collection.SimpleArrayMap": {
      const count = nativeData.size();
      for (let l2 = 0;l2 < count; l2++) {
        const key = nativeData.keyAt(l2);
        store[key] = dataDeserialize(nativeData.get(key));
      }
      break;
    }
    case "androidx.collection.ArrayMap":
    case "android.os.Bundle":
    case "java.util.HashMap":
    case "java.util.Map": {
      store = {};
      const keys = nativeData.keySet().toArray();
      for (let k2 = 0;k2 < keys.length; k2++) {
        const key = keys[k2];
        store[key] = dataDeserialize(nativeData.get(key));
      }
      break;
    }
    default:
      if (typeof nativeData === "object" && nativeData instanceof java.util.List) {
        const array = [];
        const size = nativeData.size();
        for (let i3 = 0, n3 = size;i3 < n3; i3++) {
          array[i3] = dataDeserialize(nativeData.get(i3));
        }
        store = array;
      } else {
        store = null;
      }
      break;
  }
  return store;
}
function dataSerialize(data, wrapPrimitives) {
  let store;
  switch (typeof data) {
    case "string":
    case "boolean": {
      if (wrapPrimitives) {
        if (typeof data === "string") {
          return new java.lang.String(data);
        }
        return new java.lang.Boolean(data);
      }
      return data;
    }
    case "number": {
      const hasDecimals = numberHasDecimals(data);
      if (numberIs64Bit(data)) {
        if (hasDecimals) {
          return java.lang.Double.valueOf(data);
        } else {
          return java.lang.Long.valueOf(data);
        }
      } else {
        if (hasDecimals) {
          return java.lang.Float.valueOf(data);
        } else {
          return java.lang.Integer.valueOf(data);
        }
      }
    }
    case "object": {
      if (!data) {
        return null;
      }
      if (data instanceof Date) {
        return new java.util.Date(data.getTime());
      }
      if (Array.isArray(data)) {
        store = new java.util.ArrayList;
        data.forEach((item) => store.add(dataSerialize(item, wrapPrimitives)));
        return store;
      }
      if (data.native) {
        return data.native;
      }
      store = new java.util.HashMap;
      Object.keys(data).forEach((key) => store.put(key, dataSerialize(data[key], wrapPrimitives)));
      return store;
    }
    default:
      return null;
  }
}
function getApplicationContext2() {
  return getApplication().getApplicationContext();
}
function getCurrentActivity() {
  return androidGetCurrentActivity();
}
function getApplication() {
  return getNativeApp();
}
function getResources() {
  return getApplication().getResources();
}
var packageName;
function getPackageName() {
  if (!packageName) {
    packageName = getApplicationContext2().getPackageName();
  }
  return packageName;
}
var inputMethodManager;
function getInputMethodManager() {
  if (!inputMethodManager) {
    inputMethodManager = getApplicationContext2().getSystemService(android.content.Context.INPUT_METHOD_SERVICE);
  }
  return inputMethodManager;
}
function getWindow() {
  return getCurrentActivity()?.getWindow();
}
function showSoftInput(nativeView) {
  const inputManager = getInputMethodManager();
  if (inputManager && nativeView instanceof android.view.View) {
    inputManager.showSoftInput(nativeView, android.view.inputmethod.InputMethodManager.SHOW_IMPLICIT);
  }
}
function dismissSoftInput(nativeView) {
  const inputManager = getInputMethodManager();
  let windowToken;
  if (nativeView instanceof android.view.View) {
    if (!nativeView.hasFocus()) {
      return;
    }
    windowToken = nativeView.getWindowToken();
  } else if (getCurrentActivity() instanceof androidx.appcompat.app.AppCompatActivity) {
    const modalDialog = (topmost()?._modalParent ?? topmost()?.modal)?._dialogFragment?.getDialog();
    const window2 = (modalDialog ?? getCurrentActivity()).getWindow();
    const decorView = window2.getDecorView();
    if (decorView) {
      windowToken = decorView.getWindowToken();
      decorView.requestFocus();
    } else {
      windowToken = null;
    }
  }
  if (inputManager && windowToken) {
    inputManager.hideSoftInputFromWindow(windowToken, 0);
  }
}
var collections;
(function(collections2) {
  function stringArrayToStringSet(str) {
    const hashSet = new java.util.HashSet;
    if (str !== undefined) {
      for (const element in str) {
        hashSet.add("" + str[element]);
      }
    }
    return hashSet;
  }
  collections2.stringArrayToStringSet = stringArrayToStringSet;
  function stringSetToStringArray(stringSet) {
    const arr = [];
    if (stringSet !== undefined) {
      const it = stringSet.iterator();
      while (it.hasNext()) {
        const element = "" + it.next();
        arr.push(element);
      }
    }
    return arr;
  }
  collections2.stringSetToStringArray = stringSetToStringArray;
})(collections || (collections = {}));
var resources;
(function(resources_1) {
  let attr;
  const attrCache = new Map;
  function getDrawableId(name) {
    return getId(":drawable/" + name);
  }
  resources_1.getDrawableId = getDrawableId;
  function getStringId(name) {
    return getId(":string/" + name);
  }
  resources_1.getStringId = getStringId;
  function getId(name) {
    const resources2 = getResources();
    const packageName2 = getPackageName();
    const uri = packageName2 + name;
    return resources2.getIdentifier(uri, null, null);
  }
  resources_1.getId = getId;
  function getResource(name, type) {
    return getResources().getIdentifier(name, type, getPackageName());
  }
  resources_1.getResource = getResource;
  function getPaletteColor(name, context) {
    if (attrCache.has(name)) {
      return attrCache.get(name);
    }
    let result = 0;
    try {
      if (!attr) {
        attr = java.lang.Class.forName("androidx.appcompat.R$attr");
      }
      let colorID = 0;
      const field = attr.getField(name);
      if (field) {
        colorID = field.getInt(null);
      }
      if (colorID) {
        const typedValue = new android.util.TypedValue;
        context.getTheme().resolveAttribute(colorID, typedValue, true);
        result = typedValue.data;
      }
    } catch (ex) {
      Trace.write("Cannot get pallete color: " + name, Trace.categories.Error, Trace.messageType.error);
    }
    attrCache.set(name, result);
    return result;
  }
  resources_1.getPaletteColor = getPaletteColor;
})(resources || (resources = {}));
var DefaultLightScrim = new Color(230, 255, 255, 255);
var DefaultDarkScrim = new Color(128, 27, 27, 27);
var DefaultStatusBarLight = new Color(0);
var DefaultStatusBarDark = new Color(0);
var systemColors = new WeakMap;
function setEnableEdgeToEdge(activity, existingColors) {
  enableEdgeToEdge(activity, {
    statusBarLightColor: existingColors.statusBarLight,
    statusBarDarkColor: existingColors.statusBarDark,
    navigationBarLightColor: existingColors.navigationBarLight,
    navigationBarDarkColor: existingColors.navigationBarDark,
    handleDarkMode: existingColors?.handler ?? null
  });
}
function setStatusBarColor(options) {
  const statusBarLightColor = options?.lightColor ?? null;
  const statusBarDarkColor = options?.darkColor ?? null;
  const activity = options?.activity ?? getCurrentActivity();
  if (activity) {
    const existingColors = systemColors.get(activity) ?? {
      navigationBarLight: DefaultLightScrim,
      navigationBarDark: DefaultDarkScrim,
      statusBarLight: DefaultStatusBarLight,
      statusBarDark: DefaultStatusBarDark
    };
    existingColors.statusBarLight ?? (existingColors.statusBarLight = statusBarLightColor);
    existingColors.statusBarDark ?? (existingColors.statusBarDark = statusBarDarkColor);
    systemColors.set(getCurrentActivity(), existingColors);
    setEnableEdgeToEdge(activity, existingColors);
  }
}
function setNavigationBarColor(options) {
  const navigationBarLightColor = options?.lightColor ?? null;
  const navigationBarDarkColor = options?.darkColor ?? null;
  const activity = options?.activity ?? getCurrentActivity();
  if (activity) {
    const existingColors = systemColors.get(activity) ?? {
      navigationBarLight: DefaultLightScrim,
      navigationBarDark: DefaultDarkScrim,
      statusBarLight: DefaultStatusBarLight,
      statusBarDark: DefaultStatusBarDark
    };
    existingColors.navigationBarLight ?? (existingColors.navigationBarLight = navigationBarLightColor);
    existingColors.navigationBarDark ?? (existingColors.navigationBarDark = navigationBarDarkColor);
    systemColors.set(getCurrentActivity(), existingColors);
    setEnableEdgeToEdge(activity, existingColors);
  }
}
function setDarkModeHandler(options) {
  const darkModeHandler = options?.handler ?? null;
  const activity = options?.activity ?? getCurrentActivity();
  if (activity) {
    const existingColors = systemColors.get(activity) ?? {
      navigationBarLight: DefaultLightScrim,
      navigationBarDark: DefaultDarkScrim,
      statusBarLight: DefaultStatusBarLight,
      statusBarDark: DefaultStatusBarDark
    };
    existingColors.handler ?? (existingColors.handler = darkModeHandler);
    systemColors.set(getCurrentActivity(), existingColors);
    setEnableEdgeToEdge(activity, existingColors);
  }
}
function enableEdgeToEdge(activity, options) {
  let handleDarkMode;
  let statusBarLight = 0;
  let statusBarDark = 0;
  let navigationBarLight = DefaultLightScrim.android;
  let navigationBarDark = DefaultDarkScrim.android;
  if (options) {
    if (typeof options.handleDarkMode === "function") {
      handleDarkMode = new org.nativescript.widgets.Utils.HandleDarkMode({
        onHandle(bar, resources2) {
          if (bar === 0) {
            return options.handleDarkMode("status", resources2);
          } else {
            return options.handleDarkMode("navigation", resources2);
          }
        }
      });
    }
    if (options.statusBarLightColor instanceof Color) {
      statusBarLight = options.statusBarLightColor.android;
    }
    if (options.statusBarDarkColor instanceof Color) {
      statusBarDark = options.statusBarDarkColor.android;
    }
    if (options.navigationBarLightColor instanceof Color) {
      navigationBarLight = options.navigationBarLightColor.android;
    }
    if (options.navigationBarDarkColor instanceof Color) {
      navigationBarDark = options.navigationBarDarkColor.android;
    }
  }
  if (handleDarkMode) {
    org.nativescript.widgets.Utils.enableEdgeToEdge(activity, java.lang.Integer.valueOf(statusBarLight), java.lang.Integer.valueOf(statusBarDark), java.lang.Integer.valueOf(navigationBarLight), java.lang.Integer.valueOf(navigationBarDark), handleDarkMode);
  } else {
    org.nativescript.widgets.Utils.enableEdgeToEdge(activity, java.lang.Integer.valueOf(statusBarLight), java.lang.Integer.valueOf(statusBarDark), java.lang.Integer.valueOf(navigationBarLight), java.lang.Integer.valueOf(navigationBarDark));
  }
}

// node_modules/@nativescript/core/utils/native-helper.android.js
var android2 = {
  resources,
  collections,
  getApplication,
  getCurrentActivity,
  getApplicationContext: getApplicationContext2,
  getWindow,
  getResources,
  getPackageName,
  getInputMethodManager,
  showSoftInput,
  dismissSoftInput,
  enableEdgeToEdge,
  setStatusBarColor,
  setNavigationBarColor,
  setDarkModeHandler
};
var ad = android2;
var iOSNativeHelper = platformCheck("Utils.iOSNativeHelper");
var ios = platformCheck("Utils.ios");

// node_modules/@nativescript/core/utils/mainthread-helper.android.js
function dispatchToMainThread(func) {
  const runOnMainThread = global.__runOnMainThread;
  if (runOnMainThread) {
    runOnMainThread(() => {
      func();
    });
  } else {
    new android.os.Handler(android.os.Looper.getMainLooper()).post(new java.lang.Runnable({
      run: func
    }));
  }
}
function isMainThread() {
  return android.os.Looper.myLooper() === android.os.Looper.getMainLooper();
}
function dispatchToUIThread(func) {
  const activity = android2.getCurrentActivity();
  if (activity && func) {
    activity.runOnUiThread(new java.lang.Runnable({
      run() {
        func();
      }
    }));
  }
}

// node_modules/@nativescript/core/utils/macrotask-scheduler.js
var scheduled = false;
var macroTaskQueue = [];
function drainMacrotaskQueue() {
  const currentQueue = macroTaskQueue;
  macroTaskQueue = [];
  scheduled = false;
  currentQueue.forEach((task) => {
    try {
      task();
    } catch (err) {
      const msg = err ? err.stack || err : err;
      Trace.write(`Error in macroTask: ${msg}`, Trace.categories.Error, Trace.messageType.error);
    }
  });
}
function queueMacrotask(task) {
  macroTaskQueue.push(task);
  if (!scheduled) {
    scheduled = true;
    dispatchToMainThread(drainMacrotaskQueue);
  }
}

// node_modules/@nativescript/core/utils/constants.android.js
var SDK_VERSION = android.os.Build.VERSION.SDK_INT;
function supportsGlass() {
  return false;
}

// node_modules/@nativescript/core/fps-meter/fps-native.android.js
class FPSCallback {
  constructor(onFrame) {
    this.running = false;
    this.onFrame = onFrame;
    this.nativeFramesSupported = SDK_VERSION >= 24 && this._isNativeFramesSupported();
    if (this.nativeFramesSupported) {
      this.impl = (nanos) => {
        this.handleFrame(nanos);
      };
    } else {
      this.impl = new android.view.Choreographer.FrameCallback({
        doFrame: (nanos) => {
          this.handleFrame(nanos);
        }
      });
    }
  }
  _isNativeFramesSupported() {
    return typeof global.__postFrameCallback === "function" && typeof global.__removeFrameCallback === "function";
  }
  start() {
    if (this.running) {
      return;
    }
    if (this.nativeFramesSupported) {
      global.__postFrameCallback(this.impl);
    } else {
      android.view.Choreographer.getInstance().postFrameCallback(this.impl);
    }
    this.running = true;
  }
  stop() {
    if (!this.running) {
      return;
    }
    if (this.nativeFramesSupported) {
      global.__removeFrameCallback(this.impl);
    } else {
      android.view.Choreographer.getInstance().removeFrameCallback(this.impl);
    }
    this.running = false;
  }
  handleFrame(nanos) {
    if (!this.running) {
      return;
    }
    this.onFrame(nanos / 1e6);
    if (this.nativeFramesSupported) {
      global.__postFrameCallback(this.impl);
    } else {
      android.view.Choreographer.getInstance().postFrameCallback(this.impl);
    }
  }
}

// node_modules/@nativescript/core/animation-frame/animation-native.android.js
function getTimeInFrameBase() {
  return java.lang.System.nanoTime() / 1e6;
}

// node_modules/@nativescript/core/animation-frame/index.js
var animationId = 0;
var currentFrameAnimationCallbacks = {};
var currentFrameScheduled = false;
var nextFrameAnimationCallbacks = {};
var shouldStop = true;
var inAnimationFrame = false;
var fpsCallback;
var lastFrameTime = 0;
function getNewId() {
  return animationId++;
}
function ensureNative() {
  if (fpsCallback) {
    return;
  }
  fpsCallback = new FPSCallback(doFrame);
}
function callAnimationCallbacks(thisFrameCbs, frameTime) {
  inAnimationFrame = true;
  for (const animationId2 in thisFrameCbs) {
    if (thisFrameCbs[animationId2]) {
      try {
        thisFrameCbs[animationId2](frameTime);
      } catch (err) {
        const msg = err ? err.stack || err : err;
        Trace.write(`Error in requestAnimationFrame: ${msg}`, Trace.categories.Error, Trace.messageType.error);
      }
    }
  }
  inAnimationFrame = false;
}
function doCurrentFrame() {
  if (!fpsCallback || !fpsCallback.running) {
    lastFrameTime = getTimeInFrameBase();
  }
  currentFrameScheduled = false;
  const thisFrameCbs = currentFrameAnimationCallbacks;
  currentFrameAnimationCallbacks = {};
  callAnimationCallbacks(thisFrameCbs, lastFrameTime);
}
function doFrame(currentTimeMillis) {
  lastFrameTime = currentTimeMillis;
  shouldStop = true;
  const thisFrameCbs = nextFrameAnimationCallbacks;
  nextFrameAnimationCallbacks = {};
  callAnimationCallbacks(thisFrameCbs, lastFrameTime);
  if (shouldStop) {
    fpsCallback.stop();
  }
}
function ensureCurrentFrameScheduled() {
  if (!currentFrameScheduled) {
    currentFrameScheduled = true;
    queueMacrotask(doCurrentFrame);
  }
}
function requestAnimationFrame2(cb) {
  const animId = getNewId();
  if (!inAnimationFrame) {
    ensureCurrentFrameScheduled();
    currentFrameAnimationCallbacks[animId] = zonedCallback(cb);
    return animId;
  }
  ensureNative();
  nextFrameAnimationCallbacks[animId] = zonedCallback(cb);
  shouldStop = false;
  fpsCallback.start();
  return animId;
}
function cancelAnimationFrame2(id) {
  delete currentFrameAnimationCallbacks[id];
  delete nextFrameAnimationCallbacks[id];
}

// node_modules/@nativescript/core/media-query-list/index.js
var exports_media_query_list = {};
__export(exports_media_query_list, {
  matchMedia: () => matchMedia,
  checkIfMediaQueryMatches: () => checkIfMediaQueryMatches,
  MediaQueryList: () => MediaQueryListImpl
});

// node_modules/@nativescript/core/platform/screen/index.android.js
class MainScreen {
  initMetrics() {
    const nativeApp2 = getNativeApp();
    nativeApp2.getSystemService(android.content.Context.WINDOW_SERVICE).getDefaultDisplay().getRealMetrics(this._metrics);
  }
  get metrics() {
    if (!this._metrics) {
      this._metrics = new android.util.DisplayMetrics;
      this.initMetrics();
    }
    return this._metrics;
  }
  get widthPixels() {
    return this.metrics.widthPixels;
  }
  get heightPixels() {
    return this.metrics.heightPixels;
  }
  get scale() {
    return this.metrics.density;
  }
  get widthDIPs() {
    return this.metrics.widthPixels / this.metrics.density;
  }
  get heightDIPs() {
    return this.metrics.heightPixels / this.metrics.density;
  }
  _updateMetrics() {
    if (!this._metrics) {
      this._metrics = new android.util.DisplayMetrics;
    }
    this.initMetrics();
  }
}

class Screen {
}
Screen.mainScreen = new MainScreen;

// node_modules/@nativescript/core/utils/layout-helper/layout-helper-shared.js
var MODE_SHIFT = 30;
var MODE_MASK = 3 << MODE_SHIFT;
var UNSPECIFIED = 0 << MODE_SHIFT;
var EXACTLY = 1 << MODE_SHIFT;
var AT_MOST = 2 << MODE_SHIFT;

// node_modules/@nativescript/core/utils/layout-helper/layout-helper-common.js
function getMode(mode) {
  switch (mode) {
    case EXACTLY:
      return "Exact";
    case AT_MOST:
      return "AtMost";
    default:
      return "Unspecified";
  }
}
function getMeasureSpecMode(spec) {
  return spec & MODE_MASK;
}
function getMeasureSpecSize(spec) {
  return spec & ~MODE_MASK;
}
function measureSpecToString(measureSpec) {
  const mode = getMeasureSpecMode(measureSpec);
  const size = getMeasureSpecSize(measureSpec);
  let text = "MeasureSpec: ";
  if (mode === UNSPECIFIED) {
    text += "UNSPECIFIED ";
  } else if (mode === EXACTLY) {
    text += "EXACTLY ";
  } else if (mode === AT_MOST) {
    text += "AT_MOST ";
  }
  text += size;
  return text;
}
function round2(value) {
  const res = Math.floor(value + 0.5);
  if (res !== 0) {
    return res;
  } else if (value === 0) {
    return 0;
  } else if (value > 0) {
    return 1;
  }
  return -1;
}

// node_modules/@nativescript/core/utils/layout-helper/index.android.js
var density;
var sdkVersion;
var useOldMeasureSpec = false;
var supportsRtl;
var layout;
(function(layout2) {
  layout2.MODE_SHIFT = 30;
  layout2.MODE_MASK = 3 << layout2.MODE_SHIFT;
  layout2.UNSPECIFIED = 0 << layout2.MODE_SHIFT;
  layout2.EXACTLY = 1 << layout2.MODE_SHIFT;
  layout2.AT_MOST = 2 << layout2.MODE_SHIFT;
  layout2.MEASURED_HEIGHT_STATE_SHIFT = 16;
  layout2.MEASURED_STATE_TOO_SMALL = 16777216;
  layout2.MEASURED_STATE_MASK = 4278190080;
  layout2.MEASURED_SIZE_MASK = 16777215;
  function getMode2(mode) {
    return getMode(mode);
  }
  layout2.getMode = getMode2;
  function getMeasureSpecMode2(spec) {
    return getMeasureSpecMode(spec);
  }
  layout2.getMeasureSpecMode = getMeasureSpecMode2;
  function getMeasureSpecSize2(spec) {
    return getMeasureSpecSize(spec);
  }
  layout2.getMeasureSpecSize = getMeasureSpecSize2;
  function makeMeasureSpec(size, mode) {
    if (sdkVersion === undefined) {
      sdkVersion = android2.getApplicationContext().getApplicationInfo().targetSdkVersion;
      useOldMeasureSpec = sdkVersion <= 17;
    }
    if (useOldMeasureSpec) {
      return size + mode;
    }
    return size & ~layout2.MODE_MASK | mode & layout2.MODE_MASK;
  }
  layout2.makeMeasureSpec = makeMeasureSpec;
  function hasRtlSupport() {
    if (supportsRtl === undefined) {
      const FLAG_SUPPORTS_RTL = android.content.pm.ApplicationInfo.FLAG_SUPPORTS_RTL;
      supportsRtl = (android2.getApplicationContext().getApplicationInfo().flags & FLAG_SUPPORTS_RTL) == FLAG_SUPPORTS_RTL;
    }
    return supportsRtl;
  }
  layout2.hasRtlSupport = hasRtlSupport;
  function getDisplayDensity() {
    if (density === undefined) {
      density = android2.getResources().getDisplayMetrics().density;
    }
    return density;
  }
  layout2.getDisplayDensity = getDisplayDensity;
  function toDevicePixels(value) {
    return value * getDisplayDensity();
  }
  layout2.toDevicePixels = toDevicePixels;
  function toDeviceIndependentPixels(value) {
    return value / getDisplayDensity();
  }
  layout2.toDeviceIndependentPixels = toDeviceIndependentPixels;
  function round3(value) {
    return round2(value);
  }
  layout2.round = round3;
  function measureNativeView(nativeView, width, widthMode, height, heightMode) {
    const view = nativeView;
    view.measure(makeMeasureSpec(width, widthMode), makeMeasureSpec(height, heightMode));
    return {
      width: view.getMeasuredWidth(),
      height: view.getMeasuredHeight()
    };
  }
  layout2.measureNativeView = measureNativeView;
  function measureSpecToString2(measureSpec) {
    return measureSpecToString(measureSpec);
  }
  layout2.measureSpecToString = measureSpecToString2;
})(layout || (layout = {}));

// node_modules/@nativescript/core/ui/core/properties/property-shared.js
var unsetValue = new Object;
function isCssUnsetValue(value) {
  return value === "unset" || value === "revert";
}
function isResetValue(value) {
  return value === unsetValue || value === "initial" || value === "inherit" || isCssUnsetValue(value);
}
function isCssWideKeyword(value) {
  return value === "initial" || value === "inherit" || isCssUnsetValue(value);
}

// node_modules/@nativescript/core/ui/styling/length-shared.js
function equalsCommon(a3, b2) {
  if (a3 == "auto" || isCssWideKeyword(a3)) {
    return b2 == "auto" || isCssWideKeyword(b2);
  }
  if (b2 == "auto" || isCssWideKeyword(b2)) {
    return false;
  }
  if (typeof a3 === "number") {
    if (typeof b2 === "number") {
      return a3 == b2;
    }
    if (!b2) {
      return false;
    }
    return b2.unit == "dip" && a3 == b2.value;
  }
  if (typeof b2 === "number") {
    return a3 ? a3.unit == "dip" && a3.value == b2 : false;
  }
  if (!a3 || !b2) {
    return false;
  }
  return a3.value == b2.value && a3.unit == b2.unit;
}
function convertToStringCommon(length) {
  if (length == "auto" || isCssWideKeyword(length)) {
    return "auto";
  }
  if (typeof length === "number") {
    return length.toString();
  }
  let val = length.value;
  if (length.unit === "%") {
    val *= 100;
  }
  return val + length.unit;
}
function toDevicePixelsCommon(length, auto = Number.NaN, parentAvailableWidth = Number.NaN) {
  if (length == "auto" || isCssWideKeyword(length)) {
    return auto;
  }
  if (typeof length === "number") {
    return layout.round(layout.toDevicePixels(length));
  }
  if (!length) {
    return auto;
  }
  switch (length.unit) {
    case "px":
      return layout.round(length.value);
    case "%":
      return layout.round(parentAvailableWidth * length.value);
    case "dip":
    default:
      return layout.round(layout.toDevicePixels(length.value));
  }
}
var PercentLength;
(function(PercentLength2) {
  function parse2(fromValue) {
    if (fromValue == "auto") {
      return "auto";
    }
    if (typeof fromValue === "string") {
      let stringValue = fromValue.trim();
      const percentIndex = stringValue.indexOf("%");
      if (percentIndex !== -1) {
        let value;
        if (percentIndex !== stringValue.length - 1 || percentIndex === 0) {
          value = Number.NaN;
        } else {
          value = parseFloat(stringValue.substring(0, stringValue.length - 1).trim()) / 100;
        }
        if (isNaN(value) || !isFinite(value)) {
          throw new Error(`Invalid value: ${fromValue}`);
        }
        return { unit: "%", value };
      } else if (stringValue.indexOf("px") !== -1) {
        stringValue = stringValue.replace("px", "").trim();
        const value = parseFloat(stringValue);
        if (isNaN(value) || !isFinite(value)) {
          throw new Error(`Invalid value: ${fromValue}`);
        }
        return { unit: "px", value };
      } else {
        const value = parseFloat(stringValue);
        if (isNaN(value) || !isFinite(value)) {
          throw new Error(`Invalid value: ${fromValue}`);
        }
        return value;
      }
    } else {
      return fromValue;
    }
  }
  PercentLength2.parse = parse2;
  PercentLength2.equals = equalsCommon;
  PercentLength2.toDevicePixels = toDevicePixelsCommon;
  PercentLength2.convertToString = convertToStringCommon;
})(PercentLength || (PercentLength = {}));
var FixedLength;
(function(FixedLength2) {
  function parse2(fromValue) {
    if (typeof fromValue === "string") {
      let stringValue = fromValue.trim();
      if (stringValue.indexOf("px") !== -1) {
        stringValue = stringValue.replace("px", "").trim();
        const value = parseFloat(stringValue);
        if (isNaN(value) || !isFinite(value)) {
          throw new Error(`Invalid value: ${stringValue}`);
        }
        return { unit: "px", value };
      } else {
        const value = parseFloat(stringValue);
        if (isNaN(value) || !isFinite(value)) {
          throw new Error(`Invalid value: ${stringValue}`);
        }
        return value;
      }
    } else {
      return fromValue;
    }
  }
  FixedLength2.parse = parse2;
  FixedLength2.equals = equalsCommon;
  FixedLength2.toDevicePixels = toDevicePixelsCommon;
  FixedLength2.convertToString = convertToStringCommon;
})(FixedLength || (FixedLength = {}));
var Length;
(function(Length2) {
  function parse2(fromValue) {
    if (fromValue == "auto") {
      return "auto";
    }
    return FixedLength.parse(fromValue);
  }
  Length2.parse = parse2;
  Length2.equals = equalsCommon;
  Length2.toDevicePixels = toDevicePixelsCommon;
  Length2.convertToString = convertToStringCommon;
})(Length || (Length = {}));

// node_modules/@nativescript/core/css-mediaquery/index.js
var RE_MEDIA_QUERY = /^(?:(only|not)?\s*([_a-z][_a-z0-9-]*)|(\([^\)]+\)))(?:\s*and\s*(.*))?$/i;
var RE_MQ_EXPRESSION = /^\(\s*([_a-z-][_a-z0-9-]*)\s*(?:\:\s*([^\)]+))?\s*\)$/;
var RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/;
var MediaQueryType;
(function(MediaQueryType2) {
  MediaQueryType2["all"] = "all";
  MediaQueryType2["print"] = "print";
  MediaQueryType2["screen"] = "screen";
})(MediaQueryType || (MediaQueryType = {}));
function matchQuery(mediaQuery, values) {
  const expressions = parseQuery(mediaQuery);
  return expressions.some((query) => {
    const { type, inverse, features } = query;
    const typeMatch = query.type === "all" || values.type === query.type;
    if (typeMatch && inverse || !(typeMatch || inverse)) {
      return false;
    }
    const expressionsMatch = features.every((feature) => {
      const value = values[feature.property];
      if (!value && value !== 0) {
        return false;
      }
      switch (feature.property) {
        case "orientation":
        case "prefers-color-scheme":
          if (typeof value !== "string") {
            return false;
          }
          return value.toLowerCase() === feature.value.toLowerCase();
        default: {
          let numVal;
          if (typeof value !== "number") {
            Trace.write(`Unknown CSS media query feature property: '${feature.property}' on '${query}'`, Trace.categories.MediaQuery, Trace.messageType.warn);
            return false;
          }
          switch (feature.property) {
            case "width":
            case "height":
            case "device-width":
            case "device-height": {
              numVal = Length.toDevicePixels(Length.parse(feature.value), 0);
              break;
            }
            default:
              Trace.write(`Unknown CSS media query feature property: '${feature.property}' on '${query}'`, Trace.categories.MediaQuery, Trace.messageType.warn);
              break;
          }
          switch (feature.modifier) {
            case "min":
              return value >= numVal;
            case "max":
              return value <= numVal;
            default:
              return value === numVal;
          }
          break;
        }
      }
    });
    return expressionsMatch && !inverse || !expressionsMatch && inverse;
  });
}
function parseQuery(mediaQuery) {
  const mediaQueryStrings = mediaQuery.split(",");
  return mediaQueryStrings.map((query) => {
    query = query.trim();
    const captures = query.match(RE_MEDIA_QUERY);
    if (!captures) {
      throw new SyntaxError(`Invalid CSS media query: '${query}'`);
    }
    const modifier = captures[1];
    const type = captures[2];
    const featureString = ((captures[3] || "") + (captures[4] || "")).trim();
    const expression = {
      inverse: !!modifier && modifier.toLowerCase() === "not",
      type: MediaQueryType[type ? type.toLowerCase() : "all"] ?? "all",
      features: []
    };
    if (!featureString) {
      return expression;
    }
    const features = featureString.match(/\([^\)]+\)/g);
    if (!features) {
      throw new SyntaxError(`Invalid CSS media query features: '${featureString}' on '${query}'`);
    }
    for (const feature of features) {
      const captures2 = feature.match(RE_MQ_EXPRESSION);
      if (!captures2) {
        throw new SyntaxError(`Invalid CSS media query feature: '${feature}' on '${query}'`);
      }
      const featureData = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
      expression.features.push({
        modifier: featureData[1],
        property: featureData[2],
        value: captures2[2]
      });
    }
    return expression;
  });
}

// node_modules/@nativescript/core/media-query-list/index.js
var mediaQueryLists = [];
var isMediaInitializationEnabled = false;
function onDeviceChange(args) {
  for (const mql of mediaQueryLists) {
    const matches = checkIfMediaQueryMatches(mql.media);
    if (mql.matches !== matches) {
      mql._matches = matches;
      mql.notify({
        eventName: MediaQueryListImpl.changeEvent,
        object: mql,
        matches: mql.matches,
        media: mql.media
      });
    }
  }
}
function checkIfMediaQueryMatches(mediaQueryString) {
  const { widthPixels, heightPixels } = Screen.mainScreen;
  let matches;
  try {
    const appProperties = getApplicationProperties();
    matches = matchQuery(mediaQueryString, {
      type: MediaQueryType.screen,
      width: widthPixels,
      height: heightPixels,
      "device-width": widthPixels,
      "device-height": heightPixels,
      orientation: appProperties.orientation,
      "prefers-color-scheme": appProperties.systemAppearance
    });
  } catch (err) {
    matches = false;
    Trace.write(err, Trace.categories.MediaQuery, Trace.messageType.error);
  }
  return matches;
}
function matchMedia(mediaQueryString) {
  isMediaInitializationEnabled = true;
  const mediaQueryList = new MediaQueryListImpl;
  isMediaInitializationEnabled = false;
  mediaQueryList._media = mediaQueryString;
  mediaQueryList._matches = checkIfMediaQueryMatches(mediaQueryString);
  return mediaQueryList;
}

class MediaQueryListImpl extends Observable {
  constructor() {
    super();
    if (!isMediaInitializationEnabled) {
      throw new TypeError("Illegal constructor");
    }
    Object.defineProperties(this, {
      _media: {
        writable: true
      },
      _matches: {
        writable: true
      },
      _onChange: {
        writable: true,
        value: null
      },
      mediaQueryChangeListeners: {
        value: new Map
      },
      _throwInvocationError: {
        value: null
      }
    });
  }
  get media() {
    this._throwInvocationError?.();
    return this._media;
  }
  get matches() {
    this._throwInvocationError?.();
    return this._matches;
  }
  addEventListener(eventName, callback, thisArg, once) {
    this._throwInvocationError?.();
    const hasChangeListeners = this.hasListeners(MediaQueryListImpl.changeEvent);
    super.addEventListener(eventName, callback, thisArg, once);
    if (eventName === MediaQueryListImpl.changeEvent && !hasChangeListeners) {
      mediaQueryLists.push(this);
      if (mediaQueryLists.length === 1) {
        toggleApplicationEventListeners(true, onDeviceChange);
      }
    }
  }
  removeEventListener(eventName, callback, thisArg) {
    this._throwInvocationError?.();
    super.removeEventListener(eventName, callback, thisArg);
    if (eventName === MediaQueryListImpl.changeEvent) {
      const hasChangeListeners = this.hasListeners(MediaQueryListImpl.changeEvent);
      if (!hasChangeListeners) {
        const index = mediaQueryLists.indexOf(this);
        if (index >= 0) {
          mediaQueryLists.splice(index, 1);
          if (!mediaQueryLists.length) {
            toggleApplicationEventListeners(false, onDeviceChange);
          }
        }
      }
    }
  }
  addListener(callback) {
    this._throwInvocationError?.();
    const wrapperCallback = (data) => {
      callback.call(this, {
        matches: this.matches,
        media: this.media
      });
    };
    this.addEventListener(MediaQueryListImpl.changeEvent, wrapperCallback);
    this.mediaQueryChangeListeners.set(callback, wrapperCallback);
  }
  removeListener(callback) {
    this._throwInvocationError?.();
    if (this.mediaQueryChangeListeners.has(callback)) {
      this.removeEventListener(MediaQueryListImpl.changeEvent, this.mediaQueryChangeListeners.get(callback));
      this.mediaQueryChangeListeners.delete(callback);
    }
  }
  get onchange() {
    this._throwInvocationError?.();
    return this._onChange;
  }
  set onchange(callback) {
    this._throwInvocationError?.();
    if (this._onChange) {
      this.removeListener(this._onChange);
    }
    if (callback) {
      this.addListener(callback);
    }
    this._onChange = callback;
  }
  _throwInvocationError() {
    throw new TypeError("Illegal invocation");
  }
}
MediaQueryListImpl.changeEvent = "change";

// node_modules/@nativescript/core/text/index.android.js
var exports_index_android2 = {};
__export(exports_index_android2, {
  encoding: () => encoding,
  TextEncoder: () => TextEncoder2,
  TextDecoder: () => TextDecoder2
});

// node_modules/@nativescript/core/text/text-common.js
var _a;
var _b;
var Object_prototype_toString = {}.toString;
var ArrayBufferString = Object_prototype_toString.call(ArrayBuffer.prototype);
function decoderReplacer(encoded) {
  let codePoint = encoded.charCodeAt(0) << 24;
  const leadingOnes = Math.clz32(~codePoint) | 0;
  let endPos = 0;
  const stringLen = encoded.length | 0;
  let result = "";
  if (leadingOnes < 5 && stringLen >= leadingOnes) {
    codePoint = codePoint << leadingOnes >>> 24 + leadingOnes;
    for (endPos = 1;endPos < leadingOnes; endPos = endPos + 1 | 0) {
      codePoint = codePoint << 6 | encoded.charCodeAt(endPos) & 63;
    }
    if (codePoint <= 65535) {
      result += String.fromCharCode(codePoint);
    } else if (codePoint <= 1114111) {
      codePoint = codePoint - 65536 | 0;
      result += String.fromCharCode((codePoint >> 10) + 55296 | 0, (codePoint & 1023) + 56320 | 0);
    } else {
      endPos = 0;
    }
  }
  for (;endPos < stringLen; endPos = endPos + 1 | 0) {
    result += "";
  }
  return result;
}
function encoderReplacer(nonAsciiChars) {
  let point = nonAsciiChars.charCodeAt(0) | 0;
  if (point >= 55296 && point <= 56319) {
    const nextcode = nonAsciiChars.charCodeAt(1) | 0;
    if (nextcode !== nextcode) {
      return String.fromCharCode(239, 191, 189);
    }
    if (nextcode >= 56320 && nextcode <= 57343) {
      point = (point - 55296 << 10) + nextcode - 56320 + 65536 | 0;
      if (point > 65535) {
        return String.fromCharCode(30 << 3 | point >>> 18, 2 << 6 | point >>> 12 & 63, 2 << 6 | point >>> 6 & 63, 2 << 6 | point & 63);
      }
    } else {
      return String.fromCharCode(239, 191, 189);
    }
  }
  if (point <= 127) {
    return nonAsciiChars;
  } else if (point <= 2047) {
    return String.fromCharCode(6 << 5 | point >>> 6, 2 << 6 | point & 63);
  } else {
    return String.fromCharCode(14 << 4 | point >>> 12, 2 << 6 | point >>> 6 & 63, 2 << 6 | point & 63);
  }
}

class TextDecoder2 {
  constructor() {
    this[_a] = "TextDecoder";
  }
  get encoding() {
    return "utf-8";
  }
  decode(input) {
    const buffer = ArrayBuffer.isView(input) ? input.buffer : input;
    if (Object_prototype_toString.call(buffer) !== ArrayBufferString) {
      throw Error("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
    }
    const inputAs8 = new Uint8Array(buffer);
    let resultingString = "";
    for (let index = 0, len = inputAs8.length | 0;index < len; index = index + 32768 | 0) {
      resultingString += String.fromCharCode.apply(0, inputAs8.slice(index, index + 32768 | 0));
    }
    return resultingString.replace(/[\xc0-\xff][\x80-\xbf]*/g, decoderReplacer);
  }
  toString() {
    return "[object TextDecoder]";
  }
}
_a = Symbol.toStringTag;

class TextEncoder2 {
  constructor() {
    this[_b] = "TextEncoder";
  }
  get encoding() {
    return "utf-8";
  }
  encode(input = "") {
    const encodedString = input === undefined ? "" : ("" + input).replace(/[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, encoderReplacer);
    const len = encodedString.length | 0, result = new Uint8Array(len);
    for (let i3 = 0;i3 < len; i3 = i3 + 1 | 0) {
      result[i3] = encodedString.charCodeAt(i3);
    }
    return result;
  }
  toString() {
    return "[object TextEncoder]";
  }
}
_b = Symbol.toStringTag;

// node_modules/@nativescript/core/text/index.android.js
var encoding;
(function(encoding2) {
  encoding2.ISO_8859_1 = "ISO-8859-1";
  encoding2.US_ASCII = "US-ASCII";
  encoding2.UTF_16 = "UTF-16";
  encoding2.UTF_16BE = "UTF-16BE";
  encoding2.UTF_16LE = "UTF-16LE";
  encoding2.UTF_8 = "UTF-8";
})(encoding || (encoding = {}));

// node_modules/@nativescript/core/xhr/index.js
var exports_xhr = {};
__export(exports_xhr, {
  XMLHttpRequest: () => XMLHttpRequest2,
  FormData: () => FormData2,
  FileReader: () => FileReader2,
  File: () => File2,
  Blob: () => Blob2
});

// node_modules/@nativescript/core/utils/utils-shared.js
function getFileExtension(path) {
  if (!path) {
    return "";
  }
  const index = path.lastIndexOf(".");
  return index !== -1 ? path.substring(index + 1) : "";
}

// node_modules/@nativescript/core/file-system/file-system-access.android.js
function getOrSetHelper(path) {
  return org.nativescript.widgets.FileHelper.fromString(getNativeApp().getApplicationContext(), path);
}
function isContentUri(path) {
  if (typeof path === "string" && path.startsWith("content:")) {
    return true;
  }
  return false;
}

class FileSystemAccess {
  constructor() {
    this._pathSeparator = "/";
    this.copy = this.copySync.bind(this);
    this.readBuffer = this.readBufferSync.bind(this);
    this.read = this.readSync.bind(this);
    this.appendBuffer = this.appendBufferSync.bind(this);
    this.append = this.appendSync.bind(this);
    this.writeBuffer = this.writeBufferSync.bind(this);
    this.write = this.writeSync.bind(this);
    this.readText = this.readTextSync.bind(this);
    this.appendText = this.appendTextSync.bind(this);
    this.writeText = this.writeTextSync.bind(this);
  }
  getLastModified(path) {
    const javaFile = new java.io.File(path);
    return new Date(javaFile.lastModified());
  }
  getFileSize(path) {
    const javaFile = new java.io.File(path);
    return javaFile.length();
  }
  getParent(path, onError) {
    try {
      const javaFile = new java.io.File(path);
      const parent = javaFile.getParentFile();
      return { path: parent.getAbsolutePath(), name: parent.getName() };
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
      return;
    }
  }
  getFile(path, onError) {
    return this.ensureFile(new java.io.File(path), false, onError);
  }
  getFolder(path, onError) {
    const javaFile = new java.io.File(path);
    const dirInfo = this.ensureFile(javaFile, true, onError);
    if (!dirInfo) {
      return;
    }
    return { path: dirInfo.path, name: dirInfo.name };
  }
  eachEntity(path, onEntity, onError) {
    if (!onEntity) {
      return;
    }
    this.enumEntities(path, onEntity, onError);
  }
  getEntities(path, onError) {
    const fileInfos = new Array;
    const onEntity = function(entity) {
      fileInfos.push(entity);
      return true;
    };
    let errorOccurred;
    const localError = function(error) {
      if (onError) {
        onError(error);
      }
      errorOccurred = true;
    };
    this.enumEntities(path, onEntity, localError);
    if (!errorOccurred) {
      return fileInfos;
    }
    return null;
  }
  fileExists(path) {
    const file = new java.io.File(path);
    return file.exists();
  }
  folderExists(path) {
    const file = new java.io.File(path);
    return file.exists() && file.isDirectory();
  }
  deleteFile(path, onError) {
    try {
      const javaFile = new java.io.File(path);
      if (!javaFile.isFile()) {
        if (onError) {
          onError({
            message: "The specified parameter is not a File entity."
          });
        }
        return;
      }
      if (!javaFile.delete()) {
        if (onError) {
          onError({ message: "File deletion failed" });
        }
      }
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  deleteFolder(path, onError) {
    try {
      const javaFile = new java.io.File(path);
      if (!javaFile.getCanonicalFile().isDirectory()) {
        if (onError) {
          onError({
            message: "The specified parameter is not a Folder entity."
          });
        }
        return;
      }
      this.deleteFolderContent(javaFile);
      if (!javaFile.delete()) {
        if (onError) {
          onError({ message: "Folder deletion failed." });
        }
      }
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  emptyFolder(path, onError) {
    try {
      const javaFile = new java.io.File(path);
      if (!javaFile.getCanonicalFile().isDirectory()) {
        if (onError) {
          onError({
            message: "The specified parameter is not a Folder entity."
          });
        }
        return;
      }
      this.deleteFolderContent(javaFile);
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  rename(path, newPath, onError) {
    const javaFile = new java.io.File(path);
    if (!javaFile.exists()) {
      if (onError) {
        onError(new Error("The file to rename does not exist"));
      }
      return;
    }
    const newFile = new java.io.File(newPath);
    if (newFile.exists()) {
      if (onError) {
        onError(new Error("A file with the same name already exists."));
      }
      return;
    }
    if (!javaFile.renameTo(newFile)) {
      if (onError) {
        onError(new Error("Failed to rename file '" + path + "' to '" + newPath + "'"));
      }
    }
  }
  getDocumentsFolderPath() {
    const dir = getNativeApp().getApplicationContext().getFilesDir();
    return dir.getAbsolutePath();
  }
  getExternalDocumentsFolderPath() {
    const dirs = getNativeApp().getApplicationContext().getExternalFilesDirs(null);
    let dir;
    if (dirs && dirs.length > 1) {
      dir = dirs[dirs.length - 1];
    }
    if (!dir) {
      dir = getNativeApp().getApplicationContext().getExternalFilesDir(null);
    }
    return dir.getAbsolutePath();
  }
  getLogicalRootPath() {
    const dir = getNativeApp().getApplicationContext().getFilesDir();
    return dir.getCanonicalPath();
  }
  getTempFolderPath() {
    const dir = getNativeApp().getApplicationContext().getCacheDir();
    return dir.getAbsolutePath();
  }
  getCurrentAppPath() {
    return this.getLogicalRootPath() + "/app";
  }
  copySync(src, dest, onError) {
    try {
      return org.nativescript.widgets.Async.File.copySync(src, dest, getNativeApp().getApplicationContext());
    } catch (error) {
      if (onError) {
        onError(error);
      }
    }
    return false;
  }
  copyAsync(src, dest) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.copy(src, dest, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: (result) => {
            resolve(result);
          },
          onError: (err) => {
            reject(err);
          }
        }), getNativeApp().getApplicationContext());
      } catch (ex) {
        reject(ex);
      }
    });
  }
  readBufferAsync(path) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.readBuffer(path, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: (result) => {
            resolve(ArrayBuffer.from(result));
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  readBufferSync(path, onError) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileInputStream(javaFile);
      const channel = stream.getChannel();
      const buffer = new ArrayBuffer(javaFile.length());
      channel.read(buffer);
      return buffer;
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  readAsync(path) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.read(path, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: (result) => {
            resolve(result);
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  readSync(path, onError) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileInputStream(javaFile);
      const bytes = Array.create("byte", javaFile.length());
      const dataInputStream = new java.io.DataInputStream(stream);
      dataInputStream.readFully(bytes);
      return bytes;
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  static getBuffer(buffer) {
    if (buffer instanceof ArrayBuffer) {
      return buffer.nativeObject || buffer;
    } else {
      return buffer?.buffer?.nativeObject || buffer;
    }
  }
  appendBufferAsync(path, buffer) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.appendBuffer(path, FileSystemAccess.getBuffer(buffer), new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: () => {
            resolve();
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  appendBufferSync(path, buffer, onError) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileOutputStream(javaFile);
      const channel = stream.getChannel();
      channel.write(FileSystemAccess.getBuffer(buffer));
      stream.close();
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  appendAsync(path, bytes) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.append(path, bytes, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: () => {
            resolve();
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  appendSync(path, bytes, onError) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileOutputStream(javaFile, true);
      stream.write(bytes, 0, bytes.length);
      stream.close();
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  writeBufferAsync(path, buffer) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.writeBuffer(path, FileSystemAccess.getBuffer(buffer), new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: () => {
            resolve();
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  writeBufferSync(path, buffer, onError) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileOutputStream(javaFile);
      const channel = stream.getChannel();
      channel.write(FileSystemAccess.getBuffer(buffer));
      stream.close();
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  writeAsync(path, bytes) {
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.write(path, bytes, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: () => {
            resolve();
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  writeSync(path, bytes, onError) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileOutputStream(javaFile);
      stream.write(bytes, 0, bytes.length);
      stream.close();
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  readTextAsync(path, encoding2) {
    let actualEncoding = encoding2;
    if (!actualEncoding) {
      actualEncoding = encoding.UTF_8;
    }
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.readText(path, actualEncoding, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: (result) => {
            if (actualEncoding === encoding.UTF_8) {
              result = FileSystemAccess._removeUtf8Bom(result);
            }
            resolve(result);
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  readTextSync(path, onError, encoding2) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileInputStream(javaFile);
      let actualEncoding = encoding2;
      if (!actualEncoding) {
        actualEncoding = encoding.UTF_8;
      }
      const reader = new java.io.InputStreamReader(stream, actualEncoding);
      const bufferedReader = new java.io.BufferedReader(reader);
      let line = undefined;
      let result = "";
      while (line !== null) {
        line = bufferedReader.readLine();
        if (line === null) {
          break;
        }
        if (result.length > 0) {
          result += `
`;
        }
        result += line;
      }
      if (actualEncoding === encoding.UTF_8) {
        result = FileSystemAccess._removeUtf8Bom(result);
      }
      bufferedReader.close();
      return result;
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  static _removeUtf8Bom(s3) {
    if (s3.charCodeAt(0) === 65279) {
      s3 = s3.slice(1);
    }
    return s3;
  }
  appendTextAsync(path, content, encoding2) {
    let actualEncoding = encoding2;
    if (!actualEncoding) {
      actualEncoding = encoding.UTF_8;
    }
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.appendText(path, content, actualEncoding, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: () => {
            resolve();
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  appendTextSync(path, content, onError, encoding2) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileOutputStream(javaFile, true);
      let actualEncoding = encoding2;
      if (!actualEncoding) {
        actualEncoding = encoding.UTF_8;
      }
      const writer = new java.io.OutputStreamWriter(stream, actualEncoding);
      writer.write(content);
      writer.close();
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  writeTextAsync(path, content, encoding2) {
    let actualEncoding = encoding2;
    if (!actualEncoding) {
      actualEncoding = encoding.UTF_8;
    }
    return new Promise((resolve, reject) => {
      try {
        org.nativescript.widgets.Async.File.writeText(path, content, actualEncoding, new org.nativescript.widgets.Async.CompleteCallback({
          onComplete: () => {
            resolve();
          },
          onError: (err) => {
            reject(err);
          }
        }), null);
      } catch (ex) {
        reject(ex);
      }
    });
  }
  writeTextSync(path, content, onError, encoding2) {
    try {
      const javaFile = new java.io.File(path);
      const stream = new java.io.FileOutputStream(javaFile);
      let actualEncoding = encoding2;
      if (!actualEncoding) {
        actualEncoding = encoding.UTF_8;
      }
      const writer = new java.io.OutputStreamWriter(stream, actualEncoding);
      writer.write(content);
      writer.close();
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  deleteFolderContent(file) {
    const filesList = file.listFiles();
    if (filesList.length === 0) {
      return true;
    }
    let childFile;
    let success = false;
    for (let i3 = 0;i3 < filesList.length; i3++) {
      childFile = filesList[i3];
      if (childFile.getCanonicalFile().isDirectory()) {
        success = this.deleteFolderContent(childFile);
        if (!success) {
          break;
        }
      }
      success = childFile.delete();
    }
    return success;
  }
  ensureFile(javaFile, isFolder, onError) {
    try {
      if (!javaFile.exists()) {
        let created;
        if (isFolder) {
          created = javaFile.mkdirs();
        } else {
          javaFile.getParentFile().mkdirs();
          created = javaFile.createNewFile();
        }
        if (!created) {
          if (onError) {
            onError("Failed to create new java File for path " + javaFile.getAbsolutePath());
          }
          return;
        } else {
          javaFile.setReadable(true);
          javaFile.setWritable(true);
        }
      }
      const path = javaFile.getAbsolutePath();
      return {
        path,
        name: javaFile.getName(),
        extension: this.getFileExtension(path)
      };
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
      return;
    }
  }
  getFileExtension(path) {
    return getFileExtension(path);
  }
  enumEntities(path, callback, onError) {
    try {
      let javaFile = new java.io.File(path);
      if (!javaFile.getCanonicalFile().isDirectory()) {
        if (onError) {
          onError("There is no folder existing at path " + path);
        }
        return;
      }
      const filesList = javaFile.listFiles();
      const length = filesList.length;
      let info;
      let retVal;
      for (let i3 = 0;i3 < length; i3++) {
        javaFile = filesList[i3];
        info = {
          path: javaFile.getAbsolutePath(),
          name: javaFile.getName()
        };
        if (javaFile.isFile()) {
          info.extension = this.getFileExtension(info.path);
        }
        retVal = callback(info);
        if (retVal === false) {
          break;
        }
      }
    } catch (exception) {
      if (onError) {
        onError(exception);
      }
    }
  }
  getPathSeparator() {
    return this._pathSeparator;
  }
  normalizePath(path) {
    if (SDK_VERSION >= 26) {
      return java.nio.file.Paths.get(path, [""]).normalize().toString();
    } else {
      const file = new java.io.File(path);
      return file.getAbsolutePath();
    }
  }
  joinPath(left, right) {
    const file1 = new java.io.File(left);
    const file2 = new java.io.File(file1, right);
    return file2.getPath();
  }
  joinPaths(paths) {
    if (!paths || paths.length === 0) {
      return "";
    }
    if (paths.length === 1) {
      return paths[0];
    }
    let result = paths[0];
    for (let i3 = 1;i3 < paths.length; i3++) {
      result = this.joinPath(result, paths[i3]);
    }
    return result;
  }
}

class FileSystemAccess29 extends FileSystemAccess {
  constructor() {
    super(...arguments);
    this.__skip = true;
    this.appendBuffer = this.appendBufferSync.bind(this);
    this.append = this.appendSync.bind(this);
    this.appendText = this.appendTextSync.bind(this);
    this.readText = this.readTextSync.bind(this);
    this.readBuffer = this.readBufferSync.bind(this);
    this.read = this.readSync.bind(this);
    this.writeText = this.writeTextSync.bind(this);
    this.writeBuffer = this.writeBufferSync.bind(this);
    this.write = this.writeSync.bind(this);
  }
  getLastModified(path) {
    if (isContentUri(path)) {
      return new Date(getOrSetHelper(path).getLastModified() * 1000);
    }
    return super.getLastModified(path);
  }
  getFileSize(path) {
    if (isContentUri(path)) {
      return getOrSetHelper(path).getSize();
    }
    return super.getFileSize(path);
  }
  getParent(path, onError) {
    if (isContentUri(path)) {
      return null;
    }
    return super.getParent(path, onError);
  }
  getFile(path, onError) {
    if (isContentUri(path)) {
      try {
        const file = getOrSetHelper(path);
        return {
          path,
          name: file.getName(),
          extension: file.getExtension()
        };
      } catch (e3) {
        if (typeof onError === "function") {
          onError(e3);
        }
        return;
      }
    }
    return super.getFile(path, onError);
  }
  getFolder(path, onError) {
    if (isContentUri(path)) {
      return null;
    }
    return super.getFolder(path, onError);
  }
  getEntities(path, onError) {
    if (isContentUri(path)) {
      return null;
    }
    return super.getEntities(path, onError);
  }
  eachEntity(path, onEntity, onError) {
    if (isContentUri(path)) {
      return null;
    }
    super.eachEntity(path, onEntity);
  }
  fileExists(path) {
    if (isContentUri(path)) {
      return org.nativescript.widgets.FileHelper.exists(getNativeApp().getApplicationContext(), path);
    }
    return super.fileExists(path);
  }
  folderExists(path) {
    if (isContentUri(path)) {
      return null;
    }
    return super.folderExists(path);
  }
  deleteFile(path, onError) {
    if (isContentUri(path)) {
      try {
        getOrSetHelper(path).delete(getNativeApp().getApplicationContext());
      } catch (e3) {
        onError?.(e3);
      }
    } else {
      super.deleteFile(path, onError);
    }
  }
  deleteFolder(path, onError) {
    if (!isContentUri(path)) {
      super.deleteFolder(path, onError);
    }
  }
  emptyFolder(path, onError) {
    if (!isContentUri(path)) {
      super.emptyFolder(path, onError);
    }
  }
  rename(path, newPath, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).renameSync(getNativeApp().getApplicationContext(), newPath, callback);
    } else {
      super.rename(path, newPath, onError);
    }
  }
  renameAsync(path, newPath) {
    return new Promise((resolve, reject) => {
      getOrSetHelper(path).renameSync(getNativeApp().getApplicationContext(), newPath, new org.nativescript.widgets.FileHelper.Callback({
        onSuccess(result) {
          resolve();
        },
        onError(error) {
          reject(error);
        }
      }));
    });
  }
  getDocumentsFolderPath() {
    return super.getDocumentsFolderPath();
  }
  getTempFolderPath() {
    return super.getTempFolderPath();
  }
  getLogicalRootPath() {
    return super.getLogicalRootPath();
  }
  getCurrentAppPath() {
    return super.getCurrentAppPath();
  }
  appendBufferAsync(path, content) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).appendBuffer(getNativeApp().getApplicationContext(), FileSystemAccess.getBuffer(content), new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve();
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.appendAsync(path, content);
  }
  appendBufferSync(path, content, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).appendSync(getNativeApp().getApplicationContext(), FileSystemAccess.getBuffer(content), callback);
    } else {
      super.appendSync(path, content, onError);
    }
  }
  appendAsync(path, content) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).append(getNativeApp().getApplicationContext(), content, new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve();
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.appendAsync(path, content);
  }
  appendSync(path, content, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).appendSync(getNativeApp().getApplicationContext(), content, callback);
    } else {
      super.appendSync(path, content, onError);
    }
  }
  appendTextAsync(path, content, encoding2) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).appendText(getNativeApp().getApplicationContext(), content, encoding2 ?? null, new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve();
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.appendTextAsync(path, content, encoding2);
  }
  appendTextSync(path, content, onError, encoding2) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).appendTextSync(getNativeApp().getApplicationContext(), content, encoding2 ?? null, callback);
    } else {
      super.appendTextSync(path, content, onError);
    }
  }
  readTextAsync(path, encoding2) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).readText(getNativeApp().getApplicationContext(), encoding2 ?? null, new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve(result);
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.readTextAsync(path, encoding2);
  }
  readTextSync(path, onError, encoding2) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      return getOrSetHelper(path).readTextSync(getNativeApp().getApplicationContext(), encoding2 ?? null, callback);
    } else {
      return super.readTextSync(path, onError, encoding2);
    }
  }
  readBufferAsync(path) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).readBuffer(getNativeApp().getApplicationContext(), new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve(result);
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.readBufferAsync(path);
  }
  readBufferSync(path, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      const ret = getOrSetHelper(path).readBufferSync(getNativeApp().getApplicationContext(), callback);
      if (ret) {
        return null;
      }
      return ArrayBuffer.from(ret);
    }
    return super.readBufferSync(path, onError);
  }
  readAsync(path) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).read(getNativeApp().getApplicationContext(), new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve(result);
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.readAsync(path);
  }
  readSync(path, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      return getOrSetHelper(path).readSync(getNativeApp().getApplicationContext(), callback);
    }
    return super.readSync(path, onError);
  }
  writeTextAsync(path, content, encoding2) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).writeText(getNativeApp().getApplicationContext(), content, encoding2 ?? null, new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve();
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.writeTextAsync(path, content, encoding2);
  }
  writeTextSync(path, content, onError, encoding2) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).writeTextSync(getNativeApp().getApplicationContext(), content, encoding2 ?? null, callback);
    } else {
      super.writeTextSync(path, content, onError);
    }
  }
  writeBufferAsync(path, content) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).writeBuffer(getNativeApp().getApplicationContext(), FileSystemAccess.getBuffer(content), new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve();
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.writeAsync(path, content);
  }
  writeBufferSync(path, content, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).writeSync(getNativeApp().getApplicationContext(), FileSystemAccess.getBuffer(content), callback);
    } else {
      super.writeSync(path, content, onError);
    }
  }
  writeAsync(path, content) {
    if (isContentUri(path)) {
      return new Promise((resolve, reject) => {
        getOrSetHelper(path).write(getNativeApp().getApplicationContext(), content, new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {
            resolve();
          },
          onError(error) {
            reject(error);
          }
        }));
      });
    }
    return super.writeAsync(path, content);
  }
  writeSync(path, content, onError) {
    if (isContentUri(path)) {
      let callback = null;
      if (typeof onError === "function") {
        callback = new org.nativescript.widgets.FileHelper.Callback({
          onSuccess(result) {},
          onError(error) {
            onError(error);
          }
        });
      }
      getOrSetHelper(path).writeSync(getNativeApp().getApplicationContext(), content, callback);
    } else {
      super.writeSync(path, content, onError);
    }
  }
  getFileExtension(path) {
    if (isContentUri(path)) {
      return getOrSetHelper(path).getExtension();
    }
    return super.getFileExtension(path);
  }
  getPathSeparator() {
    return super.getPathSeparator();
  }
  normalizePath(path) {
    return super.normalizePath(path);
  }
  joinPath(left, right) {
    return super.joinPath(left, right);
  }
  joinPaths(paths) {
    return super.joinPaths(paths);
  }
}

// node_modules/@nativescript/core/file-system/index.js
var fileAccess;
function getFileAccess() {
  if (!fileAccess) {
    if (__ANDROID__ && SDK_VERSION >= 29) {
      fileAccess = new FileSystemAccess29;
    } else {
      fileAccess = new FileSystemAccess;
    }
  }
  return fileAccess;
}
function createFile(info) {
  const file = new File;
  file._path = info.path;
  file._name = info.name;
  file._extension = info.extension;
  return file;
}
function createFolder(info) {
  const documents = knownFolders.documents();
  if (info.path === documents.path) {
    return documents;
  }
  const temp = knownFolders.temp();
  if (info.path === temp.path) {
    return temp;
  }
  const folder = new Folder;
  folder._path = info.path;
  folder._name = info.name;
  return folder;
}

class FileSystemEntity {
  get parent() {
    const onError = function(error) {
      throw error;
    };
    const folderInfo = getFileAccess().getParent(this.path, onError);
    if (!folderInfo) {
      return;
    }
    return createFolder(folderInfo);
  }
  remove() {
    return new Promise((resolve, reject) => {
      let hasError = false;
      const localError = function(error) {
        hasError = true;
        reject(error);
      };
      this.removeSync(localError);
      if (!hasError) {
        resolve(true);
      }
    });
  }
  removeSync(onError) {
    if (this._isKnown) {
      if (onError) {
        onError({ message: "Cannot delete known folder." });
      }
      return;
    }
    const fileAccess2 = getFileAccess();
    if (this instanceof File) {
      fileAccess2.deleteFile(this.path, onError);
    } else if (this instanceof Folder) {
      fileAccess2.deleteFolder(this.path, onError);
    }
  }
  rename(newName) {
    return new Promise((resolve, reject) => {
      let hasError = false;
      const localError = function(error) {
        hasError = true;
        reject(error);
      };
      this.renameSync(newName, localError);
      if (!hasError) {
        resolve(true);
      }
    });
  }
  renameSync(newName, onError) {
    if (this._isKnown) {
      if (onError) {
        onError(new Error("Cannot rename known folder."));
      }
      return;
    }
    const localError = function(error) {
      if (onError) {
        onError(error);
      }
      return null;
    };
    const fileAccess2 = getFileAccess();
    if (fileAccess2.__skip) {
      fileAccess2.rename(this.path, newName, localError);
      const fileInfo = getFileAccess().getFile(this.path, null);
      if (fileInfo) {
        this._name = fileInfo.name;
        this._extension = fileInfo.extension;
      }
      return;
    }
    const parentFolder = this.parent;
    if (!parentFolder) {
      if (onError) {
        onError(new Error("No parent folder."));
      }
      return;
    }
    const path = parentFolder.path;
    const newPath = fileAccess2.joinPath(path, newName);
    fileAccess2.rename(this.path, newPath, localError);
    this._path = newPath;
    this._name = newName;
    if (this instanceof File) {
      this._extension = fileAccess2.getFileExtension(newPath);
    }
  }
  get name() {
    return this._name;
  }
  get path() {
    return this._path;
  }
  get lastModified() {
    return getFileAccess().getLastModified(this.path);
  }
}
var AndroidDirectory;
(function(AndroidDirectory2) {
  AndroidDirectory2["ALARMS"] = "alarms";
  AndroidDirectory2["AUDIOBOOKS"] = "audiobooks";
  AndroidDirectory2["DCIM"] = "dcim";
  AndroidDirectory2["DOCUMENTS"] = "documents";
  AndroidDirectory2["DOWNLOADS"] = "downloads";
  AndroidDirectory2["MOVIES"] = "movies";
  AndroidDirectory2["MUSIC"] = "music";
  AndroidDirectory2["NOTIFICATIONS"] = "notifications";
  AndroidDirectory2["PICTURES"] = "pictures";
  AndroidDirectory2["PODCASTS"] = "podcasts";
  AndroidDirectory2["RINGTONES"] = "ringtones";
  AndroidDirectory2["SCREENSHOTS"] = "screenshots";
})(AndroidDirectory || (AndroidDirectory = {}));
function getAndroidDirectory(value) {
  switch (value) {
    case AndroidDirectory.ALARMS:
      return {
        path: android.os.Environment.DIRECTORY_ALARMS,
        column: android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.AUDIOBOOKS:
      return {
        path: android.os.Environment.DIRECTORY_AUDIOBOOKS,
        column: android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.DCIM:
      return {
        path: android.os.Environment.DIRECTORY_DCIM,
        column: android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.DOCUMENTS:
      return {
        path: android.os.Environment.DIRECTORY_DOCUMENTS,
        column: android.provider.MediaStore.Files.getContentUri("external")
      };
    case AndroidDirectory.DOWNLOADS:
      return {
        path: android.os.Environment.DIRECTORY_DOWNLOADS,
        column: android.provider.MediaStore.Downloads.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.MOVIES:
      return {
        path: android.os.Environment.DIRECTORY_MOVIES,
        column: android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.MUSIC:
      return {
        path: android.os.Environment.DIRECTORY_MUSIC,
        column: android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.NOTIFICATIONS:
      return {
        path: android.os.Environment.DIRECTORY_NOTIFICATIONS,
        column: android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.PICTURES:
      return {
        path: android.os.Environment.DIRECTORY_PICTURES,
        column: android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.PODCASTS:
      return {
        path: android.os.Environment.DIRECTORY_PODCASTS,
        column: android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.RINGTONES:
      return {
        path: android.os.Environment.DIRECTORY_RINGTONES,
        column: android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
      };
    case AndroidDirectory.SCREENSHOTS:
      return {
        path: android.os.Environment.DIRECTORY_SCREENSHOTS,
        column: android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI
      };
    default:
      return null;
  }
}

class Android {
  createFile(options) {
    if (!__ANDROID__) {
      throw new Error(`createFile is available on Android only!`);
    }
    const context = getNativeApp().getApplicationContext();
    const meta = new android.content.ContentValues;
    meta.put(android.provider.MediaStore.MediaColumns.DISPLAY_NAME, options.name);
    meta.put(android.provider.MediaStore.MediaColumns.MIME_TYPE, options.mime);
    const externalDirectory = getAndroidDirectory(options.directory);
    if (SDK_VERSION >= 29) {
      const relativePath = options?.relativePath ? `/${options.relativePath}` : "";
      meta.put(android.provider.MediaStore.MediaColumns.RELATIVE_PATH, `${externalDirectory.path}${relativePath}`);
    } else {
      const relativePath = options?.relativePath ? `${options.relativePath}/` : "";
      const directory = android.os.Environment.getExternalStoragePublicDirectory(externalDirectory.path);
      const file = new java.io.File(directory, `${relativePath}${options.name}`);
      meta.put(android.provider.MediaStore.MediaColumns.DATA, file.getAbsolutePath());
    }
    const uri = context.getContentResolver().insert(externalDirectory.column, meta);
    return File.fromPath(uri.toString());
  }
}
var ad2 = new Android;

class iOS {
}
var ios2 = new iOS;

class File extends FileSystemEntity {
  static get ios() {
    return ios2;
  }
  static get android() {
    return ad2;
  }
  static fromPath(path, copy = false) {
    const onError = function(error) {
      throw error;
    };
    if (__ANDROID__ && copy) {
      if (path.startsWith("content:")) {
        const fileInfo2 = getFileAccess().getFile(path, onError);
        if (!fileInfo2) {
          const tempFile = `${knownFolders.temp().path}/${java.util.UUID.randomUUID().toString()}`;
          org.nativescript.widgets.Async.File.copySync(path, tempFile, getNativeApp().getApplicationContext());
          path = tempFile;
        } else {
          const ext = fileInfo2.extension;
          const name = `${fileInfo2.name.replace(`.${ext}`, "")}.${ext}`;
          const tempFile = `${knownFolders.temp().path}/${name}`;
          getFileAccess().copySync(path, tempFile);
          path = tempFile;
        }
      }
    }
    const fileInfo = getFileAccess().getFile(path, onError);
    if (!fileInfo) {
      return;
    }
    return createFile(fileInfo);
  }
  static exists(path) {
    return getFileAccess().fileExists(path);
  }
  get extension() {
    return this._extension;
  }
  get isLocked() {
    return !!this._locked;
  }
  get size() {
    return getFileAccess().getFileSize(this.path);
  }
  append(content) {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().appendAsync(this.path, content).then(() => {
        resolve();
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  appendSync(content, onError) {
    this._checkAccess();
    try {
      this._locked = true;
      const that = this;
      const localError = function(error) {
        that._locked = false;
        if (onError) {
          onError(error);
        }
      };
      getFileAccess().appendSync(this.path, content, localError);
    } finally {
      this._locked = false;
    }
  }
  appendText(content, encoding2) {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().appendTextAsync(this.path, content, encoding2).then(() => {
        resolve(true);
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  appendTextSync(content, onError, encoding2) {
    this._checkAccess();
    try {
      this._locked = true;
      const that = this;
      const localError = function(error) {
        that._locked = false;
        if (onError) {
          onError(error);
        }
      };
      getFileAccess().appendTextSync(this.path, content, localError, encoding2);
    } finally {
      this._locked = false;
    }
  }
  copy(dest) {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().copyAsync(this.path, dest).then((result) => {
        resolve(result);
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  copySync(dest, onError) {
    this._checkAccess();
    this._locked = true;
    const that = this;
    const localError = (error) => {
      that._locked = false;
      if (onError) {
        onError(error);
      }
    };
    const content = getFileAccess().copySync(this.path, dest, localError);
    this._locked = false;
    return content;
  }
  read() {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().readAsync(this.path).then((result) => {
        resolve(result);
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  readSync(onError) {
    this._checkAccess();
    this._locked = true;
    const that = this;
    const localError = (error) => {
      that._locked = false;
      if (onError) {
        onError(error);
      }
    };
    const content = getFileAccess().readSync(this.path, localError);
    this._locked = false;
    return content;
  }
  write(content) {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().writeAsync(this.path, content).then(() => {
        resolve();
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  writeSync(content, onError) {
    this._checkAccess();
    try {
      this._locked = true;
      const that = this;
      const localError = function(error) {
        that._locked = false;
        if (onError) {
          onError(error);
        }
      };
      getFileAccess().writeSync(this.path, content, localError);
    } finally {
      this._locked = false;
    }
  }
  readText(encoding2) {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().readTextAsync(this.path, encoding2).then((result) => {
        resolve(result);
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  readTextSync(onError, encoding2) {
    this._checkAccess();
    this._locked = true;
    const that = this;
    const localError = (error) => {
      that._locked = false;
      if (onError) {
        onError(error);
      }
    };
    const content = getFileAccess().readTextSync(this.path, localError, encoding2);
    this._locked = false;
    return content;
  }
  writeText(content, encoding2) {
    return new Promise((resolve, reject) => {
      try {
        this._checkAccess();
      } catch (ex) {
        reject(ex);
        return;
      }
      this._locked = true;
      getFileAccess().writeTextAsync(this.path, content, encoding2).then(() => {
        resolve(true);
        this._locked = false;
      }, (error) => {
        reject(error);
        this._locked = false;
      });
    });
  }
  writeTextSync(content, onError, encoding2) {
    this._checkAccess();
    try {
      this._locked = true;
      const that = this;
      const localError = function(error) {
        that._locked = false;
        if (onError) {
          onError(error);
        }
      };
      getFileAccess().writeTextSync(this.path, content, localError, encoding2);
    } finally {
      this._locked = false;
    }
  }
  _checkAccess() {
    if (this.isLocked) {
      throw new Error("Cannot access a locked file.");
    }
  }
}

class Folder extends FileSystemEntity {
  static fromPath(path) {
    const onError = function(error) {
      throw error;
    };
    const folderInfo = getFileAccess().getFolder(path, onError);
    if (!folderInfo) {
      return;
    }
    return createFolder(folderInfo);
  }
  static exists(path) {
    return getFileAccess().folderExists(path);
  }
  contains(name) {
    const fileAccess2 = getFileAccess();
    const path = fileAccess2.joinPath(this.path, name);
    if (fileAccess2.fileExists(path)) {
      return true;
    }
    return fileAccess2.folderExists(path);
  }
  clear() {
    return new Promise((resolve, reject) => {
      let hasError = false;
      const onError = function(error) {
        hasError = true;
        reject(error);
      };
      this.clearSync(onError);
      if (!hasError) {
        resolve(true);
      }
    });
  }
  clearSync(onError) {
    getFileAccess().emptyFolder(this.path, onError);
  }
  get isKnown() {
    return this._isKnown;
  }
  getFile(name) {
    const fileAccess2 = getFileAccess();
    const path = fileAccess2.joinPath(this.path, name);
    const onError = function(error) {
      throw error;
    };
    const fileInfo = fileAccess2.getFile(path, onError);
    if (!fileInfo) {
      return;
    }
    return createFile(fileInfo);
  }
  getFolder(name) {
    const fileAccess2 = getFileAccess();
    const path = fileAccess2.joinPath(this.path, name);
    const onError = function(error) {
      throw error;
    };
    const folderInfo = fileAccess2.getFolder(path, onError);
    if (!folderInfo) {
      return;
    }
    return createFolder(folderInfo);
  }
  getEntities() {
    return new Promise((resolve, reject) => {
      let hasError = false;
      const localError = function(error) {
        hasError = true;
        reject(error);
      };
      const entities = this.getEntitiesSync(localError);
      if (!hasError) {
        resolve(entities);
      }
    });
  }
  getEntitiesSync(onError) {
    const fileInfos = getFileAccess().getEntities(this.path, onError);
    if (!fileInfos) {
      return null;
    }
    const entities = new Array;
    for (let i3 = 0;i3 < fileInfos.length; i3++) {
      if (fileInfos[i3].extension) {
        entities.push(createFile(fileInfos[i3]));
      } else {
        entities.push(createFolder(fileInfos[i3]));
      }
    }
    return entities;
  }
  eachEntity(onEntity) {
    if (!onEntity) {
      return;
    }
    const onSuccess = function(fileInfo) {
      let entity;
      if (fileInfo.extension) {
        entity = createFile(fileInfo);
      } else {
        entity = createFolder(fileInfo);
      }
      return onEntity(entity);
    };
    const onError = function(error) {
      throw error;
    };
    getFileAccess().eachEntity(this.path, onSuccess, onError);
  }
}
var knownFolders;
(function(knownFolders2) {
  let _documents;
  let _externalDocuments;
  let _temp;
  let _app;
  function documents() {
    if (!_documents) {
      const path = getFileAccess().getDocumentsFolderPath();
      _documents = new Folder;
      _documents._path = path;
      _documents._isKnown = true;
    }
    return _documents;
  }
  knownFolders2.documents = documents;
  function externalDocuments() {
    if (!_externalDocuments) {
      const path = getFileAccess().getExternalDocumentsFolderPath();
      _externalDocuments = new Folder;
      _externalDocuments._path = path;
      _externalDocuments._isKnown = true;
    }
    return _externalDocuments;
  }
  knownFolders2.externalDocuments = externalDocuments;
  function temp() {
    if (!_temp) {
      const path = getFileAccess().getTempFolderPath();
      _temp = new Folder;
      _temp._path = path;
      _temp._isKnown = true;
    }
    return _temp;
  }
  knownFolders2.temp = temp;
  function currentApp() {
    if (!_app) {
      const path = getFileAccess().getCurrentAppPath();
      _app = new Folder;
      _app._path = path;
      _app._isKnown = true;
    }
    return _app;
  }
  knownFolders2.currentApp = currentApp;
  let ios3;
  (function(ios4) {
    function _checkPlatform(knownFolderName) {
      if (!__APPLE__) {
        throw new Error(`The "${knownFolderName}" known folder is available on iOS only!`);
      }
    }
    let _library;
    function library() {
      _checkPlatform("library");
      if (!_library) {
        const existingFolderInfo = getExistingFolderInfo(5);
        if (existingFolderInfo) {
          _library = existingFolderInfo.folder;
          _library._path = existingFolderInfo.path;
          _library._isKnown = true;
        }
      }
      return _library;
    }
    ios4.library = library;
    let _developer;
    function developer() {
      _checkPlatform("developer");
      if (!_developer) {
        const existingFolderInfo = getExistingFolderInfo(6);
        if (existingFolderInfo) {
          _developer = existingFolderInfo.folder;
          _developer._path = existingFolderInfo.path;
          _developer._isKnown = true;
        }
      }
      return _developer;
    }
    ios4.developer = developer;
    let _desktop;
    function desktop() {
      _checkPlatform("desktop");
      if (!_desktop) {
        const existingFolderInfo = getExistingFolderInfo(12);
        if (existingFolderInfo) {
          _desktop = existingFolderInfo.folder;
          _desktop._path = existingFolderInfo.path;
          _desktop._isKnown = true;
        }
      }
      return _desktop;
    }
    ios4.desktop = desktop;
    let _downloads;
    function downloads() {
      _checkPlatform("downloads");
      if (!_downloads) {
        const existingFolderInfo = getExistingFolderInfo(15);
        if (existingFolderInfo) {
          _downloads = existingFolderInfo.folder;
          _downloads._path = existingFolderInfo.path;
          _downloads._isKnown = true;
        }
      }
      return _downloads;
    }
    ios4.downloads = downloads;
    let _movies;
    function movies() {
      _checkPlatform("movies");
      if (!_movies) {
        const existingFolderInfo = getExistingFolderInfo(17);
        if (existingFolderInfo) {
          _movies = existingFolderInfo.folder;
          _movies._path = existingFolderInfo.path;
          _movies._isKnown = true;
        }
      }
      return _movies;
    }
    ios4.movies = movies;
    let _music;
    function music() {
      _checkPlatform("music");
      if (!_music) {
        const existingFolderInfo = getExistingFolderInfo(18);
        if (existingFolderInfo) {
          _music = existingFolderInfo.folder;
          _music._path = existingFolderInfo.path;
          _music._isKnown = true;
        }
      }
      return _music;
    }
    ios4.music = music;
    let _pictures;
    function pictures() {
      _checkPlatform("pictures");
      if (!_pictures) {
        const existingFolderInfo = getExistingFolderInfo(19);
        if (existingFolderInfo) {
          _pictures = existingFolderInfo.folder;
          _pictures._path = existingFolderInfo.path;
          _pictures._isKnown = true;
        }
      }
      return _pictures;
    }
    ios4.pictures = pictures;
    let _sharedPublic;
    function sharedPublic() {
      _checkPlatform("sharedPublic");
      if (!_sharedPublic) {
        const existingFolderInfo = getExistingFolderInfo(21);
        if (existingFolderInfo) {
          _sharedPublic = existingFolderInfo.folder;
          _sharedPublic._path = existingFolderInfo.path;
          _sharedPublic._isKnown = true;
        }
      }
      return _sharedPublic;
    }
    ios4.sharedPublic = sharedPublic;
    function getExistingFolderInfo(pathDirectory) {
      const fileAccess2 = getFileAccess();
      const folderPath = fileAccess2.getKnownPath(pathDirectory);
      const folderInfo = fileAccess2.getExistingFolder(folderPath);
      if (folderInfo) {
        return {
          folder: createFolder(folderInfo),
          path: folderPath
        };
      }
      return;
    }
  })(ios3 = knownFolders2.ios || (knownFolders2.ios = {}));
})(knownFolders || (knownFolders = {}));
var path;
(function(path_1) {
  function normalize2(path2) {
    return getFileAccess().normalizePath(path2);
  }
  path_1.normalize = normalize2;
  function join(...paths) {
    const fileAccess2 = getFileAccess();
    return fileAccess2.joinPaths(paths);
  }
  path_1.join = join;
  path_1.separator = getFileAccess().getPathSeparator();
})(path || (path = {}));

// node_modules/@nativescript/core/utils/index.android.js
var exports_index_android3 = {};
__export(exports_index_android3, {
  verifyCallback: () => verifyCallback,
  toUIString: () => toUIString,
  throttle: () => throttle,
  supportsGlass: () => supportsGlass,
  setTimeout: () => setTimeout2,
  setInterval: () => setInterval,
  sanitizeModuleName: () => sanitizeModuleName,
  releaseNativeObject: () => releaseNativeObject,
  queueMacrotask: () => queueMacrotask,
  queueGC: () => queueGC,
  openUrlAsync: () => openUrlAsync,
  openUrl: () => openUrl,
  openFile: () => openFile,
  numberIs64Bit: () => numberIs64Bit,
  numberHasDecimals: () => numberHasDecimals,
  mergeSort: () => mergeSort,
  merge: () => merge,
  mainThreadify: () => mainThreadify,
  layout: () => layout,
  isUndefined: () => isUndefined,
  isSystemURI: () => isSystemURI,
  isString: () => isString,
  isObject: () => isObject,
  isNumber: () => isNumber,
  isNullOrUndefined: () => isNullOrUndefined,
  isMainThread: () => isMainThread,
  isFunction: () => isFunction,
  isFontIconURI: () => isFontIconURI,
  isFileOrResourcePath: () => isFileOrResourcePath,
  isEmoji: () => isEmoji,
  isDefined: () => isDefined,
  isDataURI: () => isDataURI,
  isBoolean: () => isBoolean,
  ios: () => ios,
  iOSNativeHelper: () => iOSNativeHelper,
  hasDuplicates: () => hasDuplicates,
  getWindow: () => getWindow,
  getModuleName: () => getModuleName,
  getFileExtension: () => getFileExtension,
  getDurationWithDampingFromSpring: () => getDurationWithDampingFromSpring,
  getClassInfo: () => getClassInfo,
  getClass: () => getClass,
  getBaseClasses: () => getBaseClasses,
  executeOnUIThread: () => executeOnUIThread,
  executeOnMainThread: () => executeOnMainThread,
  escapeRegexSymbols: () => escapeRegexSymbols,
  eliminateDuplicates: () => eliminateDuplicates,
  dispatchToUIThread: () => dispatchToUIThread,
  dispatchToMainThread: () => dispatchToMainThread,
  dismissSoftInput: () => dismissSoftInput2,
  dismissKeyboard: () => dismissKeyboard,
  debug: () => debug,
  debounce: () => debounce,
  dataSerialize: () => dataSerialize,
  dataDeserialize: () => dataDeserialize,
  copyToClipboard: () => copyToClipboard,
  convertString: () => convertString,
  clearTimeout: () => clearTimeout2,
  clearInterval: () => clearInterval,
  android: () => android2,
  ad: () => ad,
  SourceError: () => SourceError,
  Source: () => Source,
  ScopeError: () => ScopeError,
  SYSTEM_PREFIX: () => SYSTEM_PREFIX,
  SDK_VERSION: () => SDK_VERSION,
  RESOURCE_PREFIX: () => RESOURCE_PREFIX,
  GC: () => GC,
  FONT_PREFIX: () => FONT_PREFIX,
  FILE_PREFIX: () => FILE_PREFIX,
  ClassInfo: () => ClassInfo,
  CORE_ANIMATION_DEFAULTS: () => CORE_ANIMATION_DEFAULTS
});

// node_modules/@nativescript/core/utils/shared.js
function debounce(fn, delay = 300, { leading } = {}) {
  let timer;
  return (...args) => {
    if (timer === undefined && leading) {
      fn.apply(this, args);
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = undefined;
    }, delay);
  };
}
function throttle(fn, delay = 300) {
  let waiting = false;
  return function(...args) {
    if (!waiting) {
      fn.apply(this, args);
      waiting = true;
      setTimeout(function() {
        waiting = false;
      }, delay);
    }
  };
}
// node_modules/@nativescript/core/utils/animation-helpers.js
var CORE_ANIMATION_DEFAULTS = {
  duration: 0.35,
  spring: {
    tension: 140,
    friction: 10,
    mass: 1,
    velocity: 0
  }
};
function getDurationWithDampingFromSpring(springSettings) {
  const opt = {
    ...CORE_ANIMATION_DEFAULTS.spring,
    ...springSettings || {}
  };
  const damping = opt.friction / Math.sqrt(2 * opt.tension);
  const undampedFrequency = Math.sqrt(opt.tension / opt.mass);
  const epsilon = 0.001;
  let duration = 0;
  if (damping < 1) {
    const a3 = Math.sqrt(1 - Math.pow(damping, 2));
    const b2 = opt.velocity / (a3 * undampedFrequency);
    const c3 = damping / a3;
    const d3 = -((b2 - c3) / epsilon);
    if (d3 > 0) {
      duration = Math.log(d3) / (damping * undampedFrequency);
    }
  }
  return {
    duration,
    damping
  };
}
// node_modules/@nativescript/core/utils/common.js
var emojiRegexModule = __toESM(require_emoji_regex(), 1);
var emojiRegex = (() => {
  const mod2 = emojiRegexModule;
  if (mod2 && typeof mod2.default === "function") {
    return mod2.default;
  }
  if (typeof mod2 === "function") {
    return mod2;
  }
  return () => /./g;
})();
var FILE_PREFIX = "file:///";
var FONT_PREFIX = "font://";
var RESOURCE_PREFIX = "res://";
var SYSTEM_PREFIX = "sys://";
function escapeRegexSymbols(source) {
  const escapeRegex = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;
  return source.replace(escapeRegex, "\\$&");
}
function convertString(value) {
  let result;
  if (!isString(value) || value.trim() === "") {
    result = value;
  } else {
    const valueAsNumber = +value;
    if (!isNaN(valueAsNumber)) {
      result = valueAsNumber;
    } else if (value && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      result = value.toLowerCase() === "true" ? true : false;
    } else {
      result = value;
    }
  }
  return result;
}
function getModuleName(path2) {
  const moduleName = path2.replace("./", "");
  return sanitizeModuleName(moduleName);
}
function sanitizeModuleName(moduleName, removeExtension = true) {
  moduleName = moduleName.trim();
  if (moduleName.startsWith("~/")) {
    moduleName = moduleName.substring(2);
  } else if (moduleName.startsWith("~")) {
    moduleName = moduleName.substring(1);
  } else if (moduleName.startsWith("/")) {
    moduleName = moduleName.substring(1);
  }
  if (removeExtension) {
    const extToRemove = ["js", "mjs", "ts", "xml", "html", "css", "scss"];
    const extensionRegEx = new RegExp(`(.*)\\.(?:${extToRemove.join("|")})`, "i");
    moduleName = moduleName.replace(extensionRegEx, "$1");
  }
  return moduleName;
}
function isFileOrResourcePath(path2) {
  if (!isString(path2)) {
    return false;
  }
  return path2.indexOf("~/") === 0 || path2.indexOf("/") === 0 || path2.indexOf(RESOURCE_PREFIX) === 0 || path2.indexOf(SYSTEM_PREFIX) === 0;
}
function isFontIconURI(uri) {
  if (!isString(uri)) {
    return false;
  }
  return uri.trim().startsWith(FONT_PREFIX);
}
function isSystemURI(uri) {
  if (!isString(uri)) {
    return false;
  }
  return uri.trim().startsWith(SYSTEM_PREFIX);
}
function isDataURI(uri) {
  if (!isString(uri)) {
    return false;
  }
  const firstSegment = uri.trim().split(",")[0];
  return firstSegment && firstSegment.indexOf("data:") === 0 && firstSegment.indexOf("base64") >= 0;
}
function mergeSort(arr, compareFunc) {
  if (arr.length < 2) {
    return arr;
  }
  const middle = arr.length / 2;
  const left = arr.slice(0, middle);
  const right = arr.slice(middle, arr.length);
  return merge(mergeSort(left, compareFunc), mergeSort(right, compareFunc), compareFunc);
}
function merge(left, right, compareFunc) {
  const result = [];
  while (left.length && right.length) {
    if (compareFunc(left[0], right[0]) <= 0) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  while (left.length) {
    result.push(left.shift());
  }
  while (right.length) {
    result.push(right.shift());
  }
  return result;
}
function hasDuplicates(arr) {
  return arr.length !== eliminateDuplicates(arr).length;
}
function eliminateDuplicates(arr) {
  return Array.from(new Set(arr));
}
function executeOnMainThread(func) {
  if (isMainThread()) {
    return func();
  } else {
    dispatchToMainThread(func);
  }
}
function executeOnUIThread(func) {
  dispatchToUIThread(func);
}
function mainThreadify(func) {
  return function(...args) {
    const argsToPass = args;
    executeOnMainThread(() => func.apply(this, argsToPass));
  };
}
function isEmoji(value) {
  return emojiRegex(value).test(value);
}
// node_modules/@nativescript/core/utils/debug-source.js
function getCurrentAppPath() {
  if (__APPLE__) {
    const currentDir = global.__dirname;
    const tnsModulesIndex = currentDir.indexOf("/tns_modules");
    let appPath = currentDir;
    if (tnsModulesIndex !== -1) {
      appPath = currentDir.substring(0, tnsModulesIndex);
    }
    return appPath;
  } else {
    const dir = getNativeApp().getApplicationContext().getFilesDir();
    return `${dir.getCanonicalPath()}/app`;
  }
}
var applicationRootPath;
function ensureAppRootPath() {
  if (!applicationRootPath) {
    applicationRootPath = getCurrentAppPath();
    applicationRootPath = applicationRootPath.substring(0, applicationRootPath.length - "app/".length);
  }
}

class Source {
  constructor(uri, line, column) {
    ensureAppRootPath();
    if (uri.length > applicationRootPath.length && uri.substring(0, applicationRootPath.length) === applicationRootPath) {
      this._uri = "file://" + uri.substring(applicationRootPath.length);
    } else {
      this._uri = uri;
    }
    this._line = line;
    this._column = column;
  }
  get uri() {
    return this._uri;
  }
  get line() {
    return this._line;
  }
  get column() {
    return this._column;
  }
  toString() {
    return this._uri + ":" + this._line + ":" + this._column;
  }
  static get(object) {
    return object[Source._source];
  }
  static set(object, src) {
    object[Source._source] = src;
  }
}
Source._source = Symbol("source");

class ScopeError extends Error {
  constructor(inner, message) {
    let formattedMessage;
    if (message && inner.message) {
      formattedMessage = message + `
 > ` + inner.message.replace(`
`, `
  `);
    } else {
      formattedMessage = message || inner.message || undefined;
    }
    super(formattedMessage);
    this.stack = __ANDROID__ ? "Error: " + this.message + `
` + inner.stack.substr(inner.stack.indexOf(`
`) + 1) : inner.stack;
    this.message = formattedMessage;
  }
}

class SourceError extends ScopeError {
  constructor(child, source, message) {
    super(child, message ? message + " @" + source + "" : source + "");
  }
}

// node_modules/@nativescript/core/utils/debug.js
var debug = true;

// node_modules/@nativescript/core/utils/index.android.js
var MIN_URI_SHARE_RESTRICTED_APK_VERSION = 24;
function GC() {
  gc();
}
var throttledGC;
var debouncedGC;
function queueGC(delay = 900, useThrottle) {
  if (useThrottle) {
    if (!throttledGC) {
      throttledGC = new Map;
    }
    if (!throttledGC.get(delay)) {
      throttledGC.set(delay, throttle(() => GC(), delay));
    }
    throttledGC.get(delay)();
  } else {
    if (!debouncedGC) {
      debouncedGC = new Map;
    }
    if (!debouncedGC.get(delay)) {
      debouncedGC.set(delay, debounce(() => GC(), delay));
    }
    debouncedGC.get(delay)();
  }
}
function releaseNativeObject(object) {
  __releaseNativeCounterpart(object);
}
function openUrl(location) {
  const context = android2.getApplicationContext();
  try {
    const intent = new android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(location.trim()));
    intent.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);
    context.startActivity(intent);
  } catch (e3) {
    Trace.write(`Failed to start activity for handling URL: ${location}`, Trace.categories.Error, Trace.messageType.error);
    return false;
  }
  return true;
}
function openUrlAsync(location) {
  return new Promise((resolve, reject) => {
    try {
      const context = android2.getApplicationContext();
      const intent = new android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(location.trim()));
      intent.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);
      context.startActivity(intent);
      resolve(true);
    } catch (e3) {
      Trace.write(`Failed to start activity for handling URL: ${location}`, Trace.categories.Error, Trace.messageType.error);
      resolve(false);
    }
  });
}
function isExternalStorageReadOnly() {
  const extStorageState = android.os.Environment.getExternalStorageState();
  if (android.os.Environment.MEDIA_MOUNTED_READ_ONLY === extStorageState) {
    return true;
  }
  return false;
}
function isExternalStorageAvailable() {
  const extStorageState = android.os.Environment.getExternalStorageState();
  if (android.os.Environment.MEDIA_MOUNTED === extStorageState) {
    return true;
  }
  return false;
}
function getMimeTypeNameFromExtension(filePath) {
  const mimeTypeMap = android.webkit.MimeTypeMap.getSingleton();
  const extension = getFileExtension(filePath).replace(".", "").toLowerCase();
  return mimeTypeMap.getMimeTypeFromExtension(extension);
}
function openFile(filePath, title = "Open File...") {
  const context = android2.getApplicationContext();
  try {
    if (!isExternalStorageAvailable()) {
      Trace.write(`
External storage is unavailable (please check app permissions).
Applications cannot access internal storage of other application on Android (see: https://developer.android.com/guide/topics/data/data-storage).
`, Trace.categories.Error, Trace.messageType.error);
      return false;
    }
    if (isExternalStorageReadOnly()) {
      Trace.write("External storage is read only", Trace.categories.Error, Trace.messageType.error);
      return false;
    }
    const mimeType = getMimeTypeNameFromExtension(filePath);
    const intent = new android.content.Intent(android.content.Intent.ACTION_VIEW);
    const chooserIntent = android.content.Intent.createChooser(intent, title);
    intent.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);
    chooserIntent.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);
    if (SDK_VERSION < MIN_URI_SHARE_RESTRICTED_APK_VERSION) {
      Trace.write(`detected sdk version ${SDK_VERSION} (< ${MIN_URI_SHARE_RESTRICTED_APK_VERSION}), using simple openFile`, Trace.categories.Debug);
      intent.setDataAndType(android.net.Uri.fromFile(new java.io.File(filePath)), mimeType);
      context.startActivity(chooserIntent);
      return true;
    }
    Trace.write(`detected sdk version ${SDK_VERSION} (>= ${MIN_URI_SHARE_RESTRICTED_APK_VERSION}), using URI openFile`, Trace.categories.Debug);
    const providerName = `${context.getPackageName()}.provider`;
    Trace.write(`fully-qualified provider name [${providerName}]`, Trace.categories.Debug);
    const apkURI = androidx.core.content.FileProvider.getUriForFile(context, providerName, new java.io.File(filePath));
    intent.addFlags(android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION);
    chooserIntent.addFlags(android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION);
    intent.setDataAndType(apkURI, mimeType);
    context.startActivity(chooserIntent);
    return true;
  } catch (err) {
    const msg = err.message ? `: ${err.message}` : "";
    Trace.write(`Error in openFile${msg}`, Trace.categories.Error, Trace.messageType.error);
    if (msg && msg.includes("Attempt to invoke virtual method") && msg.includes("android.content.pm.ProviderInfo.loadXmlMetaData") && msg.includes("on a null object reference")) {
      Trace.write(`
Please ensure you have your manifest correctly configured with the FileProvider.
(see: https://developer.android.com/reference/android/support/v4/content/FileProvider#ProviderDefinition)
`, Trace.categories.Error);
    }
    return false;
  }
}
function dismissSoftInput2(nativeView) {
  android2.dismissSoftInput(nativeView);
}
function dismissKeyboard() {
  dismissSoftInput2();
  const modalDialog = (topmost()?._modalParent ?? topmost()?.modal)?._dialogFragment?.getDialog();
  const view = modalDialog ?? android2.getCurrentActivity();
  if (view) {
    const focus = view.getCurrentFocus();
    if (focus) {
      focus.clearFocus();
    }
  }
}
function copyToClipboard(value) {
  try {
    const clipboard = android2.getApplicationContext().getSystemService(android.content.Context.CLIPBOARD_SERVICE);
    const clip2 = android.content.ClipData.newPlainText("Clipboard value", value);
    clipboard.setPrimaryClip(clip2);
  } catch (err) {
    console.log(err);
  }
}
// app/package.json
var package_default = {
  main: "bundle.js"
};

// node_modules/@nativescript/core/profiling/index.js
function uptime() {
  return global.android ? org.nativescript.Process.getUpTime() : global.__tns_uptime();
}
function log2(message, ...optionalParams) {
  if (global.__nslog) {
    global.__nslog("CONSOLE LOG: " + message);
  }
  console.log(message, ...optionalParams);
}
var timers = {};
var anyGlobal = global;
var profileNames = [];
var time = global.__time || Date.now;
function start(name) {
  let info = timers[name];
  if (info) {
    info.currentStart = time();
    info.runCount++;
  } else {
    info = {
      totalTime: 0,
      count: 0,
      currentStart: time(),
      runCount: 1
    };
    timers[name] = info;
    profileNames.push(name);
  }
}
function stop(name) {
  const info = timers[name];
  if (!info) {
    throw new Error(`No timer started: ${name}`);
  }
  if (info.runCount) {
    info.runCount--;
    if (info.runCount) {
      info.count++;
    } else {
      info.lastTime = time() - info.currentStart;
      info.totalTime += info.lastTime;
      info.count++;
      info.currentStart = 0;
    }
  } else {
    throw new Error(`Timer ${name} paused more times than started.`);
  }
  return info;
}
function countersProfileFunctionFactory(fn, name, type = 1) {
  profileNames.push(name);
  return function() {
    start(name);
    try {
      return fn.apply(this, arguments);
    } finally {
      stop(name);
    }
  };
}
function timelineProfileFunctionFactory(fn, name, type = 1) {
  return type === 1 ? function() {
    const start2 = time();
    try {
      return fn.apply(this, arguments);
    } finally {
      const end = time();
      console.log(`Timeline: Modules: ${name} ${this}  (${start2}ms. - ${end}ms.)`);
    }
  } : function() {
    const start2 = time();
    try {
      return fn.apply(this, arguments);
    } finally {
      const end = time();
      console.log(`Timeline: Modules: ${name}  (${start2}ms. - ${end}ms.)`);
    }
  };
}
var Level;
(function(Level2) {
  Level2[Level2["none"] = 0] = "none";
  Level2[Level2["lifecycle"] = 1] = "lifecycle";
  Level2[Level2["timeline"] = 2] = "timeline";
})(Level || (Level = {}));
var tracingLevel = Level.none;
var profileFunctionFactory;
function enable(mode = "counters") {
  profileFunctionFactory = mode && {
    counters: countersProfileFunctionFactory,
    timeline: timelineProfileFunctionFactory
  }[mode];
  tracingLevel = {
    lifecycle: Level.lifecycle,
    timeline: Level.timeline
  }[mode] || Level.none;
}
try {
  if (package_default && package_default.profiling) {
    enable(package_default.profiling);
  }
} catch (e1) {
  try {
    console.log("Profiling startup failed to figure out defaults from package.json, error: " + e1);
  } catch (e22) {}
}
function profileFunction(fn, customName) {
  return profileFunctionFactory(fn, customName || fn.name);
}
var profileMethodUnnamed = (target, key, descriptor) => {
  if (descriptor === undefined) {
    descriptor = Object.getOwnPropertyDescriptor(target, key);
  }
  const originalMethod = descriptor.value;
  let className = "";
  if (target && target.constructor && target.constructor.name) {
    className = target.constructor.name + ".";
  }
  const name = className + key?.toString();
  descriptor.value = profileFunctionFactory(originalMethod, name, 1);
  return descriptor;
};
var profileStaticMethodUnnamed = (ctor, key, descriptor) => {
  if (descriptor === undefined) {
    descriptor = Object.getOwnPropertyDescriptor(ctor, key);
  }
  const originalMethod = descriptor.value;
  let className = "";
  if (ctor && ctor.name) {
    className = ctor.name + ".";
  }
  const name = className + key?.toString();
  descriptor.value = profileFunctionFactory(originalMethod, name, 0);
  return descriptor;
};
function profileMethodNamed(name) {
  return (target, key, descriptor) => {
    if (descriptor === undefined) {
      descriptor = Object.getOwnPropertyDescriptor(target, key);
    }
    const originalMethod = descriptor.value;
    descriptor.value = profileFunctionFactory(originalMethod, name);
    return descriptor;
  };
}
var voidMethodDecorator = () => {};
function profile(nameFnOrTarget, fnOrKey, descriptor, attrs) {
  if (typeof nameFnOrTarget === "object" && (typeof fnOrKey === "string" || typeof fnOrKey === "symbol")) {
    if (!profileFunctionFactory) {
      return;
    }
    return profileMethodUnnamed(nameFnOrTarget, fnOrKey, descriptor);
  } else if (typeof nameFnOrTarget === "function" && (typeof fnOrKey === "string" || typeof fnOrKey === "symbol")) {
    if (!profileFunctionFactory) {
      return;
    }
    return profileStaticMethodUnnamed(nameFnOrTarget, fnOrKey, descriptor);
  } else if (typeof nameFnOrTarget === "string" && typeof fnOrKey === "function") {
    if (!profileFunctionFactory) {
      return fnOrKey;
    }
    return profileFunction(fnOrKey, nameFnOrTarget);
  } else if (typeof nameFnOrTarget === "function") {
    if (!profileFunctionFactory) {
      return nameFnOrTarget;
    }
    return profileFunction(nameFnOrTarget);
  } else if (typeof nameFnOrTarget === "string") {
    if (!profileFunctionFactory) {
      return voidMethodDecorator;
    }
    return profileMethodNamed(nameFnOrTarget);
  } else {
    if (!profileFunctionFactory) {
      return voidMethodDecorator;
    }
    return profileMethodUnnamed;
  }
}
function level() {
  return tracingLevel;
}
function trace(message, start2, end) {
  log2(`Timeline: Modules: ${message}  (${start2}ms. - ${end}ms.)`);
}
// node_modules/@nativescript/core/core-types/validators.js
function makeValidator(...values) {
  return function(value) {
    return values.indexOf(value) !== -1;
  };
}
function makeParser(isValid, allowNumbers = false) {
  return (value) => {
    const lower = value && value.toLowerCase();
    if (isValid(value)) {
      return value;
    } else if (isValid(lower)) {
      return lower;
    } else {
      if (allowNumbers) {
        const convNumber = +value;
        if (!isNaN(convNumber)) {
          return value;
        }
      }
      throw new Error("Invalid value: " + value);
    }
  };
}

// node_modules/@nativescript/core/ui/core/properties/index.js
var cssPropertyNames = [];
var HAS_OWN = Object.prototype.hasOwnProperty;
var symbolPropertyMap = {};
var cssSymbolPropertyMap = {};
var CSS_VARIABLE_NAME_RE = /^--[^,\s]+?$/;
var DIP_RE = /([0-9]+(\.[0-9]+)?)dip\b/g;
var UNSET_RE = /unset/g;
var INFINITY_RE = /infinity/g;
var inheritableProperties = new Array;
var inheritableCssProperties = new Array;
function isCssVariable(property) {
  return CSS_VARIABLE_NAME_RE.test(property);
}
function isCssCalcExpression(value) {
  return value.includes("calc(");
}
function isCssVariableExpression(value) {
  return value.includes("var(--");
}
function _evaluateCssVariableExpression(view, cssName, value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!isCssVariableExpression(value)) {
    return value;
  }
  let output = value.trim();
  let lastValue;
  while (lastValue !== output) {
    lastValue = output;
    const idx = output.lastIndexOf("var(");
    if (idx === -1) {
      continue;
    }
    const endIdx = output.indexOf(")", idx);
    if (endIdx === -1) {
      continue;
    }
    const matched = output.substring(idx + 4, endIdx).split(",").map((v) => v.trim()).filter((v) => !!v);
    const cssVariableName = matched.shift();
    let cssVariableValue = view.style.getCssVariable(cssVariableName);
    if (cssVariableValue === null && matched.length) {
      cssVariableValue = _evaluateCssVariableExpression(view, cssName, matched.join(", ")).split(",")[0];
    }
    if (!cssVariableValue) {
      cssVariableValue = "unset";
    }
    output = `${output.substring(0, idx)}${cssVariableValue}${output.substring(endIdx + 1)}`;
  }
  return output;
}
function _evaluateCssCalcExpression(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (isCssCalcExpression(value)) {
    return calc(_replaceKeywordsWithValues(_replaceDip(value)));
  } else {
    return value;
  }
  return value;
}
function _replaceDip(value) {
  return value.replace(DIP_RE, "$1");
}
function _replaceKeywordsWithValues(value) {
  let cssValue = value;
  if (cssValue.includes("unset")) {
    cssValue = cssValue.replace(UNSET_RE, "0");
  }
  if (cssValue.includes("infinity")) {
    cssValue = cssValue.replace(INFINITY_RE, "999999");
  }
  return cssValue;
}
class Property {
  constructor(options) {
    this.enumerable = true;
    this.configurable = true;
    const propertyName = options.name;
    this.name = propertyName;
    const key = Symbol(propertyName + ":propertyKey");
    this.key = key;
    const getDefault = Symbol(propertyName + ":getDefault");
    this.getDefault = getDefault;
    const setNative = Symbol(propertyName + ":setNative");
    this.setNative = setNative;
    const defaultValueKey = Symbol(propertyName + ":nativeDefaultValue");
    this.defaultValueKey = defaultValueKey;
    const defaultValue = options.defaultValue;
    this.defaultValue = defaultValue;
    const eventName = propertyName + "Change";
    let equalityComparer = options.equalityComparer;
    let affectsLayout = options.affectsLayout;
    let valueChanged = options.valueChanged;
    let valueConverter = options.valueConverter;
    this.overrideHandlers = function(options2) {
      if (typeof options2.equalityComparer !== "undefined") {
        equalityComparer = options2.equalityComparer;
      }
      if (typeof options2.affectsLayout !== "undefined") {
        affectsLayout = options2.affectsLayout;
      }
      if (typeof options2.valueChanged !== "undefined") {
        valueChanged = options2.valueChanged;
      }
      if (typeof options2.valueConverter !== "undefined") {
        valueConverter = options2.valueConverter;
      }
    };
    const property = this;
    this.set = function(boxedValue) {
      const reset = isResetValue(boxedValue);
      let value;
      let wrapped;
      if (reset) {
        value = defaultValue;
      } else {
        wrapped = boxedValue && boxedValue.wrapped;
        value = wrapped ? WrappedValue.unwrap(boxedValue) : boxedValue;
        if (valueConverter && typeof value === "string") {
          value = valueConverter(value);
        }
      }
      const oldValue = key in this ? this[key] : defaultValue;
      const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
      if (wrapped || changed) {
        if (affectsLayout) {
          this.requestLayout();
        }
        if (reset) {
          delete this[key];
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (this[setNative]) {
            if (this._suspendNativeUpdatesCount) {
              if (this._suspendedUpdates) {
                this._suspendedUpdates[propertyName] = property;
              }
            } else if (defaultValueKey in this) {
              this[setNative](this[defaultValueKey]);
              delete this[defaultValueKey];
            } else {
              this[setNative](defaultValue);
            }
          }
        } else {
          this[key] = value;
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (this[setNative]) {
            if (this._suspendNativeUpdatesCount) {
              if (this._suspendedUpdates) {
                this._suspendedUpdates[propertyName] = property;
              }
            } else {
              if (!(defaultValueKey in this)) {
                this[defaultValueKey] = this[getDefault] ? this[getDefault]() : defaultValue;
              }
              this[setNative](value);
            }
          }
        }
        if (this.hasListeners(eventName)) {
          this.notify({
            object: this,
            eventName,
            propertyName,
            value,
            oldValue
          });
        }
        if (this.domNode) {
          if (reset) {
            this.domNode.attributeRemoved(propertyName);
          } else {
            this.domNode.attributeModified(propertyName, value);
          }
        }
      }
    };
    this.get = function() {
      return key in this ? this[key] : defaultValue;
    };
    this.nativeValueChange = function(owner, value) {
      const oldValue = key in owner ? owner[key] : defaultValue;
      const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
      if (changed) {
        owner[key] = value;
        if (valueChanged) {
          valueChanged(owner, oldValue, value);
        }
        if (owner.nativeViewProtected && !(defaultValueKey in owner)) {
          owner[defaultValueKey] = owner[getDefault] ? owner[getDefault]() : defaultValue;
        }
        if (owner.hasListeners(eventName)) {
          owner.notify({
            object: owner,
            eventName,
            propertyName,
            value,
            oldValue
          });
        }
        if (affectsLayout) {
          owner.requestLayout();
        }
        if (owner.domNode) {
          owner.domNode.attributeModified(propertyName, value);
        }
      }
    };
    symbolPropertyMap[key] = this;
  }
  register(cls) {
    if (this.registered) {
      throw new Error(`Property ${this.name} already registered.`);
    }
    this.registered = true;
    Object.defineProperty(cls.prototype, this.name, this);
  }
  isSet(instance) {
    return this.key in instance;
  }
}
Property.prototype.isStyleProperty = false;

class CoercibleProperty extends Property {
  constructor(options) {
    super(options);
    const propertyName = options.name;
    const key = this.key;
    const getDefault = this.getDefault;
    const setNative = this.setNative;
    const defaultValueKey = this.defaultValueKey;
    const defaultValue = this.defaultValue;
    const coerceKey = Symbol(propertyName + ":coerceKey");
    const eventName = propertyName + "Change";
    let affectsLayout = options.affectsLayout;
    let equalityComparer = options.equalityComparer;
    let valueChanged = options.valueChanged;
    let valueConverter = options.valueConverter;
    let coerceCallback = options.coerceValue;
    const property = this;
    this.overrideHandlers = function(options2) {
      if (typeof options2.equalityComparer !== "undefined") {
        equalityComparer = options2.equalityComparer;
      }
      if (typeof options2.affectsLayout !== "undefined") {
        affectsLayout = options2.affectsLayout;
      }
      if (typeof options2.valueChanged !== "undefined") {
        valueChanged = options2.valueChanged;
      }
      if (typeof options2.valueConverter !== "undefined") {
        valueConverter = options2.valueConverter;
      }
      if (typeof options2.coerceValue !== "undefined") {
        coerceCallback = options2.coerceValue;
      }
    };
    this.coerce = function(target) {
      const originalValue = coerceKey in target ? target[coerceKey] : defaultValue;
      target[propertyName] = originalValue;
    };
    this.set = function(boxedValue) {
      const reset = isResetValue(boxedValue);
      let value;
      let wrapped;
      if (reset) {
        value = defaultValue;
        delete this[coerceKey];
      } else {
        wrapped = boxedValue && boxedValue.wrapped;
        value = wrapped ? WrappedValue.unwrap(boxedValue) : boxedValue;
        if (valueConverter && typeof value === "string") {
          value = valueConverter(value);
        }
        this[coerceKey] = value;
        value = coerceCallback(this, value);
      }
      const oldValue = key in this ? this[key] : defaultValue;
      const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
      if (wrapped || changed) {
        if (reset) {
          delete this[key];
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (this[setNative]) {
            if (this._suspendNativeUpdatesCount) {
              if (this._suspendedUpdates) {
                this._suspendedUpdates[propertyName] = property;
              }
            } else if (defaultValueKey in this) {
              this[setNative](this[defaultValueKey]);
              delete this[defaultValueKey];
            } else {
              this[setNative](defaultValue);
            }
          }
        } else {
          this[key] = value;
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (this[setNative]) {
            if (this._suspendNativeUpdatesCount) {
              if (this._suspendedUpdates) {
                this._suspendedUpdates[propertyName] = property;
              }
            } else {
              if (!(defaultValueKey in this)) {
                this[defaultValueKey] = this[getDefault] ? this[getDefault]() : defaultValue;
              }
              this[setNative](value);
            }
          }
        }
        if (this.hasListeners(eventName)) {
          this.notify({
            object: this,
            eventName,
            propertyName,
            value,
            oldValue
          });
        }
        if (affectsLayout) {
          this.requestLayout();
        }
        if (this.domNode) {
          if (reset) {
            this.domNode.attributeRemoved(propertyName);
          } else {
            this.domNode.attributeModified(propertyName, value);
          }
        }
      }
    };
  }
}

class InheritedProperty extends Property {
  constructor(options) {
    super(options);
    const name = options.name;
    const key = this.key;
    const defaultValue = options.defaultValue;
    const sourceKey = Symbol(name + ":valueSourceKey");
    this.sourceKey = sourceKey;
    const setBase = this.set;
    const setFunc = (valueSource) => function(value) {
      const that = this;
      let unboxedValue;
      let newValueSource;
      if (isResetValue(value)) {
        const parent = that.parent;
        if (value !== "initial" && parent && parent[sourceKey] !== 0) {
          unboxedValue = parent[name];
          newValueSource = 1;
        } else {
          unboxedValue = defaultValue;
          newValueSource = 0;
        }
      } else {
        unboxedValue = value;
        newValueSource = valueSource;
      }
      const currentValue = that[key];
      setBase.call(that, unboxedValue);
      const newValue = that[key];
      that[sourceKey] = newValueSource;
      if (currentValue !== newValue) {
        const reset = newValueSource === 0;
        that.eachChild((child) => {
          const childValueSource = child[sourceKey] || 0;
          if (reset) {
            if (childValueSource === 1) {
              setFunc.call(child, unsetValue);
            }
          } else {
            if (childValueSource <= 1) {
              setInheritedValue.call(child, newValue);
            }
          }
          return true;
        });
      }
    };
    const setInheritedValue = setFunc(1);
    this.setInheritedValue = setInheritedValue;
    this.set = setFunc(3);
    inheritableProperties.push(this);
  }
}

class CssProperty {
  constructor(options) {
    const propertyName = options.name;
    this.name = propertyName;
    if (options.cssName) {
      cssPropertyNames.push(options.cssName);
    }
    this.cssName = `css:${options.cssName}`;
    this.cssLocalName = options.cssName;
    const key = Symbol(propertyName + ":propertyKey");
    this.key = key;
    const sourceKey = Symbol(propertyName + ":valueSourceKey");
    this.sourceKey = sourceKey;
    const getDefault = Symbol(propertyName + ":getDefault");
    this.getDefault = getDefault;
    const setNative = Symbol(propertyName + ":setNative");
    this.setNative = setNative;
    const defaultValueKey = Symbol(propertyName + ":nativeDefaultValue");
    this.defaultValueKey = defaultValueKey;
    const defaultValue = options.defaultValue;
    this.defaultValue = defaultValue;
    const eventName = propertyName + "Change";
    let affectsLayout = options.affectsLayout;
    let equalityComparer = options.equalityComparer;
    let valueChanged = options.valueChanged;
    let valueConverter = options.valueConverter;
    this.overrideHandlers = function(options2) {
      if (typeof options2.equalityComparer !== "undefined") {
        equalityComparer = options2.equalityComparer;
      }
      if (typeof options2.affectsLayout !== "undefined") {
        affectsLayout = options2.affectsLayout;
      }
      if (typeof options2.valueChanged !== "undefined") {
        valueChanged = options2.valueChanged;
      }
      if (typeof options2.valueConverter !== "undefined") {
        valueConverter = options2.valueConverter;
      }
    };
    const property = this;
    function setLocalValue(newValue) {
      const view = this.viewRef.get();
      if (!view) {
        Trace.write(`${newValue} not set to view because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
        return;
      }
      const reset = isResetValue(newValue) || newValue === "";
      let value;
      if (reset) {
        value = defaultValue;
        delete this[sourceKey];
      } else {
        this[sourceKey] = 3;
        value = valueConverter && typeof newValue === "string" ? valueConverter(newValue) : newValue;
      }
      const oldValue = key in this ? this[key] : defaultValue;
      const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
      if (changed) {
        if (reset) {
          delete this[key];
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (view[setNative]) {
            if (view._suspendNativeUpdatesCount) {
              if (view._suspendedUpdates) {
                view._suspendedUpdates[propertyName] = property;
              }
            } else if (defaultValueKey in this) {
              view[setNative](this[defaultValueKey]);
              delete this[defaultValueKey];
            } else {
              view[setNative](defaultValue);
            }
          }
        } else {
          this[key] = value;
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (view[setNative]) {
            if (view._suspendNativeUpdatesCount) {
              if (view._suspendedUpdates) {
                view._suspendedUpdates[propertyName] = property;
              }
            } else {
              if (!(defaultValueKey in this)) {
                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
              }
              view[setNative](value);
            }
          }
        }
        if (this.hasListeners(eventName)) {
          this.notify({
            object: this,
            eventName,
            propertyName,
            value,
            oldValue
          });
        }
        if (affectsLayout) {
          view.requestLayout();
        }
      }
    }
    function setCssValue(newValue) {
      const view = this.viewRef.get();
      if (!view) {
        Trace.write(`${newValue} not set to view because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
        return;
      }
      const currentValueSource = this[sourceKey] || 0;
      if (currentValueSource === 3) {
        return;
      }
      const reset = isResetValue(newValue) || newValue === "";
      let value;
      if (reset) {
        value = defaultValue;
        delete this[sourceKey];
      } else {
        value = valueConverter && typeof newValue === "string" ? valueConverter(newValue) : newValue;
        this[sourceKey] = 2;
      }
      const oldValue = key in this ? this[key] : defaultValue;
      const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
      if (changed) {
        if (reset) {
          delete this[key];
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (view[setNative]) {
            if (view._suspendNativeUpdatesCount) {
              if (view._suspendedUpdates) {
                view._suspendedUpdates[propertyName] = property;
              }
            } else if (defaultValueKey in this) {
              view[setNative](this[defaultValueKey]);
              delete this[defaultValueKey];
            } else {
              view[setNative](defaultValue);
            }
          }
        } else {
          this[key] = value;
          if (valueChanged) {
            valueChanged(this, oldValue, value);
          }
          if (view[setNative]) {
            if (view._suspendNativeUpdatesCount) {
              if (view._suspendedUpdates) {
                view._suspendedUpdates[propertyName] = property;
              }
            } else {
              if (!(defaultValueKey in this)) {
                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
              }
              view[setNative](value);
            }
          }
        }
        if (this.hasListeners(eventName)) {
          this.notify({
            object: this,
            eventName,
            propertyName,
            value,
            oldValue
          });
        }
        if (affectsLayout) {
          view.requestLayout();
        }
      }
    }
    function get() {
      return key in this ? this[key] : defaultValue;
    }
    this.cssValueDescriptor = {
      enumerable: true,
      configurable: true,
      get,
      set: setCssValue
    };
    this.localValueDescriptor = {
      enumerable: true,
      configurable: true,
      get,
      set: setLocalValue
    };
    cssSymbolPropertyMap[key] = this;
  }
  register(cls) {
    if (this.registered) {
      throw new Error(`Property ${this.name} already registered.`);
    }
    this.registered = true;
    Object.defineProperty(cls.prototype, this.name, this.localValueDescriptor);
    Object.defineProperty(cls.prototype, this.cssName, this.cssValueDescriptor);
    if (this.cssLocalName !== this.cssName) {
      Object.defineProperty(cls.prototype, this.cssLocalName, this.localValueDescriptor);
    }
  }
  isSet(instance) {
    return this.key in instance;
  }
}
CssProperty.prototype.isStyleProperty = true;

class CssAnimationProperty {
  constructor(options) {
    const propertyName = options.name;
    this.name = propertyName;
    if (options.cssName) {
      cssPropertyNames.push(options.cssName);
    }
    CssAnimationProperty.properties[propertyName] = this;
    if (options.cssName && options.cssName !== propertyName) {
      CssAnimationProperty.properties[options.cssName] = this;
    }
    this._valueConverter = options.valueConverter;
    const cssLocalName = options.cssName || propertyName;
    this.cssLocalName = cssLocalName;
    const cssName = "css:" + cssLocalName;
    this.cssName = cssName;
    const keyframeName = "keyframe:" + propertyName;
    this.keyframe = keyframeName;
    const defaultName = "default:" + propertyName;
    const defaultValueKey = Symbol(defaultName);
    this.defaultValueKey = defaultValueKey;
    this.defaultValue = options.defaultValue;
    const cssValue = Symbol(cssName);
    const styleValue = Symbol(`local:${propertyName}`);
    const keyframeValue = Symbol(keyframeName);
    const computedValue = Symbol("computed-value:" + propertyName);
    this.key = computedValue;
    const computedSource = Symbol("computed-source:" + propertyName);
    this.source = computedSource;
    this.getDefault = Symbol(propertyName + ":getDefault");
    const getDefault = this.getDefault;
    const setNative = this.setNative = Symbol(propertyName + ":setNative");
    const eventName = propertyName + "Change";
    const property = this;
    function descriptor(symbol, propertySource, enumerable, configurable, getsComputed) {
      return {
        enumerable,
        configurable,
        get: getsComputed ? function() {
          return this[computedValue];
        } : function() {
          return this[symbol];
        },
        set(boxedValue) {
          const view = this.viewRef.get();
          if (!view) {
            Trace.write(`${boxedValue} not set to view because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
            return;
          }
          const oldValue = this[computedValue];
          const oldSource = this[computedSource];
          const wasSet = oldSource !== 0;
          const reset = isResetValue(boxedValue) || boxedValue === "";
          if (reset) {
            this[symbol] = boxedValue;
            if (this[computedSource] === propertySource) {
              if (!isResetValue(this[styleValue])) {
                this[computedSource] = 3;
                this[computedValue] = this[styleValue];
              } else if (!isResetValue(this[cssValue])) {
                this[computedSource] = 2;
                this[computedValue] = this[cssValue];
              } else {
                delete this[computedSource];
                delete this[computedValue];
              }
            }
          } else {
            if (options.valueConverter && typeof boxedValue === "string") {
              boxedValue = options.valueConverter(boxedValue);
            }
            this[symbol] = boxedValue;
            if (this[computedSource] <= propertySource) {
              this[computedSource] = propertySource;
              this[computedValue] = boxedValue;
            }
          }
          const value = this[computedValue];
          const source = this[computedSource];
          const isSet = source !== 0;
          const computedValueChanged = oldValue !== value && (!options.equalityComparer || !options.equalityComparer(oldValue, value));
          if (computedValueChanged && options.valueChanged) {
            options.valueChanged(this, oldValue, value);
          }
          if (view[setNative] && (computedValueChanged || isSet !== wasSet)) {
            if (view._suspendNativeUpdatesCount) {
              if (view._suspendedUpdates) {
                view._suspendedUpdates[propertyName] = property;
              }
            } else {
              if (isSet) {
                if (!wasSet && !(defaultValueKey in this)) {
                  this[defaultValueKey] = view[getDefault] ? view[getDefault]() : options.defaultValue;
                }
                view[setNative](value);
              } else if (wasSet) {
                if (defaultValueKey in this) {
                  view[setNative](this[defaultValueKey]);
                } else {
                  view[setNative](options.defaultValue);
                }
              }
            }
          }
          if (computedValueChanged && this.hasListeners(eventName)) {
            this.notify({
              object: this,
              eventName,
              propertyName,
              value,
              oldValue
            });
          }
        }
      };
    }
    const defaultPropertyDescriptor = descriptor(defaultValueKey, 0, false, false, false);
    const cssPropertyDescriptor = descriptor(cssValue, 2, false, false, false);
    const stylePropertyDescriptor = descriptor(styleValue, 3, true, true, true);
    const keyframePropertyDescriptor = descriptor(keyframeValue, 4, false, false, false);
    symbolPropertyMap[computedValue] = this;
    cssSymbolPropertyMap[computedValue] = this;
    this.register = (cls) => {
      cls.prototype[computedValue] = options.defaultValue;
      cls.prototype[computedSource] = 0;
      cls.prototype[cssValue] = unsetValue;
      cls.prototype[styleValue] = unsetValue;
      cls.prototype[keyframeValue] = unsetValue;
      Object.defineProperty(cls.prototype, defaultName, defaultPropertyDescriptor);
      Object.defineProperty(cls.prototype, cssName, cssPropertyDescriptor);
      Object.defineProperty(cls.prototype, propertyName, stylePropertyDescriptor);
      if (options.cssName && options.cssName !== options.name) {
        Object.defineProperty(cls.prototype, options.cssName, stylePropertyDescriptor);
      }
      Object.defineProperty(cls.prototype, keyframeName, keyframePropertyDescriptor);
    };
  }
  _initDefaultNativeValue(target) {
    const view = target.viewRef.get();
    if (!view) {
      Trace.write(`_initDefaultNativeValue not executed to view because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
      return;
    }
    const defaultValueKey = this.defaultValueKey;
    if (!(defaultValueKey in target)) {
      const getDefault = this.getDefault;
      target[defaultValueKey] = view[getDefault] ? view[getDefault]() : this.defaultValue;
    }
  }
  static _getByCssName(name) {
    return this.properties[name];
  }
  static _getPropertyNames() {
    return Object.keys(CssAnimationProperty.properties);
  }
  isSet(instance) {
    return instance[this.source] !== 0;
  }
}
CssAnimationProperty.properties = {};
CssAnimationProperty.prototype.isStyleProperty = true;

class InheritedCssProperty extends CssProperty {
  constructor(options) {
    super(options);
    const propertyName = options.name;
    const key = this.key;
    const sourceKey = this.sourceKey;
    const getDefault = this.getDefault;
    const setNative = this.setNative;
    const defaultValueKey = this.defaultValueKey;
    const eventName = propertyName + "Change";
    const defaultValue = options.defaultValue;
    let affectsLayout = options.affectsLayout;
    let equalityComparer = options.equalityComparer;
    let valueChanged = options.valueChanged;
    let valueConverter = options.valueConverter;
    const property = this;
    this.overrideHandlers = function(options2) {
      if (typeof options2.equalityComparer !== "undefined") {
        equalityComparer = options2.equalityComparer;
      }
      if (typeof options2.affectsLayout !== "undefined") {
        affectsLayout = options2.affectsLayout;
      }
      if (typeof options2.valueChanged !== "undefined") {
        valueChanged = options2.valueChanged;
      }
      if (typeof options2.valueConverter !== "undefined") {
        valueConverter = options2.valueConverter;
      }
    };
    const setFunc = (valueSource) => function(boxedValue) {
      const view = this.viewRef.get();
      if (!view) {
        Trace.write(`${boxedValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
        return;
      }
      const reset = isResetValue(boxedValue) || boxedValue === "";
      const currentValueSource = this[sourceKey] || 0;
      if (reset) {
        if (valueSource === 2 && currentValueSource === 3) {
          return;
        }
      } else {
        if (currentValueSource > valueSource) {
          return;
        }
      }
      const oldValue = key in this ? this[key] : defaultValue;
      let value;
      let unsetNativeValue = false;
      if (reset) {
        const parentStyle = view.parent ? view.parent.style : null;
        if (boxedValue !== "initial" && parentStyle && parentStyle[sourceKey] > 0) {
          value = parentStyle[propertyName];
          this[sourceKey] = 1;
          this[key] = value;
        } else {
          value = defaultValue;
          delete this[sourceKey];
          delete this[key];
          unsetNativeValue = true;
        }
      } else {
        this[sourceKey] = valueSource;
        if (valueConverter && typeof boxedValue === "string") {
          value = valueConverter(boxedValue);
        } else {
          value = boxedValue;
        }
        this[key] = value;
      }
      const changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
      if (changed) {
        if (valueChanged) {
          valueChanged(this, oldValue, value);
        }
        if (view[setNative]) {
          if (view._suspendNativeUpdatesCount) {
            if (view._suspendedUpdates) {
              view._suspendedUpdates[propertyName] = property;
            }
          } else if (unsetNativeValue) {
            if (defaultValueKey in this) {
              view[setNative](this[defaultValueKey]);
              delete this[defaultValueKey];
            } else {
              view[setNative](defaultValue);
            }
          } else {
            if (!(defaultValueKey in this)) {
              this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
            }
            view[setNative](value);
          }
        }
        if (this.hasListeners(eventName)) {
          this.notify({
            object: this,
            eventName,
            propertyName,
            value,
            oldValue
          });
        }
        if (affectsLayout) {
          view.requestLayout();
        }
        view.eachChild((child) => {
          const childStyle = child.style;
          const childValueSource = childStyle[sourceKey] || 0;
          if (reset) {
            if (childValueSource === 1) {
              setDefaultFunc.call(childStyle, unsetValue);
            }
          } else {
            if (childValueSource <= 1) {
              setInheritedFunc.call(childStyle, value);
            }
          }
          return true;
        });
      }
    };
    const setDefaultFunc = setFunc(0);
    const setInheritedFunc = setFunc(1);
    this.setInheritedValue = setInheritedFunc;
    this.cssValueDescriptor.set = setFunc(2);
    this.localValueDescriptor.set = setFunc(3);
    inheritableCssProperties.push(this);
  }
}

class ShorthandProperty {
  constructor(options) {
    this.name = options.name;
    const key = Symbol(this.name + ":propertyKey");
    this.key = key;
    this.cssName = `css:${options.cssName}`;
    this.cssLocalName = `${options.cssName}`;
    const converter = options.converter;
    function setLocalValue(value) {
      const view = this.viewRef.get();
      if (!view) {
        Trace.write(`setLocalValue not executed to view because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
        return;
      }
      view._batchUpdate(() => {
        for (const [p2, v] of converter(value)) {
          this[p2.name] = v;
        }
      });
    }
    function setCssValue(value) {
      const view = this.viewRef.get();
      if (!view) {
        Trace.write(`setCssValue not executed to view because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
        return;
      }
      view._batchUpdate(() => {
        for (const [p2, v] of converter(value)) {
          this[p2.cssName] = v;
        }
      });
    }
    this.cssValueDescriptor = {
      enumerable: true,
      configurable: true,
      get: options.getter,
      set: setCssValue
    };
    this.localValueDescriptor = {
      enumerable: true,
      configurable: true,
      get: options.getter,
      set: setLocalValue
    };
    this.propertyBagDescriptor = {
      enumerable: false,
      configurable: true,
      set(value) {
        converter(value).forEach(([property, value2]) => {
          this[property.cssLocalName] = value2;
        });
      }
    };
    cssSymbolPropertyMap[key] = this;
  }
  register(cls) {
    if (this.registered) {
      throw new Error(`Property ${this.name} already registered.`);
    }
    this.registered = true;
    Object.defineProperty(cls.prototype, this.name, this.localValueDescriptor);
    Object.defineProperty(cls.prototype, this.cssName, this.cssValueDescriptor);
    if (this.cssLocalName !== this.cssName) {
      Object.defineProperty(cls.prototype, this.cssLocalName, this.localValueDescriptor);
    }
    Object.defineProperty(cls.prototype.PropertyBag, this.cssLocalName, this.propertyBagDescriptor);
  }
}
function inheritablePropertyValuesOn(view) {
  const array = new Array;
  for (const prop of inheritableProperties) {
    const sourceKey = prop.sourceKey;
    const valueSource = view[sourceKey] || 0;
    if (valueSource !== 0) {
      array.push({ property: prop, value: view[prop.name] });
    }
  }
  return array;
}
function inheritableCssPropertyValuesOn(style) {
  const array = new Array;
  for (const prop of inheritableCssProperties) {
    const sourceKey = prop.sourceKey;
    const valueSource = style[sourceKey] || 0;
    if (valueSource !== 0) {
      array.push({ property: prop, value: style[prop.name] });
    }
  }
  return array;
}
var initNativeView = profile('"properties".initNativeView', function initNativeView2(view) {
  if (view._suspendedUpdates) {
    applyPendingNativeSetters(view);
  } else {
    applyAllNativeSetters(view);
  }
  view._suspendedUpdates = {};
});
function applyPendingNativeSetters(view) {
  const suspendedUpdates = view._suspendedUpdates;
  for (const propertyName in suspendedUpdates) {
    if (!HAS_OWN.call(suspendedUpdates, propertyName))
      continue;
    const property = suspendedUpdates[propertyName];
    const setNative = property.setNative;
    if (view[setNative]) {
      const { getDefault, isStyleProperty, defaultValueKey, defaultValue } = property;
      let value;
      if (isStyleProperty) {
        const style = view.style;
        if (property.isSet(view.style)) {
          if (!(defaultValueKey in style)) {
            style[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
          }
          value = view.style[propertyName];
        } else {
          value = style[defaultValueKey];
        }
      } else {
        if (property.isSet(view)) {
          if (!(defaultValueKey in view)) {
            view[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
          }
          value = view[propertyName];
        } else {
          value = view[defaultValueKey];
        }
      }
      view[setNative](value);
    }
  }
}
function applyAllNativeSetters(view) {
  let symbols = Object.getOwnPropertySymbols(view);
  for (const symbol of symbols) {
    const property = symbolPropertyMap[symbol];
    if (!property) {
      continue;
    }
    const setNative = property.setNative;
    const getDefault = property.getDefault;
    if (setNative in view) {
      const defaultValueKey = property.defaultValueKey;
      if (!(defaultValueKey in view)) {
        view[defaultValueKey] = view[getDefault] ? view[getDefault]() : property.defaultValue;
      }
      const value = view[symbol];
      view[setNative](value);
    }
  }
  const style = view.style;
  symbols = Object.getOwnPropertySymbols(style);
  for (const symbol of symbols) {
    const property = cssSymbolPropertyMap[symbol];
    if (!property) {
      continue;
    }
    if (view[property.setNative]) {
      const defaultValueKey = property.defaultValueKey;
      if (!(defaultValueKey in style)) {
        style[defaultValueKey] = view[property.getDefault] ? view[property.getDefault]() : property.defaultValue;
      }
      const value = style[symbol];
      view[property.setNative](value);
    }
  }
}
function clearInheritedProperties(view) {
  for (const prop of inheritableProperties) {
    const sourceKey = prop.sourceKey;
    if (view[sourceKey] === 1) {
      prop.set.call(view, unsetValue);
    }
  }
  const style = view.style;
  for (const prop of inheritableCssProperties) {
    const sourceKey = prop.sourceKey;
    if (style[sourceKey] === 1) {
      prop.setInheritedValue.call(style, unsetValue);
    }
  }
}
function propagateInheritableProperties(view, child) {
  const inheritablePropertyValues = inheritablePropertyValuesOn(view);
  for (const pair of inheritablePropertyValues) {
    const prop = pair.property;
    const sourceKey = prop.sourceKey;
    const currentValueSource = child[sourceKey] || 0;
    if (currentValueSource <= 1) {
      prop.setInheritedValue.call(child, pair.value);
    }
  }
}
function propagateInheritableCssProperties(parentStyle, childStyle) {
  const inheritableCssPropertyValues = inheritableCssPropertyValuesOn(parentStyle);
  for (const pair of inheritableCssPropertyValues) {
    const prop = pair.property;
    const sourceKey = prop.sourceKey;
    const currentValueSource = childStyle[sourceKey] || 0;
    if (currentValueSource <= 1) {
      prop.setInheritedValue.call(childStyle, pair.value, 1);
    }
  }
}
function getSetProperties(view) {
  const result = [];
  const ownProps = Object.getOwnPropertyNames(view);
  for (let i3 = 0;i3 < ownProps.length; i3++) {
    const prop = ownProps[i3];
    result.push([prop, view[prop]]);
  }
  const symbols = Object.getOwnPropertySymbols(view);
  for (const symbol of symbols) {
    const property = symbolPropertyMap[symbol];
    if (!property) {
      continue;
    }
    const value = view[property.key];
    result.push([property.name, value]);
  }
  return result;
}
function getComputedCssValues(view) {
  const result = [];
  const style = view.style;
  for (const prop of cssPropertyNames) {
    if (prop !== undefined && prop !== null) {
      result.push([prop, style[prop]]);
    }
  }
  result.push(["top", "auto"]);
  result.push(["left", "auto"]);
  result.push(["bottom", "auto"]);
  result.push(["right", "auto"]);
  return result;
}

// node_modules/@nativescript/core/ui/styling/font-common.js
var FONTS_BASE_PATH = "/fonts";

class Font {
  get isItalic() {
    return this.fontStyle === FontStyle.ITALIC;
  }
  get isBold() {
    return isFontWeightBold(this.fontWeight);
  }
  constructor(fontFamily, fontSize, fontStyle, fontWeight, fontScale, fontVariationSettings) {
    this.fontFamily = fontFamily;
    this.fontSize = fontSize;
    this.fontVariationSettings = fontVariationSettings;
    this.fontStyle = fontStyle ?? FontStyle.NORMAL;
    this.fontWeight = fontWeight ?? FontWeight.NORMAL;
    this.fontScale = fontScale ?? 1;
  }
  static equals(value1, value2) {
    if (!value1 && !value2) {
      return true;
    }
    if (!value1 || !value2) {
      return false;
    }
    return value1.fontFamily === value2.fontFamily && value1.fontSize === value2.fontSize && value1.fontStyle === value2.fontStyle && value1.fontWeight === value2.fontWeight && value1.fontScale === value2.fontScale && FontVariationSettings.toString(value1.fontVariationSettings) === FontVariationSettings.toString(value2.fontVariationSettings);
  }
}
Font.default = undefined;
var FontStyle;
(function(FontStyle2) {
  FontStyle2.NORMAL = "normal";
  FontStyle2.ITALIC = "italic";
  FontStyle2.isValid = makeValidator(FontStyle2.NORMAL, FontStyle2.ITALIC);
  FontStyle2.parse = makeParser(FontStyle2.isValid);
})(FontStyle || (FontStyle = {}));
var FontWeight;
(function(FontWeight2) {
  FontWeight2.THIN = "100";
  FontWeight2.EXTRA_LIGHT = "200";
  FontWeight2.LIGHT = "300";
  FontWeight2.NORMAL = "normal";
  FontWeight2.MEDIUM = "500";
  FontWeight2.SEMI_BOLD = "600";
  FontWeight2.BOLD = "bold";
  FontWeight2.EXTRA_BOLD = "800";
  FontWeight2.BLACK = "900";
  FontWeight2.isValid = makeValidator(FontWeight2.THIN, FontWeight2.EXTRA_LIGHT, FontWeight2.LIGHT, FontWeight2.NORMAL, "400", FontWeight2.MEDIUM, FontWeight2.SEMI_BOLD, FontWeight2.BOLD, "700", FontWeight2.EXTRA_BOLD, FontWeight2.BLACK);
  FontWeight2.parse = makeParser(FontWeight2.isValid);
})(FontWeight || (FontWeight = {}));
var FontVariationSettings;
(function(FontVariationSettings2) {
  function parse2(fontVariationSettings) {
    if (!fontVariationSettings) {
      return null;
    }
    const excluded = ["normal", "revert-layer"];
    const variationSettingsValue = fontVariationSettings.trim();
    if (excluded.indexOf(variationSettingsValue.toLowerCase()) !== -1) {
      return null;
    }
    const chunks = variationSettingsValue.split(",");
    if (chunks.length) {
      const parsed = [];
      for (const chunk of chunks) {
        const trimmedChunk = chunk.trim();
        const axisChunks = trimmedChunk.split(" ");
        if (axisChunks.length === 2) {
          const axisName = axisChunks[0].trim();
          const axisValue = parseFloat(axisChunks[1]);
          if (!isNaN(axisValue) && axisName.length === 6 && (axisName.startsWith("'") && axisName.endsWith("'") || axisName.startsWith('"') && axisName.endsWith('"'))) {
            const unquotedAxisName = axisName.substring(1, axisName.length - 1);
            parsed.push({ axis: unquotedAxisName, value: axisValue });
          } else {
            Trace.write("Invalid value (font-variation-settings): " + variationSettingsValue, Trace.categories.Error, Trace.messageType.error);
          }
        } else {
          Trace.write("Invalid value (font-variation-settings): " + variationSettingsValue, Trace.categories.Error, Trace.messageType.error);
        }
      }
      return parsed;
    }
    Trace.write("Invalid value (font-variation-settings): " + variationSettingsValue, Trace.categories.Error, Trace.messageType.error);
  }
  FontVariationSettings2.parse = parse2;
  function toString(fontVariationSettings) {
    if (fontVariationSettings?.length) {
      return fontVariationSettings.map(({ axis, value }) => `'${axis}' ${value}`).join(", ");
    }
    return null;
  }
  FontVariationSettings2.toString = toString;
})(FontVariationSettings || (FontVariationSettings = {}));
function parseFontFamily(value) {
  if (!value) {
    return [];
  }
  return value.split(",").map((v) => (v || "").trim().replace(/['"]+/g, "")).filter((v) => !!v);
}
function isFontWeightBold(fontWeight) {
  return fontWeight === FontWeight.SEMI_BOLD || fontWeight === FontWeight.BOLD || fontWeight === "700" || fontWeight === FontWeight.EXTRA_BOLD || fontWeight === FontWeight.BLACK;
}
var genericFontFamilies;
(function(genericFontFamilies2) {
  genericFontFamilies2.serif = "serif";
  genericFontFamilies2.sansSerif = "sans-serif";
  genericFontFamilies2.monospace = "monospace";
  genericFontFamilies2.system = "system";
})(genericFontFamilies || (genericFontFamilies = {}));
var styles = new Set([FontStyle.NORMAL, FontStyle.ITALIC]);
var weights = new Set([FontWeight.THIN, FontWeight.EXTRA_LIGHT, FontWeight.LIGHT, FontWeight.NORMAL, "400", FontWeight.MEDIUM, FontWeight.SEMI_BOLD, FontWeight.BOLD, "700", FontWeight.EXTRA_BOLD, FontWeight.BLACK]);
function parseFont(fontValue) {
  const result = {
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal"
  };
  const parts = fontValue.split(/\s+/);
  let part;
  while (part = parts.shift()) {
    if (part === "normal") {} else if (part === "small-caps") {
      result.fontVariant = part;
    } else if (styles.has(part)) {
      result.fontStyle = part;
    } else if (weights.has(part)) {
      result.fontWeight = part;
    } else if (!result.fontSize) {
      const sizes = part.split("/");
      result.fontSize = sizes[0];
      result.lineHeight = sizes.length > 1 ? sizes[1] : undefined;
    } else {
      result.fontFamily = part;
      if (parts.length) {
        result.fontFamily += " " + parts.join(" ");
      }
      break;
    }
  }
  return result;
}

// node_modules/@nativescript/core/ui/styling/font.android.js
var typefaceCache = new Map;
var appAssets;

class Font2 extends Font {
  withFontFamily(family) {
    return new Font2(family, this.fontSize, this.fontStyle, this.fontWeight, 1, this.fontVariationSettings);
  }
  withFontStyle(style) {
    return new Font2(this.fontFamily, this.fontSize, style, this.fontWeight, 1, this.fontVariationSettings);
  }
  withFontWeight(weight) {
    return new Font2(this.fontFamily, this.fontSize, this.fontStyle, weight, 1, this.fontVariationSettings);
  }
  withFontSize(size) {
    return new Font2(this.fontFamily, size, this.fontStyle, this.fontWeight, 1, this.fontVariationSettings);
  }
  withFontScale(scale) {
    return new Font2(this.fontFamily, this.fontSize, this.fontStyle, this.fontWeight, 1, this.fontVariationSettings);
  }
  withFontVariationSettings(variationSettings) {
    return new Font2(this.fontFamily, this.fontSize, this.fontStyle, this.fontWeight, 1, variationSettings);
  }
  getAndroidTypeface() {
    if (!this._typeface) {
      this._typeface = SDK_VERSION >= 28 ? createTypeface(this) : createTypefaceLegacy(this);
    }
    return this._typeface;
  }
  getUIFont(defaultFont) {
    return;
  }
}
Font2.default = new Font2(undefined, undefined);
function computeFontCacheKey(fontFamily, font) {
  const sep = ":";
  return [fontFamily, String(FontVariationSettings.toString(font.fontVariationSettings)).replace(/'/g, "").replace(/[\s,]/g, "_")].join(sep);
}
function loadFontFromFile(fontFamily, font) {
  const cacheKey = SDK_VERSION >= 26 ? computeFontCacheKey(fontFamily, font) : fontFamily;
  appAssets = appAssets || getNativeApp().getApplicationContext().getAssets();
  if (!appAssets) {
    return null;
  }
  let result;
  if (typefaceCache.has(cacheKey)) {
    result = typefaceCache.get(cacheKey);
  } else {
    const basePath = path.join(knownFolders.currentApp().path, FONTS_BASE_PATH, fontFamily);
    let fontAssetPath;
    if (File.exists(basePath + ".ttf")) {
      fontAssetPath = basePath + ".ttf";
    } else if (File.exists(basePath + ".otf")) {
      fontAssetPath = basePath + ".otf";
    } else {
      fontAssetPath = null;
      if (Trace.isEnabled()) {
        Trace.write("Could not find font file for " + fontFamily, Trace.categories.Error, Trace.messageType.error);
      }
    }
    result = null;
    if (fontAssetPath) {
      try {
        if (SDK_VERSION >= 26) {
          const builder = new android.graphics.Typeface.Builder(fontAssetPath);
          if (builder) {
            builder.setFontVariationSettings(font.fontVariationSettings?.length ? FontVariationSettings.toString(font.fontVariationSettings) : "");
            result = builder.build();
          } else {
            result = android.graphics.Typeface.createFromFile(fontAssetPath);
            if (Trace.isEnabled()) {
              Trace.write("Could not create builder for " + fontFamily, Trace.categories.Error, Trace.messageType.error);
            }
          }
        } else {
          result = android.graphics.Typeface.createFromFile(fontAssetPath);
        }
      } catch (e3) {
        if (Trace.isEnabled()) {
          Trace.write("Error loading font asset: " + fontAssetPath, Trace.categories.Error, Trace.messageType.error);
        }
      }
    }
    typefaceCache.set(cacheKey, result);
  }
  return result;
}
function createTypeface(font) {
  const fontFamilies = parseFontFamily(font.fontFamily);
  const fontWeightNum = getNumericFontWeight(font.fontWeight);
  let result;
  for (const fontFamily of fontFamilies) {
    switch (fontFamily.toLowerCase()) {
      case genericFontFamilies.serif:
        result = android.graphics.Typeface.create(android.graphics.Typeface.SERIF, fontWeightNum, font.isItalic);
        break;
      case genericFontFamilies.sansSerif:
      case genericFontFamilies.system:
        result = android.graphics.Typeface.create(android.graphics.Typeface.SANS_SERIF, fontWeightNum, font.isItalic);
        break;
      case genericFontFamilies.monospace:
        result = android.graphics.Typeface.create(android.graphics.Typeface.MONOSPACE, fontWeightNum, font.isItalic);
        break;
      default: {
        result = loadFontFromFile(fontFamily, font);
        if (result) {
          result = android.graphics.Typeface.create(result, fontWeightNum, font.isItalic);
        }
        break;
      }
    }
    if (result) {
      break;
    }
  }
  if (!result) {
    result = android.graphics.Typeface.create(android.graphics.Typeface.SANS_SERIF, fontWeightNum, font.isItalic);
  }
  return result;
}
function createTypefaceLegacy(font) {
  const fontFamilies = parseFontFamily(font.fontFamily);
  const fontWeight = font.fontWeight;
  const fontSuffix = getFontWeightSuffix(fontWeight);
  let result;
  let fontStyle = 0;
  if (font.isBold) {
    fontStyle |= android.graphics.Typeface.BOLD;
  }
  if (font.isItalic) {
    fontStyle |= android.graphics.Typeface.ITALIC;
  }
  for (const fontFamily of fontFamilies) {
    switch (fontFamily.toLowerCase()) {
      case genericFontFamilies.serif:
        result = android.graphics.Typeface.create("serif" + fontSuffix, fontStyle);
        break;
      case genericFontFamilies.sansSerif:
      case genericFontFamilies.system:
        result = android.graphics.Typeface.create("sans-serif" + fontSuffix, fontStyle);
        break;
      case genericFontFamilies.monospace:
        result = android.graphics.Typeface.create("monospace" + fontSuffix, fontStyle);
        break;
      default: {
        result = loadFontFromFile(fontFamily, font);
        if (result && fontStyle) {
          result = android.graphics.Typeface.create(result, fontStyle);
        }
        break;
      }
    }
    if (result) {
      break;
    }
  }
  if (!result) {
    result = android.graphics.Typeface.create("sans-serif" + fontSuffix, fontStyle);
  }
  return result;
}
function getFontWeightSuffix(fontWeight) {
  if (typeof fontWeight === "number") {
    fontWeight = fontWeight + "";
  }
  switch (fontWeight) {
    case FontWeight.THIN:
      return SDK_VERSION >= 16 ? "-thin" : "";
    case FontWeight.EXTRA_LIGHT:
    case FontWeight.LIGHT:
      return SDK_VERSION >= 16 ? "-light" : "";
    case FontWeight.NORMAL:
    case "400":
    case undefined:
    case null:
      return "";
    case FontWeight.MEDIUM:
    case FontWeight.SEMI_BOLD:
      return SDK_VERSION >= 21 ? "-medium" : "";
    case FontWeight.BOLD:
    case "700":
    case FontWeight.EXTRA_BOLD:
      return "";
    case FontWeight.BLACK:
      return SDK_VERSION >= 21 ? "-black" : "";
    default:
      throw new Error(`Invalid font weight: "${fontWeight}"`);
  }
}
function getNumericFontWeight(fontWeight) {
  let value;
  if (typeof fontWeight === "number") {
    value = fontWeight;
  } else {
    switch (fontWeight) {
      case FontWeight.NORMAL:
      case undefined:
      case null:
        value = 400;
        break;
      case FontWeight.BOLD:
        value = 700;
        break;
      default:
        value = parseInt(fontWeight);
        break;
    }
  }
  return value;
}

// node_modules/@nativescript/core/image-source/image-source-common.js
function getScaledDimensions(width, height, maxSize) {
  if (height >= width) {
    if (height <= maxSize) {
      return { width, height };
    }
    return {
      width: Math.round(maxSize * width / height),
      height: maxSize
    };
  }
  if (width <= maxSize) {
    return { width, height };
  }
  return {
    width: maxSize,
    height: Math.round(maxSize * height / width)
  };
}

// node_modules/@nativescript/core/image-source/index.android.js
function getApplication2() {
  return getNativeApp();
}

class ImageSource {
  get height() {
    if (this.android) {
      return this.android.getHeight();
    }
    return NaN;
  }
  get width() {
    if (this.android) {
      return this.android.getWidth();
    }
    return NaN;
  }
  get rotationAngle() {
    return this._rotationAngle;
  }
  set rotationAngle(value) {
    this._rotationAngle = value;
  }
  constructor(nativeSource) {
    if (nativeSource) {
      this.setNativeSource(nativeSource);
    }
  }
  static fromAsset(asset) {
    return new Promise((resolve, reject) => {
      asset.getImageAsync((image, err) => {
        if (image) {
          resolve(new ImageSource(image));
        } else {
          reject(err);
        }
      });
    });
  }
  static fromUrl(url) {
    return getImage(url);
  }
  static fromResourceSync(name) {
    const res = getApplication2().getResources();
    if (res) {
      const identifier = res.getIdentifier(name, "drawable", getApplication2().getPackageName());
      if (0 < identifier) {
        const bitmapDrawable = res.getDrawable(identifier);
        if (bitmapDrawable && bitmapDrawable.getBitmap) {
          return new ImageSource(bitmapDrawable.getBitmap());
        }
      }
    }
    return null;
  }
  static fromResource(name) {
    return new Promise((resolve, reject) => {
      resolve(ImageSource.fromResourceSync(name));
    });
  }
  static fromFileSync(path2) {
    let fileName = typeof path2 === "string" ? path2.trim() : "";
    if (fileName.indexOf("~/") === 0) {
      fileName = path.join(knownFolders.currentApp().path, fileName.replace("~/", ""));
    }
    const bitmap = android.graphics.BitmapFactory.decodeFile(fileName, null);
    if (bitmap) {
      const result = new ImageSource(bitmap);
      result.rotationAngle = getRotationAngleFromFile(fileName);
      return result;
    } else {
      return null;
    }
  }
  static fromFile(path2) {
    return new Promise((resolve, reject) => {
      resolve(ImageSource.fromFileSync(path2));
    });
  }
  static fromFileOrResourceSync(path2) {
    if (!isFileOrResourcePath(path2)) {
      throw new Error(`${path2} is not a valid file or resource.`);
    }
    if (path2.indexOf(RESOURCE_PREFIX) === 0) {
      return ImageSource.fromResourceSync(path2.substr(RESOURCE_PREFIX.length));
    }
    return ImageSource.fromFileSync(path2);
  }
  static iosSymbolScaleFor(scale) {
    return 0;
  }
  static fromSystemImageSync(name) {
    return ImageSource.fromResourceSync(name);
  }
  static fromSystemImage(name) {
    return ImageSource.fromResource(name);
  }
  static fromDataSync(data) {
    const bitmap = android.graphics.BitmapFactory.decodeStream(data);
    return bitmap ? new ImageSource(bitmap) : null;
  }
  static fromData(data) {
    return new Promise((resolve, reject) => {
      resolve(ImageSource.fromDataSync(data));
    });
  }
  static fromBase64Sync(source) {
    let bitmap;
    if (typeof source === "string") {
      const bytes = android.util.Base64.decode(source, android.util.Base64.DEFAULT);
      bitmap = android.graphics.BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
    }
    return bitmap ? new ImageSource(bitmap) : null;
  }
  static fromBase64(source) {
    return new Promise((resolve, reject) => {
      resolve(ImageSource.fromBase64Sync(source));
    });
  }
  static fromFontIconCodeSync(source, font, color2) {
    font = font || Font2.default;
    const paint = new android.graphics.Paint;
    paint.setTypeface(font.getAndroidTypeface());
    paint.setAntiAlias(true);
    if (color2) {
      paint.setColor(color2.android);
    }
    const scaledFontSize = layout.toDevicePixels(font.fontSize);
    if (scaledFontSize) {
      paint.setTextSize(scaledFontSize);
    }
    const textBounds = new android.graphics.Rect;
    paint.getTextBounds(source, 0, source.length, textBounds);
    const padding = 1;
    const textWidth = textBounds.width() + padding * 2;
    const textHeight = textBounds.height() + padding * 2;
    if (textWidth > 0 && textHeight > 0) {
      const bitmap = android.graphics.Bitmap.createBitmap(textWidth, textHeight, android.graphics.Bitmap.Config.ARGB_8888);
      const canvas = new android.graphics.Canvas(bitmap);
      canvas.drawText(source, -textBounds.left + padding, -textBounds.top + padding, paint);
      return new ImageSource(bitmap);
    }
    return null;
  }
  fromAsset(asset) {
    console.log("fromAsset() is deprecated. Use ImageSource.fromAsset() instead.");
    return ImageSource.fromAsset(asset).then((imgSource) => {
      this.setNativeSource(imgSource.android);
      return this;
    });
  }
  loadFromResource(name) {
    console.log("fromResource() and loadFromResource() are deprecated. Use ImageSource.fromResource[Sync]() instead.");
    const imgSource = ImageSource.fromResourceSync(name);
    this.android = imgSource ? imgSource.android : null;
    return !!this.android;
  }
  fromResource(name) {
    return new Promise((resolve, reject) => {
      resolve(this.loadFromResource(name));
    });
  }
  loadFromFile(path2) {
    console.log("fromFile() and loadFromFile() are deprecated. Use ImageSource.fromFile[Sync]() instead.");
    const imgSource = ImageSource.fromFileSync(path2);
    this.android = imgSource ? imgSource.android : null;
    return !!this.android;
  }
  fromFile(path2) {
    return new Promise((resolve, reject) => {
      resolve(this.loadFromFile(path2));
    });
  }
  loadFromData(data) {
    console.log("fromData() and loadFromData() are deprecated. Use ImageSource.fromData[Sync]() instead.");
    const imgSource = ImageSource.fromDataSync(data);
    this.android = imgSource ? imgSource.android : null;
    return !!this.android;
  }
  fromData(data) {
    return new Promise((resolve, reject) => {
      resolve(this.loadFromData(data));
    });
  }
  loadFromBase64(source) {
    console.log("fromBase64() and loadFromBase64() are deprecated. Use ImageSource.fromBase64[Sync]() instead.");
    const imgSource = ImageSource.fromBase64Sync(source);
    this.android = imgSource ? imgSource.android : null;
    return !!this.android;
  }
  fromBase64(data) {
    return new Promise((resolve, reject) => {
      resolve(this.loadFromBase64(data));
    });
  }
  loadFromFontIconCode(source, font, color2) {
    console.log("loadFromFontIconCode() is deprecated. Use ImageSource.fromFontIconCodeSync() instead.");
    const imgSource = ImageSource.fromFontIconCodeSync(source, font, color2);
    this.android = imgSource ? imgSource.android : null;
    return !!this.android;
  }
  getNativeSource() {
    return this.android;
  }
  setNativeSource(source) {
    if (!source) {
      this.android = null;
    } else if (source instanceof android.graphics.Bitmap) {
      this.android = source;
    } else if (source instanceof android.graphics.drawable.Drawable) {
      this.android = org.nativescript.widgets.Utils.getBitmapFromDrawable(source);
    } else {
      throw new Error("The method setNativeSource() expects an android.graphics.Bitmap or android.graphics.drawable.Drawable instance.");
    }
  }
  saveToFile(path2, format, quality = 100) {
    if (!this.android) {
      return false;
    }
    const targetFormat = getTargetFormat(format);
    const outputStream = new java.io.BufferedOutputStream(new java.io.FileOutputStream(path2));
    const res = this.android.compress(targetFormat, quality, outputStream);
    outputStream.close();
    return res;
  }
  saveToFileAsync(path2, format, quality = 100) {
    return new Promise((resolve, reject) => {
      org.nativescript.widgets.Utils.saveToFileAsync(this.android, path2, format, quality, new org.nativescript.widgets.Utils.AsyncImageCallback({
        onSuccess(param0) {
          resolve(param0);
        },
        onError(param0) {
          if (param0) {
            reject(param0.getMessage());
          } else {
            reject();
          }
        }
      }));
    });
  }
  toBase64String(format, quality = 100) {
    if (!this.android) {
      return null;
    }
    const targetFormat = getTargetFormat(format);
    const outputStream = new java.io.ByteArrayOutputStream;
    const base64Stream = new android.util.Base64OutputStream(outputStream, android.util.Base64.NO_WRAP);
    this.android.compress(targetFormat, quality, base64Stream);
    base64Stream.close();
    outputStream.close();
    return outputStream.toString();
  }
  toBase64StringAsync(format, quality = 100) {
    return new Promise((resolve, reject) => {
      org.nativescript.widgets.Utils.toBase64StringAsync(this.android, format, quality, new org.nativescript.widgets.Utils.AsyncImageCallback({
        onSuccess(param0) {
          resolve(param0);
        },
        onError(param0) {
          if (param0) {
            reject(param0.getMessage());
          } else {
            reject();
          }
        }
      }));
    });
  }
  resize(maxSize, options) {
    const dim = getScaledDimensions(this.android.getWidth(), this.android.getHeight(), maxSize);
    const bm = android.graphics.Bitmap.createScaledBitmap(this.android, dim.width, dim.height, options && options.filter);
    return new ImageSource(bm);
  }
  resizeAsync(maxSize, options) {
    return new Promise((resolve, reject) => {
      org.nativescript.widgets.Utils.resizeAsync(this.android, maxSize, JSON.stringify(options || {}), new org.nativescript.widgets.Utils.AsyncImageCallback({
        onSuccess(param0) {
          resolve(new ImageSource(param0));
        },
        onError(param0) {
          if (param0) {
            reject(param0.getMessage());
          } else {
            reject();
          }
        }
      }));
    });
  }
}
function getTargetFormat(format) {
  switch (format) {
    case "jpeg":
    case "jpg":
      return android.graphics.Bitmap.CompressFormat.JPEG;
    default:
      return android.graphics.Bitmap.CompressFormat.PNG;
  }
}
function getRotationAngleFromFile(filename) {
  let result = 0;
  const ei = new android.media.ExifInterface(filename);
  const orientation = ei.getAttributeInt(android.media.ExifInterface.TAG_ORIENTATION, android.media.ExifInterface.ORIENTATION_NORMAL);
  switch (orientation) {
    case android.media.ExifInterface.ORIENTATION_ROTATE_90:
      result = 90;
      break;
    case android.media.ExifInterface.ORIENTATION_ROTATE_180:
      result = 180;
      break;
    case android.media.ExifInterface.ORIENTATION_ROTATE_270:
      result = 270;
      break;
  }
  return result;
}

// node_modules/@nativescript/core/http/http-interfaces.js
var HttpResponseEncoding;
(function(HttpResponseEncoding2) {
  HttpResponseEncoding2[HttpResponseEncoding2["UTF8"] = 0] = "UTF8";
  HttpResponseEncoding2[HttpResponseEncoding2["GBK"] = 1] = "GBK";
})(HttpResponseEncoding || (HttpResponseEncoding = {}));

// node_modules/@nativescript/core/http/http-request/http-request-common.js
function getFilenameFromUrl(url) {
  const slashPos = url.lastIndexOf("/") + 1;
  const questionMarkPos = url.lastIndexOf("?");
  let actualFileName;
  if (questionMarkPos !== -1) {
    actualFileName = url.substring(slashPos, questionMarkPos);
  } else {
    actualFileName = url.substring(slashPos);
  }
  const result = path.join(knownFolders.documents().path, actualFileName);
  return result;
}

// node_modules/@nativescript/core/debugger/index.js
var network;
function getNetwork() {
  return network;
}
var NetworkAgent;
(function(NetworkAgent2) {
  function responseReceived(requestId, result, headers) {
    const requestIdStr = requestId.toString();
    const mimeType = headers["Content-Type"] || headers["content-type"] || "application/octet-stream";
    const contentLengthHeader = headers["Content-Length"] || headers["content-length"];
    let contentLength = parseInt(contentLengthHeader, 10);
    if (isNaN(contentLength)) {
      contentLength = 0;
    }
    const response = {
      url: result.url || "",
      status: result.statusCode,
      statusText: result.statusText || "",
      headers,
      mimeType,
      fromDiskCache: false,
      connectionReused: true,
      connectionId: 0,
      encodedDataLength: contentLength,
      securityState: "info"
    };
    const responseData = {
      requestId: requestIdStr,
      type: mimeTypeToType(response.mimeType),
      response,
      timestamp: getTimeStamp()
    };
    global.__inspector.responseReceived(responseData);
    global.__inspector.loadingFinished({
      requestId: requestIdStr,
      timestamp: getTimeStamp(),
      encodedDataLength: contentLength
    });
    const hasTextContent = responseData.type === "Document" || responseData.type === "Script";
    let data;
    if (!hasTextContent) {
      if (responseData.type === "Image") {
        const bitmap = result.responseAsImage;
        if (bitmap) {
          const outputStream = new java.io.ByteArrayOutputStream;
          bitmap.compress(android.graphics.Bitmap.CompressFormat.PNG, 100, outputStream);
          const base64Image = android.util.Base64.encodeToString(outputStream.toByteArray(), android.util.Base64.DEFAULT);
          data = base64Image;
        }
      }
    } else {
      data = result.responseAsString;
    }
    const successfulRequestData = {
      requestId: requestIdStr,
      data,
      hasTextContent
    };
    global.__inspector.dataForRequestId(successfulRequestData);
  }
  NetworkAgent2.responseReceived = responseReceived;
  function requestWillBeSent(requestId, options) {
    const request = {
      url: options.url,
      method: options.method,
      headers: options.headers || {},
      postData: options.content ? options.content.toString() : "",
      initialPriority: "Medium",
      referrerPolicy: "no-referrer-when-downgrade"
    };
    const requestData = {
      requestId: requestId.toString(),
      url: request.url,
      request,
      timestamp: getTimeStamp(),
      type: "Document",
      wallTime: 0
    };
    global.__inspector.requestWillBeSent(requestData);
  }
  NetworkAgent2.requestWillBeSent = requestWillBeSent;
  function getTimeStamp() {
    const d3 = new Date;
    return Math.round(d3.getTime() / 1000);
  }
  function mimeTypeToType(mimeType) {
    let type = "Document";
    if (mimeType) {
      if (mimeType.indexOf("image") === 0) {
        type = "Image";
      } else if (mimeType.indexOf("javascript") !== -1 || mimeType.indexOf("json") !== -1) {
        type = "Script";
      }
    }
    return type;
  }
})(NetworkAgent || (NetworkAgent = {}));

// node_modules/@nativescript/core/http/http-request/index.android.js
function parseJSON(source) {
  const src = source.trim();
  if (src.lastIndexOf(")") === src.length - 1) {
    return JSON.parse(src.substring(src.indexOf("(") + 1, src.lastIndexOf(")")));
  }
  return JSON.parse(src);
}
var requestIdCounter = 0;
var pendingRequests = {};
var debugRequests;
if (__DEV__) {
  debugRequests = new Map;
}
var completeCallback;
function ensureCompleteCallback() {
  if (completeCallback) {
    return;
  }
  completeCallback = new org.nativescript.widgets.Async.CompleteCallback({
    onComplete: function(result, context) {
      onRequestComplete(context, result);
    },
    onError: function(error, context) {
      onRequestError(error, context);
    }
  });
}
function onRequestComplete(requestId, result) {
  const callbacks = pendingRequests[requestId];
  delete pendingRequests[requestId];
  if (result.error) {
    callbacks.rejectCallback(new Error(result.error.toString()));
    return;
  }
  const headers = {};
  if (result.headers) {
    const jHeaders = result.headers;
    const length = jHeaders.size();
    let pair;
    for (let i3 = 0;i3 < length; i3++) {
      pair = jHeaders.get(i3);
      addHeader(headers, pair.key, pair.value);
    }
  }
  if (__DEV__) {
    const debugRequestInfo = debugRequests.get(requestId);
    if (debugRequestInfo) {
      const debugRequest = debugRequestInfo.debugRequest;
      let mime = headers["Content-Type"] ?? "text/plain";
      if (typeof mime === "string") {
        mime = mime.split(";")[0] ?? "text/plain";
      }
      debugRequest.mimeType = mime;
      debugRequest.data = result.raw;
      const debugResponse = {
        url: result.url,
        status: result.statusCode,
        statusText: result.statusText,
        headers,
        mimeType: mime,
        fromDiskCache: false,
        timing: {
          requestTime: debugRequestInfo.timestamp,
          proxyStart: -1,
          proxyEnd: -1,
          dnsStart: -1,
          dnsEnd: -1,
          connectStart: -1,
          connectEnd: -1,
          sslStart: -1,
          sslEnd: -1,
          serviceWorkerFetchStart: -1,
          serviceWorkerFetchReady: -1,
          serviceWorkerFetchEnd: -1,
          sendStart: -1,
          sendEnd: -1,
          receiveHeadersEnd: -1
        }
      };
      debugRequest.responseReceived(debugResponse);
      debugRequest.loadingFinished();
      debugRequests.delete(requestId);
    }
  }
  callbacks.resolveCallback({
    content: {
      raw: result.raw,
      toArrayBuffer: () => Uint8Array.from(result.raw.toByteArray()).buffer,
      toString: (encoding2) => {
        let str;
        if (encoding2) {
          str = decodeResponse(result.raw, encoding2);
        } else {
          str = result.responseAsString;
        }
        if (typeof str === "string") {
          return str;
        } else {
          throw new Error("Response content may not be converted to string");
        }
      },
      toJSON: (encoding2) => {
        let str;
        if (encoding2) {
          str = decodeResponse(result.raw, encoding2);
        } else {
          str = result.responseAsString;
        }
        return parseJSON(str);
      },
      toImage: () => {
        return new Promise((resolveImage, rejectImage) => {
          if (result.responseAsImage != null) {
            resolveImage(new ImageSource(result.responseAsImage));
          } else {
            rejectImage(new Error("Response content may not be converted to an Image"));
          }
        });
      },
      toFile: (destinationFilePath) => {
        if (!destinationFilePath) {
          destinationFilePath = getFilenameFromUrl(callbacks.url);
        }
        let stream;
        try {
          const file = File.fromPath(destinationFilePath);
          const javaFile = new java.io.File(destinationFilePath);
          stream = new java.io.FileOutputStream(javaFile);
          stream.write(result.raw.toByteArray());
          return file;
        } catch (exception) {
          throw new Error(`Cannot save file with path: ${destinationFilePath}.`);
        } finally {
          if (stream) {
            stream.close();
          }
        }
      }
    },
    statusCode: result.statusCode,
    headers
  });
}
function onRequestError(error, requestId) {
  const callbacks = pendingRequests[requestId];
  delete pendingRequests[requestId];
  if (callbacks) {
    callbacks.rejectCallback(new Error(error));
  }
}
function buildJavaOptions(options) {
  if (typeof options.url !== "string") {
    throw new Error("Http request must provide a valid url.");
  }
  const javaOptions = new org.nativescript.widgets.Async.Http.RequestOptions;
  javaOptions.url = options.url;
  if (typeof options.method === "string") {
    javaOptions.method = options.method;
  }
  if (typeof options.content === "string" || options.content instanceof FormData) {
    const nativeString = new java.lang.String(options.content.toString());
    const nativeBytes = nativeString.getBytes("UTF-8");
    const nativeBuffer = java.nio.ByteBuffer.wrap(nativeBytes);
    javaOptions.content = nativeBuffer;
  } else if (options.content instanceof ArrayBuffer) {
    const typedArray = new Uint8Array(options.content);
    const nativeBuffer = java.nio.ByteBuffer.wrap(Array.from(typedArray));
    javaOptions.content = nativeBuffer;
  }
  if (typeof options.timeout === "number") {
    javaOptions.timeout = options.timeout;
  }
  if (typeof options.dontFollowRedirects === "boolean") {
    javaOptions.dontFollowRedirects = options.dontFollowRedirects;
  }
  if (options.headers) {
    const arrayList = new java.util.ArrayList;
    const pair = org.nativescript.widgets.Async.Http.KeyValuePair;
    for (const key in options.headers) {
      arrayList.add(new pair(key, options.headers[key] + ""));
    }
    javaOptions.headers = arrayList;
  }
  javaOptions.screenWidth = Screen.mainScreen.widthPixels;
  javaOptions.screenHeight = Screen.mainScreen.heightPixels;
  return javaOptions;
}
function request(options) {
  if (options === undefined || options === null) {
    return;
  }
  return new Promise((resolve, reject) => {
    try {
      const javaOptions = buildJavaOptions(options);
      if (__DEV__) {
        const network2 = getNetwork();
        const debugRequest = network2 && network2.create();
        if (options.url && debugRequest) {
          const timestamp = Date.now() / 1000;
          debugRequests.set(requestIdCounter, {
            debugRequest,
            timestamp
          });
          const request2 = {
            url: options.url,
            method: "GET",
            headers: options.headers,
            timestamp
          };
          debugRequest.requestWillBeSent(request2);
        }
      }
      const callbacks = {
        url: options.url,
        resolveCallback: resolve,
        rejectCallback: reject
      };
      pendingRequests[requestIdCounter] = callbacks;
      ensureCompleteCallback();
      org.nativescript.widgets.Async.Http.MakeRequest(javaOptions, completeCallback, new java.lang.Integer(requestIdCounter));
      requestIdCounter++;
    } catch (ex) {
      reject(ex);
    }
  });
}
function decodeResponse(raw, encoding2) {
  let charsetName = "UTF-8";
  if (encoding2 === HttpResponseEncoding.GBK) {
    charsetName = "GBK";
  }
  return raw.toString(charsetName);
}
function addHeader(headers, key, value) {
  if (!headers[key]) {
    headers[key] = value;
  } else if (Array.isArray(headers[key])) {
    headers[key].push(value);
  } else {
    const values = [headers[key]];
    values.push(value);
    headers[key] = values;
  }
}
// node_modules/@nativescript/core/http/index.js
function getImage(arg) {
  return new Promise((resolve, reject) => {
    request(typeof arg === "string" ? { url: arg, method: "GET" } : arg).then((r3) => {
      try {
        resolve(r3.content.toImage());
      } catch (err) {
        reject(err);
      }
    }, (err) => {
      reject(err);
    });
  });
}

// node_modules/@nativescript/core/xhr/index.js
var _a2;
var _b2;
var _c;
var XMLHttpRequestResponseType;
(function(XMLHttpRequestResponseType2) {
  XMLHttpRequestResponseType2.empty = "";
  XMLHttpRequestResponseType2.text = "text";
  XMLHttpRequestResponseType2.json = "json";
  XMLHttpRequestResponseType2.blob = "blob";
  XMLHttpRequestResponseType2.arraybuffer = "arraybuffer";
})(XMLHttpRequestResponseType || (XMLHttpRequestResponseType = {}));

class XMLHttpRequest2 {
  get upload() {
    return this;
  }
  get readyState() {
    return this._readyState;
  }
  get responseType() {
    return this._responseType;
  }
  set responseType(value) {
    if (value === XMLHttpRequestResponseType.empty || value in XMLHttpRequestResponseType) {
      this._responseType = value;
    } else {
      throw new Error(`Response type of '${value}' not supported.`);
    }
  }
  get responseText() {
    if (this._responseType !== XMLHttpRequestResponseType.empty && this._responseType !== XMLHttpRequestResponseType.text) {
      throw new Error("Failed to read the 'responseText' property from 'XMLHttpRequest': " + "The value is only accessible if the object's 'responseType' is '' or 'text' " + `(was '${this._responseType}').`);
    }
    if (isFunction(this._responseTextReader)) {
      return this._responseTextReader();
    }
    return "";
  }
  get response() {
    if (this._responseType === XMLHttpRequestResponseType.empty || this._responseType === XMLHttpRequestResponseType.text) {
      if (this._readyState !== this.LOADING && this._readyState !== this.DONE) {
        return "";
      } else {
        return this._response;
      }
    } else {
      if (this._readyState !== this.DONE) {
        return null;
      } else {
        return this._response;
      }
    }
  }
  get status() {
    return this._status;
  }
  get statusText() {
    if (this._readyState === this.UNSENT || this._readyState === this.OPENED || this._errorFlag) {
      return "";
    }
    return statuses[this._status];
  }
  constructor() {
    this.UNSENT = 0;
    this.OPENED = 1;
    this.HEADERS_RECEIVED = 2;
    this.LOADING = 3;
    this.DONE = 4;
    this._responseType = "";
    this._listeners = new Map;
    this._readyState = this.UNSENT;
  }
  _loadResponse(r3) {
    this._status = r3.statusCode;
    this._headers = r3.headers;
    this._setReadyState(this.HEADERS_RECEIVED);
    this._setReadyState(this.LOADING);
    this._responseTextReader = () => r3.content.toString();
    const contentType = this.getResponseHeader("Content-Type");
    const mimeType = contentType && contentType.toLowerCase() || "text/xml";
    const finalMimeType = this._overrideMimeType || mimeType;
    if (this._responseType === XMLHttpRequestResponseType.json) {
      this._response = r3.content.toJSON();
    } else if (this._responseType === XMLHttpRequestResponseType.text || this._responseType === XMLHttpRequestResponseType.empty) {
      this._response = this.responseText;
    } else if (this._responseType === XMLHttpRequestResponseType.arraybuffer) {
      this._response = r3.content.toArrayBuffer();
    } else if (this._responseType === XMLHttpRequestResponseType.blob) {
      this._response = new Blob2([r3.content.toArrayBuffer()], {
        type: finalMimeType
      });
    }
    this.emitEvent("progress");
    this._sendFlag = false;
    this._setReadyState(this.DONE);
  }
  emitEvent(eventName, ...args) {
    if (isFunction(this["on" + eventName])) {
      this["on" + eventName](...args);
    }
    const handlers = this._listeners.get(eventName) || [];
    handlers.forEach((handler) => {
      handler(...args);
    });
  }
  _setReadyState(value) {
    if (this._readyState !== value) {
      this._readyState = value;
      this.emitEvent("readystatechange");
    }
    if (this._readyState === this.DONE) {
      this.emitEvent("load");
      this.emitEvent("loadend");
    }
  }
  _setRequestError(eventName, error) {
    this._readyState = this.DONE;
    this._response = error;
    this.emitEvent("readystatechange");
    this.emitEvent(eventName, error);
    this.emitEvent("loadend");
  }
  addEventListener(eventName, handler) {
    if (["abort", "error", "load", "loadend", "loadstart", "progress", "readystatechange"].indexOf(eventName) === -1) {
      if (Trace.isEnabled()) {
        Trace.write("XHR Event not supported: " + eventName, Trace.categories.Debug, Trace.messageType.warn);
      }
    }
    const handlers = this._listeners.get(eventName) || [];
    handlers.push(handler);
    this._listeners.set(eventName, handlers);
  }
  removeEventListener(eventName, toDetach) {
    let handlers = this._listeners.get(eventName) || [];
    handlers = handlers.filter((handler) => handler !== toDetach);
    this._listeners.set(eventName, handlers);
  }
  open(method, url, async, user, password) {
    if (isString(method) && isString(url)) {
      this._options = { url, method };
      this._options.headers = {};
      if (isString(user)) {
        this._options.headers["user"] = user;
      }
      if (isString(password)) {
        this._options.headers["password"] = password;
      }
      this._setReadyState(this.OPENED);
    }
  }
  abort() {
    this._response = null;
    this._responseTextReader = null;
    this._headers = null;
    this._status = null;
    if (this._readyState === this.OPENED && this._sendFlag || this._readyState === this.HEADERS_RECEIVED || this._readyState === this.LOADING) {
      this._errorFlag = true;
      this._sendFlag = false;
      this._setRequestError("abort");
    }
    if (this._readyState === this.DONE) {
      this._readyState = this.UNSENT;
    }
  }
  send(data) {
    this._errorFlag = false;
    this._response = null;
    this._responseTextReader = null;
    this._headers = null;
    this._status = null;
    if (this._readyState !== this.OPENED || this._sendFlag) {
      throw new Error("Failed to execute 'send' on 'XMLHttpRequest': " + "The object's state must be OPENED.");
    }
    if (isString(data) && this._options.method !== "GET") {
      this._options.content = data;
    } else if (data instanceof FormData2) {
      this._options.content = data.toString();
    } else if (data instanceof Blob2) {
      this.setRequestHeader("Content-Type", data.type);
      this._options.content = Blob2.InternalAccessor.getBuffer(data);
    } else if (data instanceof ArrayBuffer) {
      this._options.content = data;
    }
    this._sendFlag = true;
    this.emitEvent("loadstart");
    request(this._options).then((r3) => {
      if (!this._errorFlag && this._sendFlag) {
        this._loadResponse(r3);
      }
    }).catch((e3) => {
      this._errorFlag = true;
      this._sendFlag = false;
      this._setRequestError("error", e3);
    });
  }
  setRequestHeader(header, value) {
    if (this._readyState !== this.OPENED || this._sendFlag) {
      throw new Error("Failed to execute 'setRequestHeader' on 'XMLHttpRequest': " + "The object's state must be OPENED.");
    }
    if (isString(header) && isString(value)) {
      this._options.headers[header] = value;
    }
  }
  getAllResponseHeaders() {
    if (this._readyState < 2 || this._errorFlag) {
      return "";
    }
    let result = "";
    for (const i3 in this._headers) {
      result += i3 + ": " + this._headers[i3] + `\r
`;
    }
    return result.substr(0, result.length - 2);
  }
  getResponseHeader(header) {
    if (isString(header) && this._readyState > 1 && this._headers && !this._errorFlag) {
      header = header.toLowerCase();
      for (const i3 in this._headers) {
        if (i3.toLowerCase() === header) {
          return this._headers[i3];
        }
      }
    }
    return null;
  }
  overrideMimeType(mime) {
    if (this._readyState === this.LOADING || this._readyState === this.DONE) {
      throw new Error("Failed to execute 'overrideMimeType' on 'XMLHttpRequest': " + "MimeType cannot be overridden when the state is LOADING or DONE.");
    }
    this._overrideMimeType = mime;
  }
}
var statuses = {
  100: "Continue",
  101: "Switching Protocols",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non - Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Request Entity Too Large",
  414: "Request - URI Too Long",
  415: "Unsupported Media Type",
  416: "Requested Range Not Satisfiable",
  417: "Expectation Failed",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported"
};

class FormData2 {
  constructor() {
    this._data = new Map;
  }
  append(name, value) {
    this._data.set(name, value);
  }
  toString() {
    const arr = new Array;
    this._data.forEach(function(value, name, map) {
      arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`);
    });
    return arr.join("&");
  }
}

class Blob2 {
  get size() {
    return this._size;
  }
  get type() {
    return this._type;
  }
  constructor(chunks = [], opts = {}) {
    this[_a2] = "Blob";
    const dataChunks = [];
    for (const chunk of chunks) {
      if (chunk instanceof Blob2) {
        dataChunks.push(chunk._buffer);
      } else if (typeof chunk === "string") {
        const textEncoder = new TextEncoder;
        dataChunks.push(textEncoder.encode(chunk));
      } else if (chunk instanceof DataView) {
        dataChunks.push(new Uint8Array(chunk.buffer.slice(0)));
      } else if (chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk)) {
        dataChunks.push(new Uint8Array(ArrayBuffer.isView(chunk) ? chunk.buffer.slice(0) : chunk.slice(0)));
      } else {
        const textEncoder = new TextEncoder;
        dataChunks.push(textEncoder.encode(String(chunk)));
      }
    }
    const size = dataChunks.reduce((size2, chunk) => size2 + chunk.byteLength, 0);
    const buffer = new Uint8Array(size);
    let offset = 0;
    for (let i3 = 0;i3 < dataChunks.length; i3++) {
      const chunk = dataChunks[i3];
      buffer.set(chunk, offset);
      offset += chunk.byteLength;
    }
    this._buffer = buffer;
    this._size = this._buffer.byteLength;
    this._type = opts.type || "";
    if (/[^\u0020-\u007E]/.test(this._type)) {
      this._type = "";
    } else {
      this._type = this._type.toLowerCase();
    }
  }
  arrayBuffer() {
    return Promise.resolve(this._buffer);
  }
  text() {
    const textDecoder = new TextDecoder;
    return Promise.resolve(textDecoder.decode(this._buffer));
  }
  slice(start2, end, type) {
    const slice = this._buffer.slice(start2 || 0, end || this._buffer.length);
    return new Blob2([slice], { type });
  }
  stream() {
    throw new Error("stream is currently not supported");
  }
  toString() {
    return "[object Blob]";
  }
}
_a2 = Symbol.toStringTag;
Blob2.InternalAccessor = class {
  static getBuffer(blob) {
    return blob._buffer;
  }
};

class File2 extends Blob2 {
  get name() {
    return this._name;
  }
  get lastModified() {
    return this._lastModified;
  }
  constructor(chunks, name, opts = {}) {
    super(chunks, opts);
    this[_b2] = "File";
    this._name = name.replace(/\//g, ":");
    this._lastModified = opts.lastModified ? new Date(opts.lastModified).valueOf() : Date.now();
  }
  toString() {
    return "[object File]";
  }
}
_b2 = Symbol.toStringTag;

class FileReader2 {
  get readyState() {
    return this._readyState;
  }
  get result() {
    return this._result;
  }
  constructor() {
    this.EMPTY = 0;
    this.LOADING = 1;
    this.DONE = 2;
    this._listeners = new Map;
    this[_c] = "FileReader";
  }
  _array2base64(input) {
    const byteToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    const output = [];
    for (let i3 = 0;i3 < input.length; i3 += 3) {
      const byte1 = input[i3];
      const haveByte2 = i3 + 1 < input.length;
      const byte2 = haveByte2 ? input[i3 + 1] : 0;
      const haveByte3 = i3 + 2 < input.length;
      const byte3 = haveByte3 ? input[i3 + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  }
  _read(blob, kind) {
    if (!(blob instanceof Blob2)) {
      throw new TypeError(`Failed to execute '${kind}' on 'FileReader': parameter 1 is not of type 'Blob'.`);
    }
    this._result = "";
    setTimeout(() => {
      this._readyState = this.LOADING;
      this.emitEvent("load");
      this.emitEvent("loadend");
    });
  }
  emitEvent(eventName, ...args) {
    if (isFunction(this["on" + eventName])) {
      this["on" + eventName](...args);
    }
    const handlers = this._listeners.get(eventName) || [];
    handlers.forEach((handler) => {
      handler(...args);
    });
  }
  addEventListener(eventName, handler) {
    if (["abort", "error", "load", "loadend", "loadstart", "progress"].indexOf(eventName) === -1) {
      throw new Error("Event not supported: " + eventName);
    }
    const handlers = this._listeners.get(eventName) || [];
    handlers.push(handler);
    this._listeners.set(eventName, handlers);
  }
  removeEventListener(eventName, toDetach) {
    let handlers = this._listeners.get(eventName) || [];
    handlers = handlers.filter((handler) => handler !== toDetach);
    this._listeners.set(eventName, handlers);
  }
  readAsDataURL(blob) {
    this._read(blob, "readAsDataURL");
    this._result = `data:${blob.type};base64,${this._array2base64(Blob2.InternalAccessor.getBuffer(blob))}`;
  }
  readAsText(blob) {
    this._read(blob, "readAsText");
    const textDecoder = new TextDecoder;
    this._result = textDecoder.decode(Blob2.InternalAccessor.getBuffer(blob));
  }
  readAsArrayBuffer(blob) {
    this._read(blob, "readAsArrayBuffer");
    this._result = Blob2.InternalAccessor.getBuffer(blob).buffer.slice(0);
  }
  abort() {}
  toString() {
    return "[object FileReader]";
  }
}
_c = Symbol.toStringTag;

// node_modules/@nativescript/core/fetch/index.js
var exports_fetch = {};
__export(exports_fetch, {
  fetch: () => fetch,
  Response: () => Response,
  Request: () => Request,
  Headers: () => Headers,
  DOMException: () => DOMException,
  Body: () => Body
});
var g2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g2,
  iterable: "Symbol" in g2 && "iterator" in Symbol,
  blob: "FileReader" in g2 && "Blob" in g2 && (() => {
    try {
      new Blob;
      return true;
    } catch (e3) {
      return false;
    }
  })(),
  formData: "FormData" in g2,
  arrayBuffer: "ArrayBuffer" in g2
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
var isArrayBufferView;
if (support.arrayBuffer) {
  const viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"];
  isArrayBufferView = ArrayBuffer.isView || ((obj) => {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  });
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  const iterator = {
    next: () => {
      const value = items.shift();
      return { done: value === undefined, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = () => iterator;
  }
  return iterator;
}

class Headers {
  constructor(headers) {
    this.map = {};
    if (headers instanceof Headers) {
      headers.forEach((value, name) => {
        this.append(name, value);
      });
    } else if (Array.isArray(headers)) {
      headers.forEach((header) => {
        if (header.length !== 2) {
          throw new TypeError("Headers constructor: expected name/value pair to be length 2, found " + header.length);
        }
        this.append(header[0], header[1]);
      });
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach((name) => {
        this.append(name, headers[name]);
      });
    }
  }
  append(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    const oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
  }
  delete(name) {
    delete this.map[normalizeName(name)];
  }
  get(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.map, normalizeName(name));
  }
  set(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  }
  forEach(callback, thisArg) {
    for (const name in this.map) {
      if (Object.prototype.hasOwnProperty.call(this.map, name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  }
  keys() {
    const items = [];
    this.forEach((_3, name) => items.push(name));
    return iteratorFor(items);
  }
  values() {
    const items = [];
    this.forEach((value) => items.push(value));
    return iteratorFor(items);
  }
  entries() {
    const items = [];
    this.forEach((value, name) => items.push([name, value]));
    return iteratorFor(items);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
}

class Body {
  constructor() {
    this.bodyUsed = false;
  }
  _initBody(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  }
  blob() {
    const rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return Promise.resolve(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as blob");
    } else {
      return Promise.resolve(new Blob([this._bodyText]));
    }
  }
  arrayBuffer() {
    if (this._bodyArrayBuffer) {
      const consumedResult = consumed(this);
      if (consumedResult) {
        return consumedResult;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  }
  text() {
    const rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  }
  formData() {
    return this.text().then(decode);
  }
  json() {
    return this.text().then(JSON.parse);
  }
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise((resolve, reject) => {
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
  });
}
function readBlobAsArrayBuffer(blob) {
  const reader = new FileReader;
  const promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  const reader = new FileReader;
  const promise = fileReaderReady(reader);
  const match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  const encoding2 = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding2);
  return promise;
}
function readArrayBufferAsText(buf) {
  const view = new Uint8Array(buf);
  const chars = new Array(view.length);
  for (let i3 = 0;i3 < view.length; i3++) {
    chars[i3] = String.fromCharCode(view[i3]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    const view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  const upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

class Request extends Body {
  constructor(input, options = {}) {
    super();
    let body = options.body;
    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError("Already read");
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }
    this.credentials = options.credentials || this.credentials || "same-origin";
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || "GET");
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal || ("AbortController" in g2 ? new AbortController().signal : undefined);
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
      throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
      if (options.cache === "no-store" || options.cache === "no-cache") {
        const reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
        } else {
          const reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
        }
      }
    }
  }
  clone() {
    return new Request(this, { body: this._bodyInit });
  }
}
function decode(body) {
  const form = new FormData;
  body.trim().split("&").forEach((bytes) => {
    if (bytes) {
      const split = bytes.split("=");
      const name = split.shift().replace(/\+/g, " ");
      const value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  const headers = new Headers;
  const preProcessed = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessed.split("\r").map((header) => header.indexOf(`
`) === 0 ? header.substr(1) : header).forEach((line) => {
    const parts = line.split(":");
    const key = parts.shift().trim();
    if (key) {
      const value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (err) {
        console.warn("Response " + err.message);
      }
    }
  });
  return headers;
}
var redirectStatuses = [301, 302, 303, 307, 308];

class Response extends Body {
  constructor(bodyInit, options = {}) {
    super();
    this.type = "default";
    this.status = options.status === undefined ? 200 : options.status;
    if (this.status < 200 || this.status > 599) {
      throw new RangeError(`Failed to construct 'Response': The status provided (${this.status}) is outside the range [200, 599].`);
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === undefined ? "" : String(options.statusText);
    this.headers = new Headers(options.headers);
    this.url = options.url || "";
    this._initBody(bodyInit);
  }
  clone() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  }
  static error() {
    const response = new Response(null, { status: 200, statusText: "" });
    response.ok = false;
    response.status = 0;
    response.type = "error";
    return response;
  }
  static redirect(url, status) {
    if (!redirectStatuses.includes(status)) {
      throw new RangeError("Invalid status code");
    }
    return new Response(null, { status, headers: { location: url } });
  }
}
var DOMException = g2.DOMException;
try {
  new g2.DOMException;
} catch (err) {
  DOMException = class {
    constructor(message, name) {
      this.message = message;
      this.name = name;
      const error = new Error(message);
      this.stack = error.stack;
    }
  };
}
function fetch(input, init) {
  return new Promise((resolve, reject) => {
    const request2 = new Request(input, init);
    if (request2.signal && request2.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    const xhr = new XMLHttpRequest;
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      const options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request2.url.startsWith("file://") && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      const body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(() => resolve(new Response(body, options)), 0);
    };
    xhr.onerror = function() {
      setTimeout(() => reject(new TypeError("Network request failed")), 0);
    };
    xhr.ontimeout = function() {
      setTimeout(() => reject(new TypeError("Network request timed out")), 0);
    };
    xhr.onabort = function() {
      setTimeout(() => reject(new DOMException("Aborted", "AbortError")), 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g2.location.href ? g2.location.href : url;
      } catch (e3) {
        return url;
      }
    }
    xhr.open(request2.method, fixUrl(request2.url), true);
    if (request2.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request2.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers) && !(g2.Headers && init.headers instanceof g2.Headers)) {
      const names = [];
      Object.getOwnPropertyNames(init.headers).forEach((name) => {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request2.headers.forEach((value, name) => {
        if (!names.includes(name)) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request2.headers.forEach((value, name) => xhr.setRequestHeader(name, value));
    }
    if (request2.signal) {
      request2.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request2.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
  });
}
fetch.polyfill = true;
if (!g2.fetch) {
  g2.fetch = fetch;
  g2.Headers = Headers;
  g2.Request = Request;
  g2.Response = Response;
}

// node_modules/@nativescript/core/wgc/index.js
var exports_wgc = {};
__export(exports_wgc, {
  btoa: () => btoa,
  atob: () => atob
});

// node_modules/@nativescript/core/wgc/atob.js
function atob(data) {
  if (__ANDROID__) {
    return org.nativescript.winter_tc.Utils.atob(data);
  }
  if (__IOS__) {
    return NSString.atob(data);
  }
}
// node_modules/@nativescript/core/wgc/btoa.js
function btoa(stringToEncode) {
  if (__ANDROID__) {
    return org.nativescript.winter_tc.Utils.btoa(stringToEncode);
  }
  if (__IOS__) {
    return NSString.btoa(stringToEncode);
  }
}
// node_modules/@nativescript/core/wgc/crypto/index.js
var exports_crypto = {};
__export(exports_crypto, {
  Crypto: () => Crypto
});

// node_modules/@nativescript/core/wgc/crypto/SubtleCrypto.js
var exports_SubtleCrypto = {};
__export(exports_SubtleCrypto, {
  SubtleCrypto: () => SubtleCrypto,
  CryptoKeyPair: () => CryptoKeyPair,
  CryptoKey: () => CryptoKey
});
var _a3;
var _b3;
var parent_ = Symbol("[[parent]]");
var native_ = Symbol("[[native]]");
var algorithm_ = Symbol("[[algorithm]]");
var usages_ = Symbol("[[usages]]");
var extractable_ = Symbol("[[extractable]]");
var type_ = Symbol("[[type]]");
var privateKey_ = Symbol("[[privateKey]]");
var publicKey_ = Symbol("[[publicKey]]");
function parseHash(hash) {
  switch (hash) {
    case "SHA-1":
      return 0;
    case "SHA-256":
      return 1;
    case "SHA-384":
      return 2;
    case "SHA-512":
      return 3;
    default:
      return null;
  }
}
function parseUsages(usages) {
  const ret = NSMutableArray.new();
  if (Array.isArray(usages)) {
    for (const usage of usages) {
      switch (usage) {
        case "encrypt":
          ret.addObject(1);
          break;
        case "decrypt":
          ret.addObject(0);
          break;
        case "sign":
          ret.addObject(2);
          break;
        case "verify":
          ret.addObject(3);
          break;
        case "deriveKey":
          ret.addObject(4);
          break;
        case "deriveBits":
          ret.addObject(5);
          break;
        case "wrapKey":
          ret.addObject(6);
          break;
        case "unwrapKey":
          ret.addObject(7);
          break;
      }
    }
  }
  return ret;
}

class CryptoKey {
  get algorithm() {
    return this[algorithm_];
  }
  get usages() {
    return this[usages_];
  }
  get extractable() {
    return this[extractable_];
  }
  get type() {
    return this[type_];
  }
  static fromNative(key) {
    if (key) {
      const ret = new CryptoKey;
      ret[native_] = key;
      return ret;
    }
    return null;
  }
}

class CryptoKeyPair {
  constructor() {
    this[_a3] = null;
    this[_b3] = null;
  }
  get privateKey() {
    if (__IOS__) {
      const kp = this[native_];
      if (!this[privateKey_]) {
        this[privateKey_] = CryptoKey.fromNative(kp.privateKey);
      }
    }
    if (__ANDROID__) {
      const kp = this[native_];
      if (!this[privateKey_]) {
        this[privateKey_] = CryptoKey.fromNative(kp.getPrivate());
      }
    }
    return this[privateKey_];
  }
  get publicKey() {
    if (__IOS__) {
      const kp = this[native_];
      if (!this[publicKey_]) {
        this[publicKey_] = CryptoKey.fromNative(kp.publicKey);
      }
    }
    if (__ANDROID__) {
      const kp = this[native_];
      if (!this[publicKey_]) {
        this[publicKey_] = CryptoKey.fromNative(kp.getPublic());
      }
    }
    return this[publicKey_];
  }
  static fromNative(keyPair) {
    if (keyPair) {
      const ret = new CryptoKeyPair;
      ret[native_] = keyPair;
      return ret;
    }
    return null;
  }
}
_a3 = privateKey_, _b3 = publicKey_;

class SubtleCrypto {
  digest(algorithm, data) {
    return new Promise((resolve, reject) => {
      let error;
      let mode;
      switch (algorithm) {
        case "SHA-1":
          mode = 0;
          break;
        case "SHA-256":
          mode = 1;
          break;
        case "SHA-384":
          mode = 2;
          break;
        case "SHA-512":
          mode = 3;
          break;
        default:
          error = new Error("Operation is not supported");
          break;
      }
      if (error !== undefined) {
        reject(error);
        return;
      }
      if (data instanceof ArrayBuffer || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {} else if (data?.BYTES_PER_ELEMENT !== 1) {
        data = new Uint8Array(data.buffer, data.byteOffset);
      } else {
        reject(new TypeError("Argument 2 could not be converted to any of: ArrayBufferView, ArrayBuffer."));
        return;
      }
      if (__ANDROID__) {
        const buffer = org.nativescript.winter_tc.Crypto.digest(mode, data);
        const ab = ArrayBuffer.from(buffer);
        if (!ab) {}
        resolve(ab);
      }
      if (__IOS__) {
        const d3 = NSData.dataWithData(data);
        NSCCrypto.digestModeCompletion(d3, mode, (ab, error2) => {
          if (!ab) {}
          resolve(interop.bufferFromData(ab));
        });
      }
    });
  }
  encrypt(algorithm, key, data) {
    return new Promise((resolve, reject) => {
      let error;
      switch (algorithm?.name) {
        case "RSA-OAEP":
          {
            try {
              if (__IOS__) {
                const hash = parseHash(key.algorithm.hash.name);
                const d3 = NSData.dataWithData(data);
                NSCCrypto.encryptRsaKeyHashDataCompletion(key.type === "private", key[parent_], hash, d3, (ret, error2) => {
                  if (ret) {
                    resolve(interop.bufferFromData(ret));
                  } else {
                    reject(new Error("Failed to encrypt data"));
                  }
                });
              }
              if (__ANDROID__) {
                const hash = parseHash(key.algorithm.hash.name);
                const ret = org.nativescript.winter_tc.Crypto.encryptRsaOAEP(key[parent_], hash, data);
                if (ret) {
                  resolve(ArrayBuffer.from(ret));
                } else {
                  reject(new Error("Failed to encrypt data"));
                }
              }
            } catch (error2) {
              reject(error2);
            }
          }
          break;
        default:
          error = new Error("Operation is not supported");
          break;
      }
      if (error) {
        reject(error);
        return;
      }
    });
  }
  decrypt(algorithm, key, data) {
    return new Promise((resolve, reject) => {
      let error;
      switch (algorithm?.name) {
        case "RSA-OAEP":
          {
            try {
              if (__IOS__) {
                const hash = parseHash(key.algorithm.hash.name);
                const d3 = NSData.dataWithData(data);
                NSCCrypto.decryptRsaKeyHashDataCompletion(key.type === "private", key[parent_], hash, d3, (ret, error2) => {
                  if (ret) {
                    resolve(interop.bufferFromData(ret));
                  } else {
                    reject(new Error("Failed to decrypt data"));
                  }
                });
              }
              if (__ANDROID__) {
                const hash = parseHash(key.algorithm.hash.name);
                const ret = org.nativescript.winter_tc.Crypto.decryptRsaOAEP(key[parent_], hash, data);
                if (ret) {
                  resolve(ArrayBuffer.from(ret));
                } else {
                  reject(new Error("Failed to decrypt data"));
                }
              }
            } catch (error2) {
              reject(error2);
            }
          }
          break;
        default:
          error = new Error("Operation is not supported");
          break;
      }
      if (error) {
        reject(error);
        return;
      }
    });
  }
  sign(algorithm, key, data) {
    return new Promise((resolve, reject) => {
      let error;
      const algorithmName = typeof algorithm === "object" ? algorithm?.name : algorithm;
      switch (algorithmName) {
        case "HMAC":
          {
            try {
              if (__IOS__) {
                const hash = parseHash(key.algorithm.hash.name);
                const d3 = NSData.dataWithData(data);
                const ret = NSCCrypto.signHmacHashData(key[native_], hash, d3);
                if (ret) {
                  resolve(interop.bufferFromData(ret));
                } else {
                  reject(new Error("Failed to sign data"));
                }
              }
              if (__ANDROID__) {
                let algo;
                switch (key.algorithm.hash.name) {
                  case "SHA-1":
                    algo = "HmacSHA1";
                    break;
                  case "SHA-256":
                    algo = "HmacSHA256";
                    break;
                  case "SHA-384":
                    algo = "HmacSHA384";
                    break;
                  case "SHA-512":
                    algo = "HmacSHA512";
                    break;
                  default:
                    error = new Error("Operation is not supported");
                    break;
                }
                if (error) {
                  reject(error);
                  return;
                }
                const ab = org.nativescript.winter_tc.Crypto.signHMAC(algo, key[native_], data);
                resolve(ArrayBuffer.from(ab));
              }
            } catch (error2) {
              reject(error2);
            }
          }
          break;
        default:
          error = new Error("Operation is not supported");
          break;
      }
      if (error) {
        reject(error);
        return;
      }
    });
  }
  verify(algorithm, key, signature, data) {
    return new Promise((resolve, reject) => {
      let error;
      const algorithmName = typeof algorithm === "object" ? algorithm?.name : algorithm;
      switch (algorithmName) {
        case "HMAC":
          {
            try {
              if (__IOS__) {
                const hash = parseHash(key.algorithm.hash.name);
                const s3 = NSData.dataWithData(signature);
                const d3 = NSData.dataWithData(data);
                const ret = NSCCrypto.verifyHmacHashSignatureData(key[native_], hash, s3, d3);
                resolve(ret);
              }
              if (__ANDROID__) {
                let algo;
                switch (key.algorithm.hash.name) {
                  case "SHA-1":
                    algo = "HmacSHA1";
                    break;
                  case "SHA-256":
                    algo = "HmacSHA256";
                    break;
                  case "SHA-384":
                    algo = "HmacSHA384";
                    break;
                  case "SHA-512":
                    algo = "HmacSHA512";
                    break;
                  default:
                    error = new Error("Operation is not supported");
                    break;
                }
                if (error) {
                  reject(error);
                  return;
                }
                const ret = org.nativescript.winter_tc.Crypto.verifyHMAC(algo, key[native_], signature, data);
                resolve(ret);
              }
            } catch (error2) {
              reject(error2);
            }
          }
          break;
        default:
          error = new Error("Operation is not supported");
          break;
      }
      if (error) {
        reject(error);
        return;
      }
    });
  }
  generateKey(algorithm, extractable, keyUsages) {
    return new Promise((resolve, reject) => {
      const algorithmHash = typeof algorithm?.hash === "object" ? algorithm?.hash?.name : algorithm.hash;
      switch (algorithm?.name) {
        case "HMAC":
          {
            let algo;
            let error;
            switch (algorithmHash) {
              case "SHA-1":
                algo = "HmacSHA1";
                break;
              case "SHA-256":
                algo = "HmacSHA256";
                break;
              case "SHA-384":
                algo = "HmacSHA384";
                break;
              case "SHA-512":
                algo = "HmacSHA512";
                break;
              default:
                error = new Error("Operation is not supported");
                break;
            }
            if (error) {
              reject(error);
              return;
            }
            if (__ANDROID__) {
              const key = org.nativescript.winter_tc.Crypto.generateKeyHMAC(algo);
              const ret = new CryptoKey;
              ret[algorithm_] = { name: algorithm.name, hash: { name: algorithmHash } };
              ret[native_] = key;
              ret[usages_] = keyUsages;
              ret[extractable_] = extractable;
              ret[type_] = "secret";
              resolve(ret);
            }
            if (__IOS__) {
              const hash = parseHash(algorithmHash);
              const key = NSCCrypto.generateKeyHmacLength(hash, algorithm?.length ?? -1);
              const ret = new CryptoKey;
              ret[algorithm_] = { name: algorithm.name, hash: { name: algorithmHash } };
              ret[native_] = key;
              ret[usages_] = keyUsages;
              ret[extractable_] = extractable;
              ret[type_] = "secret";
              resolve(ret);
            }
          }
          break;
        case "RSA-OAEP":
          {
            if (__IOS__) {
              const hash = parseHash(algorithm.hash);
              if (hash === null) {}
              const usages = parseUsages(keyUsages);
              NSCCrypto.generateKeyRsaModulusLengthPublicExponentSizeHashExtractableKeyUsagesCompletion(2, algorithm.modulusLength, null, 0, hash, !!extractable, usages, (kp, error) => {
                if (!kp) {
                  reject(new Error("Failed to generateKey"));
                } else {
                  const ret = CryptoKeyPair.fromNative(kp);
                  ret.privateKey[parent_] = kp;
                  ret.privateKey[algorithm_] = { name: algorithm.name, hash: { name: algorithm.hash }, modulusLength: algorithm.modulusLength, publicExponent: new Uint8Array([1, 0, 1]) };
                  ret.privateKey[type_] = "private";
                  ret.privateKey[extractable_] = extractable;
                  ret.publicKey[parent_] = kp;
                  ret.publicKey[algorithm_] = { name: algorithm.name, hash: { name: algorithm.hash }, modulusLength: algorithm.modulusLength, publicExponent: new Uint8Array([1, 0, 1]) };
                  ret.publicKey[type_] = "public";
                  ret.publicKey[extractable_] = extractable;
                  resolve(ret);
                }
              });
            }
            if (__ANDROID__) {
              const hash = parseHash(algorithm.hash);
              if (hash === null) {}
              const kp = org.nativescript.winter_tc.Crypto.generateKeyRsaOAEP(algorithm.modulusLength);
              if (!kp) {
                reject(new Error("Failed to generateKey"));
              } else {
                const ret = CryptoKeyPair.fromNative(kp);
                ret.privateKey[parent_] = kp;
                ret.privateKey[algorithm_] = { name: algorithm.name, hash: { name: algorithm.hash }, modulusLength: algorithm.modulusLength, publicExponent: new Uint8Array([1, 0, 1]) };
                ret.privateKey[type_] = "private";
                ret.privateKey[extractable_] = extractable;
                ret.publicKey[parent_] = kp;
                ret.publicKey[algorithm_] = { name: algorithm.name, hash: { name: algorithm.hash }, modulusLength: algorithm.modulusLength, publicExponent: new Uint8Array([1, 0, 1]) };
                ret.publicKey[type_] = "public";
                ret.publicKey[extractable_] = extractable;
                resolve(ret);
              }
            }
          }
          break;
        default:
          reject(new Error(`'subtle.generateKey()' is not implemented for ${algorithm?.name}.
						  Unrecognized algorithm name`));
          break;
      }
    });
  }
}

// node_modules/@nativescript/core/wgc/crypto/index.js
var subtle = new SubtleCrypto;

class Crypto {
  get subtle() {
    return subtle;
  }
  randomUUID() {
    if (__ANDROID__) {
      return org.nativescript.winter_tc.Crypto.randomUUID();
    }
    if (__IOS__) {
      return NSCCrypto.randomUUID();
    }
  }
  getRandomValues(typedArray) {
    if (__ANDROID__) {
      if (typedArray.BYTES_PER_ELEMENT !== 1) {
        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset);
      }
      org.nativescript.winter_tc.Crypto.getRandomValues(typedArray);
    }
    if (__IOS__) {
      if (typedArray.BYTES_PER_ELEMENT !== 1) {
        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
      }
      const data = NSMutableData.dataWithBytesNoCopyLength(typedArray, typedArray.byteLength);
      NSCCrypto.getRandomValues(data);
    }
    return typedArray;
  }
}

// node_modules/@nativescript/core/core-types/animation-types.js
class CubicBezierAnimationCurve {
  constructor(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
}

// node_modules/@nativescript/core/core-types/index.js
var CoreTypes;
(function(CoreTypes2) {
  CoreTypes2.zeroLength = {
    value: 0,
    unit: "px"
  };
  let KeyboardType;
  (function(KeyboardType2) {
    KeyboardType2.datetime = "datetime";
    KeyboardType2.phone = "phone";
    KeyboardType2.number = "number";
    KeyboardType2.decimal = "decimal";
    KeyboardType2.url = "url";
    KeyboardType2.email = "email";
    KeyboardType2.integer = "integer";
  })(KeyboardType = CoreTypes2.KeyboardType || (CoreTypes2.KeyboardType = {}));
  let AutofillType;
  (function(AutofillType2) {
    AutofillType2.username = "username";
    AutofillType2.password = "password";
    AutofillType2.newUsername = "newUsername";
    AutofillType2.newPassword = "newPassword";
    AutofillType2.oneTimeCode = "oneTimeCode";
    AutofillType2.none = "none";
  })(AutofillType = CoreTypes2.AutofillType || (CoreTypes2.AutofillType = {}));
  let ReturnKeyType;
  (function(ReturnKeyType2) {
    ReturnKeyType2.done = "done";
    ReturnKeyType2.next = "next";
    ReturnKeyType2.go = "go";
    ReturnKeyType2.search = "search";
    ReturnKeyType2.send = "send";
  })(ReturnKeyType = CoreTypes2.ReturnKeyType || (CoreTypes2.ReturnKeyType = {}));
  let TextAlignment;
  (function(TextAlignment2) {
    TextAlignment2.left = "left";
    TextAlignment2.center = "center";
    TextAlignment2.right = "right";
    TextAlignment2.justify = "justify";
  })(TextAlignment = CoreTypes2.TextAlignment || (CoreTypes2.TextAlignment = {}));
  let TextDecoration;
  (function(TextDecoration2) {
    TextDecoration2.none = "none";
    TextDecoration2.underline = "underline";
    TextDecoration2.lineThrough = "line-through";
  })(TextDecoration = CoreTypes2.TextDecoration || (CoreTypes2.TextDecoration = {}));
  let TextTransform;
  (function(TextTransform2) {
    TextTransform2.none = "none";
    TextTransform2.capitalize = "capitalize";
    TextTransform2.uppercase = "uppercase";
    TextTransform2.lowercase = "lowercase";
  })(TextTransform = CoreTypes2.TextTransform || (CoreTypes2.TextTransform = {}));
  let WhiteSpace;
  (function(WhiteSpace2) {
    WhiteSpace2.normal = "normal";
    WhiteSpace2.nowrap = "nowrap";
    WhiteSpace2.wrap = "wrap";
  })(WhiteSpace = CoreTypes2.WhiteSpace || (CoreTypes2.WhiteSpace = {}));
  let TextOverflow;
  (function(TextOverflow2) {
    TextOverflow2.clip = "clip";
    TextOverflow2.ellipsis = "ellipsis";
  })(TextOverflow = CoreTypes2.TextOverflow || (CoreTypes2.TextOverflow = {}));
  let Orientation;
  (function(Orientation2) {
    Orientation2.horizontal = "horizontal";
    Orientation2.vertical = "vertical";
  })(Orientation = CoreTypes2.Orientation || (CoreTypes2.Orientation = {}));
  let DeviceOrientation;
  (function(DeviceOrientation2) {
    DeviceOrientation2.portrait = "portrait";
    DeviceOrientation2.landscape = "landscape";
    DeviceOrientation2.unknown = "unknown";
  })(DeviceOrientation = CoreTypes2.DeviceOrientation || (CoreTypes2.DeviceOrientation = {}));
  let HorizontalAlignment;
  (function(HorizontalAlignment2) {
    HorizontalAlignment2.start = "start";
    HorizontalAlignment2.left = "left";
    HorizontalAlignment2.center = "center";
    HorizontalAlignment2.right = "right";
    HorizontalAlignment2.end = "end";
    HorizontalAlignment2.stretch = "stretch";
    HorizontalAlignment2.isValid = makeValidator(HorizontalAlignment2.start, HorizontalAlignment2.left, HorizontalAlignment2.center, HorizontalAlignment2.right, HorizontalAlignment2.end, HorizontalAlignment2.stretch);
    HorizontalAlignment2.parse = makeParser(HorizontalAlignment2.isValid);
  })(HorizontalAlignment = CoreTypes2.HorizontalAlignment || (CoreTypes2.HorizontalAlignment = {}));
  let VerticalAlignment;
  (function(VerticalAlignment2) {
    VerticalAlignment2.top = "top";
    VerticalAlignment2.middle = "middle";
    VerticalAlignment2.bottom = "bottom";
    VerticalAlignment2.stretch = "stretch";
  })(VerticalAlignment = CoreTypes2.VerticalAlignment || (CoreTypes2.VerticalAlignment = {}));
  let VerticalAlignmentText;
  (function(VerticalAlignmentText2) {
    VerticalAlignmentText2.top = "top";
    VerticalAlignmentText2.middle = "middle";
    VerticalAlignmentText2.bottom = "bottom";
    VerticalAlignmentText2.stretch = "stretch";
    VerticalAlignmentText2.texttop = "text-top";
    VerticalAlignmentText2.textbottom = "text-bottom";
    VerticalAlignmentText2.sup = "sup";
    VerticalAlignmentText2.sub = "sub";
    VerticalAlignmentText2.baseline = "baseline";
    VerticalAlignmentText2.isValid = makeValidator(VerticalAlignmentText2.top, VerticalAlignmentText2.middle, VerticalAlignmentText2.bottom, VerticalAlignmentText2.stretch, VerticalAlignmentText2.texttop, VerticalAlignmentText2.textbottom, VerticalAlignmentText2.sup, VerticalAlignmentText2.sub, VerticalAlignmentText2.baseline);
    VerticalAlignmentText2.parse = (value) => value.toLowerCase() === "center" ? VerticalAlignmentText2.middle : parseStrict(value);
    const parseStrict = makeParser(VerticalAlignmentText2.isValid);
  })(VerticalAlignmentText = CoreTypes2.VerticalAlignmentText || (CoreTypes2.VerticalAlignmentText = {}));
  let ImageStretch;
  (function(ImageStretch2) {
    ImageStretch2.none = "none";
    ImageStretch2.aspectFill = "aspectFill";
    ImageStretch2.aspectFit = "aspectFit";
    ImageStretch2.fill = "fill";
  })(ImageStretch = CoreTypes2.ImageStretch || (CoreTypes2.ImageStretch = {}));
  let Visibility;
  (function(Visibility2) {
    Visibility2.visible = "visible";
    Visibility2.collapse = "collapse";
    Visibility2.collapsed = "collapsed";
    Visibility2.hidden = "hidden";
    Visibility2.isValid = makeValidator(Visibility2.visible, Visibility2.hidden, Visibility2.collapse);
    Visibility2.parse = (value) => value.toLowerCase() === "collapsed" ? Visibility2.collapse : parseStrict(value);
    const parseStrict = makeParser(Visibility2.isValid);
  })(Visibility = CoreTypes2.Visibility || (CoreTypes2.Visibility = {}));
  let FontAttributes;
  (function(FontAttributes2) {
    FontAttributes2.Normal = 0;
    FontAttributes2.Bold = 1;
    FontAttributes2.Italic = 1 << 1;
  })(FontAttributes = CoreTypes2.FontAttributes || (CoreTypes2.FontAttributes = {}));
  let DeviceType;
  (function(DeviceType2) {
    DeviceType2.Phone = "Phone";
    DeviceType2.Tablet = "Tablet";
  })(DeviceType = CoreTypes2.DeviceType || (CoreTypes2.DeviceType = {}));
  let UpdateTextTrigger;
  (function(UpdateTextTrigger2) {
    UpdateTextTrigger2.focusLost = "focusLost";
    UpdateTextTrigger2.textChanged = "textChanged";
  })(UpdateTextTrigger = CoreTypes2.UpdateTextTrigger || (CoreTypes2.UpdateTextTrigger = {}));
  let Accuracy;
  (function(Accuracy2) {
    Accuracy2.any = 300;
    Accuracy2.high = 3;
  })(Accuracy = CoreTypes2.Accuracy || (CoreTypes2.Accuracy = {}));
  let Dock;
  (function(Dock2) {
    Dock2.left = "left";
    Dock2.top = "top";
    Dock2.right = "right";
    Dock2.bottom = "bottom";
  })(Dock = CoreTypes2.Dock || (CoreTypes2.Dock = {}));
  let AutocapitalizationType;
  (function(AutocapitalizationType2) {
    AutocapitalizationType2.none = "none";
    AutocapitalizationType2.words = "words";
    AutocapitalizationType2.sentences = "sentences";
    AutocapitalizationType2.allCharacters = "allcharacters";
  })(AutocapitalizationType = CoreTypes2.AutocapitalizationType || (CoreTypes2.AutocapitalizationType = {}));
  let NavigationBarVisibility;
  (function(NavigationBarVisibility2) {
    NavigationBarVisibility2.auto = "auto";
    NavigationBarVisibility2.never = "never";
    NavigationBarVisibility2.always = "always";
  })(NavigationBarVisibility = CoreTypes2.NavigationBarVisibility || (CoreTypes2.NavigationBarVisibility = {}));
  let AndroidActionBarIconVisibility;
  (function(AndroidActionBarIconVisibility2) {
    AndroidActionBarIconVisibility2.auto = "auto";
    AndroidActionBarIconVisibility2.never = "never";
    AndroidActionBarIconVisibility2.always = "always";
  })(AndroidActionBarIconVisibility = CoreTypes2.AndroidActionBarIconVisibility || (CoreTypes2.AndroidActionBarIconVisibility = {}));
  let AndroidActionItemPosition;
  (function(AndroidActionItemPosition2) {
    AndroidActionItemPosition2.actionBar = "actionBar";
    AndroidActionItemPosition2.actionBarIfRoom = "actionBarIfRoom";
    AndroidActionItemPosition2.popup = "popup";
  })(AndroidActionItemPosition = CoreTypes2.AndroidActionItemPosition || (CoreTypes2.AndroidActionItemPosition = {}));
  let IOSActionItemPosition;
  (function(IOSActionItemPosition2) {
    IOSActionItemPosition2.left = "left";
    IOSActionItemPosition2.right = "right";
  })(IOSActionItemPosition = CoreTypes2.IOSActionItemPosition || (CoreTypes2.IOSActionItemPosition = {}));
  let ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2.png = "png";
    ImageFormat2.jpeg = "jpeg";
    ImageFormat2.jpg = "jpg";
  })(ImageFormat = CoreTypes2.ImageFormat || (CoreTypes2.ImageFormat = {}));
  let FontStyle2;
  (function(FontStyle3) {
    FontStyle3.normal = "normal";
    FontStyle3.italic = "italic";
  })(FontStyle2 = CoreTypes2.FontStyle || (CoreTypes2.FontStyle = {}));
  let FontWeight2;
  (function(FontWeight3) {
    FontWeight3.thin = "100";
    FontWeight3.extraLight = "200";
    FontWeight3.light = "300";
    FontWeight3.normal = "normal";
    FontWeight3.medium = "500";
    FontWeight3.semiBold = "600";
    FontWeight3.bold = "bold";
    FontWeight3.extraBold = "800";
    FontWeight3.black = "900";
  })(FontWeight2 = CoreTypes2.FontWeight || (CoreTypes2.FontWeight = {}));
  let BackgroundRepeat;
  (function(BackgroundRepeat2) {
    BackgroundRepeat2.repeat = "repeat";
    BackgroundRepeat2.repeatX = "repeat-x";
    BackgroundRepeat2.repeatY = "repeat-y";
    BackgroundRepeat2.noRepeat = "no-repeat";
    BackgroundRepeat2.isValid = makeValidator(BackgroundRepeat2.repeat, BackgroundRepeat2.repeatX, BackgroundRepeat2.repeatY, BackgroundRepeat2.noRepeat);
    BackgroundRepeat2.parse = makeParser(BackgroundRepeat2.isValid);
  })(BackgroundRepeat = CoreTypes2.BackgroundRepeat || (CoreTypes2.BackgroundRepeat = {}));
  let AnimationCurve;
  (function(AnimationCurve2) {
    AnimationCurve2.ease = "ease";
    AnimationCurve2.easeIn = "easeIn";
    AnimationCurve2.easeOut = "easeOut";
    AnimationCurve2.easeInOut = "easeInOut";
    AnimationCurve2.linear = "linear";
    AnimationCurve2.spring = "spring";
    function cubicBezier(x1, y1, x2, y2) {
      return new CubicBezierAnimationCurve(x1, y1, x2, y2);
    }
    AnimationCurve2.cubicBezier = cubicBezier;
  })(AnimationCurve = CoreTypes2.AnimationCurve || (CoreTypes2.AnimationCurve = {}));
  let StatusBarStyle;
  (function(StatusBarStyle2) {
    StatusBarStyle2.light = "light";
    StatusBarStyle2.dark = "dark";
  })(StatusBarStyle = CoreTypes2.StatusBarStyle || (CoreTypes2.StatusBarStyle = {}));
  let SystemAppearance;
  (function(SystemAppearance2) {
    SystemAppearance2.light = "light";
    SystemAppearance2.dark = "dark";
  })(SystemAppearance = CoreTypes2.SystemAppearance || (CoreTypes2.SystemAppearance = {}));
  let LayoutDirection;
  (function(LayoutDirection2) {
    LayoutDirection2.ltr = "ltr";
    LayoutDirection2.rtl = "rtl";
  })(LayoutDirection = CoreTypes2.LayoutDirection || (CoreTypes2.LayoutDirection = {}));
})(CoreTypes || (CoreTypes = {}));
var AnimationCurve = CoreTypes.AnimationCurve;
var Enums = {
  Accuracy: CoreTypes.Accuracy,
  AndroidActionBarIconVisibility: CoreTypes.AndroidActionBarIconVisibility,
  AndroidActionItemPosition: CoreTypes.AndroidActionItemPosition,
  AnimationCurve: CoreTypes.AnimationCurve,
  AutocapitalizationType: CoreTypes.AutocapitalizationType,
  BackgroundRepeat: CoreTypes.BackgroundRepeat,
  DeviceOrientation: CoreTypes.DeviceOrientation,
  DeviceType: CoreTypes.DeviceType,
  Dock: CoreTypes.Dock,
  FontAttributes: CoreTypes.FontAttributes,
  FontStyle: CoreTypes.FontStyle,
  FontWeight: CoreTypes.FontWeight,
  HorizontalAlignment: CoreTypes.HorizontalAlignment,
  IOSActionItemPosition: CoreTypes.IOSActionItemPosition,
  ImageFormat: CoreTypes.ImageFormat,
  KeyboardType: CoreTypes.KeyboardType,
  NavigationBarVisibility: CoreTypes.NavigationBarVisibility,
  Orientation: CoreTypes.Orientation,
  ReturnKeyType: CoreTypes.ReturnKeyType,
  StatusBarStyle: CoreTypes.StatusBarStyle,
  Stretch: CoreTypes.ImageStretch,
  SystemAppearance: CoreTypes.SystemAppearance,
  LayoutDirection: CoreTypes.LayoutDirection,
  TextAlignment: CoreTypes.TextAlignment,
  TextDecoration: CoreTypes.TextDecoration,
  TextTransform: CoreTypes.TextTransform,
  UpdateTextTrigger: CoreTypes.UpdateTextTrigger,
  VerticalAlignment: CoreTypes.VerticalAlignment,
  Visibility: CoreTypes.Visibility,
  WhiteSpace: CoreTypes.WhiteSpace
};

// node_modules/@nativescript/core/css/system-classes.js
var MODAL = "modal";
var ROOT = "root";
var cssClasses = [];
var CSSUtils;
(function(CSSUtils2) {
  CSSUtils2.CLASS_PREFIX = "ns-";
  CSSUtils2.MODAL_ROOT_VIEW_CSS_CLASS = `${CSSUtils2.CLASS_PREFIX}${MODAL}`;
  CSSUtils2.ROOT_VIEW_CSS_CLASS = `${CSSUtils2.CLASS_PREFIX}${ROOT}`;
  function getSystemCssClasses() {
    return cssClasses;
  }
  CSSUtils2.getSystemCssClasses = getSystemCssClasses;
  function pushToSystemCssClasses(value) {
    const index = cssClasses.indexOf(value);
    if (index == -1) {
      cssClasses.push(value);
    }
    return cssClasses.length;
  }
  CSSUtils2.pushToSystemCssClasses = pushToSystemCssClasses;
  function removeSystemCssClass(value) {
    const index = cssClasses.indexOf(value);
    let removedElement;
    if (index > -1) {
      removedElement = cssClasses.splice(index, 1);
    }
    return removedElement;
  }
  CSSUtils2.removeSystemCssClass = removeSystemCssClass;
  function getModalRootViewCssClass() {
    return CSSUtils2.MODAL_ROOT_VIEW_CSS_CLASS;
  }
  CSSUtils2.getModalRootViewCssClass = getModalRootViewCssClass;
  function getRootViewCssClasses() {
    return [CSSUtils2.ROOT_VIEW_CSS_CLASS, ...cssClasses];
  }
  CSSUtils2.getRootViewCssClasses = getRootViewCssClasses;
  function pushToRootViewCssClasses(value) {
    return pushToSystemCssClasses(value) + 1;
  }
  CSSUtils2.pushToRootViewCssClasses = pushToRootViewCssClasses;
  function removeFromRootViewCssClasses(value) {
    return removeSystemCssClass(value);
  }
  CSSUtils2.removeFromRootViewCssClasses = removeFromRootViewCssClasses;
})(CSSUtils || (CSSUtils = {}));

// node_modules/@nativescript/core/platform/common.js
var platformNames = {
  android: "Android",
  ios: "iOS",
  visionos: "visionOS",
  apple: "apple"
};
var isAndroid = !!__ANDROID__;
var isIOS = !!__IOS__ || !!__VISIONOS__;
var isVisionOS = !!__VISIONOS__;
var isApple = !!__APPLE__;
// node_modules/@nativescript/core/platform/device/index.android.js
var MIN_TABLET_PIXELS = 600;

class DeviceRef {
  get manufacturer() {
    if (!this._manufacturer) {
      this._manufacturer = android.os.Build.MANUFACTURER;
    }
    return this._manufacturer;
  }
  get os() {
    return platformNames.android;
  }
  get osVersion() {
    if (!this._osVersion) {
      this._osVersion = android.os.Build.VERSION.RELEASE;
    }
    return this._osVersion;
  }
  get model() {
    if (!this._model) {
      this._model = android.os.Build.MODEL;
    }
    return this._model;
  }
  get sdkVersion() {
    if (!this._sdkVersion) {
      this._sdkVersion = android.os.Build.VERSION.SDK;
    }
    return this._sdkVersion;
  }
  get deviceType() {
    if (!this._deviceType) {
      const dips = Math.min(Screen.mainScreen.widthPixels, Screen.mainScreen.heightPixels) / Screen.mainScreen.scale;
      if (dips >= MIN_TABLET_PIXELS) {
        this._deviceType = "Tablet";
      } else {
        this._deviceType = "Phone";
      }
    }
    return this._deviceType;
  }
  get uuid() {
    if (!this._uuid) {
      const nativeApp2 = getNativeApp();
      this._uuid = android.provider.Settings.Secure.getString(nativeApp2.getContentResolver(), android.provider.Settings.Secure.ANDROID_ID);
    }
    return this._uuid;
  }
  get language() {
    let defaultNativeLocale;
    if (SDK_VERSION >= 24) {
      defaultNativeLocale = android.content.res.Resources.getSystem().getConfiguration().getLocales().get(0);
    } else {
      defaultNativeLocale = android.content.res.Resources.getSystem().getConfiguration().locale;
    }
    return defaultNativeLocale.getLanguage().replace("_", "-");
  }
  get region() {
    let defaultNativeLocale;
    if (SDK_VERSION >= 24) {
      defaultNativeLocale = android.content.res.Resources.getSystem().getConfiguration().getLocales().get(0);
    } else {
      defaultNativeLocale = android.content.res.Resources.getSystem().getConfiguration().locale;
    }
    return defaultNativeLocale.getCountry();
  }
}
var Device = new DeviceRef;
// node_modules/@nativescript/core/module-name-resolver/helpers.js
var appForModuleResolverCallback;
function prepareAppForModuleResolver(callback) {
  appForModuleResolverCallback = callback;
}
function initAppForModuleResolver() {
  if (appForModuleResolverCallback) {
    appForModuleResolverCallback();
    appForModuleResolverCallback = undefined;
  }
}
var resolverInstance;
function getResolveInstance() {
  return resolverInstance;
}
function _setResolver(resolver) {
  resolverInstance = resolver;
}
function clearResolverCache() {
  if (resolverInstance) {
    resolverInstance.clearCache();
  }
}

// node_modules/@nativescript/core/ui/core/weak-event-listener/index.js
var handlersForEventName = new Map;
var sourcesMap = new WeakMap;

class TargetHandlerPair {
  constructor(target, handler) {
    this.tagetRef = new WeakRef(target);
    this.handler = handler;
  }
}
function getHandlerForEventName(eventName) {
  let handler = handlersForEventName.get(eventName);
  if (!handler) {
    handler = function(eventData) {
      const source = eventData.object;
      const sourceEventMap = sourcesMap.get(source);
      if (!sourceEventMap) {
        source.removeEventListener(eventName, handlersForEventName.get(eventName));
        return;
      }
      const targetHandlerPairList = sourceEventMap.get(eventName);
      if (!targetHandlerPairList) {
        return;
      }
      const deadPairsIndexes = [];
      let pair;
      let target;
      for (let i3 = 0;i3 < targetHandlerPairList.length; i3++) {
        pair = targetHandlerPairList[i3];
        target = pair.tagetRef.get();
        if (target) {
          pair.handler.call(target, eventData);
        } else {
          deadPairsIndexes.push(i3);
        }
      }
      if (deadPairsIndexes.length === targetHandlerPairList.length) {
        source.removeEventListener(eventName, handlersForEventName.get(eventName));
        sourceEventMap.delete(eventName);
      } else {
        for (let j2 = deadPairsIndexes.length - 1;j2 >= 0; j2--) {
          targetHandlerPairList.splice(deadPairsIndexes[j2], 1);
        }
      }
    };
    handlersForEventName.set(eventName, handler);
  }
  return handler;
}
function validateArgs(source, eventName, handler, target) {
  if (!source) {
    throw new Error("source is null or undefined");
  }
  if (!target) {
    throw new Error("target is null or undefined");
  }
  if (typeof eventName !== "string") {
    throw new Error("eventName is not a string");
  }
  if (typeof handler !== "function") {
    throw new Error("handler is not a function");
  }
}
function addWeakEventListener(source, eventName, handler, target) {
  validateArgs(source, eventName, handler, target);
  let shouldAttach = false;
  let sourceEventMap = sourcesMap.get(source);
  if (!sourceEventMap) {
    sourceEventMap = new Map;
    sourcesMap.set(source, sourceEventMap);
    shouldAttach = true;
  }
  let pairList = sourceEventMap.get(eventName);
  if (!pairList) {
    pairList = new Array;
    sourceEventMap.set(eventName, pairList);
    shouldAttach = true;
  }
  pairList.push(new TargetHandlerPair(target, handler));
  if (shouldAttach) {
    source.addEventListener(eventName, getHandlerForEventName(eventName));
  }
}
function removeWeakEventListener(source, eventName, handler, target) {
  validateArgs(source, eventName, handler, target);
  const handlerForEventWithName = handlersForEventName.get(eventName);
  if (!handlerForEventWithName) {
    return;
  }
  const sourceEventMap = sourcesMap.get(source);
  if (!sourceEventMap) {
    return;
  }
  const targetHandlerPairList = sourceEventMap.get(eventName);
  if (!targetHandlerPairList) {
    return;
  }
  const targetHandlerPairsToRemove = [];
  let pair;
  let registeredTarget;
  for (let i3 = 0;i3 < targetHandlerPairList.length; i3++) {
    pair = targetHandlerPairList[i3];
    registeredTarget = pair.tagetRef.get();
    if (!registeredTarget || registeredTarget === target && handler === pair.handler) {
      targetHandlerPairsToRemove.push(i3);
    }
  }
  if (targetHandlerPairsToRemove.length === targetHandlerPairList.length) {
    source.removeEventListener(eventName, handlerForEventWithName);
    sourceEventMap.delete(eventName);
  } else {
    for (let j2 = targetHandlerPairsToRemove.length - 1;j2 >= 0; j2--) {
      targetHandlerPairList.splice(targetHandlerPairsToRemove[j2], 1);
    }
  }
}

// node_modules/@nativescript/core/ui/builder/binding-builder.js
var expressionSymbolsRegex = /[\+\-\*\/%\?:<>=!\|&\(\)^~]|^`.*\$\{.+\}.*`$/;
var bindingConstants;
(function(bindingConstants2) {
  bindingConstants2.sourceProperty = "sourceProperty";
  bindingConstants2.targetProperty = "targetProperty";
  bindingConstants2.expression = "expression";
  bindingConstants2.twoWay = "twoWay";
  bindingConstants2.source = "source";
  bindingConstants2.bindingValueKey = "$value";
  bindingConstants2.parentValueKey = "$parent";
  bindingConstants2.parentsValueKey = "$parents";
  bindingConstants2.newPropertyValueKey = "$newPropertyValue";
})(bindingConstants || (bindingConstants = {}));
var hasEqualSignRegex = /=+/;
var equalSignComparisionOperatorsRegex = /(==|===|>=|<=|!=|!==)/;
var parentsRegex = /\$parents\s*\[\s*(['"]*)\w*\1\s*\]/g;
function isNamedParam(value) {
  const equalSignIndex = value.search(hasEqualSignRegex);
  if (equalSignIndex > -1) {
    const equalSignSurround = value.substr(equalSignIndex > 0 ? equalSignIndex - 1 : 0, 3);
    if (equalSignSurround.search(equalSignComparisionOperatorsRegex) === -1) {
      return true;
    }
  }
  return false;
}
function areNamedParams(params) {
  for (let i3 = 0;i3 < params.length; i3++) {
    if (isNamedParam(params[i3])) {
      return true;
    }
  }
  return false;
}
var namedParamConstants = {
  propName: "propName",
  propValue: "propValue"
};
function getPropertyNameValuePair(param, knownOptions, callback) {
  let nameValuePair = {};
  let propertyName = param.substr(0, param.indexOf("=")).trim();
  const propertyValue = param.substr(param.indexOf("=") + 1).trim();
  if (knownOptions) {
    if (!propertyName) {
      propertyName = knownOptions.defaultProperty;
    } else {
      propertyName = propertyName in knownOptions ? propertyName : null;
    }
  }
  if (propertyName) {
    if (callback) {
      nameValuePair = callback(propertyName, propertyValue);
    } else {
      nameValuePair[namedParamConstants.propName] = propertyName;
      nameValuePair[namedParamConstants.propValue] = propertyValue;
    }
    return nameValuePair;
  }
  return null;
}
function parseNamedProperties(parameterList, knownOptions, callback) {
  const result = {};
  let nameValuePair;
  for (let i3 = 0;i3 < parameterList.length; i3++) {
    nameValuePair = getPropertyNameValuePair(parameterList[i3], knownOptions, callback);
    if (nameValuePair) {
      result[nameValuePair[namedParamConstants.propName]] = nameValuePair[namedParamConstants.propValue];
    }
  }
  return result;
}
function getParamsArray(value) {
  const result = [];
  let skipComma = 0;
  let indexReached = 0;
  let singleQuoteBlock = false;
  let doubleQuoteBlock = false;
  for (let i3 = 0;i3 < value.length; i3++) {
    if (value[i3] === '"') {
      doubleQuoteBlock = !doubleQuoteBlock;
    }
    if (value[i3] === "'") {
      singleQuoteBlock = !singleQuoteBlock;
    }
    if (value[i3] === "(" || value[i3] === "[") {
      skipComma++;
    }
    if (value[i3] === ")" || value[i3] === "]") {
      skipComma--;
    }
    if (value[i3] === "," && skipComma === 0 && !(singleQuoteBlock || doubleQuoteBlock)) {
      result.push(value.substr(indexReached, i3 - indexReached));
      indexReached = i3 + 1;
    }
  }
  result.push(value.substr(indexReached));
  return result;
}
function isExpression(expression) {
  return expression.search(expressionSymbolsRegex) > -1;
}
function getBindingOptions(name, value) {
  let namedParams = [];
  const params = getParamsArray(value);
  if (!areNamedParams(params)) {
    if (params.length === 1) {
      const trimmedValue = params[0].trim();
      let sourceProp;
      if (isExpression(trimmedValue)) {
        sourceProp = bindingConstants.bindingValueKey;
        namedParams.push(bindingConstants.expression + " = " + trimmedValue);
      } else {
        sourceProp = trimmedValue;
      }
      namedParams.push(bindingConstants.sourceProperty + " = " + sourceProp);
      namedParams.push(bindingConstants.twoWay + " = true");
    } else {
      namedParams.push(bindingConstants.sourceProperty + " = " + params[0].trim());
      namedParams.push(bindingConstants.expression + " = " + params[1].trim());
      const twoWay = params[2] ? params[2].toLowerCase().trim() === "true" : true;
      namedParams.push(bindingConstants.twoWay + " = " + twoWay);
    }
  } else {
    namedParams = params;
  }
  const bindingPropertyHandler = function(prop, value2) {
    const result = {};
    result[namedParamConstants.propName] = prop;
    if (prop === bindingConstants.twoWay) {
      if (value2 === "true") {
        result[namedParamConstants.propValue] = true;
      } else {
        result[namedParamConstants.propValue] = false;
      }
    } else {
      result[namedParamConstants.propValue] = value2;
    }
    return result;
  };
  const bindingOptionsParameters = parseNamedProperties(namedParams, xmlBindingProperties, bindingPropertyHandler);
  const bindOptions = {
    targetProperty: name
  };
  for (const prop in bindingOptionsParameters) {
    if (bindingOptionsParameters.hasOwnProperty(prop)) {
      bindOptions[prop] = bindingOptionsParameters[prop];
    }
  }
  if (bindOptions[bindingConstants.twoWay] === undefined) {
    bindOptions[bindingConstants.twoWay] = true;
  }
  return bindOptions;
}
var xmlBindingProperties = {
  sourceProperty: true,
  expression: true,
  twoWay: true,
  source: true,
  defaultProperty: bindingConstants.sourceProperty
};

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i3 = 0;i3 < set.length; i3 += 2) {
    pos += set[i3];
    if (pos > code) {
      return false;
    }
    pos += set[i3 + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === undefined)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === undefined)
    options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine2(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === undefined)
    end = code.length;
  for (var i3 = from;i3 < end; i3++) {
    var next = code.charCodeAt(i3);
    if (isNewLine2(next)) {
      return i3 < end - 1 && next === 13 && code.charCodeAt(i3 + 1) === 10 ? i3 + 2 : i3 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty2 = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty2.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n3) {
  return new Position(this.line, this.column + n3);
};
var SourceLocation = function SourceLocation2(p2, start2, end) {
  this.start = start2;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0;; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  ecmaVersion: null,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowAwaitOutsideFunction: null,
  allowSuperOutsideMethod: null,
  allowHashBang: false,
  checkPrivateFields: true,
  locations: false,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`);
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text, start2, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start2,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start2, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(`
`, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse2() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i3 = this.scopeStack.length - 1;i3 >= 0; i3--) {
    var ref2 = this.scopeStack[i3];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i3 = this.scopeStack.length - 1;i3 >= 0; i3--) {
    var ref2 = this.scopeStack[i3];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i3 = 0;i3 < plugins.length; i3++) {
    cls = plugins[i3](cls);
  }
  return cls;
};
Parser.parse = function parse3(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer2(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (;; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start2));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start2 += match[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i3 = 0, list = Object.keys(this.undefinedExports);i3 < list.length; i3 += 1) {
      var name = list[i3];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next + 5, after;
    if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next + 2, after$1;
    if (this.input.slice(next, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i3 = 0;
  for (;i3 < this.labels.length; ++i3) {
    var lab2 = this.labels[i3];
    if (node.label == null || lab2.name === node.label.name) {
      if (lab2.kind != null && (isBreak || lab2.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i3 === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors;
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false;this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels;i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i3 = this.labels.length - 1;i3 >= 0; i3--) {
    var label$1 = this.labels[i3];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === undefined)
    createNewLexicalScope = true;
  if (node === undefined)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (;; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i3 = 0;i3 < used.length; ++i3) {
    var id = used[i3];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i3 = 0, list = node.specifiers;i3 < list.length; i3 += 1) {
        var spec = list[i3];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i3 = 0, list = pat.properties;i3 < list.length; i3 += 1) {
      var prop = list[i3];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements;i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i3 = 0, list = decls;i3 < list.length; i3 += 1) {
    var decl = list[i3];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(exports, node.exported, node.exported.start);
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i3 = 0;i3 < statements.length && this.isDirectiveCandidate(statements[i3]); ++i3) {
    statements[i3].directive = statements[i3].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i3 = 0, list = node.properties;i3 < list.length; i3 += 1) {
          var prop = list[i3];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i3 = 0;i3 < end; i3++) {
    var elt = exprList[i3];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === undefined)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === undefined)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i3 = 0, list = expr.properties;i3 < list.length; i3 += 1) {
        var prop = list[i3];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements;i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === undefined)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types2 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types2.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types2.f_expr || parent === types2.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types2.b_stat || parent === types2.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types2.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i3 = this.context.length - 1;i3 >= 1; i3--) {
    var context = this.context[i3];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types2.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types2.b_stat : types2.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types2.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types2.p_stat : types2.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types2.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types2.b_stat)) {
    this.context.push(types2.f_expr);
  } else {
    this.context.push(types2.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types2.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types2.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types2.f_expr) {
      this.context[index] = types2.f_expr_gen;
    } else {
      this.context[index] = types2.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types2.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types2.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, `
`),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === undefined)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === undefined)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start2 = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start2, "getter should have no params");
    } else {
      this.raiseRecoverable(start2, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression2 = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression2) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i3 = 0, list = params;i3 < list.length; i3 += 1) {
    var param = list[i3];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i3 = 0, list = node.params;i3 < list.length; i3 += 1) {
    var param = list[i3];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = undefined;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start2, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start2, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i3 = this.scopeStack.length - 1;i3 >= 0; --i3) {
      var scope$3 = this.scopeStack[i3];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i3 = this.scopeStack.length - 1;; i3--) {
    var scope = this.scopeStack[i3];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i3 = this.scopeStack.length - 1;; i3--) {
    var scope = this.scopeStack[i3];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node2 = function Node3(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node2(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node2(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node2(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d3 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d3.nonBinary.Script_Extensions = d3.nonBinary.Script;
  d3.nonBinary.gc = d3.nonBinary.General_Category;
  d3.nonBinary.sc = d3.nonBinary.Script;
  d3.nonBinary.scx = d3.nonBinary.Script_Extensions;
}
for (i3 = 0, list = [9, 10, 11, 12, 13, 14];i3 < list.length; i3 += 1) {
  ecmaVersion = list[i3];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i3;
var list;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this;self2; self2 = self2.parent) {
    for (var other = alt;other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i4, forceU) {
  if (forceU === undefined)
    forceU = false;
  var s3 = this.source;
  var l2 = s3.length;
  if (i4 >= l2) {
    return -1;
  }
  var c3 = s3.charCodeAt(i4);
  if (!(forceU || this.switchU) || c3 <= 55295 || c3 >= 57344 || i4 + 1 >= l2) {
    return c3;
  }
  var next = s3.charCodeAt(i4 + 1);
  return next >= 56320 && next <= 57343 ? (c3 << 10) + next - 56613888 : c3;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i4, forceU) {
  if (forceU === undefined)
    forceU = false;
  var s3 = this.source;
  var l2 = s3.length;
  if (i4 >= l2) {
    return l2;
  }
  var c3 = s3.charCodeAt(i4), next;
  if (!(forceU || this.switchU) || c3 <= 55295 || c3 >= 57344 || i4 + 1 >= l2 || (next = s3.charCodeAt(i4 + 1)) < 56320 || next > 57343) {
    return i4 + 1;
  }
  return i4 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === undefined)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === undefined)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === undefined)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === undefined)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === undefined)
    forceU = false;
  var pos = this.pos;
  for (var i4 = 0, list2 = chs;i4 < list2.length; i4 += 1) {
    var ch = list2[i4];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u3 = false;
  var v = false;
  for (var i4 = 0;i4 < flags.length; i4++) {
    var flag = flags.charAt(i4);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i4 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u3 = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u3 && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _3 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(41)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(93) || state.eat(125)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i4 = 0, list2 = state.backReferenceNames;i4 < list2.length; i4 += 1) {
    var name = list2[i4];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(124)) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(123)) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start2 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(94) || state.eat(36)) {
    return true;
  }
  if (state.eat(92)) {
    if (state.eat(66) || state.eat(98)) {
      return true;
    }
    state.pos = start2;
  }
  if (state.eat(40) && state.eat(63)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(60);
    }
    if (state.eat(61) || state.eat(33)) {
      this.regexp_disjunction(state);
      if (!state.eat(41)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === undefined)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(63);
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start2 = state.pos;
  if (state.eat(123)) {
    var min2 = 0, max2 = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min2 = state.lastIntValue;
      if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
        max2 = state.lastIntValue;
      }
      if (state.eat(125)) {
        if (max2 !== -1 && max2 < min2 && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start2 = state.pos;
  if (state.eat(40)) {
    if (state.eat(63)) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(45);
        if (addModifiers || hasHyphen) {
          for (var i4 = 0;i4 < addModifiers.length; i4++) {
            var modifier = addModifiers.charAt(i4);
            if (addModifiers.indexOf(modifier, i4 + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0;i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(58)) {
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(40)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(41)) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start2 = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(63)) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i4 = 0, list2 = known;i4 < list2.length; i4 += 1) {
          var altID = list2[i4];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n3 = state.lastIntValue;
    if (state.switchU) {
      if (n3 > state.maxBackReference) {
        state.maxBackReference = n3;
      }
      return true;
    }
    if (n3 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(107)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start2 = state.pos;
  if (state.eat(99)) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === undefined)
    forceU = false;
  var start2 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(117)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start2;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(47)) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(91)) {
    var negate = state.eat(94);
    var result = this.regexp_classContents(state);
    if (!state.eat(93)) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start2 = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(98)) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(45)) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(99)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start2 = state.pos;
    while (state.eatChars([38, 38])) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
    while (state.eatChars([45, 45])) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (;; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start2 = state.pos;
  if (state.eat(91)) {
    var negate = state.eat(94);
    var result = this.regexp_classContents(state);
    if (state.eat(93)) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start2;
  }
  if (state.eat(92)) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start2 = state.pos;
  if (state.eatChars([92, 113])) {
    if (state.eat(123)) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(125)) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(124)) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start2 = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(98)) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start2;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start2 = state.pos;
  if (state.eat(120)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start2;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start2;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n22 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n22;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start2 = state.pos;
  state.lastIntValue = 0;
  for (var i4 = 0;i4 < length; ++i4) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start2;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = undefined, pos = start2;(nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(true, this.input.slice(start2 + 2, end), start2, this.pos, startLoc, this.curPosition());
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine2(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(false, this.input.slice(start2 + startSkip, this.pos), start2, this.pos, startLoc, this.curPosition());
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  if (ecmaVersion2 >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion2 >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion2 >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (;; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start2, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e3) {}
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i4 = 0, e3 = len == null ? Infinity : len;i4 < e3; ++i4, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = undefined;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i4 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine2(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine2(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += `
`;
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (;this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === `
`) {
          ++this.pos;
        }
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "\t";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(codePos, "Invalid escape sequence in template string");
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine2(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n3 = this.readInt(16, len);
  if (n3 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n3;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.15.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node: Node2,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types2,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine: isNewLine2,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse4(input, options) {
  return Parser.parse(input, options);
}

// node_modules/@nativescript/core/ui/core/bindable/bindable-expressions.js
var expressionsCache = {};
var FORCED_CHAIN_VALUE = Symbol("forcedChain");
var unaryOperators = {
  "+": (v) => +v,
  "-": (v) => -v,
  "!": (v) => !v,
  void: (v) => {
    return;
  },
  typeof: (v) => typeof v
};
var binaryOperators = {
  "+": (l2, r3) => l2 + r3,
  "-": (l2, r3) => l2 - r3,
  "*": (l2, r3) => l2 * r3,
  "**": (l2, r3) => l2 ** r3,
  "/": (l2, r3) => l2 / r3,
  "%": (l2, r3) => l2 % r3,
  "<": (l2, r3) => l2 < r3,
  ">": (l2, r3) => l2 > r3,
  "<=": (l2, r3) => l2 <= r3,
  ">=": (l2, r3) => l2 >= r3,
  "==": (l2, r3) => l2 == r3,
  "!=": (l2, r3) => l2 != r3,
  "===": (l2, r3) => l2 === r3,
  "!==": (l2, r3) => l2 !== r3,
  "|": (l2, r3) => l2 | r3,
  in: (l2, r3) => (l2 in r3),
  instanceof: (l2, r3) => l2 instanceof r3
};
var logicalOperators = {
  "&&": (l2, r3) => l2 && r3(),
  "||": (l2, r3) => l2 || r3(),
  "??": (l2, r3) => l2 ?? r3()
};
var expressionParsers = {
  ArrayExpression: (expression, model, isBackConvert, changedModel) => {
    const parsed = [];
    for (const element of expression.elements) {
      const value = convertExpressionToValue(element, model, isBackConvert, changedModel);
      element.type == "SpreadElement" ? parsed.push(...value) : parsed.push(value);
    }
    return parsed;
  },
  BinaryExpression: (expression, model, isBackConvert, changedModel) => {
    if (binaryOperators[expression.operator] == null) {
      throw new Error("Disallowed binary operator: " + expression.operator);
    }
    const left = convertExpressionToValue(expression.left, model, isBackConvert, changedModel);
    let converterExpression = expression.right;
    if (expression.operator == "|") {
      if (converterExpression.type == "ChainExpression") {
        converterExpression = converterExpression.expression;
      }
      if (converterExpression.type == "CallExpression") {
        !converterExpression.arguments.includes(expression.left) && converterExpression.arguments.unshift(expression.left);
        expression.right.nsIsCallable = true;
        converterExpression = converterExpression.callee;
      }
      switch (converterExpression.type) {
        case "Identifier":
        case "MemberExpression":
        case "NewExpression":
          converterExpression.nsRequiresConverter = true;
          converterExpression.nsIsPendingCall = true;
          break;
        default:
          throw new Error("Invalid converter syntax");
      }
    }
    const right = convertExpressionToValue(expression.right, model, isBackConvert, changedModel);
    if (expression.operator == "|") {
      if (converterExpression.nsRequiresConverter) {
        if (expression.right.nsIsCallable) {
          return right;
        }
        if (isFunction(right)) {
          return right(left);
        }
        if (isNullOrUndefined(right)) {
          throw new Error("Cannot perform a call using a null or undefined property");
        }
      }
      throw new Error("Invalid converter syntax");
    }
    return binaryOperators[expression.operator](left, right);
  },
  CallExpression: (expression, model, isBackConvert, changedModel) => {
    expression.callee.nsIsPendingCall = true;
    const callback = convertExpressionToValue(expression.callee, model, isBackConvert, changedModel);
    if (!expression.optional && isNullOrUndefined(callback)) {
      throw new Error("Cannot perform a call using a null or undefined property");
    }
    const parsedArgs = [];
    for (const argument of expression.arguments) {
      const value = convertExpressionToValue(argument, model, isBackConvert, changedModel);
      argument.type == "SpreadElement" ? parsedArgs.push(...value) : parsedArgs.push(value);
    }
    return expression.optional ? callback?.(...parsedArgs) : callback(...parsedArgs);
  },
  ChainExpression: (expression, model, isBackConvert, changedModel) => {
    return convertExpressionToValue(expression.expression, model, isBackConvert, changedModel);
  },
  ConditionalExpression: (expression, model, isBackConvert, changedModel) => {
    const test = convertExpressionToValue(expression.test, model, isBackConvert, changedModel);
    return convertExpressionToValue(expression[test ? "consequent" : "alternate"], model, isBackConvert, changedModel);
  },
  Identifier: (expression, model, isBackConvert, changedModel) => {
    const context = getContext(expression.name, model, changedModel);
    let value = context[expression.name];
    if (expression.nsRequiresConverter) {
      value = getConverterCallback(value, isBackConvert);
    }
    return expression.nsIsPendingCall && typeof value === "function" ? value.bind(context) : value;
  },
  Literal: (expression, model, isBackConvert, changedModel) => {
    return expression.regex != null ? new RegExp(expression.regex.pattern, expression.regex.flags) : expression.value;
  },
  LogicalExpression: (expression, model, isBackConvert, changedModel) => {
    if (logicalOperators[expression.operator] == null) {
      throw new Error("Disallowed logical operator: " + expression.operator);
    }
    const left = convertExpressionToValue(expression.left, model, isBackConvert, changedModel);
    return logicalOperators[expression.operator](left, () => convertExpressionToValue(expression.right, model, isBackConvert, changedModel));
  },
  MemberExpression: (expression, model, isBackConvert, changedModel) => {
    if (expression.object.type == "MemberExpression") {
      expression.object.nsIsChained = true;
    }
    const object = convertExpressionToValue(expression.object, model, isBackConvert, changedModel);
    const property = expression.computed ? convertExpressionToValue(expression.property, model, isBackConvert, changedModel) : expression.property?.name;
    if (object == null && expression.object.type == "Identifier") {
      return expression.nsIsChained ? FORCED_CHAIN_VALUE : undefined;
    }
    if (object == FORCED_CHAIN_VALUE) {
      return expression.nsIsChained ? object : undefined;
    }
    let value = expression.optional ? object?.[property] : object[property];
    if (expression.nsRequiresConverter) {
      value = getConverterCallback(value, isBackConvert);
    }
    return expression.nsIsPendingCall && typeof value === "function" ? value.bind(object) : value;
  },
  NewExpression: (expression, model, isBackConvert, changedModel) => {
    const callback = convertExpressionToValue(expression.callee, model, isBackConvert, changedModel);
    const parsedArgs = [];
    for (const argument of expression.arguments) {
      const value2 = convertExpressionToValue(argument, model, isBackConvert, changedModel);
      argument.type == "SpreadElement" ? parsedArgs.push(...value2) : parsedArgs.push(value2);
    }
    let value = new callback(...parsedArgs);
    if (expression.nsRequiresConverter) {
      value = getConverterCallback(value, isBackConvert);
    }
    return value;
  },
  ObjectExpression: (expression, model, isBackConvert, changedModel) => {
    const parsedObject = {};
    for (const property of expression.properties) {
      const value = convertExpressionToValue(property, model, isBackConvert, changedModel);
      Object.assign(parsedObject, value);
    }
    return parsedObject;
  },
  Property: (expression, model, isBackConvert, changedModel) => {
    const key = expression.computed ? convertExpressionToValue(expression.key, model, isBackConvert, changedModel) : expression.key?.name;
    const value = convertExpressionToValue(expression.value, model, isBackConvert, changedModel);
    return { [key]: value };
  },
  SpreadElement: (expression, model, isBackConvert, changedModel) => {
    const argument = convertExpressionToValue(expression.argument, model, isBackConvert, changedModel);
    return argument;
  },
  TemplateElement: (expression, model, isBackConvert, changedModel) => {
    return expression.value.cooked;
  },
  TemplateLiteral: (expression, model, isBackConvert, changedModel) => {
    let parsedText = "";
    const length = expression.quasis.length;
    for (let i4 = 0;i4 < length; i4++) {
      const q2 = expression.quasis[i4];
      parsedText += convertExpressionToValue(q2, model, isBackConvert, changedModel);
      if (!q2.tail) {
        parsedText += convertExpressionToValue(expression.expressions[i4], model, isBackConvert, changedModel);
      }
    }
    return parsedText;
  },
  UnaryExpression: (expression, model, isBackConvert, changedModel) => {
    if (unaryOperators[expression.operator] == null) {
      throw Error("Disallowed unary operator: " + expression.operator);
    }
    const argument = convertExpressionToValue(expression.argument, model, isBackConvert, changedModel);
    return unaryOperators[expression.operator](argument);
  }
};
function getContext(key, model, changedModel) {
  let context = key in changedModel ? changedModel : model;
  if (!(key in context)) {
    context = global;
  }
  return context;
}
function getConverterCallback(value, isBackConvert) {
  let callback = null;
  if (isNullOrUndefined(value)) {
    callback = value;
  } else if (isFunction(value)) {
    callback = isBackConvert ? Function.prototype : value;
  } else if (isObject(value) && (isFunction(value.toModel) || isFunction(value.toView))) {
    callback = (isBackConvert ? value.toModel : value.toView) || Function.prototype;
  } else {
    callback = value;
  }
  return callback;
}
function parseExpression(expressionText) {
  let expression = expressionsCache[expressionText];
  if (expression == null) {
    const program = parse4(expressionText, { ecmaVersion: 2020 });
    const statements = program.body;
    for (const statement of statements) {
      if (statement.type == "ExpressionStatement") {
        expression = statement.expression;
        break;
      }
    }
    expressionsCache[expressionText] = expression;
  }
  return expression;
}
function convertExpressionToValue(expression, model, isBackConvert, changedModel) {
  if (!(expression.type in expressionParsers)) {
    throw Error("Invalid expression syntax");
  }
  return expressionParsers[expression.type](expression, model, isBackConvert, changedModel);
}

// node_modules/@nativescript/core/ui/core/bindable/bindable-resources.js
var resources2 = {};
function get() {
  return resources2;
}
function set(res) {
  resources2 = res;
}

// node_modules/@nativescript/core/ui/core/bindable/index.js
var paramsRegex = /\[\s*(['"])*(\w*)\1\s*\]/;
var bc = bindingConstants;
var emptyArray = [];
var propertiesCache = {};
function getProperties(property) {
  if (!property) {
    return emptyArray;
  }
  let result = propertiesCache[property];
  if (result) {
    return result;
  }
  const parentsMatches = property.match(parentsRegex);
  result = property.replace(parentsRegex, "parentsMatch").replace(/\]/g, "").split(/\.|\[/);
  let parentsMatchesCounter = 0;
  for (let i4 = 0, resultLength = result.length;i4 < resultLength; i4++) {
    if (result[i4] === "parentsMatch") {
      result[i4] = parentsMatches[parentsMatchesCounter++];
    }
  }
  propertiesCache[property] = result;
  return result;
}
function getEventOrGestureName(name) {
  return name.indexOf("on") === 0 ? name.slice(2) : name;
}
function isGesture(eventOrGestureName) {
  const t3 = eventOrGestureName.trim().toLowerCase();
  return t3 === "tap" || t3 === "doubletap" || t3 === "pinch" || t3 === "pan" || t3 === "swipe" || t3 === "rotation" || t3 === "longpress" || t3 === "touch";
}
function isEventOrGesture(name, view) {
  if (typeof name === "string") {
    const eventOrGestureName = getEventOrGestureName(name);
    const evt = `${eventOrGestureName}Event`;
    return view.constructor && evt in view.constructor || isGesture(eventOrGestureName);
  }
  return false;
}

class Binding {
  constructor(target, options) {
    this.propertyChangeListeners = new Map;
    this.target = new WeakRef(target);
    this.options = options;
    this.sourceProperties = getProperties(options.sourceProperty);
    this.targetOptions = this.resolveOptions(target, getProperties(options.targetProperty));
    if (!this.targetOptions) {
      throw new Error(`Invalid property: ${options.targetProperty} for target: ${target}`);
    }
    if (options.twoWay) {
      const target2 = this.targetOptions.instance.get();
      if (target2 instanceof Observable) {
        target2.on(`${this.targetOptions.property}Change`, this.onTargetPropertyChanged, this);
      }
    }
  }
  onTargetPropertyChanged(data2) {
    this.updateTwoWay(data2.value);
  }
  loadedHandlerVisualTreeBinding(args) {
    const target = args.object;
    target.off("loaded", this.loadedHandlerVisualTreeBinding, this);
    const context = target.bindingContext;
    if (context !== undefined && context !== null) {
      this.update(context);
    }
  }
  clearSource() {
    this.propertyChangeListeners.forEach((observable, index, map) => {
      removeWeakEventListener(observable, Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
    });
    this.propertyChangeListeners.clear();
    if (this.sourceOptions) {
      this.sourceOptions.instance = undefined;
      this.sourceOptions = undefined;
    }
  }
  sourceAsObject(source) {
    const objectType = typeof source;
    if (objectType === "number") {
      source = new Number(source);
    } else if (objectType === "boolean") {
      source = new Boolean(source);
    } else if (objectType === "string") {
      source = new String(source);
    }
    return source;
  }
  bindingContextChanged(data2) {
    const target = this.targetOptions.instance.get();
    if (!target) {
      this.unbind();
      return;
    }
    const value = data2.value;
    if (value !== null && value !== undefined) {
      this.update(value);
    } else {
      this.clearBinding();
    }
  }
  bind(source) {
    const target = this.targetOptions.instance.get();
    if (this.sourceIsBindingContext && target instanceof Observable && this.targetOptions.property !== "bindingContext") {
      target.on("bindingContextChange", this.bindingContextChanged, this);
    }
    this.update(source);
  }
  update(source) {
    this.clearSource();
    source = this.sourceAsObject(source);
    if (!isNullOrUndefined(source)) {
      this.source = new WeakRef(source);
      this.sourceOptions = this.resolveOptions(source, this.sourceProperties);
      const sourceValue = this.getSourcePropertyValue();
      this.updateTarget(sourceValue);
      this.addPropertyChangeListeners(this.source, this.sourceProperties);
    } else if (!this.sourceIsBindingContext) {
      const sourceValue = this.getSourcePropertyValue();
      this.updateTarget(sourceValue ? sourceValue : source);
    }
  }
  unbind() {
    const target = this.targetOptions.instance.get();
    if (target instanceof Observable) {
      if (this.options.twoWay) {
        target.off(`${this.targetOptions.property}Change`, this.onTargetPropertyChanged, this);
      }
      if (this.sourceIsBindingContext && this.targetOptions.property !== "bindingContext") {
        target.off("bindingContextChange", this.bindingContextChanged, this);
      }
    }
    if (this.targetOptions) {
      this.targetOptions = undefined;
    }
    this.sourceProperties = undefined;
    if (!this.source) {
      return;
    }
    this.clearSource();
  }
  resolveObjectsAndProperties(source, properties) {
    const result = [];
    let currentObject = source;
    let currentObjectChanged = false;
    for (let i4 = 0, propsArrayLength = properties.length;i4 < propsArrayLength; i4++) {
      const property = properties[i4];
      if (property === bc.bindingValueKey) {
        currentObjectChanged = true;
      }
      if (property === bc.parentValueKey || property.indexOf(bc.parentsValueKey) === 0) {
        const parentView = this.getParentView(this.target.get(), property).view;
        if (parentView) {
          currentObject = parentView.bindingContext;
        } else {
          const targetInstance = this.target.get();
          targetInstance.off("loaded", this.loadedHandlerVisualTreeBinding, this);
          targetInstance.on("loaded", this.loadedHandlerVisualTreeBinding, this);
        }
        currentObjectChanged = true;
      }
      if (currentObject) {
        result.push({ instance: currentObject, property });
      } else {
        break;
      }
      if (!currentObjectChanged && i4 < propsArrayLength - 1) {
        currentObject = currentObject ? currentObject[properties[i4]] : null;
      }
      currentObjectChanged = false;
    }
    return result;
  }
  addPropertyChangeListeners(source, sourceProperty, parentProperies) {
    const objectsAndProperties = this.resolveObjectsAndProperties(source.get(), sourceProperty);
    let prop = parentProperies || "";
    for (let i4 = 0, length = objectsAndProperties.length;i4 < length; i4++) {
      const propName = objectsAndProperties[i4].property;
      prop += "$" + propName;
      const currentObject = objectsAndProperties[i4].instance;
      if (!this.propertyChangeListeners.has(prop) && currentObject instanceof Observable && currentObject._isViewBase) {
        addWeakEventListener(currentObject, `${propName}Change`, this.onSourcePropertyChanged, this);
        addWeakEventListener(currentObject, Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
        this.propertyChangeListeners.set(prop, currentObject);
      } else if (!this.propertyChangeListeners.has(prop) && currentObject instanceof Observable) {
        addWeakEventListener(currentObject, Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
        this.propertyChangeListeners.set(prop, currentObject);
      }
    }
  }
  prepareExpressionForUpdate() {
    const escapedSourceProperty = escapeRegexSymbols(this.options.sourceProperty);
    const expRegex = new RegExp(escapedSourceProperty, "g");
    const resultExp = this.options.expression.replace(expRegex, bc.newPropertyValueKey);
    return resultExp;
  }
  updateTwoWay(value) {
    if (this.updating || !this.options.twoWay) {
      return;
    }
    let newValue = value;
    if (__UI_USE_EXTERNAL_RENDERER__) {} else if (this.options.expression) {
      const changedModel = {};
      const targetInstance = this.target.get();
      let sourcePropertyName = "";
      if (this.sourceOptions) {
        sourcePropertyName = this.sourceOptions.property;
      } else if (typeof this.options.sourceProperty === "string" && this.options.sourceProperty.indexOf(".") === -1) {
        sourcePropertyName = this.options.sourceProperty;
      }
      const updateExpression = this.prepareExpressionForUpdate();
      this.prepareContextForExpression(targetInstance, changedModel, updateExpression);
      changedModel[bc.bindingValueKey] = value;
      changedModel[bc.newPropertyValueKey] = value;
      if (sourcePropertyName !== "") {
        changedModel[sourcePropertyName] = value;
      }
      const expressionValue = this._getExpressionValue(updateExpression, true, changedModel);
      if (expressionValue instanceof Error) {
        Trace.write(expressionValue.message, Trace.categories.Binding, Trace.messageType.error);
      }
      newValue = expressionValue;
    }
    this.updateSource(newValue);
  }
  _getExpressionValue(expression, isBackConvert, changedModel) {
    let result = null;
    if (!__UI_USE_EXTERNAL_RENDERER__) {
      let context;
      const targetInstance = this.target.get();
      const addedProps = [];
      try {
        let exp2;
        try {
          exp2 = parseExpression(expression);
        } catch (e3) {
          result = new Error(e3 + " at " + targetInstance);
        }
        if (exp2) {
          context = this.source && this.source.get && this.source.get() || global;
          const resources3 = get();
          for (const prop in resources3) {
            if (resources3.hasOwnProperty(prop) && !context.hasOwnProperty(prop)) {
              context[prop] = resources3[prop];
              addedProps.push(prop);
            }
          }
          if (this.prepareContextForExpression(targetInstance, context, expression, addedProps)) {
            result = convertExpressionToValue(exp2, context, isBackConvert, changedModel ? changedModel : context);
          } else {
            targetInstance.off("loaded", this.loadedHandlerVisualTreeBinding, this);
            targetInstance.on("loaded", this.loadedHandlerVisualTreeBinding, this);
          }
        }
      } catch (e3) {
        result = new Error(e3 + " at " + targetInstance);
      }
      for (const prop of addedProps) {
        delete context[prop];
      }
      addedProps.length = 0;
    }
    return result;
  }
  onSourcePropertyChanged(data2) {
    const sourceProps = this.sourceProperties;
    const sourcePropsLength = sourceProps.length;
    let changedPropertyIndex = sourceProps.indexOf(data2.propertyName);
    let parentProps = "";
    if (changedPropertyIndex > -1) {
      parentProps = "$" + sourceProps.slice(0, changedPropertyIndex + 1).join("$");
      while (this.propertyChangeListeners.get(parentProps) !== data2.object) {
        changedPropertyIndex += sourceProps.slice(changedPropertyIndex + 1).indexOf(data2.propertyName) + 1;
        parentProps = "$" + sourceProps.slice(0, changedPropertyIndex + 1).join("$");
      }
    }
    if (__UI_USE_EXTERNAL_RENDERER__ || !this.options.expression) {
      if (changedPropertyIndex > -1) {
        const props = sourceProps.slice(changedPropertyIndex + 1);
        const propsLength = props.length;
        if (propsLength > 0) {
          let value = data2.value;
          for (let i4 = 0;i4 < propsLength; i4++) {
            value = value[props[i4]];
          }
          this.updateTarget(value);
        } else if (data2.propertyName === this.sourceOptions.property) {
          this.updateTarget(data2.value);
        }
      }
    } else {
      const expressionValue = this._getExpressionValue(this.options.expression, false, undefined);
      if (expressionValue instanceof Error) {
        Trace.write(expressionValue.message, Trace.categories.Binding, Trace.messageType.error);
      } else {
        this.updateTarget(expressionValue);
      }
    }
    if (changedPropertyIndex > -1 && changedPropertyIndex < sourcePropsLength - 1) {
      const probablyChangedObject = this.propertyChangeListeners.get(parentProps);
      if (probablyChangedObject && probablyChangedObject !== data2.object[sourceProps[changedPropertyIndex]]) {
        for (let i4 = sourcePropsLength - 1;i4 > changedPropertyIndex; i4--) {
          const prop = "$" + sourceProps.slice(0, i4 + 1).join("$");
          if (this.propertyChangeListeners.has(prop)) {
            removeWeakEventListener(this.propertyChangeListeners.get(prop), Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
            this.propertyChangeListeners.delete(prop);
          }
        }
        const newProps = sourceProps.slice(changedPropertyIndex + 1);
        const newObject = data2.object[sourceProps[changedPropertyIndex]];
        if (!isNullOrUndefined(newObject) && typeof newObject === "object") {
          this.addPropertyChangeListeners(new WeakRef(newObject), newProps, parentProps);
        }
      }
    }
  }
  prepareContextForExpression(target, model, expression, addedProps = []) {
    let success = true;
    let parentViewAndIndex;
    let parentView;
    let expressionCP = expression;
    if (expressionCP.indexOf(bc.bindingValueKey) > -1) {
      model[bc.bindingValueKey] = model;
      addedProps.push(bc.bindingValueKey);
    }
    const parentsArray = expressionCP.match(parentsRegex);
    if (parentsArray) {
      for (let i4 = 0;i4 < parentsArray.length; i4++) {
        expressionCP = expressionCP.replace(parentsArray[i4], "");
        parentViewAndIndex = this.getParentView(target, parentsArray[i4]);
        if (parentViewAndIndex.view) {
          model[bc.parentsValueKey] = model[bc.parentsValueKey] || {};
          model[bc.parentsValueKey][parentViewAndIndex.index] = parentViewAndIndex.view.bindingContext;
          addedProps.push(bc.parentsValueKey);
        } else {
          success = false;
        }
      }
    }
    if (expressionCP.indexOf(bc.parentValueKey) > -1) {
      parentView = this.getParentView(target, bc.parentValueKey).view;
      if (parentView) {
        model[bc.parentValueKey] = parentView.bindingContext;
        addedProps.push(bc.parentValueKey);
      } else {
        success = false;
      }
    }
    return success;
  }
  getSourcePropertyValue() {
    if (__UI_USE_EXTERNAL_RENDERER__) {} else if (this.options.expression) {
      const changedModel = {};
      changedModel[bc.bindingValueKey] = this.source ? this.source.get() : undefined;
      const expressionValue = this._getExpressionValue(this.options.expression, false, changedModel);
      if (expressionValue instanceof Error) {
        Trace.write(expressionValue.message, Trace.categories.Binding, Trace.messageType.error);
      } else {
        return expressionValue;
      }
    }
    if (this.sourceOptions) {
      const sourceOptionsInstance = this.sourceOptions.instance.get();
      if (this.sourceOptions.property === bc.bindingValueKey) {
        return sourceOptionsInstance;
      } else if (sourceOptionsInstance instanceof Observable && this.sourceOptions.property && this.sourceOptions.property !== "") {
        return sourceOptionsInstance.get(this.sourceOptions.property);
      } else if (sourceOptionsInstance && this.sourceOptions.property && this.sourceOptions.property !== "" && this.sourceOptions.property in sourceOptionsInstance) {
        return sourceOptionsInstance[this.sourceOptions.property];
      } else {
        Trace.write("Property: '" + this.sourceOptions.property + "' is invalid or does not exist. SourceProperty: '" + this.options.sourceProperty + "'", Trace.categories.Binding, Trace.messageType.error);
      }
    }
    return null;
  }
  clearBinding() {
    this.clearSource();
    this.updateTarget(unsetValue);
  }
  updateTarget(value) {
    if (this.updating) {
      return;
    }
    this.updateOptions(this.targetOptions, isNullOrUndefined(value) ? unsetValue : value);
  }
  updateSource(value) {
    if (this.updating || !this.source || !this.source.get()) {
      return;
    }
    this.updateOptions(this.sourceOptions, value);
  }
  getParentView(target, property) {
    if (!target) {
      return { view: null, index: null };
    }
    let result;
    if (property === bc.parentValueKey) {
      result = target.parent;
    }
    let index = null;
    if (property.indexOf(bc.parentsValueKey) === 0) {
      result = target.parent;
      const indexParams = paramsRegex.exec(property);
      if (indexParams && indexParams.length > 1) {
        index = indexParams[2];
      }
      if (!isNaN(index)) {
        let indexAsInt = parseInt(index);
        while (indexAsInt > 0) {
          result = result.parent;
          indexAsInt--;
        }
      } else if (isString(index)) {
        while (result && result.typeName !== index) {
          result = result.parent;
        }
      }
    }
    return { view: result, index };
  }
  resolveOptions(obj, properties) {
    const objectsAndProperties = this.resolveObjectsAndProperties(obj, properties);
    if (objectsAndProperties.length > 0) {
      const resolvedObj = objectsAndProperties[objectsAndProperties.length - 1].instance;
      const prop = objectsAndProperties[objectsAndProperties.length - 1].property;
      return {
        instance: new WeakRef(this.sourceAsObject(resolvedObj)),
        property: prop
      };
    }
    return null;
  }
  updateOptions(options, value) {
    let optionsInstance;
    if (options && options.instance) {
      optionsInstance = options.instance.get();
    }
    if (!optionsInstance) {
      return;
    }
    this.updating = true;
    try {
      if (isEventOrGesture(options.property, optionsInstance) && isFunction(value)) {
        optionsInstance.off(options.property);
        optionsInstance.on(options.property, value, optionsInstance.bindingContext);
      } else if (optionsInstance instanceof Observable) {
        optionsInstance.set(options.property, value);
      } else {
        optionsInstance[options.property] = value;
      }
    } catch (ex) {
      Trace.write("Binding error while setting property " + options.property + " of " + optionsInstance + ": " + ex, Trace.categories.Binding, Trace.messageType.error);
    }
    this.updating = false;
  }
}

// node_modules/@nativescript/core/module-name-resolver/qualifier-matcher/index.js
var MIN_WH = "minWH";
var MIN_W = "minW";
var MIN_H = "minH";
var PRIORITY_STEP = 1e4;
var minWidthHeightQualifier = {
  isMatch: function(path2) {
    return new RegExp(`.${MIN_WH}\\d+`).test(path2);
  },
  getMatchOccurences: function(path2) {
    return path2.match(new RegExp(`.${MIN_WH}\\d+`, "g"));
  },
  getMatchValue(value, context) {
    const numVal = parseInt(value.substring(MIN_WH.length + 1));
    if (isNaN(numVal)) {
      return -1;
    }
    const actualLength = Math.min(context.width, context.height);
    if (actualLength < numVal) {
      return -1;
    }
    return PRIORITY_STEP - (actualLength - numVal);
  }
};
var minWidthQualifier = {
  isMatch: function(path2) {
    return new RegExp(`.${MIN_W}\\d+`).test(path2) && !new RegExp(`.${MIN_WH}\\d+`).test(path2);
  },
  getMatchOccurences: function(path2) {
    return path2.match(new RegExp(`.${MIN_W}\\d+`, "g"));
  },
  getMatchValue(value, context) {
    const numVal = parseInt(value.substring(MIN_W.length + 1));
    if (isNaN(numVal)) {
      return -1;
    }
    const actualWidth = context.width;
    if (actualWidth < numVal) {
      return -1;
    }
    return PRIORITY_STEP - (actualWidth - numVal);
  }
};
var minHeightQualifier = {
  isMatch: function(path2) {
    return new RegExp(`.${MIN_H}\\d+`).test(path2) && !new RegExp(`.${MIN_WH}\\d+`).test(path2);
  },
  getMatchOccurences: function(path2) {
    return path2.match(new RegExp(`.${MIN_H}\\d+`, "g"));
  },
  getMatchValue(value, context) {
    const numVal = parseInt(value.substring(MIN_H.length + 1));
    if (isNaN(numVal)) {
      return -1;
    }
    const actualHeight = context.height;
    if (actualHeight < numVal) {
      return -1;
    }
    return PRIORITY_STEP - (actualHeight - numVal);
  }
};
var platformQualifier = {
  isMatch: function(path2) {
    return path2.includes(".android") || path2.includes(".ios");
  },
  getMatchOccurences: function(path2) {
    return path2.match(new RegExp("\\.android|\\.ios", "g"));
  },
  getMatchValue(value, context) {
    const val = value.substring(1);
    return val === context.os.toLowerCase() ? 1 : -1;
  }
};
var orientationQualifier = {
  isMatch: function(path2) {
    return path2.includes(".land") || path2.includes(".port");
  },
  getMatchOccurences: function(path2) {
    return path2.match(new RegExp("\\.land|\\.port", "g"));
  },
  getMatchValue(value, context) {
    const val = value.substring(1);
    const isLandscape = context.width > context.height ? 1 : -1;
    return val === "land" ? isLandscape : -isLandscape;
  }
};
var supportedQualifiers = [minWidthHeightQualifier, minWidthQualifier, minHeightQualifier, orientationQualifier, platformQualifier];
function checkQualifiers(path2, context) {
  let result = 0;
  let value;
  for (let i4 = 0;i4 < supportedQualifiers.length; i4++) {
    const qualifier = supportedQualifiers[i4];
    if (qualifier.isMatch(path2)) {
      const occurences = qualifier.getMatchOccurences(path2);
      value = qualifier.getMatchValue(occurences[occurences.length - 1], context);
      if (value < 0) {
        return -1;
      }
      if (value > 0) {
        result += value + (supportedQualifiers.length - i4) * PRIORITY_STEP;
      }
    }
  }
  return result;
}
function stripQualifiers(path2) {
  for (let i4 = 0;i4 < supportedQualifiers.length; i4++) {
    const qualifier = supportedQualifiers[i4];
    if (qualifier.isMatch(path2)) {
      const occurences = qualifier.getMatchOccurences(path2);
      for (let j2 = 0;j2 < occurences.length; j2++) {
        path2 = path2.replace(occurences[j2], "");
      }
    }
  }
  return path2;
}
function findMatch(path2, ext, candidates, context) {
  const fullPath = ext ? path2 + ext : path2;
  let bestValue = -1;
  let result = null;
  for (let i4 = 0;i4 < candidates.length; i4++) {
    const filePath = candidates[i4];
    const cleanFilePath = stripQualifiers(filePath);
    if (cleanFilePath !== fullPath) {
      continue;
    }
    const value = checkQualifiers(filePath, context);
    if (value >= 0 && value > bestValue) {
      bestValue = value;
      result = candidates[i4];
    }
  }
  return result;
}

// node_modules/@nativescript/core/module-name-resolver/index.js
class ModuleNameResolver {
  constructor(context, moduleListProvider = global.getRegisteredModules) {
    this.context = context;
    this.moduleListProvider = moduleListProvider;
    this._cache = {};
    initAppForModuleResolver();
  }
  resolveModuleName(path2, ext) {
    const key = path2 + ext;
    let result = this._cache[key];
    if (result === undefined) {
      result = this.resolveModuleNameImpl(path2, ext);
      this._cache[key] = result;
    }
    if (Trace.isEnabled()) {
      Trace.write(`path: '${path2}' with ext: '${ext}' resolved: '${result}'`, Trace.categories.ModuleNameResolver);
    }
    return result;
  }
  clearCache() {
    this._cache = {};
  }
  resolveModuleNameImpl(path2, ext) {
    let result = null;
    ext = ext ? "." + ext : "";
    path2 = stripQualifiers(path2);
    const candidates = this.getCandidates(path2, ext);
    result = findMatch(path2, ext, candidates, this.context);
    return result;
  }
  getCandidates(path2, ext) {
    const candidates = this.moduleListProvider().filter((moduleName) => moduleName.startsWith(path2) && (!ext || moduleName.endsWith(ext)));
    return candidates;
  }
}
function resolveModuleName(path2, ext) {
  if (global.__snapshot) {
    return resolveModuleSnapshot(path2, ext);
  }
  if (!getResolveInstance()) {
    _setResolver(new ModuleNameResolver({
      width: Screen.mainScreen.widthDIPs,
      height: Screen.mainScreen.heightDIPs,
      os: Device.os,
      deviceType: Device.deviceType
    }));
  }
  return getResolveInstance().resolveModuleName(path2, ext);
}
function resolveModuleSnapshot(path2, ext) {
  Trace.write(`Resolving module in SNAPSHOT context - path: '${path2}' with ext: '${ext}'`, Trace.categories.ModuleNameResolver);
  return new ModuleNameResolver({
    width: 400,
    height: 800,
    os: "Android",
    deviceType: "Phone"
  }).resolveModuleName(path2, ext);
}

// node_modules/@nativescript/core/ui/builder/component-builder/index.js
var legacyShortBarrels = [
  "text/formatted-string",
  "text/span",
  "ui/text-base/formatted-string",
  "ui/text-base/span",
  "ui/action-bar",
  "ui/activity-indicator",
  "ui/button",
  "ui/content-view",
  "ui/date-picker",
  "ui/frame",
  "ui/html-view",
  "ui/image",
  "ui/label",
  "ui/layouts/absolute-layout",
  "ui/layouts/dock-layout",
  "ui/layouts/grid-layout",
  "ui/layouts/stack-layout",
  "ui/layouts/flexbox-layout",
  "ui/layouts/wrap-layout",
  "ui/list-picker",
  "ui/page",
  "ui/placeholder",
  "ui/progress",
  "ui/proxy-view-container",
  "ui/repeater",
  "ui/scroll-view",
  "ui/search-bar",
  "ui/segmented-bar",
  "ui/slider",
  "ui/switch",
  "ui/tab-view",
  "ui/web-view",
  "ui/text-field",
  "ui/text-view",
  "ui/time-picker",
  "ui/list-view"
];
var CORE_UI_BARREL = "@nativescript/core/ui";
var CODE_FILE = "codeFile";
var CSS_FILE = "cssFile";
var IMPORT = "import";
var createComponentInstance = profile("createComponentInstance", (elementName, namespace) => {
  let instance;
  let instanceModule;
  let resolvedModuleName;
  try {
    if (typeof namespace === "string") {
      if (legacyShortBarrels.includes(namespace)) {
        resolvedModuleName = CORE_UI_BARREL;
      } else {
        resolvedModuleName = resolveModuleName(namespace, "");
      }
      instanceModule = global.loadModule(resolvedModuleName);
    } else {
      instanceModule = global.loadModule(CORE_UI_BARREL);
    }
    const instanceType = instanceModule[elementName];
    instance = new instanceType;
  } catch (ex) {
    throw new ScopeError(ex, "Module '" + (resolvedModuleName || elementName) + "' not found for element '" + (namespace ? namespace + ":" : "") + elementName + "'.");
  }
  return { instance, instanceModule };
});
var getComponentModuleExports = profile("getComponentModuleExports", (instance, moduleExports, attributes) => {
  if (attributes) {
    const codeFileAttribute = attributes[CODE_FILE] || attributes[IMPORT];
    if (codeFileAttribute) {
      const resolvedCodeFileModule = resolveModuleName(sanitizeModuleName(codeFileAttribute), "");
      if (resolvedCodeFileModule) {
        moduleExports = global.loadModule(resolvedCodeFileModule);
        instance.exports = moduleExports;
      } else {
        throw new Error(`Code file with path "${codeFileAttribute}" cannot be found! Looking for webpack module with name "${resolvedCodeFileModule}"`);
      }
    }
  }
  return moduleExports;
});
var applyComponentCss = profile("applyComponentCss", (instance, moduleName, attributes) => {
  let cssApplied = false;
  if (attributes && attributes[CSS_FILE]) {
    const resolvedCssModuleName = resolveModuleName(sanitizeModuleName(attributes[CSS_FILE]), "css");
    if (resolvedCssModuleName) {
      instance.addCssFile(resolvedCssModuleName);
      cssApplied = true;
    } else {
      throw new Error(`Css file with path "${attributes[CSS_FILE]}" cannot be found! Looking for webpack module with name "${resolvedCssModuleName}"`);
    }
  }
  if (moduleName && !cssApplied) {
    const resolvedCssModuleName = resolveModuleName(moduleName, "css");
    if (resolvedCssModuleName) {
      instance.addCssFile(resolvedCssModuleName);
    }
  }
});
var applyComponentAttributes = profile("applyComponentAttributes", (instance, instanceModule, moduleExports, attributes) => {
  if (instance && instanceModule) {
    for (let attr in attributes) {
      const attrValue = attributes[attr];
      if (attr.indexOf(":") !== -1) {
        const platformName = attr.split(":")[0].trim();
        if (platformName.toLowerCase() === Device.os.toLowerCase()) {
          attr = attr.split(":")[1].trim();
        } else {
          continue;
        }
      }
      if (attr.indexOf(".") !== -1) {
        let subObj = instance;
        const properties = attr.split(".");
        const subPropName = properties[properties.length - 1];
        for (let i4 = 0;i4 < properties.length - 1; i4++) {
          if (subObj !== undefined && subObj !== null) {
            subObj = subObj[properties[i4]];
          }
        }
        if (subObj !== undefined && subObj !== null) {
          setPropertyValue(subObj, instanceModule, moduleExports, subPropName, attrValue);
        }
      } else {
        setPropertyValue(instance, instanceModule, moduleExports, attr, attrValue);
      }
    }
  }
});
function getComponentModule(elementName, namespace, attributes, moduleExports, moduleNamePath, isRootComponent) {
  elementName = elementName.split("-").map((s3) => s3[0].toUpperCase() + s3.substring(1)).join("");
  const { instance, instanceModule } = createComponentInstance(elementName, namespace, null);
  moduleExports = getComponentModuleExports(instance, moduleExports, attributes);
  if (isRootComponent) {
    applyComponentCss(instance, moduleNamePath, attributes);
  }
  applyComponentAttributes(instance, instanceModule, moduleExports, attributes);
  let componentModule;
  if (instance && instanceModule) {
    componentModule = { component: instance, exports: instanceModule };
  }
  return componentModule;
}
function setPropertyValue(instance, instanceModule, exports, propertyName, propertyValue) {
  if (isBinding(propertyValue) && instance.bind) {
    const bindOptions = getBindingOptions(propertyName, getBindingExpressionFromAttribute(propertyValue));
    instance.bind({
      sourceProperty: bindOptions[bindingConstants.sourceProperty],
      targetProperty: bindOptions[bindingConstants.targetProperty],
      expression: bindOptions[bindingConstants.expression],
      twoWay: bindOptions[bindingConstants.twoWay]
    }, bindOptions[bindingConstants.source]);
  } else if (isEventOrGesture(propertyName, instance)) {
    const handler = exports && exports[propertyValue];
    if (typeof handler === "function") {
      instance.on(propertyName, handler);
    }
  } else if (isKnownFunction(propertyName, instance) && exports && typeof exports[propertyValue] === "function") {
    instance[propertyName] = exports[propertyValue];
  } else {
    instance[propertyName] = propertyValue;
  }
}
function getBindingExpressionFromAttribute(value) {
  return value.replace("{{", "").replace("}}", "").trim();
}
function isBinding(value) {
  let isBinding2;
  if (typeof value === "string") {
    const str = value.trim();
    isBinding2 = str.indexOf("{{") === 0 && str.lastIndexOf("}}") === str.length - 2;
  }
  return isBinding2;
}
var KNOWN_FUNCTIONS = "knownFunctions";
function isKnownFunction(name, instance) {
  return instance.constructor && KNOWN_FUNCTIONS in instance.constructor && instance.constructor[KNOWN_FUNCTIONS].indexOf(name) !== -1;
}

// node_modules/@nativescript/core/js-libs/easysax/easysax.js
function EasySAXParser() {
  if (!this)
    return null;
  this.angularSyntax = false;
  function nullFunc2() {}
  this.onTextNode = nullFunc2;
  this.onStartNode = nullFunc2;
  this.onEndNode = nullFunc2;
  this.onCDATA = nullFunc2;
  this.onError = nullFunc2;
  this.onComment = null;
  this.onQuestion = null;
  this.onAttention = null;
  this.is_onComment = this.is_onQuestion = this.is_onAttention = false;
  this.isNamespace = false;
  this.useNS = null;
  this.default_xmlns = null;
  this.xmlns = null;
  this.nsmatrix = { xmlns: this.xmlns };
  this.hasSurmiseNS = false;
  this.attr_string = "";
  this.attr_posstart = 0;
  this.attr_res;
}
EasySAXParser.prototype.on = function(name, cb) {
  if (typeof cb !== "function") {
    if (cb !== null)
      return;
  }
  switch (name) {
    case "error":
      this.onError = cb || nullFunc;
      break;
    case "startNode":
      this.onStartNode = cb || nullFunc;
      break;
    case "endNode":
      this.onEndNode = cb || nullFunc;
      break;
    case "textNode":
      this.onTextNode = cb || nullFunc;
      break;
    case "cdata":
      this.onCDATA = cb || nullFunc;
      break;
    case "comment":
      this.onComment = cb;
      this.is_onComment = !!cb;
      break;
    case "question":
      this.onQuestion = cb;
      this.is_onQuestion = !!cb;
      break;
    case "attention":
      this.onAttention = cb;
      this.is_onAttention = !!cb;
      break;
  }
};
EasySAXParser.prototype.ns = function(root, ns) {
  if (!root || typeof root !== "string" || !ns) {
    return;
  }
  var u3, x2 = {}, ok, v, i4;
  for (i4 in ns) {
    v = ns[i4];
    if (typeof v === "string") {
      if (root === v)
        ok = true;
      x2[i4] = v;
    }
  }
  if (ok) {
    this.isNamespace = true;
    this.default_xmlns = root;
    this.useNS = x2;
  }
};
EasySAXParser.prototype.parse = function(xml) {
  if (typeof xml !== "string") {
    return;
  }
  if (this.isNamespace) {
    this.nsmatrix = { xmlns: this.default_xmlns };
    parse(xml);
    this.nsmatrix = false;
  } else {
    parse(xml);
  }
  this.attr_res = true;
};
var xharsQuot = {
  constructor: false,
  hasOwnProperty: false,
  isPrototypeOf: false,
  propertyIsEnumerable: false,
  toLocaleString: false,
  toString: false,
  valueOf: false,
  quot: '"',
  QUOT: '"',
  amp: "&",
  AMP: "&",
  nbsp: "",
  apos: "'",
  lt: "<",
  LT: "<",
  gt: ">",
  GT: ">",
  copy: "",
  laquo: "",
  raquo: "",
  reg: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  micro: "",
  para: ""
};
function rpEntities(s3, d3, x2, z2) {
  if (z2) {
    return xharsQuot[z2] || "\x01";
  }
  if (d3) {
    return String.fromCodePoint(d3);
  }
  return String.fromCodePoint(parseInt(x2, 16));
}
function unEntities(s3, i4) {
  s3 = String(s3);
  if (s3.length > 3 && s3.indexOf("&") !== -1) {
    if (s3.indexOf("&gt;") !== -1)
      s3 = s3.replace(/&gt;/g, ">");
    if (s3.indexOf("&lt;") !== -1)
      s3 = s3.replace(/&lt;/g, "<");
    if (s3.indexOf("&quot;") !== -1)
      s3 = s3.replace(/&quot;/g, '"');
    if (s3.indexOf("&") !== -1) {
      s3 = s3.replace(/&#(\d+);|&#x([0123456789abcdef]+);|&(\w+);/ig, rpEntities);
    }
  }
  return s3;
}
EasySAXParser.prototype.allowedAngularAttributeChars = function(w) {
  if (!this.angularSyntax) {
    return false;
  } else {
    return w === 40 || w === 41 || w === 91 || w === 93 || w === 94 || w === 35;
  }
};
EasySAXParser.prototype.getAttrs = function() {
  if (this.attr_res !== null) {
    return this.attr_res;
  }
  var u3, res = {}, s3 = this.attr_string, i4 = this.attr_posstart, l2 = s3.length, attr_list = this.hasSurmiseNS ? [] : false, name, value = "", ok = false, noValueAttribute = false, j2, w, nn, n3, hasNewMatrix, alias, newalias;
  aa:
    for (;i4 < l2; i4++) {
      w = s3.charCodeAt(i4);
      if (w === 32 || w < 14 && w > 8) {
        continue;
      }
      if (w < 65 && !this.allowedAngularAttributeChars(w) || w > 122 || w > 90 && w < 97 && !this.allowedAngularAttributeChars(w)) {
        return this.attr_res = false;
      }
      for (j2 = i4 + 1;j2 < l2; j2++) {
        w = s3.charCodeAt(j2);
        if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w === 46) {
          if (noValueAttribute) {
            j2--;
            break;
          } else {
            continue;
          }
        }
        if (this.allowedAngularAttributeChars(w)) {
          continue;
        }
        if (w === 32 || w > 8 && w < 14) {
          noValueAttribute = true;
          continue;
        } else if (w === 61) {
          noValueAttribute = false;
          break;
        } else {
          if (!noValueAttribute)
            return this.attr_res = false;
        }
        break;
      }
      name = s3.substring(i4, j2).trim();
      ok = true;
      if (name === "xmlns:xmlns") {
        return this.attr_res = false;
      }
      w = s3.charCodeAt(j2 + 1);
      while (w = s3.charCodeAt(j2 + 1)) {
        if (w === 32 || w > 8 && w < 14) {
          j2++;
        } else {
          break;
        }
      }
      if (!noValueAttribute) {
        if (w === 34) {
          j2 = s3.indexOf('"', i4 = j2 + 2);
        } else {
          if (w === 39) {
            j2 = s3.indexOf("'", i4 = j2 + 2);
          } else {
            return this.attr_res = false;
          }
        }
      }
      if (j2 === -1) {
        return this.attr_res = false;
      }
      if (j2 + 1 < l2 && !noValueAttribute) {
        w = s3.charCodeAt(j2 + 1);
        if (w > 32 || w < 9 || w < 32 && w > 13) {
          return this.attr_res = false;
        }
      }
      if (noValueAttribute) {
        value = "";
      } else {
        value = s3.substring(i4, j2);
      }
      i4 = j2;
      if (this.isNamespace) {
        if (this.hasSurmiseNS) {
          if (newalias = name === "xmlns" ? "xmlns" : name.charCodeAt(0) === 120 && name.substr(0, 6) === "xmlns:" && name.substr(6)) {
            alias = this.useNS[unEntities(value)];
            if (alias) {
              if (this.nsmatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  hasNewMatrix = true;
                  nn = {};
                  for (n3 in this.nsmatrix)
                    nn[n3] = this.nsmatrix[n3];
                  this.nsmatrix = nn;
                }
                this.nsmatrix[newalias] = alias;
              }
            } else {
              if (this.nsmatrix[newalias]) {
                if (!hasNewMatrix) {
                  hasNewMatrix = true;
                  nn = {};
                  for (n3 in this.nsmatrix)
                    nn[n3] = this.nsmatrix[n3];
                  this.nsmatrix = nn;
                }
                this.nsmatrix[newalias] = false;
              }
            }
            res[name] = value;
            continue;
          }
          attr_list.push(name, value);
          continue;
        }
        w = name.length;
        while (--w) {
          if (name.charCodeAt(w) === 58) {
            if (w = this.nsmatrix[name.substring(0, w)]) {
              res[w + name.substr(w)] = value;
            }
            continue aa;
          }
        }
      }
      res[name] = value;
      noValueAttribute = false;
    }
  if (!ok) {
    return this.attr_res = true;
  }
  if (this.hasSurmiseNS) {
    bb:
      for (i4 = 0, l2 = attr_list.length;i4 < l2; i4++) {
        name = attr_list[i4++];
        w = name.length;
        while (--w) {
          if (name.charCodeAt(w) === 58) {
            if (w = this.nsmatrix[name.substring(0, w)]) {
              res[w + name.substr(w)] = attr_list[i4];
            }
            continue bb;
            break;
          }
        }
        res[name] = attr_list[i4];
      }
  }
  return this.attr_res = res;
};
EasySAXParser.prototype.parse = function(xml) {
  var u3, xml = String(xml), nodestack = [], stacknsmatrix = [], elem, tagend = false, tagstart = false, j2 = 0, i4 = 0, k2 = 0, len, x2, y2, q2, w, xmlns, stopIndex = 0, stop2, _nsmatrix, ok, pos = 0, ln = 0, lnStart = -2, lnEnd = -1;
  len = xml.length;
  function getStringNode() {
    return xml.substring(i4, j2 + 1);
  }
  function findLineAndColumnFromPos() {
    while (lnStart < lnEnd && lnEnd < pos) {
      lnStart = lnEnd;
      lnEnd = xml.indexOf(`
`, lnEnd + 1);
      ++ln;
    }
    return { line: ln, column: pos - lnStart };
  }
  function position(p2) {
    pos = p2;
    return findLineAndColumnFromPos;
  }
  while (j2 !== -1) {
    stop2 = stopIndex > 0;
    if (xml.charCodeAt(j2) === 60) {
      i4 = j2;
    } else {
      i4 = xml.indexOf("<", j2);
    }
    if (i4 === -1) {
      if (nodestack.length) {
        this.onError("end file", position(j2));
        return;
      }
      return;
    }
    if (j2 !== i4 && !stop2) {
      ok = this.onTextNode(xml.substring(j2, i4), unEntities, position(j2));
      if (ok === false)
        return;
    }
    w = xml.charCodeAt(i4 + 1);
    if (w === 33) {
      w = xml.charCodeAt(i4 + 2);
      if (w === 91 && xml.substr(i4 + 3, 6) === "CDATA[") {
        j2 = xml.indexOf("]]>", i4);
        if (j2 === -1) {
          this.onError("cdata", position(i4));
          return;
        }
        if (!stop2) {
          ok = this.onCDATA(xml.substring(i4 + 9, j2), false, position(i4));
          if (ok === false)
            return;
        }
        j2 += 3;
        continue;
      }
      if (w === 45 && xml.charCodeAt(i4 + 3) === 45) {
        j2 = xml.indexOf("-->", i4);
        if (j2 === -1) {
          this.onError("expected -->", position(i4));
          return;
        }
        if (this.is_onComment && !stop2) {
          ok = this.onComment(xml.substring(i4 + 4, j2), unEntities, position(i4));
          if (ok === false)
            return;
        }
        j2 += 3;
        continue;
      }
      j2 = xml.indexOf(">", i4 + 1);
      if (j2 === -1) {
        this.onError('expected ">"', position(i4 + 1));
        return;
      }
      if (this.is_onAttention && !stop2) {
        ok = this.onAttention(xml.substring(i4, j2 + 1), unEntities, position(i4));
        if (ok === false)
          return;
      }
      j2 += 1;
      continue;
    } else {
      if (w === 63) {
        j2 = xml.indexOf("?>", i4);
        if (j2 === -1) {
          this.onError("...?>", position(i4));
          return;
        }
        if (this.is_onQuestion) {
          ok = this.onQuestion(xml.substring(i4, j2 + 2), position(i4));
          if (ok === false)
            return;
        }
        j2 += 2;
        continue;
      }
    }
    var inside = false;
    for (k2 = i4, j2 = -1;k2 < len; k2++) {
      var c3 = xml.charCodeAt(k2);
      if (!inside) {
        if (c3 === 34) {
          inside = c3;
        } else if (c3 === 39) {
          inside = c3;
        } else if (c3 === 62) {
          j2 = k2;
          break;
        }
      } else {
        if (c3 === inside) {
          inside = false;
        }
      }
    }
    if (j2 == -1) {
      this.onError("...>", position(i4 + 1));
      return;
    }
    this.attr_res = true;
    if (w === 47) {
      tagstart = false;
      tagend = true;
      x2 = elem = nodestack.pop();
      q2 = i4 + 2 + x2.length;
      if (xml.substring(i4 + 2, q2) !== x2) {
        this.onError("close tagname", position(i4 + 2));
        return;
      }
      for (;q2 < j2; q2++) {
        w = xml.charCodeAt(q2);
        if (w === 32 || w > 8 && w < 14) {
          continue;
        }
        this.onError("close tag", position(i4 + 2));
        return;
      }
    } else {
      if (xml.charCodeAt(j2 - 1) === 47) {
        x2 = elem = xml.substring(i4 + 1, j2 - 1);
        tagstart = true;
        tagend = true;
      } else {
        x2 = elem = xml.substring(i4 + 1, j2);
        tagstart = true;
        tagend = false;
      }
      if (!(w > 96 && w < 123 || w > 64 && w < 91)) {
        this.onError("first char nodeName", position(i4 + 1));
        return;
      }
      for (q2 = 1, y2 = x2.length;q2 < y2; q2++) {
        w = x2.charCodeAt(q2);
        if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w === 46) {
          continue;
        }
        if (w === 32 || w < 14 && w > 8) {
          elem = x2.substring(0, q2);
          this.attr_res = null;
          break;
        }
        this.onError("invalid nodeName", position(i4 + 1));
        return;
      }
      if (!tagend) {
        nodestack.push(elem);
      }
    }
    if (this.isNamespace) {
      if (stop2) {
        if (tagend) {
          if (!tagstart) {
            if (--stopIndex === 0) {
              this.nsmatrix = stacknsmatrix.pop();
            }
          }
        } else {
          stopIndex += 1;
        }
        j2 += 1;
        continue;
      }
      _nsmatrix = this.nsmatrix;
      if (!tagend) {
        stacknsmatrix.push(this.nsmatrix);
        if (this.attr_res !== true) {
          if (this.hasSurmiseNS = x2.indexOf("xmlns", q2) !== -1) {
            this.attr_string = x2;
            this.attr_posstart = q2;
            this.getAttrs();
            this.hasSurmiseNS = false;
          }
        }
      }
      w = elem.indexOf(":");
      if (w !== -1) {
        xmlns = this.nsmatrix[elem.substring(0, w)];
        elem = elem.substr(w + 1);
      } else {
        xmlns = this.nsmatrix.xmlns;
      }
      if (!xmlns) {
        if (tagend) {
          if (tagstart) {
            this.nsmatrix = _nsmatrix;
          } else {
            this.nsmatrix = stacknsmatrix.pop();
          }
        } else {
          stopIndex = 1;
          this.attr_res = true;
        }
        j2 += 1;
        continue;
      }
      elem = xmlns + ":" + elem;
    }
    if (tagstart) {
      this.attr_string = x2;
      this.attr_posstart = q2;
      var that = this;
      ok = this.onStartNode(elem, function() {
        return that.getAttrs();
      }, unEntities, tagend, getStringNode, position(i4));
      if (ok === false) {
        return;
      }
      this.attr_res = true;
    }
    if (tagend) {
      ok = this.onEndNode(elem, unEntities, tagstart, getStringNode, position(i4));
      if (ok === false) {
        return;
      }
      if (this.isNamespace) {
        if (tagstart) {
          this.nsmatrix = _nsmatrix;
        } else {
          this.nsmatrix = stacknsmatrix.pop();
        }
      }
    }
    j2 += 1;
  }
};

// node_modules/@nativescript/core/xml/index.js
class ParserEventType {
}
ParserEventType.StartElement = "StartElement";
ParserEventType.EndElement = "EndElement";
ParserEventType.Text = "Text";
ParserEventType.CDATA = "CDATA";
ParserEventType.Comment = "Comment";

class ParserEvent {
  constructor(eventType, position, prefix, namespace, elementName, attributes, data2) {
    this._eventType = eventType;
    this._position = position;
    this._prefix = prefix;
    this._namespace = namespace;
    this._elementName = elementName;
    this._attributes = attributes;
    this._data = data2;
  }
  toString() {
    return JSON.stringify({
      eventType: this.eventType,
      position: this.position,
      prefix: this.prefix,
      namespace: this.namespace,
      elementName: this.elementName,
      attributes: this.attributes,
      data: this.data
    });
  }
  get eventType() {
    return this._eventType;
  }
  get position() {
    return this._position;
  }
  get prefix() {
    return this._prefix;
  }
  get namespace() {
    return this._namespace;
  }
  get elementName() {
    return this._elementName;
  }
  get attributes() {
    return this._attributes;
  }
  get data() {
    return this._data;
  }
}
var _ampCodes;
var _entitySearchRegEx = /&#(\d+);|&#x([0123456789abcdef]+);|&(\w+);/gi;
function _generateAmpMap() {
  const objCodes = {
    Tab: 9,
    NewLine: 10,
    excl: 33,
    quot: 34,
    QUOT: 34,
    num: 35,
    dollar: 36,
    percent: 37,
    amp: 38,
    AMP: 38,
    apos: 39,
    lpar: 40,
    rpar: 41,
    ast: 42,
    midast: 42,
    plus: 43,
    comma: 44,
    period: 46,
    sol: 47,
    colon: 58,
    semi: 59,
    lt: 60,
    LT: 60,
    equals: 61,
    gt: 62,
    GT: 62,
    quest: 63,
    commat: 64,
    lsqb: 91,
    lbrack: 91,
    bsol: 92,
    rsqb: 92,
    rbrack: 92,
    Hat: 94,
    lowbar: 95,
    grave: 96,
    DiacriticalGrave: 96,
    lcub: 123,
    lbrace: 123,
    verbar: 124,
    vert: 124,
    VerticalLine: 124,
    rcub: 125,
    rbrace: 125,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    brkbar: 166,
    sect: 167,
    uml: 168,
    copy: 169,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    reg: 174,
    macr: 175,
    hibar: 175,
    deg: 176,
    plusmn: 177,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    sup1: 185,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    Agrave: 192,
    Aacute: 193,
    Acirc: 194,
    Atilde: 195,
    Auml: 196,
    Aring: 197,
    AElig: 198,
    Ccedil: 199,
    Egrave: 200,
    Eacute: 201,
    Ecirc: 202,
    Euml: 203,
    Igrave: 204,
    Iacute: 205,
    Icirc: 206,
    Iuml: 207,
    ETH: 208,
    Dstrok: 208,
    Ntilde: 209,
    Ograve: 210,
    Oacute: 211,
    Ocirc: 212,
    Otilde: 213,
    Ouml: 214,
    times: 215,
    Oslash: 216,
    Ugrave: 217,
    Uacute: 218,
    Ucirc: 219,
    Uuml: 220,
    Yacute: 221,
    THORN: 222,
    szlig: 223,
    agrave: 224,
    aacute: 225,
    acirc: 226,
    atilde: 227,
    auml: 228,
    aring: 229,
    aelig: 230,
    ccedil: 231,
    egrave: 232,
    eacute: 233,
    ecirc: 234,
    euml: 235,
    igrave: 236,
    iacute: 237,
    icirc: 238,
    iuml: 239,
    eth: 240,
    ntilde: 241,
    ograve: 242,
    oacute: 243,
    ocirc: 244,
    otilde: 245,
    ouml: 246,
    divide: 247,
    oslash: 248,
    ugrave: 249,
    uacute: 250,
    ucirc: 251,
    uuml: 252,
    yacute: 253,
    thorn: 254,
    yuml: 255,
    fnof: 402,
    imped: 437,
    gacute: 501,
    jmath: 567,
    circ: 710,
    caron: 711,
    Hacek: 711,
    breve: 728,
    Breve: 728,
    dot: 729,
    DiacriticalDot: 729,
    ring: 730,
    ogon: 731,
    tilde: 732,
    DiacriticalTilde: 732,
    dblac: 733,
    DiacriticalDoubleAcute: 733,
    DownBreve: 785,
    UnderBar: 818,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    epsiv: 949,
    varepsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigmav: 962,
    varsigma: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetav: 977,
    vartheta: 977,
    thetasym: 977,
    Upsi: 978,
    upsih: 978,
    straightphi: 981,
    piv: 982,
    varpi: 982,
    Gammad: 988,
    gammad: 989,
    digamma: 989,
    kappav: 1008,
    varkappa: 1008,
    rhov: 1009,
    varrho: 1009,
    epsi: 1013,
    straightepsilon: 1013,
    bepsi: 1014,
    backepsilon: 1014,
    euro: 8364,
    trade: 8482,
    TRADE: 8482,
    forall: 8704,
    part: 8706,
    larr: 8592,
    rarr: 8593,
    hyphen: 8208,
    dash: 8208,
    ndash: 8211,
    mdash: 8212,
    horbar: 8213,
    Vert: 8214,
    Verbar: 8214,
    lsquo: 8216,
    OpenCurlyQuote: 8216,
    rsquo: 8217,
    rsquor: 8217,
    CloseCurlyQuote: 8217,
    lsquor: 8218,
    sbquo: 8218,
    ldquo: 8220,
    OpenCurlyDoubleQuote: 8220,
    rdquo: 8221,
    rdquor: 8221,
    CloseCurlyDoubleQuote: 8221,
    ldquor: 8222,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    ddagger: 8225,
    bull: 8226,
    bullet: 8226,
    nldr: 8229,
    hellip: 8230,
    mldr: 8230,
    hybull: 8259,
    tdot: 8411,
    TripleDot: 8411,
    DotDot: 8412,
    star: 9734,
    phone: 9742,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830,
    female: 9792,
    male: 9794,
    check: 10003,
    checkmark: 10003,
    cross: 10007,
    VerticalSeparator: 10072,
    EmptySmallSquare: 9723,
    FilledSmallSquare: 9724,
    starf: 9733,
    bigstar: 9733,
    square: 9633,
    squ: 9633,
    Square: 9633
  };
  const ampCodes = new Map;
  for (const key in objCodes) {
    if (objCodes.hasOwnProperty(key)) {
      ampCodes.set(key, objCodes[key]);
    }
  }
  return ampCodes;
}
if (global.__snapshot) {
  _ampCodes = _generateAmpMap();
}
function _HandleAmpEntities(found, decimalValue, hexValue, wordValue) {
  if (wordValue) {
    if (!_ampCodes) {
      _ampCodes = _generateAmpMap();
    }
    const res = _ampCodes.get(wordValue);
    if (res) {
      return String.fromCodePoint(res);
    }
    return found;
  }
  if (decimalValue) {
    return String.fromCodePoint(parseInt(decimalValue, 10));
  }
  return String.fromCodePoint(parseInt(hexValue, 16));
}

class XmlParser {
  constructor(onEvent, onError, processNamespaces) {
    this._processNamespaces = processNamespaces;
    this._parser = new EasySAXParser;
    const that = this;
    this._parser.on("startNode", function(elem, attr, uq, tagend, str, pos) {
      let attributes = attr();
      if (attributes === true) {
        attributes = undefined;
      }
      if (attributes) {
        for (const key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            attributes[key] = XmlParser._dereferenceEntities(attributes[key]);
          }
        }
      }
      let prefix = undefined;
      let namespace = undefined;
      let name = elem;
      if (that._processNamespaces) {
        const stackEntry = XmlParser._getNamespacesStackEntry(attributes);
        that._namespaceStack.push(stackEntry);
        const resolved = that._resolveNamespace(name);
        prefix = resolved.prefix;
        namespace = resolved.namespace;
        name = resolved.name;
      }
      onEvent(new ParserEvent(ParserEventType.StartElement, pos(), prefix, namespace, name, attributes, undefined));
    });
    this._parser.on("textNode", function(text, uq, pos) {
      const data2 = uq(XmlParser._dereferenceEntities(text));
      onEvent(new ParserEvent(ParserEventType.Text, pos(), undefined, undefined, undefined, undefined, data2));
    });
    this._parser.on("endNode", function(elem, uq, tagstart, str, pos) {
      let prefix = undefined;
      let namespace = undefined;
      let name = elem;
      if (that._processNamespaces) {
        const resolved = that._resolveNamespace(name);
        prefix = resolved.prefix;
        namespace = resolved.namespace;
        name = resolved.name;
      }
      onEvent(new ParserEvent(ParserEventType.EndElement, pos(), prefix, namespace, name, undefined, undefined));
      if (that._processNamespaces) {
        that._namespaceStack.pop();
      }
    });
    this._parser.on("cdata", function(data2, res, pos) {
      onEvent(new ParserEvent(ParserEventType.CDATA, pos(), undefined, undefined, undefined, undefined, data2));
    });
    this._parser.on("comment", function(text, uq, pos) {
      onEvent(new ParserEvent(ParserEventType.Comment, pos(), undefined, undefined, undefined, undefined, text));
    });
    if (onError) {
      this._parser.on("error", function(msg, pos) {
        onError(new Error(msg), pos());
      });
    }
  }
  get angularSyntax() {
    return this._parser.angularSyntax;
  }
  set angularSyntax(value) {
    this._parser.angularSyntax = value;
  }
  parse(xmlString) {
    if (this._processNamespaces) {
      this._namespaceStack = [];
    }
    this._parser.parse(xmlString);
  }
  static _getNamespacesStackEntry(attributes) {
    const stackEntry = {};
    if (!attributes) {
      return stackEntry;
    }
    let attributeName;
    let namespacePrefix;
    for (const key in attributes) {
      if (!attributes.hasOwnProperty(key)) {
        continue;
      }
      attributeName = key;
      if (attributeName.indexOf("xmlns") !== 0) {
        continue;
      }
      namespacePrefix = "";
      if (attributeName.indexOf(":") !== -1) {
        namespacePrefix = attributeName.split(":")[1];
      }
      stackEntry[namespacePrefix] = attributes[key];
    }
    return stackEntry;
  }
  _resolveNamespace(fullName) {
    const result = {
      prefix: undefined,
      namespace: undefined,
      name: undefined
    };
    result.prefix = "";
    if (fullName.indexOf(":") !== -1) {
      const split = fullName.split(":");
      result.prefix = split[0];
      result.name = split[1];
    } else {
      result.name = fullName;
    }
    let stackEntry;
    for (let i4 = this._namespaceStack.length - 1;i4 >= 0; i4--) {
      stackEntry = this._namespaceStack[i4];
      for (const key in stackEntry) {
        if (!stackEntry.hasOwnProperty(key)) {
          continue;
        }
        if (result.prefix === key) {
          result.namespace = stackEntry[key];
          return result;
        }
      }
    }
    return result;
  }
  static _dereferenceEntities(s3) {
    s3 = String(s3);
    if (s3.length > 3 && s3.indexOf("&") !== -1) {
      s3 = s3.replace(_entitySearchRegEx, _HandleAmpEntities);
    }
    return s3;
  }
}

// node_modules/@nativescript/core/ui/builder/index.js
if (typeof global.__metadata === "undefined") {
  global.__metadata = (metadataKey, metadataValue) => {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") {
      return Reflect.metadata(metadataKey, metadataValue);
    }
  };
}
var ios3 = platformNames.ios.toLowerCase();
var android3 = platformNames.android.toLowerCase();
var visionos = platformNames.visionos.toLowerCase();
var apple = platformNames.apple.toLowerCase();
var defaultNameSpaceMatcher = /tns\.xsd$/i;

class Builder {
  static createViewFromEntry(entry) {
    if (entry.create) {
      const view = entry.create();
      if (!view) {
        throw new Error("Failed to create View with entry.create() function.");
      }
      return view;
    } else if (entry.moduleName) {
      const moduleName = sanitizeModuleName(entry.moduleName);
      const resolvedCodeModuleName = resolveModuleName(moduleName, "");
      const moduleExports = resolvedCodeModuleName ? global.loadModule(resolvedCodeModuleName) : null;
      if (moduleExports && moduleExports.createPage) {
        const view = moduleExports.createPage();
        const resolvedCssModuleName = resolveModuleName(moduleName, "css");
        if (resolvedCssModuleName) {
          view.addCssFile(resolvedCssModuleName);
        }
        return view;
      } else {
        let componentView;
        if (__UI_USE_XML_PARSER__) {
          const componentModule = loadInternal(moduleName, moduleExports);
          componentView = componentModule && componentModule.component;
        } else {
          const resolvedXmlModuleName = resolveModuleName(moduleName, "xml");
          const componentModule = resolvedXmlModuleName ? global.loadModule(resolvedXmlModuleName) : null;
          if (componentModule?.default) {
            componentView = new componentModule.default;
          } else {
            throw new Error("Failed to load component from module: " + moduleName);
          }
        }
        return componentView;
      }
    }
    throw new Error("Failed to load page XML file for module: " + entry.moduleName);
  }
  static parse(value, context) {
    if (typeof value === "function") {
      return value();
    } else {
      const exports = context ? getExports(context) : undefined;
      const componentModule = parseInternal(value, exports);
      return componentModule && componentModule.component;
    }
  }
  static load(pathOrOptions, context) {
    let componentModule;
    if (typeof pathOrOptions === "string") {
      const moduleName = sanitizeModuleName(pathOrOptions);
      componentModule = loadInternal(moduleName, context);
    } else {
      componentModule = loadCustomComponent(pathOrOptions.path, pathOrOptions.name, pathOrOptions.attributes, pathOrOptions.exports, pathOrOptions.page, true);
    }
    return componentModule && componentModule.component;
  }
  static parseMultipleTemplates(value, context) {
    const dummyComponent = `<ListView><ListView.itemTemplates>${value}</ListView.itemTemplates></ListView>`;
    return parseInternal(dummyComponent, context).component["itemTemplates"];
  }
}
Builder.knownTemplates = new Set(["itemTemplate"]);
Builder.knownMultiTemplates = new Set(["itemTemplates"]);
Builder.knownCollections = new Set(["items", "spans", "actionItems"]);
function loadInternal(moduleName, moduleExports) {
  let componentModule;
  const resolvedXmlModule = resolveModuleName(moduleName, "xml");
  if (resolvedXmlModule) {
    const text = global.loadModule(resolvedXmlModule);
    componentModule = parseInternal(text, moduleExports, resolvedXmlModule, moduleName);
  }
  const componentView = componentModule && componentModule.component;
  if (componentView) {
    componentView.exports = moduleExports;
    componentView._moduleName = moduleName;
  }
  if (!componentModule) {
    throw new Error("Failed to load component from module: " + moduleName);
  }
  return componentModule;
}
function loadCustomComponent(componentNamespace, componentName, attributes, context, parentPage, isRootComponent = true, moduleNamePath) {
  if (!parentPage && context) {
    parentPage = context["_parentPage"];
    delete context["_parentPage"];
  }
  let result;
  componentNamespace = sanitizeModuleName(componentNamespace);
  const moduleName = `${componentNamespace}/${componentName}`;
  const resolvedCodeModuleName = resolveModuleName(moduleName, "");
  const resolvedXmlModuleName = resolveModuleName(moduleName, "xml");
  let resolvedCssModuleName = resolveModuleName(moduleName, "css");
  if (resolvedXmlModuleName) {
    let subExports = context;
    if (resolvedCodeModuleName) {
      subExports = global.loadModule(resolvedCodeModuleName);
    }
    if (!subExports) {
      subExports = {};
    }
    subExports["_parentPage"] = parentPage;
    result = loadInternal(moduleName, subExports);
    if (isDefined(result) && isDefined(result.component) && isDefined(attributes)) {
      for (const attr in attributes) {
        setPropertyValue(result.component, subExports, context, attr, attributes[attr]);
      }
    }
  } else {
    result = getComponentModule(componentName, componentNamespace, attributes, context, moduleNamePath, isRootComponent);
    if (!resolvedCssModuleName) {
      resolvedCssModuleName = resolveModuleName(componentNamespace, "css");
    }
  }
  if (parentPage && resolvedCssModuleName) {
    parentPage.addCssFile(resolvedCssModuleName);
  }
  return result;
}
function getExports(instance) {
  const isView = !!instance._domId;
  if (!isView) {
    return instance.exports || instance;
  }
  let exportObject = instance.exports;
  let parent = instance.parent;
  while (exportObject === undefined && parent) {
    exportObject = parent.exports;
    parent = parent.parent;
  }
  return exportObject;
}
function parseInternal(value, context, xmlModule, moduleName) {
  if (__UI_USE_XML_PARSER__) {
    let start2;
    let ui;
    const errorFormat = debug && xmlModule ? xml2ui.SourceErrorFormat(xmlModule) : xml2ui.PositionErrorFormat;
    const componentSourceTracker = debug && xmlModule ? xml2ui.ComponentSourceTracker(xmlModule) : () => {};
    (start2 = new xml2ui.XmlStringParser(errorFormat)).pipe(new xml2ui.PlatformFilter).pipe(new xml2ui.XmlStateParser(ui = new xml2ui.ComponentParser(context, errorFormat, componentSourceTracker, moduleName)));
    start2.parse(value);
    return ui.rootComponentModule;
  } else {
    return null;
  }
}
var xml2ui;
(function(xml2ui2) {

  class XmlProducerBase {
    pipe(next) {
      this._next = next;
      return next;
    }
    next(args) {
      this._next.parse(args);
    }
  }
  xml2ui2.XmlProducerBase = XmlProducerBase;

  class XmlStringParser extends XmlProducerBase {
    constructor(error) {
      super();
      this.error = error || PositionErrorFormat;
    }
    parse(value) {
      if (__UI_USE_XML_PARSER__) {
        const xmlParser = new XmlParser((args) => {
          try {
            this.next(args);
          } catch (e3) {
            throw this.error(e3, args.position);
          }
        }, (e3, p2) => {
          throw this.error(e3, p2);
        }, true);
        if (isString(value)) {
          xmlParser.parse(value);
        } else if (isObject(value) && isString(value.default)) {
          xmlParser.parse(value.default);
        }
      }
    }
  }
  xml2ui2.XmlStringParser = XmlStringParser;
  function PositionErrorFormat(e3, p2) {
    return new ScopeError(e3, "Parsing XML at " + p2.line + ":" + p2.column);
  }
  xml2ui2.PositionErrorFormat = PositionErrorFormat;
  function SourceErrorFormat(uri) {
    return (e3, p2) => {
      console.error(uri);
      const source = p2 ? new Source(uri, p2.line, p2.column) : new Source(uri, -1, -1);
      e3 = new SourceError(e3, source, "Building UI from XML.");
      return e3;
    };
  }
  xml2ui2.SourceErrorFormat = SourceErrorFormat;
  function ComponentSourceTracker(uri) {
    return (component, p2) => {
      if (!Source.get(component)) {
        const source = p2 ? new Source(uri, p2.line, p2.column) : new Source(uri, -1, -1);
        Source.set(component, source);
      }
    };
  }
  xml2ui2.ComponentSourceTracker = ComponentSourceTracker;

  class PlatformFilter extends XmlProducerBase {
    parse(args) {
      if (args.eventType === ParserEventType.StartElement) {
        if (PlatformFilter.isPlatform(args.elementName)) {
          if (this.currentPlatformContext) {
            throw new Error("Already in '" + this.currentPlatformContext + "' platform context and cannot switch to '" + args.elementName + "' platform! Platform tags cannot be nested.");
          }
          this.currentPlatformContext = args.elementName;
          return;
        }
      }
      if (args.eventType === ParserEventType.EndElement) {
        if (PlatformFilter.isPlatform(args.elementName)) {
          this.currentPlatformContext = undefined;
          return;
        }
      }
      if (this.currentPlatformContext && !PlatformFilter.isCurentPlatform(this.currentPlatformContext)) {
        return;
      }
      this.next(args);
    }
    static isPlatform(value) {
      if (value) {
        const toLower = value.toLowerCase();
        return toLower === android3 || toLower === ios3 || toLower === visionos || toLower === apple;
      }
      return false;
    }
    static isCurentPlatform(value) {
      value = value && value.toLowerCase();
      return value === apple ? __APPLE__ : value === Device.os.toLowerCase();
    }
  }
  xml2ui2.PlatformFilter = PlatformFilter;

  class XmlArgsReplay extends XmlProducerBase {
    constructor(args, errorFormat) {
      super();
      this.args = args;
      this.error = errorFormat;
    }
    replay() {
      this.args.forEach((args) => {
        try {
          this.next(args);
        } catch (e3) {
          throw this.error(e3, args.position);
        }
      });
    }
  }
  xml2ui2.XmlArgsReplay = XmlArgsReplay;

  class XmlStateParser {
    constructor(state) {
      this.state = state;
    }
    parse(args) {
      this.state = this.state.parse(args);
    }
  }
  xml2ui2.XmlStateParser = XmlStateParser;

  class TemplateParser {
    constructor(parent, templateProperty, setTemplateProperty = true) {
      this.parent = parent;
      this._context = templateProperty.context;
      this._recordedXmlStream = new Array;
      this._templateProperty = templateProperty;
      this._nestingLevel = 0;
      this._state = 0;
      this._setTemplateProperty = setTemplateProperty;
    }
    parse(args) {
      if (args.eventType === ParserEventType.StartElement) {
        this.parseStartElement(args.prefix, args.namespace, args.elementName, args.attributes);
      } else if (args.eventType === ParserEventType.EndElement) {
        this.parseEndElement(args.prefix, args.elementName);
      }
      this._recordedXmlStream.push(args);
      return this._state === 2 ? this.parent : this;
    }
    get elementName() {
      return this._templateProperty.elementName;
    }
    parseStartElement(prefix, namespace, elementName, attributes) {
      if (this._state === 0) {
        this._state = 1;
      } else if (this._state === 2) {
        throw new Error("Template must have exactly one root element but multiple elements were found.");
      }
      this._nestingLevel++;
    }
    parseEndElement(prefix, elementName) {
      if (this._state === 0) {
        throw new Error("Template must have exactly one root element but none was found.");
      } else if (this._state === 2) {
        throw new Error("No more closing elements expected for this template.");
      }
      this._nestingLevel--;
      if (this._nestingLevel === 0) {
        this._state = 2;
        if (this._setTemplateProperty && this._templateProperty.name in this._templateProperty.parent.component) {
          const template = this.buildTemplate();
          this._templateProperty.parent.component[this._templateProperty.name] = template;
        }
      }
    }
    buildTemplate() {
      if (__UI_USE_XML_PARSER__) {
        const context = this._context;
        const errorFormat = this._templateProperty.errorFormat;
        const sourceTracker = this._templateProperty.sourceTracker;
        const template = profile("Template()", () => {
          let start2;
          let ui;
          (start2 = new xml2ui2.XmlArgsReplay(this._recordedXmlStream, errorFormat)).pipe(new XmlStateParser(ui = new ComponentParser(context, errorFormat, sourceTracker)));
          start2.replay();
          return ui.rootComponentModule.component;
        });
        return template;
      } else {
        return null;
      }
    }
  }
  xml2ui2.TemplateParser = TemplateParser;

  class MultiTemplateParser {
    get value() {
      return this._value;
    }
    constructor(parent, templateProperty) {
      this.parent = parent;
      this.templateProperty = templateProperty;
      this._childParsers = new Array;
    }
    parse(args) {
      if (args.eventType === ParserEventType.StartElement && args.elementName === "template") {
        const childParser = new TemplateParser(this, this.templateProperty, false);
        childParser["key"] = args.attributes["key"];
        this._childParsers.push(childParser);
        return childParser;
      }
      if (args.eventType === ParserEventType.EndElement) {
        const name = ComponentParser.getComplexPropertyName(args.elementName);
        if (name === this.templateProperty.name) {
          const templates = new Array;
          for (let i4 = 0;i4 < this._childParsers.length; i4++) {
            templates.push({
              key: this._childParsers[i4]["key"],
              createView: this._childParsers[i4].buildTemplate()
            });
          }
          this._value = templates;
          return this.parent.parse(args);
        }
      }
      return this;
    }
  }
  xml2ui2.MultiTemplateParser = MultiTemplateParser;

  class ComponentParser {
    constructor(context, errorFormat, sourceTracker, moduleName) {
      this.moduleName = moduleName;
      this.parents = new Array;
      this.complexProperties = new Array;
      this.context = context;
      this.error = errorFormat;
      this.sourceTracker = sourceTracker;
    }
    buildComponent(args) {
      if (args.prefix && args.namespace) {
        return loadCustomComponent(args.namespace, args.elementName, args.attributes, this.context, this.currentRootView, !this.currentRootView, this.moduleName);
      } else {
        let namespace = args.namespace;
        if (defaultNameSpaceMatcher.test(namespace || "")) {
          namespace = undefined;
        }
        return getComponentModule(args.elementName, namespace, args.attributes, this.context, this.moduleName, !this.currentRootView);
      }
    }
    parse(args) {
      const parent = this.parents[this.parents.length - 1];
      const complexProperty = this.complexProperties[this.complexProperties.length - 1];
      if (args.eventType === ParserEventType.StartElement) {
        if (ComponentParser.isComplexProperty(args.elementName)) {
          const name = ComponentParser.getComplexPropertyName(args.elementName);
          const complexProperty2 = {
            parent,
            name,
            items: []
          };
          this.complexProperties.push(complexProperty2);
          if (ComponentParser.isKnownTemplate(name, parent.exports)) {
            return new TemplateParser(this, {
              context: (parent ? getExports(parent.component) : null) || this.context,
              parent,
              name,
              elementName: args.elementName,
              templateItems: [],
              errorFormat: this.error,
              sourceTracker: this.sourceTracker
            });
          }
          if (ComponentParser.isKnownMultiTemplate(name, parent.exports)) {
            const parser = new MultiTemplateParser(this, {
              context: (parent ? getExports(parent.component) : null) || this.context,
              parent,
              name,
              elementName: args.elementName,
              templateItems: [],
              errorFormat: this.error,
              sourceTracker: this.sourceTracker
            });
            complexProperty2.parser = parser;
            return parser;
          }
        } else {
          const componentModule = this.buildComponent(args);
          if (componentModule) {
            this.sourceTracker(componentModule.component, args.position);
            if (parent) {
              if (complexProperty && complexProperty.parent == parent) {
                ComponentParser.addToComplexProperty(parent, complexProperty, componentModule);
              } else if (parent.component._addChildFromBuilder) {
                parent.component._addChildFromBuilder(args.elementName, componentModule.component);
              }
            } else if (this.parents.length === 0) {
              this.rootComponentModule = componentModule;
              if (this.rootComponentModule) {
                this.currentRootView = this.rootComponentModule.component;
                if (this.currentRootView.exports) {
                  this.context = this.currentRootView.exports;
                }
              }
            }
            this.parents.push(componentModule);
          }
        }
      } else if (args.eventType === ParserEventType.EndElement) {
        if (ComponentParser.isComplexProperty(args.elementName)) {
          if (complexProperty) {
            if (complexProperty.parser) {
              parent.component[complexProperty.name] = complexProperty.parser.value;
            } else if (parent && parent.component._addArrayFromBuilder) {
              parent.component._addArrayFromBuilder(complexProperty.name, complexProperty.items);
              complexProperty.items = [];
            }
          }
          this.complexProperties.pop();
        } else {
          this.parents.pop();
        }
      }
      return this;
    }
    static isComplexProperty(name) {
      return isString(name) && name.indexOf(".") !== -1;
    }
    static getComplexPropertyName(fullName) {
      let name;
      if (isString(fullName)) {
        const names = fullName.split(".");
        name = names[names.length - 1];
      }
      return name;
    }
    static isKnownTemplate(name, exports) {
      return Builder.knownTemplates.has(name);
    }
    static isKnownMultiTemplate(name, exports) {
      return Builder.knownMultiTemplates.has(name);
    }
    static addToComplexProperty(parent, complexProperty, elementModule) {
      const parentComponent = parent.component;
      if (ComponentParser.isKnownCollection(complexProperty.name, parent.exports)) {
        complexProperty.items.push(elementModule.component);
      } else if (parentComponent._addChildFromBuilder) {
        parentComponent._addChildFromBuilder(complexProperty.name, elementModule.component);
      } else {
        parentComponent[complexProperty.name] = elementModule.component;
      }
    }
    static isKnownCollection(name, context) {
      return Builder.knownCollections.has(name);
    }
  }
  ComponentParser.KNOWNCOLLECTIONS = "knownCollections";
  ComponentParser.KNOWNTEMPLATES = "knownTemplates";
  ComponentParser.KNOWNMULTITEMPLATES = "knownMultiTemplates";
  __decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [ParserEvent]),
    __metadata("design:returntype", Object)
  ], ComponentParser.prototype, "buildComponent", null);
  xml2ui2.ComponentParser = ComponentParser;
})(xml2ui || (xml2ui = {}));

// node_modules/@nativescript/core/globals/global-utils.js
class NativeScriptGlobalState {
  constructor() {
    this.launched = false;
    this._appInstanceReady = false;
    this.events = new Observable;
    this._setLaunched = this._setLaunchedFn.bind(this);
    this.events.on("launch", this._setLaunched);
    if (level() > 0) {
      this.events.on("displayed", () => {
        const duration = uptime();
        const end = time();
        const start2 = end - duration;
        trace(`Displayed in ${duration.toFixed(2)}ms`, start2, end);
      });
    }
  }
  get appInstanceReady() {
    return this._appInstanceReady;
  }
  set appInstanceReady(value) {
    this._appInstanceReady = value;
    if (this.appEventWiring && this.appEventWiring.length) {
      for (const callback of this.appEventWiring) {
        callback();
      }
      this.appEventWiring = null;
    }
  }
  addEventWiring(callback) {
    if (this._appInstanceReady) {
      callback();
    } else {
      if (!this.appEventWiring) {
        this.appEventWiring = [];
      }
      this.appEventWiring.push(callback);
    }
  }
  _setLaunchedFn() {
    this.launched = true;
    this.events.off("launch", this._setLaunched);
    this._setLaunched = null;
  }
}
function getNativeScriptGlobals() {
  if (!global.NativeScriptGlobals) {
    global.NativeScriptGlobals = new NativeScriptGlobalState;
  }
  return global.NativeScriptGlobals;
}

// node_modules/@nativescript/core/application/application-common.js
var ORIENTATION_CSS_CLASSES = [
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.DeviceOrientation.portrait}`,
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.DeviceOrientation.landscape}`,
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.DeviceOrientation.unknown}`
];
var SYSTEM_APPEARANCE_CSS_CLASSES = [
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.SystemAppearance.light}`,
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.SystemAppearance.dark}`
];
var LAYOUT_DIRECTION_CSS_CLASSES = [
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.LayoutDirection.ltr}`,
  `${CSSUtils.CLASS_PREFIX}${CoreTypes.LayoutDirection.rtl}`
];
var sdkVersionClasses = [];
function initializeSdkVersionClass(rootView2) {
  const majorVersion = Math.floor(SDK_VERSION);
  sdkVersionClasses = [];
  let platformPrefix = "";
  if (__APPLE__) {
    platformPrefix = __VISIONOS__ ? "ns-visionos" : "ns-ios";
  } else if (__ANDROID__) {
    platformPrefix = "ns-android";
  }
  if (platformPrefix) {
    sdkVersionClasses.push(`${platformPrefix}-${majorVersion}`);
  }
  applySdkVersionClass(rootView2);
}
function applySdkVersionClass(rootView2) {
  if (!sdkVersionClasses.length) {
    return;
  }
  if (!rootView2) {
    return;
  }
  const classesToAdd = sdkVersionClasses.filter((className) => !rootView2.cssClasses.has(className));
  classesToAdd.forEach((className) => rootView2.cssClasses.add(className));
  const rootModalViews = rootView2._getRootModalViews();
  if (rootModalViews.length > 0) {
    rootModalViews.forEach((rootModalView) => {
      const modalClassesToAdd = sdkVersionClasses.filter((className) => !rootModalView.cssClasses.has(className));
      modalClassesToAdd.forEach((className) => rootModalView.cssClasses.add(className));
    });
  }
}
var globalEvents = getNativeScriptGlobals().events;
class ApplicationCommon {
  constructor() {
    this.launchEvent = "launch";
    this.suspendEvent = "suspend";
    this.displayedEvent = "displayed";
    this.backgroundEvent = "background";
    this.foregroundEvent = "foreground";
    this.resumeEvent = "resume";
    this.exitEvent = "exit";
    this.lowMemoryEvent = "lowMemory";
    this.uncaughtErrorEvent = "uncaughtError";
    this.discardedErrorEvent = "discardedError";
    this.orientationChangedEvent = "orientationChanged";
    this.systemAppearanceChangedEvent = "systemAppearanceChanged";
    this.layoutDirectionChangedEvent = "layoutDirectionChanged";
    this.fontScaleChangedEvent = "fontScaleChanged";
    this.livesyncEvent = "livesync";
    this.loadAppCssEvent = "loadAppCss";
    this.cssChangedEvent = "cssChanged";
    this.initRootViewEvent = "initRootView";
    this.on = globalEvents.on.bind(globalEvents);
    this.once = globalEvents.once.bind(globalEvents);
    this.off = globalEvents.off.bind(globalEvents);
    this.notify = globalEvents.notify.bind(globalEvents);
    this.hasListeners = globalEvents.hasListeners.bind(globalEvents);
    this._inBackground = false;
    this._suspended = false;
    this._cssFile = "./app.css";
    this.started = false;
    this.autoSystemAppearanceChanged = true;
    getNativeScriptGlobals().appInstanceReady = true;
    global.__onUncaughtError = (error) => {
      this.notify({
        eventName: this.uncaughtErrorEvent,
        object: this,
        android: error,
        ios: error,
        error
      });
    };
    global.__onDiscardedError = (error) => {
      this.notify({
        eventName: this.discardedErrorEvent,
        object: this,
        error
      });
    };
    global.__onLiveSync = (context) => {
      if (this.suspended) {
        return;
      }
      const rootView2 = this.getRootView();
      this.livesync(rootView2, context);
    };
  }
  livesync(rootView2, context) {
    this.notify({ eventName: this.livesyncEvent, object: this });
    const liveSyncCore = global.__onLiveSyncCore;
    let reapplyAppStyles = false;
    if (context && context.path) {
      const styleExtensions = ["css", "scss"];
      const appStylesFullFileName = this.getCssFileName();
      const appStylesFileName = appStylesFullFileName.substring(0, appStylesFullFileName.lastIndexOf(".") + 1);
      reapplyAppStyles = styleExtensions.some((ext) => context.path === appStylesFileName.concat(ext));
    }
    if (rootView2 && reapplyAppStyles) {
      rootView2._onCssStateChange();
    } else if (liveSyncCore) {
      liveSyncCore(context);
    }
  }
  applyCssClass(rootView2, cssClasses2, newCssClass, skipCssUpdate = false) {
    if (!rootView2.cssClasses.has(newCssClass)) {
      cssClasses2.forEach((cssClass) => this.removeCssClass(rootView2, cssClass));
      this.addCssClass(rootView2, newCssClass);
      this.increaseStyleScopeApplicationCssSelectorVersion(rootView2);
      if (!skipCssUpdate) {
        rootView2._onCssStateChange();
      }
      if (Trace.isEnabled()) {
        const rootCssClasses = Array.from(rootView2.cssClasses);
        Trace.write(`Applying root css class: ${newCssClass}. rootView css classes: ${rootCssClasses.join(" ")}`, Trace.categories.Style);
      }
    }
  }
  addCssClass(rootView2, cssClass) {
    CSSUtils.pushToSystemCssClasses(cssClass);
    rootView2.cssClasses.add(cssClass);
  }
  removeCssClass(rootView2, cssClass) {
    CSSUtils.removeSystemCssClass(cssClass);
    rootView2.cssClasses.delete(cssClass);
  }
  increaseStyleScopeApplicationCssSelectorVersion(rootView2) {
    const styleScope = rootView2._styleScope ?? rootView2?.currentPage?._styleScope;
    if (styleScope) {
      styleScope._increaseApplicationCssSelectorVersion();
    }
  }
  setRootViewCSSClasses(rootView2) {
    const platform = Device.os.toLowerCase();
    const deviceType = Device.deviceType.toLowerCase();
    const orientation = this.orientation();
    const systemAppearance = this.systemAppearance();
    const layoutDirection = this.layoutDirection();
    if (platform) {
      CSSUtils.pushToSystemCssClasses(`${CSSUtils.CLASS_PREFIX}${platform}`);
    }
    if (deviceType) {
      CSSUtils.pushToSystemCssClasses(`${CSSUtils.CLASS_PREFIX}${deviceType}`);
    }
    if (orientation) {
      CSSUtils.pushToSystemCssClasses(`${CSSUtils.CLASS_PREFIX}${orientation}`);
    }
    if (systemAppearance) {
      CSSUtils.pushToSystemCssClasses(`${CSSUtils.CLASS_PREFIX}${systemAppearance}`);
    }
    if (layoutDirection) {
      CSSUtils.pushToSystemCssClasses(`${CSSUtils.CLASS_PREFIX}${layoutDirection}`);
    }
    rootView2.cssClasses.add(CSSUtils.ROOT_VIEW_CSS_CLASS);
    const rootViewCssClasses = CSSUtils.getSystemCssClasses();
    rootViewCssClasses.forEach((c3) => rootView2.cssClasses.add(c3));
    this.increaseStyleScopeApplicationCssSelectorVersion(rootView2);
    rootView2._onCssStateChange();
    if (Trace.isEnabled()) {
      const rootCssClasses = Array.from(rootView2.cssClasses);
      Trace.write(`Setting root css classes: ${rootCssClasses.join(" ")}`, Trace.categories.Style);
    }
  }
  setMaxRefreshRate(options) {}
  getMainEntry() {
    return getAppMainEntry();
  }
  notifyLaunch(additionalLanchEventData) {
    const launchArgs = {
      eventName: this.launchEvent,
      object: this,
      ios: this.ios,
      android: this.android,
      ...additionalLanchEventData
    };
    this.notify(launchArgs);
    this.loadAppCss();
    return launchArgs.root;
  }
  createRootView(view, fireLaunchEvent = false, additionalLanchEventData) {
    let rootView2 = view;
    if (!rootView2) {
      if (fireLaunchEvent) {
        rootView2 = this.notifyLaunch(additionalLanchEventData);
        if (rootView2 === null) {
          return null;
        }
      }
      if (!rootView2) {
        if (!getAppMainEntry()) {
          throw new Error("Main entry is missing. App cannot be started. Verify app bootstrap.");
        }
        rootView2 = Builder.createViewFromEntry(getAppMainEntry());
      }
    }
    return rootView2;
  }
  getRootView() {
    throw new Error("getRootView() Not implemented.");
  }
  resetRootView(entry) {
    setAppMainEntry(typeof entry === "string" ? { moduleName: entry } : entry);
  }
  initRootView(rootView2) {
    this.setRootViewCSSClasses(rootView2);
    readyInitAccessibilityCssHelper();
    readyInitFontScale();
    this.notify({ eventName: this.initRootViewEvent, rootView: rootView2 });
  }
  getResources() {
    return get();
  }
  setResources(res) {
    set(res);
  }
  setCssFileName(cssFileName) {
    this._cssFile = cssFileName;
    this.notify({
      eventName: this.cssChangedEvent,
      object: this,
      cssFile: cssFileName
    });
  }
  getCssFileName() {
    return this._cssFile;
  }
  loadAppCss() {
    try {
      this.notify({
        eventName: this.loadAppCssEvent,
        object: this,
        ios: this.ios,
        android: this.android,
        cssFile: this.getCssFileName()
      });
    } catch (e3) {
      if (Trace.isEnabled()) {
        Trace.write(`The app CSS file ${this.getCssFileName()} couldn't be loaded!`, Trace.categories.Style, Trace.messageType.warn);
      }
    }
  }
  addCss(cssText, attributeScoped) {
    this.notify({
      eventName: this.cssChangedEvent,
      object: this,
      cssText
    });
    if (!attributeScoped) {
      const rootView2 = this.getRootView();
      if (rootView2) {
        rootView2._onCssStateChange();
      }
    }
  }
  run(entry) {
    throw new Error("run() Not implemented.");
  }
  getOrientation() {
    throw new Error("getOrientation() not implemented");
  }
  setOrientation(value) {
    if (this._orientation === value) {
      return;
    }
    this._orientation = value;
    Screen.mainScreen._updateMetrics();
    this.orientationChanged(this.getRootView(), value);
    this.notify({
      eventName: this.orientationChangedEvent,
      android: this.android,
      ios: this.ios,
      newValue: value,
      object: this
    });
  }
  orientation() {
    return this._orientation ?? (this._orientation = this.getOrientation());
  }
  orientationChanged(rootView2, newOrientation) {
    if (!rootView2) {
      return;
    }
    const newOrientationCssClass = `${CSSUtils.CLASS_PREFIX}${newOrientation}`;
    this.applyCssClass(rootView2, ORIENTATION_CSS_CLASSES, newOrientationCssClass, true);
    const rootModalViews = rootView2._getRootModalViews();
    rootModalViews.forEach((rootModalView) => {
      this.applyCssClass(rootModalView, ORIENTATION_CSS_CLASSES, newOrientationCssClass, true);
      rootModalView._onCssStateChange();
    });
    rootView2._onCssStateChange();
  }
  getNativeApplication() {
    throw new Error("getNativeApplication() not implemented");
  }
  hasLaunched() {
    return getNativeScriptGlobals().launched;
  }
  getSystemAppearance() {
    throw new Error("getSystemAppearance() not implemented");
  }
  setSystemAppearance(value) {
    if (this._systemAppearance === value) {
      return;
    }
    this._systemAppearance = value;
    this.systemAppearanceChanged(this.getRootView(), value);
    this.notify({
      eventName: this.systemAppearanceChangedEvent,
      android: this.android,
      ios: this.ios,
      newValue: value,
      object: this
    });
  }
  systemAppearance() {
    return this._systemAppearance ?? (this._systemAppearance = this.getSystemAppearance());
  }
  setAutoSystemAppearanceChanged(value) {
    this.autoSystemAppearanceChanged = value;
  }
  systemAppearanceChanged(rootView2, newSystemAppearance) {
    if (!rootView2 || !this.autoSystemAppearanceChanged) {
      return;
    }
    const newSystemAppearanceCssClass = `${CSSUtils.CLASS_PREFIX}${newSystemAppearance}`;
    this.applyCssClass(rootView2, SYSTEM_APPEARANCE_CSS_CLASSES, newSystemAppearanceCssClass, true);
    const rootModalViews = rootView2._getRootModalViews();
    rootModalViews.forEach((rootModalView) => {
      this.applyCssClass(rootModalView, SYSTEM_APPEARANCE_CSS_CLASSES, newSystemAppearanceCssClass, true);
      rootModalView._onCssStateChange();
    });
    rootView2._onCssStateChange();
  }
  getLayoutDirection() {
    throw new Error("getLayoutDirection() not implemented");
  }
  setLayoutDirection(value) {
    if (this._layoutDirection === value) {
      return;
    }
    this._layoutDirection = value;
    this.layoutDirectionChanged(this.getRootView(), value);
    this.notify({
      eventName: this.layoutDirectionChangedEvent,
      android: this.android,
      ios: this.ios,
      newValue: value,
      object: this
    });
  }
  layoutDirection() {
    return this._layoutDirection ?? (this._layoutDirection = this.getLayoutDirection());
  }
  layoutDirectionChanged(rootView2, newLayoutDirection) {
    if (!rootView2) {
      return;
    }
    const newLayoutDirectionCssClass = `${CSSUtils.CLASS_PREFIX}${newLayoutDirection}`;
    this.applyCssClass(rootView2, LAYOUT_DIRECTION_CSS_CLASSES, newLayoutDirectionCssClass, true);
    const rootModalViews = rootView2._getRootModalViews();
    rootModalViews.forEach((rootModalView) => {
      this.applyCssClass(rootModalView, LAYOUT_DIRECTION_CSS_CLASSES, newLayoutDirectionCssClass, true);
      rootModalView._onCssStateChange();
    });
    rootView2._onCssStateChange();
  }
  get inBackground() {
    return isAppInBackground();
  }
  setInBackground(value, additonalData) {
    setAppInBackground(value);
    this.notify({
      eventName: value ? this.backgroundEvent : this.foregroundEvent,
      object: this,
      ios: this.ios,
      ...additonalData
    });
  }
  get suspended() {
    return this._suspended;
  }
  setSuspended(value, additonalData) {
    this._suspended = value;
    this.notify({
      eventName: value ? this.suspendEvent : this.resumeEvent,
      object: this,
      ios: this.ios,
      android: this.android,
      ...additonalData
    });
  }
  get android() {
    return;
  }
  get ios() {
    return;
  }
  get AndroidApplication() {
    return this.android;
  }
  get iOSApplication() {
    return this.ios;
  }
}
ApplicationCommon.on = globalEvents.on.bind(globalEvents);
ApplicationCommon.once = globalEvents.once.bind(globalEvents);
ApplicationCommon.off = globalEvents.off.bind(globalEvents);
ApplicationCommon.notify = globalEvents.notify.bind(globalEvents);
ApplicationCommon.hasListeners = globalEvents.hasListeners.bind(globalEvents);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Function)
], ApplicationCommon.prototype, "notifyLaunch", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Function, Object, Object]),
  __metadata("design:returntype", undefined)
], ApplicationCommon.prototype, "createRootView", null);
prepareAppForModuleResolver(() => {
  ApplicationCommon.on("livesync", (args) => clearResolverCache());
  ApplicationCommon.on("orientationChanged", (args) => {
    _setResolver(undefined);
  });
});

// node_modules/@nativescript/core/utils/lazy.js
function lazy(action) {
  let _value;
  return () => _value || (_value = action());
}

// node_modules/@nativescript/core/application/application.android.js
var NativeScriptLifecycleCallbacks_;
function initNativeScriptLifecycleCallbacks() {
  if (NativeScriptLifecycleCallbacks_) {
    return NativeScriptLifecycleCallbacks_;
  }
  var NativeScriptLifecycleCallbacksImpl = function(_super) {
    __extends(NativeScriptLifecycleCallbacksImpl2, _super);
    function NativeScriptLifecycleCallbacksImpl2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.activitiesCount = 0;
      return _this;
    }
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivityCreated = function(activity, savedInstanceState) {
      this.setThemeOnLaunch(activity);
      enableEdgeToEdge(activity);
      if (!Application.android.startActivity) {
        Application.android.setStartActivity(activity);
      }
      if (!this.nativescriptActivity && "isNativeScriptActivity" in activity) {
        this.nativescriptActivity = activity;
      }
      this.notifyActivityCreated(activity, savedInstanceState);
      if (Application.hasListeners(Application.displayedEvent)) {
        this.subscribeForGlobalLayout(activity);
      }
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivityDestroyed = function(activity) {
      if (activity === Application.android.foregroundActivity) {
        Application.android.setForegroundActivity(undefined);
      }
      if (activity === this.nativescriptActivity) {
        this.nativescriptActivity = undefined;
      }
      if (activity === Application.android.startActivity) {
        Application.android.setStartActivity(undefined);
        if (this.nativescriptActivity) {
          Application.android.setStartActivity(this.nativescriptActivity);
        }
      }
      Application.android.notify({
        eventName: Application.android.activityDestroyedEvent,
        object: Application.android,
        activity
      });
      gc();
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivityPaused = function(activity) {
      if ("isNativeScriptActivity" in activity) {
        Application.setSuspended(true, {
          android: activity,
          activity
        });
      }
      Application.android.notify({
        eventName: Application.android.activityPausedEvent,
        object: Application.android,
        activity
      });
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivityResumed = function(activity) {
      Application.android.setForegroundActivity(activity);
      Application.android.notify({
        eventName: Application.android.activityResumedEvent,
        object: Application.android,
        activity
      });
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivitySaveInstanceState = function(activity, bundle) {
      Application.android.notify({
        eventName: Application.android.saveActivityStateEvent,
        object: Application.android,
        activity,
        bundle
      });
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivityStarted = function(activity) {
      this.activitiesCount++;
      if (this.activitiesCount === 1) {
        Application.android.setInBackground(false, {
          android: activity,
          activity
        });
      }
      Application.android.notify({
        eventName: Application.android.activityStartedEvent,
        object: Application.android,
        activity
      });
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.onActivityStopped = function(activity) {
      this.activitiesCount--;
      if (this.activitiesCount === 0) {
        Application.android.setInBackground(true, {
          android: activity,
          activity
        });
      }
      Application.android.notify({
        eventName: Application.android.activityStoppedEvent,
        object: Application.android,
        activity
      });
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.setThemeOnLaunch = function(activity) {
      var activityInfo = activity.getPackageManager().getActivityInfo(activity.getComponentName(), android.content.pm.PackageManager.GET_META_DATA);
      if (activityInfo.metaData) {
        var setThemeOnLaunch = activityInfo.metaData.getInt("SET_THEME_ON_LAUNCH", -1);
        if (setThemeOnLaunch !== -1) {
          activity.setTheme(setThemeOnLaunch);
        }
      }
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.notifyActivityCreated = function(activity, bundle) {
      Application.android.notify({
        eventName: Application.android.activityCreatedEvent,
        object: Application.android,
        activity,
        bundle
      });
    };
    NativeScriptLifecycleCallbacksImpl2.prototype.subscribeForGlobalLayout = function(activity) {
      var rootView2 = activity.getWindow().getDecorView().getRootView();
      global.onGlobalLayoutListener = new android.view.ViewTreeObserver.OnGlobalLayoutListener({
        onGlobalLayout: function() {
          Application.android.notify({
            eventName: Application.displayedEvent,
            object: Application,
            android: Application.android,
            activity
          });
          var viewTreeObserver = rootView2.getViewTreeObserver();
          viewTreeObserver.removeOnGlobalLayoutListener(global.onGlobalLayoutListener);
        }
      });
      rootView2.getViewTreeObserver().addOnGlobalLayoutListener(global.onGlobalLayoutListener);
    };
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivityCreated", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivityDestroyed", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivityPaused", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivityResumed", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivitySaveInstanceState", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivityStarted", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "onActivityStopped", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "setThemeOnLaunch", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "notifyActivityCreated", null);
    __decorate([
      profile
    ], NativeScriptLifecycleCallbacksImpl2.prototype, "subscribeForGlobalLayout", null);
    NativeScriptLifecycleCallbacksImpl2 = __decorate([
      JavaProxy("org.nativescript.NativeScriptLifecycleCallbacks")
    ], NativeScriptLifecycleCallbacksImpl2);
    return NativeScriptLifecycleCallbacksImpl2;
  }(android.app.Application.ActivityLifecycleCallbacks);
  NativeScriptLifecycleCallbacks_ = NativeScriptLifecycleCallbacksImpl;
  return NativeScriptLifecycleCallbacks_;
}
var NativeScriptComponentCallbacks_;
function initNativeScriptComponentCallbacks() {
  if (NativeScriptComponentCallbacks_) {
    return NativeScriptComponentCallbacks_;
  }
  var NativeScriptComponentCallbacksImpl = function(_super) {
    __extends(NativeScriptComponentCallbacksImpl2, _super);
    function NativeScriptComponentCallbacksImpl2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NativeScriptComponentCallbacksImpl2.prototype.onLowMemory = function() {
      gc();
      java.lang.System.gc();
      Application.notify({
        eventName: Application.lowMemoryEvent,
        object: Application,
        android: this
      });
    };
    NativeScriptComponentCallbacksImpl2.prototype.onTrimMemory = function(level2) {};
    NativeScriptComponentCallbacksImpl2.prototype.onConfigurationChanged = function(newConfiguration) {
      Application.android.onConfigurationChanged(newConfiguration);
    };
    __decorate([
      profile
    ], NativeScriptComponentCallbacksImpl2.prototype, "onLowMemory", null);
    __decorate([
      profile
    ], NativeScriptComponentCallbacksImpl2.prototype, "onTrimMemory", null);
    __decorate([
      profile
    ], NativeScriptComponentCallbacksImpl2.prototype, "onConfigurationChanged", null);
    NativeScriptComponentCallbacksImpl2 = __decorate([
      JavaProxy("org.nativescript.NativeScriptComponentCallbacks")
    ], NativeScriptComponentCallbacksImpl2);
    return NativeScriptComponentCallbacksImpl2;
  }(android.content.ComponentCallbacks2);
  NativeScriptComponentCallbacks_ = NativeScriptComponentCallbacksImpl;
  return NativeScriptComponentCallbacks_;
}
var BroadcastReceiver = lazy(() => {
  var BroadcastReceiverImpl = function(_super) {
    __extends(BroadcastReceiverImpl2, _super);
    function BroadcastReceiverImpl2(onReceiveCallback) {
      var _this = _super.call(this) || this;
      _this._onReceiveCallback = onReceiveCallback;
      return global.__native(_this);
    }
    BroadcastReceiverImpl2.prototype.onReceive = function(context, intent) {
      if (this._onReceiveCallback) {
        this._onReceiveCallback(context, intent);
      }
    };
    return BroadcastReceiverImpl2;
  }(android.content.BroadcastReceiver);
  return BroadcastReceiverImpl;
});

class AndroidApplication extends ApplicationCommon {
  constructor() {
    super(...arguments);
    this.activityCreatedEvent = AndroidApplication.activityCreatedEvent;
    this.activityDestroyedEvent = AndroidApplication.activityDestroyedEvent;
    this.activityStartedEvent = AndroidApplication.activityStartedEvent;
    this.activityPausedEvent = AndroidApplication.activityPausedEvent;
    this.activityResumedEvent = AndroidApplication.activityResumedEvent;
    this.activityStoppedEvent = AndroidApplication.activityStoppedEvent;
    this.saveActivityStateEvent = AndroidApplication.saveActivityStateEvent;
    this.activityResultEvent = AndroidApplication.activityResultEvent;
    this.activityBackPressedEvent = AndroidApplication.activityBackPressedEvent;
    this.activityNewIntentEvent = AndroidApplication.activityNewIntentEvent;
    this.activityRequestPermissionsEvent = AndroidApplication.activityRequestPermissionsEvent;
    this._registeredReceivers = {};
    this._registeredReceiversById = {};
    this._nextReceiverId = 1;
    this._pendingReceiverRegistrations = [];
  }
  init(nativeApp2) {
    if (this.nativeApp === nativeApp2) {
      return;
    }
    if (this.nativeApp) {
      throw new Error("Application.android already initialized.");
    }
    this._nativeApp = nativeApp2;
    setNativeApp(nativeApp2);
    this._context = nativeApp2.getApplicationContext();
    this._packageName = nativeApp2.getPackageName();
    this.lifecycleCallbacks = new (initNativeScriptLifecycleCallbacks());
    this.nativeApp.registerActivityLifecycleCallbacks(this.lifecycleCallbacks);
    this.componentCallbacks = new (initNativeScriptComponentCallbacks());
    this.nativeApp.registerComponentCallbacks(this.componentCallbacks);
    this._registerPendingReceivers();
  }
  _registerPendingReceivers() {
    this._pendingReceiverRegistrations.forEach((info) => this._registerReceiver(this.context, info.intent, info.callback, info.flags, info.id));
    this._pendingReceiverRegistrations.length = 0;
  }
  onConfigurationChanged(configuration) {
    this.setOrientation(this.getOrientationValue(configuration));
    this.setSystemAppearance(this.getSystemAppearanceValue(configuration));
    this.setLayoutDirection(this.getLayoutDirectionValue(configuration));
  }
  getNativeApplication() {
    let nativeApp2 = this.nativeApp;
    if (nativeApp2) {
      return nativeApp2;
    }
    nativeApp2 = getNativeApp();
    if (!nativeApp2) {
      throw new Error("Failed to retrieve native Android Application object. If you have a custom android.app.Application type implemented make sure that you've called the 'Application.android.init' method.");
    }
    return nativeApp2;
  }
  get nativeApp() {
    return this._nativeApp;
  }
  run(entry) {
    if (this.started) {
      throw new Error("Application is already started.");
    }
    this.started = true;
    setAppMainEntry(typeof entry === "string" ? { moduleName: entry } : entry);
    if (!this.nativeApp) {
      const nativeApp2 = this.getNativeApplication();
      this.init(nativeApp2);
    }
  }
  get startActivity() {
    return androidGetStartActivity();
  }
  get foregroundActivity() {
    return androidGetForegroundActivity();
  }
  setStartActivity(value) {
    androidSetStartActivity(value);
  }
  setForegroundActivity(value) {
    androidSetForegroundActivity(value);
  }
  get paused() {
    return this.suspended;
  }
  get backgrounded() {
    return this.inBackground;
  }
  get context() {
    return this._context;
  }
  get packageName() {
    return this._packageName;
  }
  registerBroadcastReceiver(intentFilter, onReceiveCallback, flags = 2) {
    const receiverId = this._nextReceiverId++;
    if (this.context) {
      this._registerReceiver(this.context, intentFilter, onReceiveCallback, flags, receiverId);
    } else {
      this._pendingReceiverRegistrations.push({
        intent: intentFilter,
        callback: onReceiveCallback,
        id: receiverId,
        flags
      });
    }
    let removed = false;
    return () => {
      if (removed) {
        return;
      }
      removed = true;
      if (this._registeredReceiversById[receiverId]) {
        const receiverInfo = this._registeredReceiversById[receiverId];
        this.context.unregisterReceiver(receiverInfo.receiver);
        this._registeredReceivers[receiverInfo.intent] = this._registeredReceivers[receiverInfo.intent]?.filter((ri) => ri.id !== receiverId);
        delete this._registeredReceiversById[receiverId];
      } else {
        this._pendingReceiverRegistrations = this._pendingReceiverRegistrations.filter((ri) => ri.id !== receiverId);
      }
    };
  }
  _registerReceiver(context, intentFilter, onReceiveCallback, flags, id) {
    var _a4;
    const receiver = new (BroadcastReceiver())(onReceiveCallback);
    if (SDK_VERSION >= 26) {
      context.registerReceiver(receiver, new android.content.IntentFilter(intentFilter), flags);
    } else {
      context.registerReceiver(receiver, new android.content.IntentFilter(intentFilter));
    }
    const receiverInfo = { receiver, intent: intentFilter, callback: onReceiveCallback, id: typeof id === "number" ? id : this._nextReceiverId++, flags };
    (_a4 = this._registeredReceivers)[intentFilter] ?? (_a4[intentFilter] = []);
    this._registeredReceivers[intentFilter].push(receiverInfo);
    this._registeredReceiversById[receiverInfo.id] = receiverInfo;
    return receiver;
  }
  unregisterBroadcastReceiver(intentFilter) {
    const receivers = this._registeredReceivers[intentFilter];
    if (receivers) {
      receivers.forEach((receiver) => {
        this.context.unregisterReceiver(receiver.receiver);
      });
      this._registeredReceivers[intentFilter] = [];
    }
  }
  getRegisteredBroadcastReceiver(intentFilter) {
    return this._registeredReceivers[intentFilter]?.[0].receiver;
  }
  getRegisteredBroadcastReceivers(intentFilter) {
    const receiversInfo = this._registeredReceivers[intentFilter];
    if (receiversInfo) {
      return receiversInfo.map((info) => info.receiver);
    }
    return [];
  }
  getRootView() {
    const activity = this.foregroundActivity || this.startActivity;
    if (!activity) {
      return;
    }
    const callbacks = activity["_callbacks"];
    setRootView(callbacks ? callbacks.getRootView() : undefined);
    return getRootView();
  }
  resetRootView(entry) {
    super.resetRootView(entry);
    const activity = this.foregroundActivity || this.startActivity;
    if (!activity) {
      throw new Error("Cannot find android activity.");
    }
    const callbacks = activity["_callbacks"];
    if (!callbacks) {
      throw new Error("Cannot find android activity callbacks.");
    }
    callbacks.resetActivityContent(activity);
  }
  getSystemAppearance() {
    const resources3 = this.context.getResources();
    const configuration = resources3.getConfiguration();
    return this.getSystemAppearanceValue(configuration);
  }
  getSystemAppearanceValue(configuration) {
    const systemAppearance = configuration.uiMode & android.content.res.Configuration.UI_MODE_NIGHT_MASK;
    switch (systemAppearance) {
      case android.content.res.Configuration.UI_MODE_NIGHT_YES:
        return "dark";
      case android.content.res.Configuration.UI_MODE_NIGHT_NO:
      case android.content.res.Configuration.UI_MODE_NIGHT_UNDEFINED:
        return "light";
    }
  }
  getLayoutDirection() {
    const resources3 = this.context.getResources();
    const configuration = resources3.getConfiguration();
    return this.getLayoutDirectionValue(configuration);
  }
  getLayoutDirectionValue(configuration) {
    const layoutDirection = configuration.getLayoutDirection();
    switch (layoutDirection) {
      case android.view.View.LAYOUT_DIRECTION_LTR:
        return CoreTypes.LayoutDirection.ltr;
      case android.view.View.LAYOUT_DIRECTION_RTL:
        return CoreTypes.LayoutDirection.rtl;
    }
  }
  getOrientation() {
    const resources3 = this.context.getResources();
    const configuration = resources3.getConfiguration();
    return this.getOrientationValue(configuration);
  }
  getOrientationValue(configuration) {
    const orientation = configuration.orientation;
    switch (orientation) {
      case android.content.res.Configuration.ORIENTATION_LANDSCAPE:
        return "landscape";
      case android.content.res.Configuration.ORIENTATION_PORTRAIT:
        return "portrait";
      default:
        return "unknown";
    }
  }
  get android() {
    return this;
  }
}
AndroidApplication.activityCreatedEvent = "activityCreated";
AndroidApplication.activityDestroyedEvent = "activityDestroyed";
AndroidApplication.activityStartedEvent = "activityStarted";
AndroidApplication.activityPausedEvent = "activityPaused";
AndroidApplication.activityResumedEvent = "activityResumed";
AndroidApplication.activityStoppedEvent = "activityStopped";
AndroidApplication.saveActivityStateEvent = "saveActivityState";
AndroidApplication.activityResultEvent = "activityResult";
AndroidApplication.activityBackPressedEvent = "activityBackPressed";
AndroidApplication.activityNewIntentEvent = "activityNewIntent";
AndroidApplication.activityRequestPermissionsEvent = "activityRequestPermissions";
var Application = new AndroidApplication;
function fontScaleChanged(origFontScale) {
  const oldValue = getFontScale();
  setFontScale(getClosestValidFontScale(origFontScale));
  const currentFontScale2 = getFontScale();
  if (oldValue !== currentFontScale2) {
    Application.notify({
      eventName: Application.fontScaleChangedEvent,
      object: Application,
      newValue: currentFontScale2
    });
  }
}
function getCurrentFontScale() {
  setupConfigListener();
  return getFontScale();
}
function useAndroidFontScale() {
  fontScaleChanged(Number(Application.android.context.getResources().getConfiguration().fontScale));
}
var configChangedCallback;
function setupConfigListener() {
  if (configChangedCallback) {
    return;
  }
  Application.off(Application.launchEvent, setupConfigListener);
  const context = Application.android?.context;
  if (!context) {
    Application.on(Application.launchEvent, setupConfigListener);
    return;
  }
  useAndroidFontScale();
  configChangedCallback = new android.content.ComponentCallbacks2({
    onLowMemory() {},
    onTrimMemory() {},
    onConfigurationChanged(newConfig) {
      fontScaleChanged(Number(newConfig.fontScale));
    }
  });
  context.registerComponentCallbacks(configChangedCallback);
  Application.on(Application.resumeEvent, useAndroidFontScale);
}
setInitFontScale(setupConfigListener);
function applyRootCssClass(cssClasses2, newCssClass) {
  const rootView2 = Application.getRootView();
  if (!rootView2) {
    return;
  }
  Application.applyCssClass(rootView2, cssClasses2, newCssClass);
  const rootModalViews = rootView2._getRootModalViews();
  rootModalViews.forEach((rootModalView) => Application.applyCssClass(rootModalView, cssClasses2, newCssClass));
}
function applyFontScaleToRootViews() {
  const rootView2 = Application.getRootView();
  if (!rootView2) {
    return;
  }
  const fontScale = getCurrentFontScale();
  rootView2.style.fontScaleInternal = fontScale;
  const rootModalViews = rootView2._getRootModalViews();
  rootModalViews.forEach((rootModalView) => rootModalView.style.fontScaleInternal = fontScale);
}
function getAndroidAccessibilityManager() {
  const context = getNativeApp().getApplicationContext();
  if (!context) {
    return null;
  }
  return context.getSystemService(android.content.Context.ACCESSIBILITY_SERVICE);
}
var accessibilityStateEnabledPropName = "accessibilityStateEnabled";
var touchExplorationStateEnabledPropName = "touchExplorationStateEnabled";

class AndroidSharedA11YObservable extends SharedA11YObservable {
  get accessibilityServiceEnabled() {
    return !!this[accessibilityStateEnabledPropName] && !!this[touchExplorationStateEnabledPropName];
  }
  set accessibilityServiceEnabled(v) {
    return;
  }
}
var accessibilityStateChangeListener;
var touchExplorationStateChangeListener;
var sharedA11YObservable;
function updateAccessibilityState() {
  const accessibilityManager = getAndroidAccessibilityManager();
  if (!accessibilityManager) {
    sharedA11YObservable.set(accessibilityStateEnabledPropName, false);
    sharedA11YObservable.set(touchExplorationStateEnabledPropName, false);
    return;
  }
  sharedA11YObservable.set(accessibilityStateEnabledPropName, !!accessibilityManager.isEnabled());
  sharedA11YObservable.set(touchExplorationStateEnabledPropName, !!accessibilityManager.isTouchExplorationEnabled());
}
function ensureStateListener() {
  if (sharedA11YObservable) {
    return sharedA11YObservable;
  }
  const accessibilityManager = getAndroidAccessibilityManager();
  sharedA11YObservable = new AndroidSharedA11YObservable;
  if (!accessibilityManager) {
    sharedA11YObservable.set(accessibilityStateEnabledPropName, false);
    sharedA11YObservable.set(touchExplorationStateEnabledPropName, false);
    return sharedA11YObservable;
  }
  accessibilityStateChangeListener = new android.view.accessibility.AccessibilityManager.AccessibilityStateChangeListener({
    onAccessibilityStateChanged(enabled2) {
      updateAccessibilityState();
      if (Trace.isEnabled()) {
        Trace.write(`AccessibilityStateChangeListener state changed to: ${!!enabled2}`, Trace.categories.Accessibility);
      }
    }
  });
  accessibilityManager.addAccessibilityStateChangeListener(accessibilityStateChangeListener);
  if (SDK_VERSION >= 19) {
    touchExplorationStateChangeListener = new android.view.accessibility.AccessibilityManager.TouchExplorationStateChangeListener({
      onTouchExplorationStateChanged(enabled2) {
        updateAccessibilityState();
        if (Trace.isEnabled()) {
          Trace.write(`TouchExplorationStateChangeListener state changed to: ${!!enabled2}`, Trace.categories.Accessibility);
        }
      }
    });
    accessibilityManager.addTouchExplorationStateChangeListener(touchExplorationStateChangeListener);
  }
  updateAccessibilityState();
  Application.on(Application.resumeEvent, updateAccessibilityState);
  Application.on(Application.exitEvent, (args) => {
    const activity = args.android;
    if (activity && !activity.isFinishing()) {
      return;
    }
    const accessibilityManager2 = getAndroidAccessibilityManager();
    if (accessibilityManager2) {
      if (accessibilityStateChangeListener) {
        accessibilityManager2.removeAccessibilityStateChangeListener(accessibilityStateChangeListener);
      }
      if (touchExplorationStateChangeListener) {
        accessibilityManager2.removeTouchExplorationStateChangeListener(touchExplorationStateChangeListener);
      }
    }
    accessibilityStateChangeListener = null;
    touchExplorationStateChangeListener = null;
    if (sharedA11YObservable) {
      sharedA11YObservable.removeEventListener(Observable.propertyChangeEvent);
      sharedA11YObservable = null;
    }
    Application.off(Application.resumeEvent, updateAccessibilityState);
  });
  return sharedA11YObservable;
}

class AccessibilityServiceEnabledObservable extends CommonA11YServiceEnabledObservable {
  constructor() {
    super(ensureStateListener());
  }
}
var accessibilityServiceObservable;
function ensureClasses() {
  if (accessibilityServiceObservable) {
    return;
  }
  setFontScaleCssClasses(new Map(VALID_FONT_SCALES.map((fs) => [fs, `a11y-fontscale-${Number(fs * 100).toFixed(0)}`])));
  accessibilityServiceObservable = new AccessibilityServiceEnabledObservable;
  initializeSdkVersionClass(Application.getRootView());
}
function updateCurrentHelperClasses(applyRootCssClass2) {
  const fontScale = getFontScale();
  const fontScaleCategory = getFontScaleCategory();
  const fontScaleCssClasses2 = getFontScaleCssClasses();
  const oldFontScaleClass = getCurrentFontScaleClass();
  if (fontScaleCssClasses2.has(fontScale)) {
    setCurrentFontScaleClass(fontScaleCssClasses2.get(fontScale));
  } else {
    setCurrentFontScaleClass(fontScaleCssClasses2.get(1));
  }
  if (oldFontScaleClass !== getCurrentFontScaleClass()) {
    applyRootCssClass2([...fontScaleCssClasses2.values()], getCurrentFontScaleClass());
  }
  const oldActiveFontScaleCategory = getCurrentFontScaleCategory();
  switch (fontScaleCategory) {
    case FontScaleCategory.ExtraSmall: {
      setCurrentFontScaleCategory(fontScaleExtraSmallCategoryClass);
      break;
    }
    case FontScaleCategory.Medium: {
      setCurrentFontScaleCategory(fontScaleMediumCategoryClass);
      break;
    }
    case FontScaleCategory.ExtraLarge: {
      setCurrentFontScaleCategory(fontScaleExtraLargeCategoryClass);
      break;
    }
    default: {
      setCurrentFontScaleCategory(fontScaleMediumCategoryClass);
      break;
    }
  }
  if (oldActiveFontScaleCategory !== getCurrentFontScaleCategory()) {
    applyRootCssClass2(fontScaleCategoryClasses, getCurrentFontScaleCategory());
  }
  const oldA11YStatusClass = getCurrentA11YServiceClass();
  if (accessibilityServiceObservable.accessibilityServiceEnabled) {
    setCurrentA11YServiceClass(a11yServiceEnabledClass);
  } else {
    setCurrentA11YServiceClass(a11yServiceDisabledClass);
  }
  if (oldA11YStatusClass !== getCurrentA11YServiceClass()) {
    applyRootCssClass2(a11yServiceClasses, getCurrentA11YServiceClass());
  }
}
function initAccessibilityCssHelper() {
  ensureClasses();
  Application.on(Application.fontScaleChangedEvent, () => {
    updateCurrentHelperClasses(applyRootCssClass);
    applyFontScaleToRootViews();
  });
  accessibilityServiceObservable.on(AccessibilityServiceEnabledObservable.propertyChangeEvent, () => updateCurrentHelperClasses(applyRootCssClass));
}
setInitAccessibilityCssHelper(initAccessibilityCssHelper);
var clickableRolesMap = new Set;
var lastFocusedView;
function accessibilityEventHelper(view, eventType) {
  const eventName = accessibilityEventTypeMap.get(eventType);
  if (!isAccessibilityServiceEnabled()) {
    if (Trace.isEnabled()) {
      Trace.write(`accessibilityEventHelper: Service not active`, Trace.categories.Accessibility);
    }
    return;
  }
  if (!eventName) {
    Trace.write(`accessibilityEventHelper: unknown eventType: ${eventType}`, Trace.categories.Accessibility, Trace.messageType.error);
    return;
  }
  if (!view) {
    if (Trace.isEnabled()) {
      Trace.write(`accessibilityEventHelper: no owner: ${eventName}`, Trace.categories.Accessibility);
    }
    return;
  }
  const androidView = view.nativeViewProtected;
  if (!androidView) {
    if (Trace.isEnabled()) {
      Trace.write(`accessibilityEventHelper: no nativeView`, Trace.categories.Accessibility);
    }
    return;
  }
  switch (eventType) {
    case android.view.accessibility.AccessibilityEvent.TYPE_VIEW_CLICKED: {
      if (SDK_VERSION >= 26) {
        for (const tapGesture of view.getGestureObservers(1) ?? []) {
          tapGesture.callback({
            android: view.android,
            eventName: "tap",
            ios: null,
            object: view,
            type: 1,
            view
          });
        }
      }
      return;
    }
    case android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED: {
      const lastView = lastFocusedView?.get();
      if (lastView && view !== lastView) {
        const lastAndroidView = lastView.nativeViewProtected;
        if (lastAndroidView) {
          lastAndroidView.clearFocus();
          lastFocusedView = null;
          notifyAccessibilityFocusState(lastView, false, true);
        }
      }
      lastFocusedView = new WeakRef(view);
      notifyAccessibilityFocusState(view, true, false);
      return;
    }
    case android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED: {
      const lastView = lastFocusedView?.get();
      if (lastView && view === lastView) {
        lastFocusedView = null;
        androidView.clearFocus();
      }
      notifyAccessibilityFocusState(view, false, true);
      return;
    }
  }
}
var TNSAccessibilityDelegate;
var androidViewToTNSView = new WeakMap;
var accessibilityEventMap;
var accessibilityEventTypeMap;
function ensureNativeClasses() {
  if (TNSAccessibilityDelegate) {
    return;
  }
  const AccessibilityDelegate = android.view.View["AccessibilityDelegate"];
  const RoleTypeMap = new Map([
    [AccessibilityRole.Button, android.widget.Button.class.getName()],
    [AccessibilityRole.Search, android.widget.EditText.class.getName()],
    [AccessibilityRole.Image, android.widget.ImageView.class.getName()],
    [AccessibilityRole.ImageButton, android.widget.ImageButton.class.getName()],
    [AccessibilityRole.KeyboardKey, android.inputmethodservice.Keyboard.Key.class.getName()],
    [AccessibilityRole.StaticText, android.widget.TextView.class.getName()],
    [AccessibilityRole.Adjustable, android.widget.SeekBar.class.getName()],
    [AccessibilityRole.Checkbox, android.widget.CheckBox.class.getName()],
    [AccessibilityRole.RadioButton, android.widget.RadioButton.class.getName()],
    [AccessibilityRole.SpinButton, android.widget.Spinner.class.getName()],
    [AccessibilityRole.Switch, android.widget.Switch.class.getName()],
    [AccessibilityRole.ProgressBar, android.widget.ProgressBar.class.getName()]
  ]);
  clickableRolesMap = new Set([AccessibilityRole.Button, AccessibilityRole.ImageButton]);
  const ignoreRoleTypesForTrace = new Set([AccessibilityRole.Header, AccessibilityRole.Link, AccessibilityRole.None, AccessibilityRole.Summary]);
  var TNSAccessibilityDelegateImpl = function(_super) {
    __extends(TNSAccessibilityDelegateImpl2, _super);
    function TNSAccessibilityDelegateImpl2() {
      var _this = _super.call(this) || this;
      return global.__native(_this);
    }
    TNSAccessibilityDelegateImpl2.prototype.getTnsView = function(androidView) {
      var _a4;
      var view = (_a4 = androidViewToTNSView.get(androidView)) === null || _a4 === undefined ? undefined : _a4.get();
      if (!view) {
        androidViewToTNSView.delete(androidView);
        return null;
      }
      return view;
    };
    TNSAccessibilityDelegateImpl2.prototype.onInitializeAccessibilityNodeInfo = function(host, info) {
      _super.prototype.onInitializeAccessibilityNodeInfo.call(this, host, info);
      var view = this.getTnsView(host);
      if (!view) {
        if (Trace.isEnabled()) {
          Trace.write("onInitializeAccessibilityNodeInfo ".concat(host, " ").concat(info, " no tns-view"), Trace.categories.Accessibility);
        }
        return;
      }
      var id = host.getTag(android2.resources.getId(":id/nativescript_accessibility_id"));
      if (id != null) {
        info.setViewIdResourceName(id);
      }
      var accessibilityRole = view.accessibilityRole;
      if (accessibilityRole) {
        var androidClassName = RoleTypeMap.get(accessibilityRole);
        if (androidClassName) {
          var oldClassName = info.getClassName() || SDK_VERSION >= 28 && host.getAccessibilityClassName() || null;
          info.setClassName(androidClassName);
          if (Trace.isEnabled()) {
            Trace.write("".concat(view, '.accessibilityRole = "').concat(accessibilityRole, '" is mapped to "').concat(androidClassName, '" (was ').concat(oldClassName, "). ").concat(info.getClassName()), Trace.categories.Accessibility);
          }
        } else if (!ignoreRoleTypesForTrace.has(accessibilityRole)) {
          if (Trace.isEnabled()) {
            Trace.write("".concat(view, '.accessibilityRole = "').concat(accessibilityRole, '" is unknown'), Trace.categories.Accessibility);
          }
        }
        if (clickableRolesMap.has(accessibilityRole)) {
          if (Trace.isEnabled()) {
            Trace.write("onInitializeAccessibilityNodeInfo ".concat(view, " - set clickable role=").concat(accessibilityRole), Trace.categories.Accessibility);
          }
          info.setClickable(true);
        }
        if (SDK_VERSION >= 28) {
          if (accessibilityRole === AccessibilityRole.Header) {
            if (Trace.isEnabled()) {
              Trace.write("onInitializeAccessibilityNodeInfo ".concat(view, " - set heading role=").concat(accessibilityRole), Trace.categories.Accessibility);
            }
            info.setHeading(true);
          } else if (host.isAccessibilityHeading()) {
            if (Trace.isEnabled()) {
              Trace.write("onInitializeAccessibilityNodeInfo ".concat(view, " - set heading from host"), Trace.categories.Accessibility);
            }
            info.setHeading(true);
          } else {
            if (Trace.isEnabled()) {
              Trace.write("onInitializeAccessibilityNodeInfo ".concat(view, " - set not heading"), Trace.categories.Accessibility);
            }
            info.setHeading(false);
          }
        }
        switch (accessibilityRole) {
          case AccessibilityRole.Switch:
          case AccessibilityRole.RadioButton:
          case AccessibilityRole.Checkbox: {
            if (Trace.isEnabled()) {
              Trace.write("onInitializeAccessibilityNodeInfo ".concat(view, " - set checkable and check=").concat(view.accessibilityState === AccessibilityState.Checked), Trace.categories.Accessibility);
            }
            info.setCheckable(true);
            info.setChecked(view.accessibilityState === AccessibilityState.Checked);
            break;
          }
          default: {
            if (Trace.isEnabled()) {
              Trace.write("onInitializeAccessibilityNodeInfo ".concat(view, " - set enabled=").concat(view.accessibilityState !== AccessibilityState.Disabled, " and selected=").concat(view.accessibilityState === AccessibilityState.Selected), Trace.categories.Accessibility);
            }
            info.setEnabled(view.accessibilityState !== AccessibilityState.Disabled);
            info.setSelected(view.accessibilityState === AccessibilityState.Selected);
            break;
          }
        }
      }
      if (view.accessible) {
        info.setFocusable(true);
      }
    };
    TNSAccessibilityDelegateImpl2.prototype.sendAccessibilityEvent = function(host, eventType) {
      _super.prototype.sendAccessibilityEvent.call(this, host, eventType);
      var view = this.getTnsView(host);
      if (!view) {
        console.log("skip - ".concat(host, " - ").concat(accessibilityEventTypeMap.get(eventType)));
        return;
      }
      try {
        accessibilityEventHelper(view, eventType);
      } catch (err) {
        console.error(err);
      }
    };
    return TNSAccessibilityDelegateImpl2;
  }(AccessibilityDelegate);
  TNSAccessibilityDelegate = new TNSAccessibilityDelegateImpl;
  accessibilityEventMap = new Map([
    [AndroidAccessibilityEvent.INVALID_POSITION, android.view.accessibility.AccessibilityEvent.INVALID_POSITION],
    [AndroidAccessibilityEvent.MAX_TEXT_LENGTH, android.view.accessibility.AccessibilityEvent.MAX_TEXT_LENGTH],
    [AndroidAccessibilityEvent.VIEW_CLICKED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_CLICKED],
    [AndroidAccessibilityEvent.VIEW_LONG_CLICKED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_LONG_CLICKED],
    [AndroidAccessibilityEvent.VIEW_SELECTED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_SELECTED],
    [AndroidAccessibilityEvent.VIEW_FOCUSED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_FOCUSED],
    [AndroidAccessibilityEvent.VIEW_TEXT_CHANGED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED],
    [AndroidAccessibilityEvent.WINDOW_STATE_CHANGED, android.view.accessibility.AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED],
    [AndroidAccessibilityEvent.NOTIFICATION_STATE_CHANGED, android.view.accessibility.AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED],
    [AndroidAccessibilityEvent.VIEW_HOVER_ENTER, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_HOVER_ENTER],
    [AndroidAccessibilityEvent.VIEW_HOVER_EXIT, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_HOVER_EXIT],
    [AndroidAccessibilityEvent.TOUCH_EXPLORATION_GESTURE_START, android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START],
    [AndroidAccessibilityEvent.TOUCH_EXPLORATION_GESTURE_END, android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END],
    [AndroidAccessibilityEvent.WINDOW_CONTENT_CHANGED, android.view.accessibility.AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED],
    [AndroidAccessibilityEvent.VIEW_SCROLLED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_SCROLLED],
    [AndroidAccessibilityEvent.VIEW_TEXT_SELECTION_CHANGED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED],
    [AndroidAccessibilityEvent.ANNOUNCEMENT, android.view.accessibility.AccessibilityEvent.TYPE_ANNOUNCEMENT],
    [AndroidAccessibilityEvent.VIEW_ACCESSIBILITY_FOCUSED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED],
    [AndroidAccessibilityEvent.VIEW_ACCESSIBILITY_FOCUS_CLEARED, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED],
    [AndroidAccessibilityEvent.VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY, android.view.accessibility.AccessibilityEvent.TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY],
    [AndroidAccessibilityEvent.GESTURE_DETECTION_START, android.view.accessibility.AccessibilityEvent.TYPE_GESTURE_DETECTION_START],
    [AndroidAccessibilityEvent.GESTURE_DETECTION_END, android.view.accessibility.AccessibilityEvent.TYPE_GESTURE_DETECTION_END],
    [AndroidAccessibilityEvent.TOUCH_INTERACTION_START, android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_INTERACTION_START],
    [AndroidAccessibilityEvent.TOUCH_INTERACTION_END, android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_INTERACTION_END],
    [AndroidAccessibilityEvent.ALL_MASK, android.view.accessibility.AccessibilityEvent.TYPES_ALL_MASK]
  ]);
  accessibilityEventTypeMap = new Map([...accessibilityEventMap].map(([k2, v]) => [v, k2]));
}
function updateAccessibilityServiceState() {
  const accessibilityManager = getAndroidAccessibilityManager();
  if (!accessibilityManager) {
    return;
  }
  setA11yEnabled(!!accessibilityManager.isEnabled() && !!accessibilityManager.isTouchExplorationEnabled());
}
function isAccessibilityServiceEnabled() {
  const accessibilityServiceEnabled = isA11yEnabled();
  if (typeof accessibilityServiceEnabled === "boolean") {
    return accessibilityServiceEnabled;
  }
  const accessibilityManager = getAndroidAccessibilityManager();
  accessibilityStateChangeListener = new android.view.accessibility.AccessibilityManager.AccessibilityStateChangeListener({
    onAccessibilityStateChanged(enabled2) {
      updateAccessibilityServiceState();
      if (Trace.isEnabled()) {
        Trace.write(`AccessibilityStateChangeListener state changed to: ${!!enabled2}`, Trace.categories.Accessibility);
      }
    }
  });
  accessibilityManager.addAccessibilityStateChangeListener(accessibilityStateChangeListener);
  if (SDK_VERSION >= 19) {
    touchExplorationStateChangeListener = new android.view.accessibility.AccessibilityManager.TouchExplorationStateChangeListener({
      onTouchExplorationStateChanged(enabled2) {
        updateAccessibilityServiceState();
        if (Trace.isEnabled()) {
          Trace.write(`TouchExplorationStateChangeListener state changed to: ${!!enabled2}`, Trace.categories.Accessibility);
        }
      }
    });
    accessibilityManager.addTouchExplorationStateChangeListener(touchExplorationStateChangeListener);
  }
  updateAccessibilityServiceState();
  Application.on(Application.exitEvent, (args) => {
    const activity = args.android;
    if (activity && !activity.isFinishing()) {
      return;
    }
    const accessibilityManager2 = getAndroidAccessibilityManager();
    if (accessibilityManager2) {
      if (accessibilityStateChangeListener) {
        accessibilityManager2.removeAccessibilityStateChangeListener(accessibilityStateChangeListener);
      }
      if (touchExplorationStateChangeListener) {
        accessibilityManager2.removeTouchExplorationStateChangeListener(touchExplorationStateChangeListener);
      }
    }
    accessibilityStateChangeListener = null;
    touchExplorationStateChangeListener = null;
    Application.off(Application.resumeEvent, updateAccessibilityServiceState);
  });
  Application.on(Application.resumeEvent, updateAccessibilityServiceState);
  return accessibilityServiceEnabled;
}
var updateAccessibilityPropertiesMicroTask;
var pendingViews = new Set;
function updateAccessibilityProperties(view) {
  if (!view.nativeViewProtected) {
    return;
  }
  pendingViews.add(view);
  if (updateAccessibilityPropertiesMicroTask)
    return;
  updateAccessibilityPropertiesMicroTask = true;
  Promise.resolve().then(() => {
    updateAccessibilityPropertiesMicroTask = false;
    let _pendingViews = Array.from(pendingViews);
    pendingViews = new Set;
    for (const view2 of _pendingViews) {
      if (!view2.nativeViewProtected)
        continue;
      setAccessibilityDelegate(view2);
      applyContentDescription(view2);
    }
    _pendingViews = [];
  });
}
setA11yUpdatePropertiesCallback(updateAccessibilityProperties);
function setAccessibilityDelegate(view) {
  if (!view.nativeViewProtected) {
    return;
  }
  ensureNativeClasses();
  const androidView = view.nativeViewProtected;
  if (!androidView || !androidView.setAccessibilityDelegate) {
    return;
  }
  androidViewToTNSView.set(androidView, new WeakRef(view));
  let hasOldDelegate = false;
  if (typeof androidView.getAccessibilityDelegate === "function") {
    hasOldDelegate = androidView.getAccessibilityDelegate() === TNSAccessibilityDelegate;
  }
  if (hasOldDelegate) {
    return;
  }
  androidView.setAccessibilityDelegate(TNSAccessibilityDelegate);
}
var applicationEvents = [Application.orientationChangedEvent, Application.systemAppearanceChangedEvent];
function toggleApplicationEventListeners2(toAdd, callback) {
  for (const eventName of applicationEvents) {
    if (toAdd) {
      Application.on(eventName, callback);
    } else {
      Application.off(eventName, callback);
    }
  }
}
setToggleApplicationEventListenersCallback(toggleApplicationEventListeners2);
setApplicationPropertiesCallback(() => {
  return {
    orientation: Application.orientation(),
    systemAppearance: Application.systemAppearance()
  };
});
function onLiveSync(args) {
  if (getImageFetcher()) {
    getImageFetcher().clearCache();
  }
}
getNativeScriptGlobals().events.on("livesync", onLiveSync);
getNativeScriptGlobals().addEventWiring(() => {
  Application.android.on("activityStarted", (args) => {
    if (!getImageFetcher()) {
      initImageCache(args.activity);
    } else {
      getImageFetcher().initCache();
    }
  });
});
getNativeScriptGlobals().addEventWiring(() => {
  Application.android.on("activityStopped", (args) => {
    if (getImageFetcher()) {
      getImageFetcher().closeCache();
    }
  });
});
// node_modules/@nativescript/core/application/application-shims.js
var addCss = Application.addCss.bind(Application);
var getCssFileName = Application.getCssFileName.bind(Application);
var getMainEntry = Application.getMainEntry.bind(Application);
var getNativeApplication = Application.getNativeApplication.bind(Application);
var getResources2 = Application.getResources.bind(Application);
var getRootView2 = Application.getRootView.bind(Application);
var hasLaunched = Application.hasLaunched.bind(Application);
var hasListeners = Application.hasListeners.bind(Application);
var loadAppCss = Application.loadAppCss.bind(Application);
var notify = Application.notify.bind(Application);
var off = Application.off.bind(Application);
var on = Application.on.bind(Application);
var orientation = Application.orientation.bind(Application);
var resetRootView = Application.resetRootView.bind(Application);
var _resetRootView = Application.resetRootView.bind(Application);
var run = Application.run.bind(Application);
var setAutoSystemAppearanceChanged = Application.setAutoSystemAppearanceChanged.bind(Application);
var setCssFileName = Application.setCssFileName.bind(Application);
var setMaxRefreshRate = Application.setMaxRefreshRate.bind(Application);
var setResources = Application.setResources.bind(Application);
var systemAppearance = Application.systemAppearance.bind(Application);
var systemAppearanceChanged = Application.systemAppearanceChanged.bind(Application);
var layoutDirection = Application.layoutDirection.bind(Application);
var layoutDirectionChanged = Application.layoutDirectionChanged.bind(Application);
var discardedErrorEvent = Application.discardedErrorEvent;
var uncaughtErrorEvent = Application.uncaughtErrorEvent;
var displayedEvent = Application.displayedEvent;
var exitEvent = Application.exitEvent;
var fontScaleChangedEvent = Application.fontScaleChangedEvent;
var launchEvent = Application.launchEvent;
var lowMemoryEvent = Application.lowMemoryEvent;
var resumeEvent = Application.resumeEvent;
var orientationChangedEvent = Application.orientationChangedEvent;
var suspendEvent = Application.suspendEvent;
var systemAppearanceChangedEvent = Application.systemAppearanceChangedEvent;
var layoutDirectionChangedEvent = Application.layoutDirectionChangedEvent;
var backgroundEvent = Application.backgroundEvent;
var foregroundEvent = Application.foregroundEvent;
var inBackground = Application.inBackground;
var suspended = Application.suspended;
var android4 = Application.android;
var ios4 = Application.ios;
// node_modules/@nativescript/core/globals/index.js
var __dirname = "/shared/data/work/00-cup/svelte-native/sshclient/node_modules/@nativescript/core/globals";
global.__dirname = typeof __dirname !== "undefined" ? __dirname : import.meta.dirname;
if (typeof global.__metadata === "undefined") {
  global.__metadata = (metadataKey, metadataValue) => {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") {
      return Reflect.metadata(metadataKey, metadataValue);
    }
  };
}
if (!global.__extends) {
  global.__extends = function(d3, b2) {
    for (const p2 in b2) {
      if (b2.hasOwnProperty(p2)) {
        d3[p2] = b2[p2];
      }
    }
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
  };
}
for (const fnName of Object.getOwnPropertyNames(modules_default)) {
  if (typeof modules_default[fnName] !== "function") {
    continue;
  }
  if (fnName in global) {
    continue;
  }
  global[fnName] = modules_default[fnName];
}
var defaultExtensionMap = {
  ".js": ".js",
  ".ts": ".js",
  ".kt": ".js",
  ".css": ".css",
  ".scss": ".css",
  ".less": ".css",
  ".sass": ".css",
  ".xml": ".xml"
};
global.moduleResolvers = [global.require];
global.registerModule = function(name, loader) {
  modules.set(name, { loader, moduleId: name });
};
global._unregisterModule = function _unregisterModule(name) {
  modules.delete(name);
};
global.registerBundlerModules = function registerBundlerModules(context, extensionMap = {}) {
  const registerWithName = (nickName, moduleId) => {
    modules.set(nickName, {
      moduleId,
      loader: () => {
        return context(moduleId);
      }
    });
  };
  const registerModuleById = (moduleId) => {
    const extDotIndex = moduleId.lastIndexOf(".");
    const base = moduleId.substring(0, extDotIndex);
    const originalExt = moduleId.substring(extDotIndex);
    const registerExt = extensionMap[originalExt] || defaultExtensionMap[originalExt] || originalExt;
    const isSourceFile = originalExt !== registerExt;
    const registerName = base + registerExt;
    if (registerName.startsWith("./") && registerName.endsWith(".js")) {
      const jsNickNames = [
        registerName.substring(2, registerName.length - 3),
        registerName.substring(0, registerName.length - 3),
        registerName.substring(2)
      ];
      jsNickNames.forEach((jsNickName) => {
        if (isSourceFile || !global.moduleExists(jsNickName)) {
          registerWithName(jsNickName, moduleId);
        }
      });
    } else if (registerName.startsWith("./")) {
      const moduleNickNames = [
        registerName.substring(2)
      ];
      moduleNickNames.forEach((moduleNickName) => {
        if (!global.moduleExists(moduleNickName)) {
          registerWithName(moduleNickName, moduleId);
        }
      });
    }
    if (isSourceFile || !global.moduleExists(registerName)) {
      registerWithName(registerName, moduleId);
    }
  };
  context.keys().forEach(registerModuleById);
};
global.moduleExists = function moduleExists(name) {
  return modules.has(name);
};
global.getRegisteredModules = function getRegisteredModules() {
  return Array.from(modules.keys());
};
global.moduleMerge = function(sourceExports, destExports) {
  for (const key in sourceExports) {
    destExports[key] = sourceExports[key];
  }
};
global.zonedCallback = function(callback) {
  if (global.zone) {
    return global.zone.bind(callback);
  }
  if (global.Zone) {
    return global.Zone.current.wrap(callback);
  } else {
    return callback;
  }
};
global.System = {
  import(path2) {
    return new Promise((resolve, reject) => {
      try {
        resolve(global.require(path2));
      } catch (e3) {
        reject(e3);
      }
    });
  }
};
global.Deprecated = function(target, key, descriptor) {
  if (descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
      console.log(`${key.toString()} is deprecated`);
      return originalMethod.apply(this, args);
    };
    return descriptor;
  } else {
    console.log(`${target && target.name || target} is deprecated`);
    return target;
  }
};
global.Experimental = function(target, key, descriptor) {
  if (descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
      console.log(`${key.toString()} is experimental`);
      return originalMethod.apply(this, args);
    };
    return descriptor;
  } else {
    console.log(`${target && target.name || target} is experimental`);
    return target;
  }
};
var modules = new Map;
global.loadModule = function loadModule(name) {
  const moduleInfo = modules.get(name);
  if (moduleInfo) {
    const result = moduleInfo.loader(name);
    if (result?.enableAutoAccept) {
      result.enableAutoAccept();
    }
    return result;
  }
  if (__COMMONJS__) {
    for (const resolver of global.moduleResolvers) {
      const result = resolver(name);
      if (result) {
        modules.set(name, { moduleId: name, loader: () => result });
        return result;
      }
    }
  }
  return null;
};
function registerOnGlobalContext(moduleName, exportName) {
  Object.defineProperty(global, exportName, {
    get: function() {
      const m2 = global.loadModule(moduleName);
      const resolvedValue = m2[exportName];
      Object.defineProperty(global, exportName, {
        value: resolvedValue,
        configurable: true,
        writable: true
      });
      return resolvedValue;
    },
    configurable: true
  });
}
function installPolyfills(moduleName, exportNames) {
  if (global.__snapshot) {
    const loadedModule = global.loadModule(moduleName);
    exportNames.forEach((exportName) => global[exportName] = loadedModule[exportName]);
  } else {
    exportNames.forEach((exportName) => registerOnGlobalContext(moduleName, exportName));
  }
}
if (!global.NativeScriptHasPolyfilled) {
  global.NativeScriptHasPolyfilled = true;
  const glb = global;
  if (__COMMONJS__) {
    global.registerModule("timer", () => exports_index_android);
    installPolyfills("timer", ["setTimeout", "clearTimeout", "setInterval", "clearInterval"]);
    global.registerModule("animation", () => exports_animation_frame);
    installPolyfills("animation", ["requestAnimationFrame", "cancelAnimationFrame"]);
    global.registerModule("media-query-list", () => exports_media_query_list);
    installPolyfills("media-query-list", ["matchMedia", "MediaQueryList"]);
    global.registerModule("text", () => exports_index_android2);
    installPolyfills("text", ["TextDecoder", "TextEncoder"]);
    global.registerModule("xhr", () => exports_xhr);
    installPolyfills("xhr", ["XMLHttpRequest", "FormData", "Blob", "File", "FileReader"]);
    global.registerModule("fetch", () => exports_fetch);
    installPolyfills("fetch", ["fetch", "Headers", "Request", "Response"]);
    global.registerModule("wgc", () => exports_wgc);
    installPolyfills("wgc", ["atob", "btoa"]);
    global.registerModule("crypto", () => exports_crypto);
    installPolyfills("crypto", ["Crypto"]);
    global.registerModule("subtle", () => exports_SubtleCrypto);
    installPolyfills("subtle-crypto", ["Subtle"]);
  } else {
    glb.setTimeout = setTimeout2;
    glb.clearTimeout = clearTimeout2;
    glb.setInterval = setInterval;
    glb.clearInterval = clearInterval;
    glb.requestAnimationFrame = requestAnimationFrame2;
    glb.cancelAnimationFrame = cancelAnimationFrame2;
    glb.matchMedia = matchMedia;
    glb.MediaQueryList = MediaQueryListImpl;
    glb.TextDecoder = TextDecoder2;
    glb.TextEncoder = TextEncoder2;
    glb.XMLHttpRequest = XMLHttpRequest2;
    glb.FormData = FormData2;
    glb.Blob = Blob2;
    glb.File = File2;
    glb.FileReader = FileReader2;
    glb.fetch = fetch;
    glb.Headers = Headers;
    glb.Request = Request;
    glb.Response = Response;
    glb.atob = atob;
    glb.btoa = btoa;
    glb.SubtleCrypto = SubtleCrypto;
  }
  glb.crypto = new Crypto;
}
// node_modules/@nativescript/core/application-settings/index.android.js
var exports_index_android4 = {};
__export(exports_index_android4, {
  setString: () => setString,
  setNumber: () => setNumber,
  setBoolean: () => setBoolean,
  remove: () => remove,
  hasKey: () => hasKey,
  getString: () => getString,
  getNumber: () => getNumber,
  getBoolean: () => getBoolean,
  getAllKeys: () => getAllKeys,
  flush: () => flush,
  clear: () => clear
});

// node_modules/@nativescript/core/application-settings/application-settings-common.js
function checkKey(key) {
  if (typeof key !== "string") {
    console.error("key: '" + key + "' must be a string");
    return false;
  }
  return true;
}
function ensureValidValue(value, valueType) {
  if (typeof value !== valueType) {
    console.error("value: '" + value + "' must be a " + valueType);
    return false;
  }
  return true;
}

// node_modules/@nativescript/core/application-settings/index.android.js
var sharedPreferences;
function ensureSharedPreferences() {
  if (!sharedPreferences) {
    sharedPreferences = getNativeApp().getApplicationContext().getSharedPreferences("prefs.db", 0);
  }
}
function verify(key) {
  if (!checkKey(key)) {
    return false;
  }
  ensureSharedPreferences();
  return true;
}
function hasKey(key) {
  if (!verify(key)) {
    return;
  }
  return sharedPreferences.contains(key);
}
function getBoolean(key, defaultValue) {
  if (!verify(key)) {
    return;
  }
  if (hasKey(key)) {
    return sharedPreferences.getBoolean(key, false);
  }
  return defaultValue;
}
function getString(key, defaultValue) {
  if (!verify(key)) {
    return;
  }
  if (hasKey(key)) {
    return sharedPreferences.getString(key, "");
  }
  return defaultValue;
}
function getNumber(key, defaultValue) {
  if (!verify(key)) {
    return;
  }
  if (hasKey(key)) {
    let val;
    try {
      val = sharedPreferences.getLong(key, long(0));
    } catch (err) {
      const oldVal = sharedPreferences.getFloat(key, float(0));
      setNumber(key, oldVal);
      val = sharedPreferences.getLong(key, long(0));
    }
    return java.lang.Double.longBitsToDouble(val);
  }
  return defaultValue;
}
function setBoolean(key, value) {
  if (!verify(key)) {
    return;
  }
  if (!ensureValidValue(value, "boolean")) {
    return;
  }
  const editor = sharedPreferences.edit();
  editor.putBoolean(key, value);
  editor.apply();
}
function setString(key, value) {
  if (!verify(key)) {
    return;
  }
  if (!ensureValidValue(value, "string")) {
    return;
  }
  const editor = sharedPreferences.edit();
  editor.putString(key, value);
  editor.apply();
}
function setNumber(key, value) {
  if (!verify(key)) {
    return;
  }
  if (!ensureValidValue(value, "number")) {
    return;
  }
  const editor = sharedPreferences.edit();
  editor.putLong(key, java.lang.Double.doubleToRawLongBits(double(value)));
  editor.apply();
}
function remove(key) {
  if (!verify(key)) {
    return;
  }
  const editor = sharedPreferences.edit();
  editor.remove(key);
  editor.apply();
}
function clear() {
  ensureSharedPreferences();
  sharedPreferences.edit().clear().apply();
}
function flush() {
  ensureSharedPreferences();
  return sharedPreferences.edit().commit();
}
function getAllKeys() {
  ensureSharedPreferences();
  const mappedPreferences = sharedPreferences.getAll();
  const iterator = mappedPreferences.keySet().iterator();
  const result = [];
  while (iterator.hasNext()) {
    const key = iterator.next();
    result.push(key);
  }
  return result;
}
// node_modules/@nativescript/core/connectivity/index.android.js
var connectionType;
(function(connectionType2) {
  connectionType2[connectionType2["none"] = 0] = "none";
  connectionType2[connectionType2["wifi"] = 1] = "wifi";
  connectionType2[connectionType2["mobile"] = 2] = "mobile";
  connectionType2[connectionType2["ethernet"] = 3] = "ethernet";
  connectionType2[connectionType2["bluetooth"] = 4] = "bluetooth";
  connectionType2[connectionType2["vpn"] = 5] = "vpn";
})(connectionType || (connectionType = {}));
// node_modules/@nativescript/core/data/observable-array/index.js
class ChangeType {
}
ChangeType.Add = "add";
ChangeType.Delete = "delete";
ChangeType.Update = "update";
ChangeType.Splice = "splice";
ChangeType.Change = "change";
var CHANGE = "change";

class ObservableArray extends Observable {
  constructor(_args) {
    super();
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      this._array = arguments[0].slice();
    } else {
      this._array = Array.apply(null, arguments);
    }
    this._addArgs = {
      eventName: CHANGE,
      object: this,
      action: ChangeType.Add,
      index: null,
      removed: [],
      addedCount: 1
    };
    this._deleteArgs = {
      eventName: CHANGE,
      object: this,
      action: ChangeType.Delete,
      index: null,
      removed: null,
      addedCount: 0
    };
  }
  *[Symbol.iterator]() {
    for (const item of this._array) {
      yield item;
    }
  }
  getItem(pos) {
    const index = pos < 0 ? this._array.length + pos : pos;
    return this._array[index];
  }
  setItem(pos, value) {
    const index = pos < 0 ? this._array.length + pos : pos;
    const oldValue = this._array[index];
    this._array[index] = value;
    this.notify({
      eventName: CHANGE,
      object: this,
      action: ChangeType.Update,
      index,
      removed: [oldValue],
      addedCount: 1
    });
  }
  get length() {
    return this._array.length;
  }
  set length(value) {
    if (isNumber(value) && this._array && this._array.length !== value) {
      const added = new Array(value > this._array.length ? value - this._array.length : 0);
      this.splice(value, this._array.length - value, ...added);
    }
  }
  toJSON() {
    return this._array;
  }
  toString() {
    return this._array.toString();
  }
  toLocaleString() {
    return this._array.toLocaleString();
  }
  concat(...args) {
    this._addArgs.index = this._array.length;
    const result = this._array.concat(...args);
    return new ObservableArray(result);
  }
  join(separator) {
    return this._array.join(separator);
  }
  pop() {
    this._deleteArgs.index = this._array.length - 1;
    const result = this._array.pop();
    this._deleteArgs.removed = [result];
    this.notify(this._deleteArgs);
    this._notifyLengthChange();
    return result;
  }
  push(...args) {
    const length = this._array.length;
    const result = this._array.push(...args);
    this._addArgs.index = length;
    this._addArgs.addedCount = result - length;
    this.notify(this._addArgs);
    this._notifyLengthChange();
    return this._array.length;
  }
  _notifyLengthChange() {
    const lengthChangedData = this._createPropertyChangeData("length", this._array.length);
    this.notify(lengthChangedData);
  }
  reverse() {
    this._array.reverse();
    return this;
  }
  shift() {
    const result = this._array.shift();
    this._deleteArgs.index = 0;
    this._deleteArgs.removed = [result];
    this.notify(this._deleteArgs);
    this._notifyLengthChange();
    return result;
  }
  slice(start2, end) {
    const result = this._array.slice(start2, end);
    return new ObservableArray(result);
  }
  sort(compareFn) {
    this._array.sort(compareFn);
    return this;
  }
  splice(start2, deleteCount, ...items) {
    const length = this._array.length;
    const result = arguments.length === 1 ? this._array.splice(start2) : this._array.splice(start2, deleteCount, ...items);
    this.notify({
      eventName: CHANGE,
      object: this,
      action: ChangeType.Splice,
      index: Math.max(Math.min(start2, length - (result.length > 0 ? 1 : 0)), 0),
      removed: result,
      addedCount: this._array.length + result.length - length
    });
    if (this._array.length !== length) {
      this._notifyLengthChange();
    }
    return new ObservableArray(result);
  }
  unshift(...args) {
    const length = this._array.length;
    const result = this._array.unshift(...args);
    this._addArgs.index = 0;
    this._addArgs.addedCount = result - length;
    this.notify(this._addArgs);
    this._notifyLengthChange();
    return result;
  }
  find(callbackfn, thisArg) {
    return this._array.find((value, index, array) => callbackfn(value, index, this), thisArg);
  }
  findIndex(callbackfn, thisArg) {
    return this._array.findIndex((value, index, array) => callbackfn(value, index, this), thisArg);
  }
  includes(searchElement, fromIndex) {
    return this._array.includes(searchElement, fromIndex);
  }
  indexOf(searchElement, fromIndex) {
    return this._array.indexOf(searchElement, fromIndex);
  }
  lastIndexOf(searchElement, fromIndex) {
    return fromIndex !== undefined ? this._array.lastIndexOf(searchElement, fromIndex) : this._array.lastIndexOf(searchElement);
  }
  every(callbackfn, thisArg) {
    return this._array.every((value, index, array) => callbackfn(value, index, this), thisArg);
  }
  some(callbackfn, thisArg) {
    return this._array.some((value, index, array) => callbackfn(value, index, this), thisArg);
  }
  forEach(callbackfn, thisArg) {
    this._array.forEach((value, index, array) => callbackfn(value, index, this), thisArg);
  }
  map(callbackfn, thisArg) {
    const result = this._array.map((value, index, array) => callbackfn(value, index, this), thisArg);
    return new ObservableArray(result);
  }
  filter(callbackfn, thisArg) {
    const result = this._array.filter((value, index, array) => callbackfn(value, index, this), thisArg);
    return new ObservableArray(result);
  }
  reduce(callbackfn, initialValue) {
    const callbackWrapper = (previousValue, currentValue, currentIndex, array) => callbackfn(previousValue, currentValue, currentIndex, this);
    return initialValue !== undefined ? this._array.reduce(callbackWrapper, initialValue) : this._array.reduce(callbackWrapper);
  }
  reduceRight(callbackfn, initialValue) {
    const callbackWrapper = (previousValue, currentValue, currentIndex, array) => callbackfn(previousValue, currentValue, currentIndex, this);
    return initialValue !== undefined ? this._array.reduceRight(callbackWrapper, initialValue) : this._array.reduceRight(callbackWrapper);
  }
}
ObservableArray.changeEvent = CHANGE;
// node_modules/@nativescript/core/data/virtual-array/index.js
class VirtualArray extends Observable {
  constructor(length = 0) {
    super();
    this._length = length;
    this._cache = {};
    this._requestedIndexes = [];
    this._loadedIndexes = [];
  }
  get length() {
    return this._length;
  }
  set length(value) {
    if (this._length !== value) {
      const index = this._length;
      const count = value - this._length;
      this._length = value;
      this.notify({
        eventName: ChangeType.Change,
        object: this,
        action: count > 0 ? ChangeType.Add : ChangeType.Delete,
        index,
        removed: new Array(count < 0 ? Math.abs(count) : 0),
        addedCount: count > 0 ? count : 0
      });
    }
  }
  get loadSize() {
    return this._loadSize;
  }
  set loadSize(value) {
    this._loadSize = value;
  }
  getItem(index) {
    const item = this._cache[index];
    if (item === undefined) {
      if (index >= 0 && index < this.length && this._requestedIndexes.indexOf(index) < 0 && this._loadedIndexes.indexOf(index) < 0) {
        this.requestItems(index);
      }
    }
    return item;
  }
  setItem(index, value) {
    if (this._cache[index] !== value) {
      this.load(index, [value]);
    }
  }
  load(index, items) {
    for (let i4 = 0;i4 < items.length; i4++) {
      const itemIndex = index + i4;
      this._cache[itemIndex] = items[i4];
      this._requestedIndexes.splice(this._requestedIndexes.indexOf(itemIndex), 1);
      if (this._loadedIndexes.indexOf(itemIndex) < 0) {
        this._loadedIndexes.push(itemIndex);
      }
    }
    if (this._requestedIndexes.length > 0) {
      for (let i4 = 0;i4 < this.loadSize - items.length; i4++) {
        this._requestedIndexes.splice(this._requestedIndexes.indexOf(index + i4), 1);
      }
    }
    this.notify({
      eventName: ChangeType.Change,
      object: this,
      action: ChangeType.Update,
      index,
      removed: new Array(items.length),
      addedCount: items.length
    });
  }
  requestItems(index) {
    const indexesToLoad = [];
    const pageIndex = this._loadSize > 0 ? this._loadSize * Math.floor(index / this._loadSize) : index;
    let count = 0;
    let start2 = -1;
    for (let i4 = 0;i4 < this.loadSize; i4++) {
      const itemIndex = pageIndex + i4;
      if (itemIndex >= this._length) {
        break;
      }
      if (this._loadedIndexes.indexOf(itemIndex) < 0) {
        if (start2 < 0) {
          start2 = itemIndex;
        }
        indexesToLoad.push(itemIndex);
        if (this._requestedIndexes.indexOf(itemIndex) < 0) {
          this._requestedIndexes.push(itemIndex);
        }
        count++;
      } else {
        if (count > 0) {
          this.notify({
            eventName: VirtualArray.itemsLoadingEvent,
            object: this,
            index: start2,
            count
          });
        }
        start2 = -1;
        count = 0;
      }
    }
    if (start2 >= 0 && count > 0) {
      this.notify({
        eventName: VirtualArray.itemsLoadingEvent,
        object: this,
        index: start2,
        count
      });
    }
  }
}
VirtualArray.changeEvent = ChangeType.Change;
VirtualArray.itemsLoadingEvent = "itemsLoading";
// node_modules/@nativescript/core/image-asset/image-asset-common.js
class ImageAssetBase extends Observable {
  constructor() {
    super();
    this._options = { keepAspectRatio: true, autoScaleFactor: true };
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = normalizeImageAssetOptions(value);
  }
  get nativeImage() {
    return this._nativeImage;
  }
  set nativeImage(value) {
    this._nativeImage = value;
  }
  getImageAsync(callback) {}
}
function toPositiveInt(value) {
  if (value == null) {
    return 0;
  }
  if (typeof value === "number") {
    return value > 0 ? Math.floor(value) : 0;
  }
  if (typeof value === "string") {
    const parsed = parseInt(value, 10);
    return isNaN(parsed) || parsed <= 0 ? 0 : parsed;
  }
  return 0;
}
function normalizeImageAssetOptions(options) {
  const normalized = options ? { ...options } : {};
  normalized.width = toPositiveInt(options?.width);
  normalized.height = toPositiveInt(options?.height);
  if (typeof normalized.keepAspectRatio !== "boolean") {
    normalized.keepAspectRatio = true;
  }
  if (typeof normalized.autoScaleFactor !== "boolean") {
    normalized.autoScaleFactor = true;
  }
  return normalized;
}

// node_modules/@nativescript/core/image-asset/index.android.js
class ImageAsset extends ImageAssetBase {
  constructor(asset) {
    super();
    let fileName = typeof asset === "string" ? asset.trim() : "";
    if (fileName.indexOf("~/") === 0) {
      fileName = path.join(knownFolders.currentApp().path, fileName.replace("~/", ""));
    }
    this.android = fileName;
  }
  get android() {
    return this._android;
  }
  set android(value) {
    this._android = value;
  }
  getImageAsync(callback) {
    org.nativescript.widgets.Utils.loadImageAsync(getNativeApp().getApplicationContext(), this.android, JSON.stringify(this.options || {}), Screen.mainScreen.widthPixels, Screen.mainScreen.heightPixels, new org.nativescript.widgets.Utils.AsyncImageCallback({
      onSuccess(bitmap) {
        callback(bitmap, null);
      },
      onError(ex) {
        callback(null, ex);
      }
    }));
  }
}
// node_modules/@nativescript/core/ui/styling/style/index.js
class Style extends Observable {
  constructor(ownerView) {
    super();
    this.unscopedCssVariables = new Map;
    this.scopedCssVariables = new Map;
    if (ownerView.constructor.toString().indexOf("[native code]") !== -1 || ownerView.toString() == "[object WeakRef]") {
      this.viewRef = ownerView;
    } else {
      this.viewRef = new WeakRef(ownerView);
    }
  }
  setScopedCssVariable(varName, value) {
    this.scopedCssVariables.set(varName, value);
  }
  setUnscopedCssVariable(varName, value) {
    this.unscopedCssVariables.set(varName, value);
  }
  removeScopedCssVariable(varName) {
    this.scopedCssVariables.delete(varName);
  }
  removeUnscopedCssVariable(varName) {
    this.unscopedCssVariables.delete(varName);
  }
  getCssVariable(varName) {
    const view = this.view;
    if (!view) {
      return null;
    }
    if (this.unscopedCssVariables.has(varName)) {
      return this.unscopedCssVariables.get(varName);
    }
    if (this.scopedCssVariables.has(varName)) {
      return this.scopedCssVariables.get(varName);
    }
    if (!view.parent || !view.parent.style) {
      return null;
    }
    return view.parent.style.getCssVariable(varName);
  }
  resetScopedCssVariables() {
    this.scopedCssVariables.clear();
  }
  resetUnscopedCssVariables() {
    this.unscopedCssVariables.clear();
  }
  toString() {
    const view = this.viewRef.get();
    if (!view) {
      Trace.write(`toString() of Style cannot execute correctly because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
      return "";
    }
    return `${view}.style`;
  }
  get view() {
    if (this.viewRef) {
      return this.viewRef.get();
    }
    return;
  }
}
Style.prototype.PropertyBag = class {
};

// node_modules/@nativescript/core/ui/styling/linear-gradient.js
class LinearGradient {
  static parse(value) {
    const result = new LinearGradient;
    result.angle = value.angle;
    result.colorStops = value.colors.map((color2) => {
      const offset2 = color2.offset || null;
      let offsetUnit;
      if (offset2 && offset2.unit === "%") {
        offsetUnit = {
          unit: "%",
          value: offset2.value
        };
      }
      return {
        color: color2.color,
        offset: offsetUnit
      };
    });
    return result;
  }
  static equals(first, second) {
    if (!first && !second) {
      return true;
    } else if (!first || !second) {
      return false;
    }
    if (first.angle !== second.angle) {
      return false;
    }
    if (first.colorStops.length !== second.colorStops.length) {
      return false;
    }
    for (let i4 = 0;i4 < first.colorStops.length; i4++) {
      const firstStop = first.colorStops[i4];
      const secondStop = second.colorStops[i4];
      if (firstStop.offset !== secondStop.offset) {
        return false;
      }
      if (!Color.equals(firstStop.color, secondStop.color)) {
        return false;
      }
    }
    return true;
  }
}

// node_modules/@nativescript/core/ui/styling/clip-path-function.js
class ClipPathFunction {
  constructor(shape, rule) {
    this._shape = shape;
    this._rule = rule;
  }
  get shape() {
    return this._shape;
  }
  get rule() {
    return this._rule;
  }
  static equals(value1, value2) {
    return value1.shape === value2.shape && value1.rule === value2.rule;
  }
  toJSON() {
    return {
      shape: this._shape,
      rule: this._rule
    };
  }
  toString() {
    return `${this._shape}(${this._rule})`;
  }
}

// node_modules/@nativescript/core/css-value/reworkcss-value.js
function parse5(str) {
  return new Parser3(str).parse();
}

class Parser3 {
  constructor(str) {
    this.str = str;
  }
  skip(match) {
    this.str = this.str.slice(match[0].length);
  }
  comma() {
    const m2 = /^, */.exec(this.str);
    if (!m2)
      return;
    this.skip(m2);
    return { type: "comma", string: "," };
  }
  ident() {
    const m2 = /^([\w-]+) */.exec(this.str);
    if (!m2)
      return;
    this.skip(m2);
    return { type: "ident", string: m2[1] };
  }
  int() {
    const m2 = /^(([-+]?\d+)(\S+)?) */.exec(this.str);
    if (!m2)
      return;
    this.skip(m2);
    const n3 = parseInt(m2[2], 10);
    const u3 = m2[3] || "";
    return { type: "number", string: m2[1], unit: u3, value: n3 };
  }
  float() {
    const m2 = /^(((?:[-+]?\d+)?\.\d+)(\S+)?) */.exec(this.str);
    if (!m2)
      return;
    this.skip(m2);
    const n3 = parseFloat(m2[2]);
    const u3 = m2[3] || "";
    return { type: "number", string: m2[1], unit: u3, value: n3 };
  }
  number() {
    return this.float() || this.int();
  }
  double() {
    const m2 = /^"([^"]*)" */.exec(this.str);
    if (!m2)
      return;
    this.skip(m2);
    return { type: "string", quote: '"', string: `"${m2[1]}"`, value: m2[1] };
  }
  single() {
    const m2 = /^'([^']*)' */.exec(this.str);
    if (!m2)
      return;
    this.skip(m2);
    return { type: "string", quote: "'", string: `'${m2[1]}'`, value: m2[1] };
  }
  string() {
    return this.single() || this.double();
  }
  value() {
    return this.number() || this.ident() || this.string() || this.comma();
  }
  parse() {
    const vals = [];
    while (this.str.length > 0) {
      const obj = this.value();
      if (!obj) {
        throw new Error(`failed to parse near \`${this.str.slice(0, 10)}...\``);
      }
      vals.push(obj);
    }
    return vals;
  }
}

// node_modules/@nativescript/core/ui/styling/background-common.js
class Background {
  constructor() {
    this.borderTopWidth = 0;
    this.borderRightWidth = 0;
    this.borderBottomWidth = 0;
    this.borderLeftWidth = 0;
    this.borderTopLeftRadius = 0;
    this.borderTopRightRadius = 0;
    this.borderBottomLeftRadius = 0;
    this.borderBottomRightRadius = 0;
    this.clearFlags = 0;
  }
  clone() {
    const clone = new Background;
    clone.color = this.color;
    clone.image = this.image;
    clone.repeat = this.repeat;
    clone.position = this.position;
    clone.size = this.size;
    clone.borderTopColor = this.borderTopColor;
    clone.borderRightColor = this.borderRightColor;
    clone.borderBottomColor = this.borderBottomColor;
    clone.borderLeftColor = this.borderLeftColor;
    clone.borderTopWidth = this.borderTopWidth;
    clone.borderRightWidth = this.borderRightWidth;
    clone.borderBottomWidth = this.borderBottomWidth;
    clone.borderLeftWidth = this.borderLeftWidth;
    clone.borderTopLeftRadius = this.borderTopLeftRadius;
    clone.borderTopRightRadius = this.borderTopRightRadius;
    clone.borderBottomRightRadius = this.borderBottomRightRadius;
    clone.borderBottomLeftRadius = this.borderBottomLeftRadius;
    clone.clipPath = this.clipPath;
    clone.boxShadows = this.boxShadows;
    clone.clearFlags = this.clearFlags;
    return clone;
  }
  withColor(value) {
    const clone = this.clone();
    clone.color = value;
    if (!value) {
      clone.clearFlags |= 1;
    }
    return clone;
  }
  withImage(value) {
    const clone = this.clone();
    clone.image = value;
    return clone;
  }
  withRepeat(value) {
    const clone = this.clone();
    clone.repeat = value;
    return clone;
  }
  withPosition(value) {
    const clone = this.clone();
    clone.position = value;
    return clone;
  }
  withSize(value) {
    const clone = this.clone();
    clone.size = value;
    return clone;
  }
  withBorderTopColor(value) {
    const clone = this.clone();
    clone.borderTopColor = value;
    return clone;
  }
  withBorderRightColor(value) {
    const clone = this.clone();
    clone.borderRightColor = value;
    return clone;
  }
  withBorderBottomColor(value) {
    const clone = this.clone();
    clone.borderBottomColor = value;
    return clone;
  }
  withBorderLeftColor(value) {
    const clone = this.clone();
    clone.borderLeftColor = value;
    return clone;
  }
  withBorderTopWidth(value) {
    const clone = this.clone();
    clone.borderTopWidth = value;
    return clone;
  }
  withBorderRightWidth(value) {
    const clone = this.clone();
    clone.borderRightWidth = value;
    return clone;
  }
  withBorderBottomWidth(value) {
    const clone = this.clone();
    clone.borderBottomWidth = value;
    return clone;
  }
  withBorderLeftWidth(value) {
    const clone = this.clone();
    clone.borderLeftWidth = value;
    return clone;
  }
  withBorderTopLeftRadius(value) {
    const clone = this.clone();
    clone.borderTopLeftRadius = value;
    return clone;
  }
  withBorderTopRightRadius(value) {
    const clone = this.clone();
    clone.borderTopRightRadius = value;
    return clone;
  }
  withBorderBottomRightRadius(value) {
    const clone = this.clone();
    clone.borderBottomRightRadius = value;
    return clone;
  }
  withBorderBottomLeftRadius(value) {
    const clone = this.clone();
    clone.borderBottomLeftRadius = value;
    return clone;
  }
  withClipPath(value) {
    const clone = this.clone();
    clone.clipPath = value;
    return clone;
  }
  withBoxShadows(value) {
    const clone = this.clone();
    clone.boxShadows = value;
    if (!value?.length) {
      clone.clearFlags |= 2;
    }
    return clone;
  }
  isEmpty() {
    return !this.color && !this.image && !this.hasBorderWidth() && !this.hasBorderRadius() && !this.clipPath;
  }
  static equals(value1, value2) {
    if (!value1 && !value2) {
      return true;
    }
    if (!value1 || !value2) {
      return false;
    }
    let isImageEqual = false;
    if (value1 instanceof LinearGradient && value2 instanceof LinearGradient) {
      isImageEqual = LinearGradient.equals(value1, value2);
    } else {
      isImageEqual = value1.image === value2.image;
    }
    let isClipPathEqual = false;
    if (value1.clipPath instanceof ClipPathFunction && value2.clipPath instanceof ClipPathFunction) {
      isClipPathEqual = ClipPathFunction.equals(value1.clipPath, value2.clipPath);
    } else {
      isClipPathEqual = value1.clipPath === value2.clipPath;
    }
    return Color.equals(value1.color, value2.color) && isImageEqual && value1.position === value2.position && value1.repeat === value2.repeat && value1.size === value2.size && Color.equals(value1.borderTopColor, value2.borderTopColor) && Color.equals(value1.borderRightColor, value2.borderRightColor) && Color.equals(value1.borderBottomColor, value2.borderBottomColor) && Color.equals(value1.borderLeftColor, value2.borderLeftColor) && value1.borderTopWidth === value2.borderTopWidth && value1.borderRightWidth === value2.borderRightWidth && value1.borderBottomWidth === value2.borderBottomWidth && value1.borderLeftWidth === value2.borderLeftWidth && value1.borderTopLeftRadius === value2.borderTopLeftRadius && value1.borderTopRightRadius === value2.borderTopRightRadius && value1.borderBottomRightRadius === value2.borderBottomRightRadius && value1.borderBottomLeftRadius === value2.borderBottomLeftRadius && isClipPathEqual;
  }
  hasBorderColor() {
    return !!this.borderTopColor || !!this.borderRightColor || !!this.borderBottomColor || !!this.borderLeftColor;
  }
  hasBorderWidth() {
    return this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0;
  }
  hasBorderRadius() {
    return this.borderTopLeftRadius > 0 || this.borderTopRightRadius > 0 || this.borderBottomRightRadius > 0 || this.borderBottomLeftRadius > 0;
  }
  hasBorder() {
    return this.hasBorderColor() && this.hasBorderWidth() || this.hasBorderRadius();
  }
  hasUniformBorderColor() {
    return Color.equals(this.borderTopColor, this.borderRightColor) && Color.equals(this.borderTopColor, this.borderBottomColor) && Color.equals(this.borderTopColor, this.borderLeftColor);
  }
  hasUniformBorderWidth() {
    return this.borderTopWidth === this.borderRightWidth && this.borderTopWidth === this.borderBottomWidth && this.borderTopWidth === this.borderLeftWidth;
  }
  hasUniformBorderRadius() {
    return this.borderTopLeftRadius === this.borderTopRightRadius && this.borderTopLeftRadius === this.borderBottomRightRadius && this.borderTopLeftRadius === this.borderBottomLeftRadius;
  }
  hasUniformBorder() {
    return this.hasUniformBorderColor() && this.hasUniformBorderWidth() && this.hasUniformBorderRadius();
  }
  getUniformBorderColor() {
    if (this.hasUniformBorderColor()) {
      return this.borderTopColor;
    }
    return;
  }
  getUniformBorderWidth() {
    if (this.hasUniformBorderWidth()) {
      return this.borderTopWidth;
    }
    return 0;
  }
  getUniformBorderRadius() {
    if (this.hasUniformBorderRadius()) {
      return this.borderTopLeftRadius;
    }
    return 0;
  }
  hasBoxShadows() {
    return this.boxShadows?.length > 0;
  }
  getBoxShadows() {
    return this.boxShadows;
  }
  toString() {
    return `isEmpty: ${this.isEmpty()}; color: ${this.color}; image: ${this.image}; repeat: ${this.repeat}; position: ${this.position}; size: ${this.size}; borderTopColor: ${this.borderTopColor}; borderRightColor: ${this.borderRightColor}; borderBottomColor: ${this.borderBottomColor}; borderLeftColor: ${this.borderLeftColor}; borderTopWidth: ${this.borderTopWidth}; borderRightWidth: ${this.borderRightWidth}; borderBottomWidth: ${this.borderBottomWidth}; borderLeftWidth: ${this.borderLeftWidth}; borderTopLeftRadius: ${this.borderTopLeftRadius}; borderTopRightRadius: ${this.borderTopRightRadius}; borderBottomRightRadius: ${this.borderBottomRightRadius}; borderBottomLeftRadius: ${this.borderBottomLeftRadius}; clipPath: ${this.clipPath};`;
  }
}
Background.default = new Background;

// node_modules/@nativescript/core/ui/styling/background.android.js
function fromBase64(source) {
  const bytes = android.util.Base64.decode(source, android.util.Base64.DEFAULT);
  return android.graphics.BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
}
function fromGradient(gradient) {
  const colors = Array.create("int", gradient.colorStops.length);
  const stops = Array.create("float", gradient.colorStops.length);
  let hasStops = false;
  gradient.colorStops.forEach((stop2, index) => {
    colors[index] = stop2.color.android;
    if (stop2.offset) {
      stops[index] = stop2.offset.value;
      hasStops = true;
    }
  });
  const alpha2 = gradient.angle / (Math.PI * 2);
  const startX = Math.pow(Math.sin(Math.PI * (alpha2 + 0.75)), 2);
  const startY = Math.pow(Math.sin(Math.PI * (alpha2 + 0.5)), 2);
  const endX = Math.pow(Math.sin(Math.PI * (alpha2 + 0.25)), 2);
  const endY = Math.pow(Math.sin(Math.PI * alpha2), 2);
  return new org.nativescript.widgets.LinearGradientDefinition(startX, startY, endX, endY, colors, hasStops ? stops : null);
}
var pattern = /url\(('|")(.*?)\1\)/;
function refreshBorderDrawable(view, borderDrawable) {
  const nativeView = view.nativeViewProtected;
  const context = nativeView.getContext();
  const background = view.style.backgroundInternal;
  if (background) {
    const backgroundPositionParsedCSSValues = createNativeCSSValueArray(background.position);
    const backgroundSizeParsedCSSValues = createNativeCSSValueArray(background.size);
    const blackColor = -16777216;
    let imageUri;
    if (background.image && typeof background.image === "string" && background.image !== "none") {
      imageUri = background.image;
      const match = imageUri.match(pattern);
      if (match && match[2]) {
        imageUri = match[2];
      }
    }
    let bitmap = null;
    if (isDataURI(imageUri)) {
      const base64Data = imageUri.split(",")[1];
      if (base64Data !== undefined) {
        bitmap = fromBase64(base64Data);
        imageUri = null;
      }
    } else if (isFileOrResourcePath(imageUri)) {
      if (imageUri.indexOf(RESOURCE_PREFIX) !== 0) {
        let fileName = imageUri;
        if (fileName.indexOf("~/") === 0) {
          fileName = path.join(knownFolders.currentApp().path, fileName.replace("~/", ""));
        }
        imageUri = FILE_PREFIX + fileName;
      }
    }
    let gradient = null;
    if (background.image && background.image instanceof LinearGradient) {
      gradient = fromGradient(background.image);
    }
    borderDrawable.refresh(background.borderTopColor ? background.borderTopColor.android : blackColor, background.borderRightColor ? background.borderRightColor.android : blackColor, background.borderBottomColor ? background.borderBottomColor.android : blackColor, background.borderLeftColor ? background.borderLeftColor.android : blackColor, background.borderTopWidth, background.borderRightWidth, background.borderBottomWidth, background.borderLeftWidth, background.borderTopLeftRadius, background.borderTopRightRadius, background.borderBottomRightRadius, background.borderBottomLeftRadius, background.clipPath instanceof ClipPathFunction ? background.clipPath.toString() : background.clipPath, background.color ? background.color.android : 0, imageUri, bitmap, gradient, context, background.repeat, background.position, backgroundPositionParsedCSSValues, background.size, backgroundSizeParsedCSSValues);
  }
}
function createNativeCSSValueArray(css) {
  if (!css) {
    return null;
  }
  const cssValues = parse5(css);
  const nativeArray = Array.create(org.nativescript.widgets.CSSValue, cssValues.length);
  for (let i4 = 0, length = cssValues.length;i4 < length; i4++) {
    nativeArray[i4] = new org.nativescript.widgets.CSSValue(cssValues[i4].type, cssValues[i4].string, cssValues[i4].unit, cssValues[i4].value);
  }
  return nativeArray;
}

// node_modules/@nativescript/core/css/parser.js
var urlRegEx = /\s*url\((?:(['"])(.*?)\1|([^)]*))\)\s*/gy;
function parseURL(text, start2 = 0) {
  urlRegEx.lastIndex = start2;
  const result = urlRegEx.exec(text);
  if (!result) {
    return null;
  }
  const end = urlRegEx.lastIndex;
  const value = result[2] || result[3];
  return { start: start2, end, value };
}
var hexColorRegEx = /\s*#((?:[0-9A-F]{8})|(?:[0-9A-F]{6})|(?:[0-9A-F]{4})|(?:[0-9A-F]{3}))\s*/giy;
function parseHexColor(text, start2 = 0) {
  hexColorRegEx.lastIndex = start2;
  const result = hexColorRegEx.exec(text);
  if (!result) {
    return null;
  }
  const end = hexColorRegEx.lastIndex;
  return { start: start2, end, value: new Color("#" + result[1]) };
}
var cssColorRegEx = /\s*((?:rgb|rgba|hsl|hsla|hsv|hsva)\([^\(\)]*\))/gy;
function parseCssColor(text, start2 = 0) {
  cssColorRegEx.lastIndex = start2;
  const result = cssColorRegEx.exec(text);
  if (!result) {
    return null;
  }
  const end = cssColorRegEx.lastIndex;
  try {
    return { start: start2, end, value: new Color(result[1]) };
  } catch {
    return null;
  }
}
function parseColorKeyword(value, start2, keyword = parseKeyword(value, start2)) {
  const parseColor = keyword && getKnownColor(keyword.value);
  if (parseColor != null) {
    const end = keyword.end;
    return { start: start2, end, value: new Color(parseColor) };
  }
  return null;
}
function parseColor(value, start2 = 0, keyword = parseKeyword(value, start2)) {
  return parseHexColor(value, start2) || parseColorKeyword(value, start2, keyword) || parseCssColor(value, start2);
}
var keywordRegEx = /\s*([a-z][\w\-]*)\s*/giy;
function parseKeyword(text, start2 = 0) {
  keywordRegEx.lastIndex = start2;
  const result = keywordRegEx.exec(text);
  if (!result) {
    return null;
  }
  const end = keywordRegEx.lastIndex;
  const value = result[1];
  return { start: start2, end, value };
}
var backgroundRepeatKeywords = new Set(["repeat", "repeat-x", "repeat-y", "no-repeat"]);
function parseRepeat(value, start2 = 0, keyword = parseKeyword(value, start2)) {
  if (keyword && backgroundRepeatKeywords.has(keyword.value)) {
    const end = keyword.end;
    const value2 = keyword.value;
    return { start: start2, end, value: value2 };
  }
  return null;
}
var unitRegEx = /\s*([+\-]?(?:\d+\.\d+|\d+|\.\d+)(?:[eE][+\-]?\d+)?)([a-zA-Z]+|%)?\s*/gy;
function parseUnit(text, start2 = 0) {
  unitRegEx.lastIndex = start2;
  const result = unitRegEx.exec(text);
  if (!result) {
    return null;
  }
  const end = unitRegEx.lastIndex;
  const value = parseFloat(result[1]);
  const unit = result[2] || "dip";
  return { start: start2, end, value: { value, unit } };
}
function parsePercentageOrLength(text, start2 = 0) {
  const unitResult = parseUnit(text, start2);
  if (unitResult) {
    const { start: start3, end } = unitResult;
    const value = unitResult.value;
    if (value.unit === "%") {
      value.value /= 100;
    } else if (!value.unit) {
      value.unit = "dip";
    } else if (value.unit === "px" || value.unit === "dip") {} else {
      return null;
    }
    return { start: start3, end, value };
  }
  return null;
}
var angleUnitsToRadMap = {
  deg: (start2, end, deg) => ({
    start: start2,
    end,
    value: deg / 180 * Math.PI
  }),
  rad: (start2, end, rad) => ({
    start: start2,
    end,
    value: rad
  }),
  grad: (start2, end, grad) => ({
    start: start2,
    end,
    value: grad / 200 * Math.PI
  }),
  turn: (start2, end, turn) => ({
    start: start2,
    end,
    value: turn * Math.PI * 2
  })
};
function parseAngle(value, start2 = 0) {
  const angleResult = parseUnit(value, start2);
  if (angleResult) {
    const { start: start3, end, value: value2 } = angleResult;
    return (angleUnitsToRadMap[value2.unit] || ((_3, __, ___) => null))(start3, end, value2.value);
  }
  return null;
}
var backgroundSizeKeywords = new Set(["auto", "contain", "cover"]);
function parseBackgroundSize(value, start2 = 0, keyword = parseKeyword(value, start2)) {
  let end = start2;
  if (keyword && backgroundSizeKeywords.has(keyword.value)) {
    end = keyword.end;
    const value2 = keyword.value;
    return { start: start2, end, value: value2 };
  }
  const firstLength = parsePercentageOrLength(value, end);
  if (firstLength) {
    end = firstLength.end;
    const secondLength = parsePercentageOrLength(value, firstLength.end);
    if (secondLength) {
      end = secondLength.end;
      return {
        start: start2,
        end,
        value: { x: firstLength.value, y: secondLength.value }
      };
    } else {
      return { start: start2, end, value: { x: firstLength.value, y: "auto" } };
    }
  }
  return null;
}
var backgroundPositionKeywords = Object.freeze(new Set(["left", "right", "top", "bottom", "center"]));
var backgroundPositionKeywordsDirection = {
  left: "x",
  right: "x",
  center: "center",
  top: "y",
  bottom: "y"
};
function parseBackgroundPosition(text, start2 = 0, keyword = parseKeyword(text, start2)) {
  function formatH(align, offset2) {
    if (align.value === "center") {
      return "center";
    }
    if (offset2 && offset2.value.value !== 0) {
      return { align: align.value, offset: offset2.value };
    }
    return align.value;
  }
  function formatV(align, offset2) {
    if (align.value === "center") {
      return "center";
    }
    if (offset2 && offset2.value.value !== 0) {
      return { align: align.value, offset: offset2.value };
    }
    return align.value;
  }
  let end = start2;
  if (keyword && backgroundPositionKeywords.has(keyword.value)) {
    end = keyword.end;
    const firstDirection = backgroundPositionKeywordsDirection[keyword.value];
    const firstLength = firstDirection !== "center" && parsePercentageOrLength(text, end);
    if (firstLength) {
      end = firstLength.end;
    }
    const secondKeyword = parseKeyword(text, end);
    if (secondKeyword && backgroundPositionKeywords.has(secondKeyword.value)) {
      end = secondKeyword.end;
      const secondDirection = backgroundPositionKeywordsDirection[secondKeyword.end];
      if (firstDirection === secondDirection && firstDirection !== "center") {
        return null;
      }
      const secondLength = secondDirection !== "center" && parsePercentageOrLength(text, end);
      if (secondLength) {
        end = secondLength.end;
      }
      if (firstDirection === secondDirection && secondDirection === "center" || firstDirection === "x" || secondDirection === "y") {
        return {
          start: start2,
          end,
          value: {
            x: formatH(keyword, firstLength),
            y: formatV(secondKeyword, secondLength)
          }
        };
      } else {
        return {
          start: start2,
          end,
          value: {
            x: formatH(secondKeyword, secondLength),
            y: formatV(keyword, firstLength)
          }
        };
      }
    } else {
      if (firstDirection === "center") {
        return { start: start2, end, value: { x: "center", y: "center" } };
      } else if (firstDirection === "x") {
        return {
          start: start2,
          end,
          value: {
            x: formatH(keyword, firstLength),
            y: "center"
          }
        };
      } else {
        return {
          start: start2,
          end,
          value: {
            x: "center",
            y: formatV(keyword, firstLength)
          }
        };
      }
    }
  } else {
    const firstLength = parsePercentageOrLength(text, end);
    if (firstLength) {
      end = firstLength.end;
      const secondLength = parsePercentageOrLength(text, end);
      if (secondLength) {
        end = secondLength.end;
        return {
          start: start2,
          end,
          value: {
            x: { align: "left", offset: firstLength.value },
            y: { align: "top", offset: secondLength.value }
          }
        };
      } else {
        return {
          start: start2,
          end,
          value: {
            x: { align: "left", offset: firstLength.value },
            y: "center"
          }
        };
      }
    } else {
      return null;
    }
  }
}
var directionRegEx = /\s*to\s*(left|right|top|bottom)\s*(left|right|top|bottom)?\s*/gy;
var sideDirections = {
  top: Math.PI * 0 / 2,
  right: Math.PI * 1 / 2,
  bottom: Math.PI * 2 / 2,
  left: Math.PI * 3 / 2
};
var cornerDirections = {
  top: {
    right: Math.PI * 1 / 4,
    left: Math.PI * 7 / 4
  },
  right: {
    top: Math.PI * 1 / 4,
    bottom: Math.PI * 3 / 4
  },
  bottom: {
    right: Math.PI * 3 / 4,
    left: Math.PI * 5 / 4
  },
  left: {
    top: Math.PI * 7 / 4,
    bottom: Math.PI * 5 / 4
  }
};
function parseDirection(text, start2 = 0) {
  directionRegEx.lastIndex = start2;
  const result = directionRegEx.exec(text);
  if (!result) {
    return null;
  }
  const end = directionRegEx.lastIndex;
  const firstDirection = result[1];
  if (result[2]) {
    const secondDirection = result[2];
    const value = cornerDirections[firstDirection][secondDirection];
    return value === undefined ? null : { start: start2, end, value };
  } else {
    return { start: start2, end, value: sideDirections[firstDirection] };
  }
}
var openingBracketRegEx = /\s*\(\s*/gy;
var closingBracketRegEx = /\s*\)\s*/gy;
var closingBracketOrCommaRegEx = /\s*([),])\s*/gy;
function parseArgumentsList(text, start2, argument) {
  openingBracketRegEx.lastIndex = start2;
  const openingBracket = openingBracketRegEx.exec(text);
  if (!openingBracket) {
    return null;
  }
  let end = openingBracketRegEx.lastIndex;
  const value = [];
  closingBracketRegEx.lastIndex = end;
  const closingBracket = closingBracketRegEx.exec(text);
  if (closingBracket) {
    return { start: start2, end, value };
  }
  for (let index = 0;; index++) {
    const arg = argument(text, end, index);
    if (!arg) {
      return null;
    }
    end = arg.end;
    value.push(arg);
    closingBracketOrCommaRegEx.lastIndex = end;
    const closingBracketOrComma = closingBracketOrCommaRegEx.exec(text);
    if (closingBracketOrComma) {
      end = closingBracketOrCommaRegEx.lastIndex;
      if (closingBracketOrComma[1] === ",") {
        continue;
      } else if (closingBracketOrComma[1] === ")") {
        return { start: start2, end, value };
      }
    } else {
      return null;
    }
  }
}
function parseColorStop(text, start2 = 0) {
  const color2 = parseColor(text, start2);
  if (!color2) {
    return null;
  }
  let end = color2.end;
  const offset2 = parsePercentageOrLength(text, end);
  if (offset2) {
    end = offset2.end;
    return {
      start: start2,
      end,
      value: { color: color2.value, offset: offset2.value }
    };
  }
  return { start: start2, end, value: { color: color2.value } };
}
var linearGradientStartRegEx = /\s*linear-gradient\s*/gy;
function parseLinearGradient(text, start2 = 0) {
  linearGradientStartRegEx.lastIndex = start2;
  const lgs = linearGradientStartRegEx.exec(text);
  if (!lgs) {
    return null;
  }
  let end = linearGradientStartRegEx.lastIndex;
  let angle = Math.PI;
  const colors = [];
  const parsedArgs = parseArgumentsList(text, end, (text2, start3, index) => {
    if (index === 0) {
      const angleArg = parseAngle(text2, start3) || parseDirection(text2, start3);
      if (angleArg) {
        angle = angleArg.value;
        return angleArg;
      }
    }
    const colorStop = parseColorStop(text2, start3);
    if (colorStop) {
      colors.push(colorStop.value);
      return colorStop;
    }
    return null;
  });
  if (!parsedArgs) {
    return null;
  }
  end = parsedArgs.end;
  return { start: start2, end, value: { angle, colors } };
}
var slashRegEx = /\s*(\/)\s*/gy;
function parseSlash(text, start2) {
  slashRegEx.lastIndex = start2;
  const slash = slashRegEx.exec(text);
  if (!slash) {
    return null;
  }
  const end = slashRegEx.lastIndex;
  return { start: start2, end, value: "/" };
}
function parseBackground(text, start2 = 0) {
  const value = {};
  let end = start2;
  while (end < text.length) {
    const keyword = parseKeyword(text, end);
    const color2 = parseColor(text, end, keyword);
    if (color2) {
      value.color = color2.value;
      end = color2.end;
      continue;
    }
    const repeat = parseRepeat(text, end, keyword);
    if (repeat) {
      value.repeat = repeat.value;
      end = repeat.end;
      continue;
    }
    const position = parseBackgroundPosition(text, end, keyword);
    if (position) {
      position.value.text = text.substring(position.start, position.end);
      value.position = position.value;
      end = position.end;
      const slash = parseSlash(text, end);
      if (slash) {
        end = slash.end;
        const size = parseBackgroundSize(text, end);
        if (!size) {
          return null;
        }
        value.size = size.value;
        end = size.end;
      }
      continue;
    }
    const url = parseURL(text, end);
    if (url) {
      value.image = url.value;
      end = url.end;
      continue;
    }
    const gradient = parseLinearGradient(text, end);
    if (gradient) {
      value.image = gradient.value;
      end = gradient.end;
      continue;
    }
    return null;
  }
  return { start: start2, end, value };
}

// node_modules/@nativescript/core/ui/styling/css-utils.js
function cleanupImportantFlags(value, propertyName) {
  if (typeof value !== "string") {
    return "" + value;
  }
  const index = value?.indexOf("!important");
  if (index >= 0) {
    if (Trace.isEnabled()) {
      Trace.write(`The !important css rule is currently not supported. Property: ${propertyName}`, Trace.categories.Style, Trace.messageType.warn);
    }
    return value.substring(0, index).trim();
  }
  return value;
}
var WHITE_SPACE_RE = /\s(?![^(]*\))/;
var COMMA_RE = /,(?![^(]*\))/;
var LENGTH_RE = /^-?[0-9]+[a-zA-Z%]*?$/;
var isLength = (v) => v === "0" || LENGTH_RE.test(v);
function parseCSSCommaSeparatedListOfValues(value) {
  const values = [];
  if (!value) {
    return [];
  }
  return value.split(COMMA_RE);
}
function parseCSSShorthand(value) {
  const parts = value.trim().split(WHITE_SPACE_RE);
  const first = parts[0];
  if (["", "none", "unset"].includes(first)) {
    return null;
  }
  const invalidColors = ["inset", "unset"];
  const inset = parts.includes("inset");
  const last = parts[parts.length - 1];
  let color2 = "black";
  if (first && !isLength(first) && !invalidColors.includes(first)) {
    color2 = first;
  } else if (last && !isLength(last) && !invalidColors.includes(last)) {
    color2 = last;
  }
  const values = parts.filter((n3) => !invalidColors.includes(n3)).filter((n3) => n3 !== color2).map((val) => {
    try {
      return Length.parse(val);
    } catch (err) {
      return CoreTypes.zeroLength;
    }
  });
  return {
    inset,
    color: color2,
    values
  };
}

// node_modules/@nativescript/core/ui/styling/css-shadow.js
function parseCSSShadow(value) {
  const data2 = parseCSSShorthand(value);
  if (!data2) {
    return null;
  }
  const [offsetX, offsetY, blurRadius, spreadRadius] = data2.values;
  return {
    inset: data2.inset,
    offsetX,
    offsetY,
    blurRadius,
    spreadRadius,
    color: data2.color ? new Color(data2.color) : undefined
  };
}

// node_modules/@nativescript/core/utils/number-utils.js
var radiansToDegrees = (a3) => a3 * (180 / Math.PI);
var degreesToRadians = (a3) => a3 * (Math.PI / 180);

// node_modules/@nativescript/core/matrix/index.js
var getTransformMatrix = ({ property, value }) => TRANSFORM_MATRIXES[property](value);
var TRANSFORM_MATRIXES = {
  scale: ({ x: x2, y: y2 }) => [x2, 0, 0, 0, y2, 0, 0, 0, 1],
  translate: ({ x: x2, y: y2 }) => [1, 0, x2, 0, 1, y2, 0, 0, 1],
  rotate: ({ x: x2, y: y2, z: z2 }) => {
    const radZ = degreesToRadians(z2);
    const cosZ = Math.cos(radZ);
    const sinZ = Math.sin(radZ);
    return [cosZ, -sinZ, 0, sinZ, cosZ, 0, 0, 0, 1];
  }
};
var matrixArrayToCssMatrix = (m2) => [m2[0], m2[3], m2[1], m2[4], m2[2], m2[5]];
function multiplyAffine2d(m1, m2) {
  return [m1[0] * m2[0] + m1[1] * m2[3], m1[0] * m2[1] + m1[1] * m2[4], m1[0] * m2[2] + m1[1] * m2[5] + m1[2], m1[3] * m2[0] + m1[4] * m2[3], m1[3] * m2[1] + m1[4] * m2[4], m1[3] * m2[2] + m1[4] * m2[5] + m1[5]];
}
function decompose2DTransformMatrix(matrix) {
  verifyTransformMatrix(matrix);
  const [A, B, C, D2, E2, F] = [...matrix];
  const determinant = A * D2 - B * C;
  const translate = { x: E2 || 0, y: F || 0 };
  let rotate = 0;
  let scale = { x: 1, y: 1 };
  if (A || B) {
    const R3 = Math.sqrt(A * A + B * B);
    rotate = B > 0 ? Math.acos(A / R3) : -Math.acos(A / R3);
    scale = { x: R3, y: determinant / R3 };
  } else if (C || D2) {
    const R3 = Math.sqrt(C * C + D2 * D2);
    rotate = Math.PI / 2 - (D2 > 0 ? Math.acos(-C / R3) : -Math.acos(C / R3));
    scale = { x: determinant / R3, y: R3 };
  }
  rotate = radiansToDegrees(rotate);
  return { translate, rotate: { x: 0, y: 0, z: rotate }, scale };
}
function verifyTransformMatrix(matrix) {
  if (matrix.length < 6) {
    throw new Error("Transform matrix should be 2x3.");
  }
}

// node_modules/@nativescript/core/ui/styling/css-transform.js
var IDENTITY_TRANSFORMATION = {
  translate: { x: 0, y: 0 },
  rotate: { x: 0, y: 0, z: 0 },
  scale: { x: 1, y: 1 }
};
var TRANSFORM_SPLITTER = new RegExp(/\s*(.+?)\((.*?)\)/g);
var TRANSFORMATIONS = Object.freeze(["rotate", "rotateX", "rotateY", "rotate3d", "translate", "translate3d", "translateX", "translateY", "scale", "scale3d", "scaleX", "scaleY"]);
var STYLE_TRANSFORMATION_MAP = Object.freeze({
  scale: (value) => ({ property: "scale", value }),
  scale3d: (value) => ({ property: "scale", value }),
  scaleX: ({ x: x2 }) => ({
    property: "scale",
    value: { x: x2, y: IDENTITY_TRANSFORMATION.scale.y }
  }),
  scaleY: ({ y: y2 }) => ({
    property: "scale",
    value: { y: y2, x: IDENTITY_TRANSFORMATION.scale.x }
  }),
  translate: (value) => ({ property: "translate", value }),
  translate3d: (value) => ({ property: "translate", value }),
  translateX: ({ x: x2 }) => ({
    property: "translate",
    value: { x: x2, y: IDENTITY_TRANSFORMATION.translate.y }
  }),
  translateY: ({ y: y2 }) => ({
    property: "translate",
    value: { y: y2, x: IDENTITY_TRANSFORMATION.translate.x }
  }),
  rotate3d: (value) => ({ property: "rotate", value }),
  rotateX: (x2) => ({
    property: "rotate",
    value: {
      x: x2,
      y: IDENTITY_TRANSFORMATION.rotate.y,
      z: IDENTITY_TRANSFORMATION.rotate.z
    }
  }),
  rotateY: (y2) => ({
    property: "rotate",
    value: {
      x: IDENTITY_TRANSFORMATION.rotate.x,
      y: y2,
      z: IDENTITY_TRANSFORMATION.rotate.z
    }
  }),
  rotate: (z2) => ({
    property: "rotate",
    value: {
      x: IDENTITY_TRANSFORMATION.rotate.x,
      y: IDENTITY_TRANSFORMATION.rotate.y,
      z: z2
    }
  })
});
function transformConverter(text) {
  const transformations = parseTransformString(text);
  if (text === "none" || text === "" || !transformations.length) {
    return IDENTITY_TRANSFORMATION;
  }
  const usedTransforms = transformations.map((t3) => t3.property);
  if (!hasDuplicates(usedTransforms)) {
    const fullTransformations = { ...IDENTITY_TRANSFORMATION };
    transformations.forEach((transform) => {
      fullTransformations[transform.property] = transform.value;
    });
    return fullTransformations;
  }
  const affineMatrix = transformations.map(getTransformMatrix).reduce(multiplyAffine2d);
  const cssMatrix = matrixArrayToCssMatrix(affineMatrix);
  return decompose2DTransformMatrix(cssMatrix);
}
function isTransformType(propertyName) {
  return TRANSFORMATIONS.indexOf(propertyName) !== -1;
}
function parseTransformString(text) {
  const matches = [];
  let match;
  while ((match = TRANSFORM_SPLITTER.exec(text)) !== null) {
    const property = match[1];
    if (isTransformType(property)) {
      const value = convertTransformValue(property, match[2]);
      matches.push(STYLE_TRANSFORMATION_MAP[property](value));
    }
  }
  return matches;
}
function convertTransformValue(property, rawValue) {
  const values = rawValue.split(",").map(parseFloat);
  const x2 = values[0];
  let y2 = values[1];
  let z2 = values[2];
  if (property === "translate") {
    y2 ?? (y2 = IDENTITY_TRANSFORMATION.translate.y);
  } else {
    y2 ?? (y2 = x2);
    z2 ?? (z2 = y2);
  }
  if (property === "rotate" || property === "rotateX" || property === "rotateY") {
    return rawValue.slice(-3) === "rad" ? radiansToDegrees(x2) : x2;
  }
  return { x: x2, y: y2, z: z2 };
}

// node_modules/@nativescript/core/ui/styling/style-properties.js
function isNonNegativeFiniteNumber(value) {
  return isFinite(value) && !isNaN(value) && value >= 0;
}
function parseClipPath(value) {
  const funcStartIndex = value.indexOf("(");
  const funcEndIndex = value.lastIndexOf(")");
  if (funcStartIndex > -1 && funcEndIndex > -1) {
    const functionName = value.substring(0, funcStartIndex).trim();
    switch (functionName) {
      case "rect":
      case "circle":
      case "ellipse":
      case "polygon":
      case "inset": {
        return new ClipPathFunction(functionName, value.substring(funcStartIndex + 1, funcEndIndex));
      }
      default:
        throw new Error(`Clip-path function ${functionName} is not valid.`);
    }
  } else {
    if (value === "none") {
      return null;
    }
    throw new Error(`Clip-path value ${value} is not valid.`);
  }
}
function parseShorthandPositioning(value) {
  const arr = value.split(/[ ,]+/);
  let top;
  let right;
  let bottom;
  let left;
  if (arr.length === 1) {
    top = arr[0];
    right = arr[0];
    bottom = arr[0];
    left = arr[0];
  } else if (arr.length === 2) {
    top = arr[0];
    bottom = arr[0];
    right = arr[1];
    left = arr[1];
  } else if (arr.length === 3) {
    top = arr[0];
    right = arr[1];
    left = arr[1];
    bottom = arr[2];
  } else if (arr.length === 4) {
    top = arr[0];
    right = arr[1];
    bottom = arr[2];
    left = arr[3];
  } else {
    throw new Error("Expected 1, 2, 3 or 4 parameters. Actual: " + value);
  }
  return {
    top,
    right,
    bottom,
    left
  };
}
function parseBorderColorPositioning(value) {
  if (value.indexOf("rgb") === 0 || value.indexOf("hsl") === 0) {
    return {
      top: value,
      right: value,
      bottom: value,
      left: value
    };
  }
  return parseShorthandPositioning(value);
}
function convertToBackgrounds(value) {
  if (typeof value === "string") {
    const backgrounds = parseBackground(value).value;
    let backgroundColor = unsetValue;
    if (backgrounds.color) {
      backgroundColor = backgrounds.color instanceof Color ? backgrounds.color : new Color(backgrounds.color);
    }
    let backgroundImage;
    if (typeof backgrounds.image === "object" && backgrounds.image) {
      backgroundImage = LinearGradient.parse(backgrounds.image);
    } else {
      backgroundImage = backgrounds.image || unsetValue;
    }
    const backgroundRepeat = backgrounds.repeat || unsetValue;
    const backgroundPosition = backgrounds.position ? backgrounds.position.text : unsetValue;
    return [
      [backgroundColorProperty, backgroundColor],
      [backgroundImageProperty, backgroundImage],
      [backgroundRepeatProperty, backgroundRepeat],
      [backgroundPositionProperty, backgroundPosition]
    ];
  } else {
    return [
      [backgroundColorProperty, unsetValue],
      [backgroundImageProperty, unsetValue],
      [backgroundRepeatProperty, unsetValue],
      [backgroundPositionProperty, unsetValue]
    ];
  }
}
function convertToMargins(value) {
  if (typeof value === "string" && value !== "auto") {
    const thickness = parseShorthandPositioning(value);
    return [
      [marginTopProperty, PercentLength.parse(thickness.top)],
      [marginRightProperty, PercentLength.parse(thickness.right)],
      [marginBottomProperty, PercentLength.parse(thickness.bottom)],
      [marginLeftProperty, PercentLength.parse(thickness.left)]
    ];
  } else {
    return [
      [marginTopProperty, value],
      [marginRightProperty, value],
      [marginBottomProperty, value],
      [marginLeftProperty, value]
    ];
  }
}
function convertToPaddings(value) {
  if (typeof value === "string" && value !== "auto") {
    const thickness = parseShorthandPositioning(value);
    return [
      [paddingTopProperty, Length.parse(thickness.top)],
      [paddingRightProperty, Length.parse(thickness.right)],
      [paddingBottomProperty, Length.parse(thickness.bottom)],
      [paddingLeftProperty, Length.parse(thickness.left)]
    ];
  } else {
    return [
      [paddingTopProperty, value],
      [paddingRightProperty, value],
      [paddingBottomProperty, value],
      [paddingLeftProperty, value]
    ];
  }
}
function convertToTransform(value) {
  if (value === unsetValue) {
    value = "none";
  }
  const { translate, rotate, scale } = transformConverter(value);
  return [
    [translateXProperty, translate.x],
    [translateYProperty, translate.y],
    [scaleXProperty, scale.x],
    [scaleYProperty, scale.y],
    [rotateProperty, rotate.z],
    [rotateXProperty, rotate.x],
    [rotateYProperty, rotate.y]
  ];
}
var minWidthProperty = new CssProperty({
  name: "minWidth",
  cssName: "min-width",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectiveMinWidth = Length.toDevicePixels(newValue, 0);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
minWidthProperty.register(Style);
var minHeightProperty = new CssProperty({
  name: "minHeight",
  cssName: "min-height",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectiveMinHeight = Length.toDevicePixels(newValue, 0);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
minHeightProperty.register(Style);
var widthProperty = new CssAnimationProperty({
  name: "width",
  cssName: "width",
  defaultValue: "auto",
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    if (global.isIOS) {
      const view = target.viewRef.get();
      if (view) {
        view.requestLayout();
      }
    }
  },
  valueConverter: PercentLength.parse
});
widthProperty.register(Style);
var heightProperty = new CssAnimationProperty({
  name: "height",
  cssName: "height",
  defaultValue: "auto",
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    if (global.isIOS) {
      const view = target.viewRef.get();
      if (view) {
        view.requestLayout();
      }
    }
  },
  valueConverter: PercentLength.parse
});
heightProperty.register(Style);
var marginProperty = new ShorthandProperty({
  name: "margin",
  cssName: "margin",
  getter: function() {
    if (PercentLength.equals(this.marginTop, this.marginRight) && PercentLength.equals(this.marginTop, this.marginBottom) && PercentLength.equals(this.marginTop, this.marginLeft)) {
      return this.marginTop;
    }
    return `${PercentLength.convertToString(this.marginTop)} ${PercentLength.convertToString(this.marginRight)} ${PercentLength.convertToString(this.marginBottom)} ${PercentLength.convertToString(this.marginLeft)}`;
  },
  converter: convertToMargins
});
marginProperty.register(Style);
var marginLeftProperty = new CssProperty({
  name: "marginLeft",
  cssName: "margin-left",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueConverter: PercentLength.parse
});
marginLeftProperty.register(Style);
var marginRightProperty = new CssProperty({
  name: "marginRight",
  cssName: "margin-right",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueConverter: PercentLength.parse
});
marginRightProperty.register(Style);
var marginTopProperty = new CssProperty({
  name: "marginTop",
  cssName: "margin-top",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueConverter: PercentLength.parse
});
marginTopProperty.register(Style);
var marginBottomProperty = new CssProperty({
  name: "marginBottom",
  cssName: "margin-bottom",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueConverter: PercentLength.parse
});
marginBottomProperty.register(Style);
var paddingProperty = new ShorthandProperty({
  name: "padding",
  cssName: "padding",
  getter: function() {
    if (Length.equals(this.paddingTop, this.paddingRight) && Length.equals(this.paddingTop, this.paddingBottom) && Length.equals(this.paddingTop, this.paddingLeft)) {
      return this.paddingTop;
    }
    return `${Length.convertToString(this.paddingTop)} ${Length.convertToString(this.paddingRight)} ${Length.convertToString(this.paddingBottom)} ${Length.convertToString(this.paddingLeft)}`;
  },
  converter: convertToPaddings
});
paddingProperty.register(Style);
var paddingLeftProperty = new CssProperty({
  name: "paddingLeft",
  cssName: "padding-left",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectivePaddingLeft = Length.toDevicePixels(newValue, 0);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
paddingLeftProperty.register(Style);
var paddingRightProperty = new CssProperty({
  name: "paddingRight",
  cssName: "padding-right",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectivePaddingRight = Length.toDevicePixels(newValue, 0);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
paddingRightProperty.register(Style);
var paddingTopProperty = new CssProperty({
  name: "paddingTop",
  cssName: "padding-top",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectivePaddingTop = Length.toDevicePixels(newValue, 0);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
paddingTopProperty.register(Style);
var paddingBottomProperty = new CssProperty({
  name: "paddingBottom",
  cssName: "padding-bottom",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectivePaddingBottom = Length.toDevicePixels(newValue, 0);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
paddingBottomProperty.register(Style);
var horizontalAlignmentProperty = new CssProperty({
  name: "horizontalAlignment",
  cssName: "horizontal-align",
  defaultValue: CoreTypes.HorizontalAlignment.stretch,
  affectsLayout: global.isIOS,
  valueConverter: CoreTypes.HorizontalAlignment.parse
});
horizontalAlignmentProperty.register(Style);
var verticalAlignmentProperty = new CssProperty({
  name: "verticalAlignment",
  cssName: "vertical-align",
  defaultValue: CoreTypes.VerticalAlignmentText.stretch,
  affectsLayout: global.isIOS,
  valueConverter: CoreTypes.VerticalAlignmentText.parse
});
verticalAlignmentProperty.register(Style);
var rotateProperty = new CssAnimationProperty({
  name: "rotate",
  cssName: "rotate",
  defaultValue: 0,
  valueConverter: parseFloat
});
rotateProperty.register(Style);
var rotateXProperty = new CssAnimationProperty({
  name: "rotateX",
  cssName: "rotatex",
  defaultValue: 0,
  valueConverter: parseFloat
});
rotateXProperty.register(Style);
var rotateYProperty = new CssAnimationProperty({
  name: "rotateY",
  cssName: "rotatey",
  defaultValue: 0,
  valueConverter: parseFloat
});
rotateYProperty.register(Style);
var perspectiveProperty = new CssAnimationProperty({
  name: "perspective",
  cssName: "perspective",
  defaultValue: 1000,
  valueConverter: parseFloat
});
perspectiveProperty.register(Style);
var scaleXProperty = new CssAnimationProperty({
  name: "scaleX",
  cssName: "scaleX",
  defaultValue: 1,
  valueConverter: parseFloat
});
scaleXProperty.register(Style);
var scaleYProperty = new CssAnimationProperty({
  name: "scaleY",
  cssName: "scaleY",
  defaultValue: 1,
  valueConverter: parseFloat
});
scaleYProperty.register(Style);
var translateXProperty = new CssAnimationProperty({
  name: "translateX",
  cssName: "translateX",
  defaultValue: 0,
  equalityComparer: FixedLength.equals,
  valueConverter: FixedLength.parse
});
translateXProperty.register(Style);
var translateYProperty = new CssAnimationProperty({
  name: "translateY",
  cssName: "translateY",
  defaultValue: 0,
  equalityComparer: FixedLength.equals,
  valueConverter: FixedLength.parse
});
translateYProperty.register(Style);
var transformProperty = new ShorthandProperty({
  name: "transform",
  cssName: "transform",
  getter: function() {
    const scaleX = this.scaleX;
    const scaleY = this.scaleY;
    const translateX = this.translateX;
    const translateY = this.translateY;
    const rotate = this.rotate;
    const rotateX = this.rotateX;
    const rotateY = this.rotateY;
    let result = "";
    if (translateX !== 0 || translateY !== 0) {
      result += `translate(${translateX}, ${translateY}) `;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      result += `scale(${scaleX}, ${scaleY}) `;
    }
    if (rotateX !== 0 || rotateY !== 0 || rotate !== 0) {
      result += `rotate(${rotateX}, ${rotateY}, ${rotate}) `;
      result += `rotate (${rotate})`;
    }
    return result.trim();
  },
  converter: convertToTransform
});
transformProperty.register(Style);
var backgroundProperty = new ShorthandProperty({
  name: "background",
  cssName: "background",
  getter: function() {
    return `${this.backgroundColor} ${this.backgroundImage} ${this.backgroundRepeat} ${this.backgroundPosition}`;
  },
  converter: convertToBackgrounds
});
backgroundProperty.register(Style);
var backgroundInternalProperty = new CssProperty({
  name: "backgroundInternal",
  cssName: "_backgroundInternal",
  defaultValue: Background.default
});
backgroundInternalProperty.register(Style);
var backgroundImageProperty = new CssProperty({
  name: "backgroundImage",
  cssName: "background-image",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withImage(newValue);
  },
  equalityComparer: (value1, value2) => {
    if (value1 instanceof LinearGradient && value2 instanceof LinearGradient) {
      return LinearGradient.equals(value1, value2);
    } else {
      return value1 === value2;
    }
  },
  valueConverter: (value) => {
    if (typeof value === "string") {
      const parsed = parseBackground(value);
      if (parsed) {
        value = typeof parsed.value.image === "object" ? LinearGradient.parse(parsed.value.image) : value;
      }
    }
    return value;
  }
});
backgroundImageProperty.register(Style);
var backgroundColorProperty = new CssAnimationProperty({
  name: "backgroundColor",
  cssName: "background-color",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withColor(newValue);
  },
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
backgroundColorProperty.register(Style);
var backgroundRepeatProperty = new CssProperty({
  name: "backgroundRepeat",
  cssName: "background-repeat",
  valueConverter: CoreTypes.BackgroundRepeat.parse,
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withRepeat(newValue);
  }
});
backgroundRepeatProperty.register(Style);
var backgroundSizeProperty = new CssProperty({
  name: "backgroundSize",
  cssName: "background-size",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withSize(newValue);
  }
});
backgroundSizeProperty.register(Style);
var backgroundPositionProperty = new CssProperty({
  name: "backgroundPosition",
  cssName: "background-position",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withPosition(newValue);
  }
});
backgroundPositionProperty.register(Style);
var borderColorProperty = new ShorthandProperty({
  name: "borderColor",
  cssName: "border-color",
  getter: function() {
    if (Color.equals(this.borderTopColor, this.borderRightColor) && Color.equals(this.borderTopColor, this.borderBottomColor) && Color.equals(this.borderTopColor, this.borderLeftColor)) {
      return this.borderTopColor;
    } else {
      return `${this.borderTopColor} ${this.borderRightColor} ${this.borderBottomColor} ${this.borderLeftColor}`;
    }
  },
  converter: function(value) {
    if (typeof value === "string") {
      const colors = parseBorderColorPositioning(value);
      return [
        [borderTopColorProperty, new Color(colors.top)],
        [borderRightColorProperty, new Color(colors.right)],
        [borderBottomColorProperty, new Color(colors.bottom)],
        [borderLeftColorProperty, new Color(colors.left)]
      ];
    } else {
      return [
        [borderTopColorProperty, value],
        [borderRightColorProperty, value],
        [borderBottomColorProperty, value],
        [borderLeftColorProperty, value]
      ];
    }
  }
});
borderColorProperty.register(Style);
var borderTopColorProperty = new CssProperty({
  name: "borderTopColor",
  cssName: "border-top-color",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withBorderTopColor(newValue);
  },
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
borderTopColorProperty.register(Style);
var borderRightColorProperty = new CssProperty({
  name: "borderRightColor",
  cssName: "border-right-color",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withBorderRightColor(newValue);
  },
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
borderRightColorProperty.register(Style);
var borderBottomColorProperty = new CssProperty({
  name: "borderBottomColor",
  cssName: "border-bottom-color",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withBorderBottomColor(newValue);
  },
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
borderBottomColorProperty.register(Style);
var borderLeftColorProperty = new CssProperty({
  name: "borderLeftColor",
  cssName: "border-left-color",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withBorderLeftColor(newValue);
  },
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
borderLeftColorProperty.register(Style);
var borderWidthProperty = new ShorthandProperty({
  name: "borderWidth",
  cssName: "border-width",
  getter: function() {
    if (Length.equals(this.borderTopWidth, this.borderRightWidth) && Length.equals(this.borderTopWidth, this.borderBottomWidth) && Length.equals(this.borderTopWidth, this.borderLeftWidth)) {
      return this.borderTopWidth;
    } else {
      return `${Length.convertToString(this.borderTopWidth)} ${Length.convertToString(this.borderRightWidth)} ${Length.convertToString(this.borderBottomWidth)} ${Length.convertToString(this.borderLeftWidth)}`;
    }
  },
  converter: function(value) {
    if (typeof value === "string" && value !== "auto") {
      const borderWidths = parseShorthandPositioning(value);
      return [
        [borderTopWidthProperty, Length.parse(borderWidths.top)],
        [borderRightWidthProperty, Length.parse(borderWidths.right)],
        [borderBottomWidthProperty, Length.parse(borderWidths.bottom)],
        [borderLeftWidthProperty, Length.parse(borderWidths.left)]
      ];
    } else {
      return [
        [borderTopWidthProperty, value],
        [borderRightWidthProperty, value],
        [borderBottomWidthProperty, value],
        [borderLeftWidthProperty, value]
      ];
    }
  }
});
borderWidthProperty.register(Style);
var borderTopWidthProperty = new CssProperty({
  name: "borderTopWidth",
  cssName: "border-top-width",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-top-width should be Non-Negative Finite number. Value: ${value}`);
    }
    const view = target.viewRef.get();
    if (view) {
      view.effectiveBorderTopWidth = value;
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderTopWidth(value);
  },
  valueConverter: Length.parse
});
borderTopWidthProperty.register(Style);
var borderRightWidthProperty = new CssProperty({
  name: "borderRightWidth",
  cssName: "border-right-width",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-right-width should be Non-Negative Finite number. Value: ${value}`);
    }
    const view = target.viewRef.get();
    if (view) {
      view.effectiveBorderRightWidth = value;
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderRightWidth(value);
  },
  valueConverter: Length.parse
});
borderRightWidthProperty.register(Style);
var borderBottomWidthProperty = new CssProperty({
  name: "borderBottomWidth",
  cssName: "border-bottom-width",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-bottom-width should be Non-Negative Finite number. Value: ${value}`);
    }
    const view = target.viewRef.get();
    if (view) {
      view.effectiveBorderBottomWidth = value;
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderBottomWidth(value);
  },
  valueConverter: Length.parse
});
borderBottomWidthProperty.register(Style);
var borderLeftWidthProperty = new CssProperty({
  name: "borderLeftWidth",
  cssName: "border-left-width",
  defaultValue: CoreTypes.zeroLength,
  affectsLayout: global.isIOS,
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-left-width should be Non-Negative Finite number. Value: ${value}`);
    }
    const view = target.viewRef.get();
    if (view) {
      view.effectiveBorderLeftWidth = value;
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderLeftWidth(value);
  },
  valueConverter: Length.parse
});
borderLeftWidthProperty.register(Style);
var borderRadiusProperty = new ShorthandProperty({
  name: "borderRadius",
  cssName: "border-radius",
  getter: function() {
    if (Length.equals(this.borderTopLeftRadius, this.borderTopRightRadius) && Length.equals(this.borderTopLeftRadius, this.borderBottomRightRadius) && Length.equals(this.borderTopLeftRadius, this.borderBottomLeftRadius)) {
      return this.borderTopLeftRadius;
    }
    return `${Length.convertToString(this.borderTopLeftRadius)} ${Length.convertToString(this.borderTopRightRadius)} ${Length.convertToString(this.borderBottomRightRadius)} ${Length.convertToString(this.borderBottomLeftRadius)}`;
  },
  converter: function(value) {
    if (typeof value === "string") {
      const borderRadius = parseShorthandPositioning(value);
      return [
        [borderTopLeftRadiusProperty, Length.parse(borderRadius.top)],
        [borderTopRightRadiusProperty, Length.parse(borderRadius.right)],
        [borderBottomRightRadiusProperty, Length.parse(borderRadius.bottom)],
        [borderBottomLeftRadiusProperty, Length.parse(borderRadius.left)]
      ];
    } else {
      return [
        [borderTopLeftRadiusProperty, value],
        [borderTopRightRadiusProperty, value],
        [borderBottomRightRadiusProperty, value],
        [borderBottomLeftRadiusProperty, value]
      ];
    }
  }
});
borderRadiusProperty.register(Style);
var borderTopLeftRadiusProperty = new CssProperty({
  name: "borderTopLeftRadius",
  cssName: "border-top-left-radius",
  defaultValue: 0,
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-top-left-radius should be Non-Negative Finite number. Value: ${value}`);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderTopLeftRadius(value);
  },
  valueConverter: Length.parse,
  equalityComparer: Length.equals
});
borderTopLeftRadiusProperty.register(Style);
var borderTopRightRadiusProperty = new CssProperty({
  name: "borderTopRightRadius",
  cssName: "border-top-right-radius",
  defaultValue: 0,
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-top-right-radius should be Non-Negative Finite number. Value: ${value}`);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderTopRightRadius(value);
  },
  valueConverter: Length.parse,
  equalityComparer: Length.equals
});
borderTopRightRadiusProperty.register(Style);
var borderBottomRightRadiusProperty = new CssProperty({
  name: "borderBottomRightRadius",
  cssName: "border-bottom-right-radius",
  defaultValue: 0,
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-bottom-right-radius should be Non-Negative Finite number. Value: ${value}`);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderBottomRightRadius(value);
  },
  valueConverter: Length.parse,
  equalityComparer: Length.equals
});
borderBottomRightRadiusProperty.register(Style);
var borderBottomLeftRadiusProperty = new CssProperty({
  name: "borderBottomLeftRadius",
  cssName: "border-bottom-left-radius",
  defaultValue: 0,
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    const value = Length.toDevicePixels(newValue, 0);
    if (!isNonNegativeFiniteNumber(value)) {
      throw new Error(`border-bottom-left-radius should be Non-Negative Finite number. Value: ${value}`);
    }
    target.backgroundInternal = target.backgroundInternal.withBorderBottomLeftRadius(value);
  },
  valueConverter: Length.parse,
  equalityComparer: Length.equals
});
borderBottomLeftRadiusProperty.register(Style);
var boxShadowProperty = new CssProperty({
  name: "boxShadow",
  cssName: "box-shadow",
  valueChanged: (target, _oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withBoxShadows(newValue?.length ? newValue.map((v) => {
      return {
        inset: v.inset,
        offsetX: Length.toDevicePixels(v.offsetX, 0),
        offsetY: Length.toDevicePixels(v.offsetY, 0),
        blurRadius: Length.toDevicePixels(v.blurRadius, 0),
        spreadRadius: Length.toDevicePixels(v.spreadRadius, 0),
        color: v.color
      };
    }) : null);
  },
  valueConverter: (value) => {
    const values = parseCSSCommaSeparatedListOfValues(value);
    const result = [];
    for (let i4 = values.length - 1;i4 >= 0; i4--) {
      const shadowVal = parseCSSShadow(values[i4]);
      if (shadowVal) {
        result.push(shadowVal);
      }
    }
    return result;
  }
});
boxShadowProperty.register(Style);
var clipPathProperty = new CssProperty({
  name: "clipPath",
  cssName: "clip-path",
  valueChanged: (target, oldValue, newValue) => {
    target.backgroundInternal = target.backgroundInternal.withClipPath(newValue);
  },
  equalityComparer: (value1, value2) => {
    if (value1 instanceof ClipPathFunction && value2 instanceof ClipPathFunction) {
      return ClipPathFunction.equals(value1, value2);
    }
    return value1 === value2;
  },
  valueConverter(value) {
    if (typeof value === "string") {
      return parseClipPath(value);
    }
    return value;
  }
});
clipPathProperty.register(Style);
var directionProperty = new InheritedCssProperty({
  defaultValue: null,
  name: "direction",
  cssName: "direction",
  affectsLayout: __APPLE__
});
directionProperty.register(Style);
var zIndexProperty = new CssProperty({
  name: "zIndex",
  cssName: "z-index",
  valueConverter: (value) => {
    const newValue = parseFloat(value);
    if (isNaN(newValue)) {
      throw new Error(`Invalid value: ${newValue}`);
    }
    return newValue;
  }
});
zIndexProperty.register(Style);
var opacityProperty = new CssAnimationProperty({
  name: "opacity",
  cssName: "opacity",
  defaultValue: 1,
  valueConverter: (value) => {
    const newValue = parseFloat(value);
    if (!isNonNegativeFiniteNumber(newValue) || newValue > 1) {
      throw new Error(`Opacity should be between [0, 1]. Value: ${newValue}`);
    }
    return newValue;
  }
});
opacityProperty.register(Style);
var colorProperty = new InheritedCssProperty({
  name: "color",
  cssName: "color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
colorProperty.register(Style);
var fontInternalProperty = new CssProperty({
  name: "fontInternal",
  cssName: "_fontInternal"
});
fontInternalProperty.register(Style);
var fontFamilyProperty = new InheritedCssProperty({
  name: "fontFamily",
  cssName: "font-family",
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    const currentFont = target.fontInternal || Font2.default;
    if (currentFont.fontFamily !== newValue) {
      const newFont = currentFont.withFontFamily(newValue);
      target.fontInternal = Font2.equals(Font2.default, newFont) ? unsetValue : newFont;
    }
  }
});
fontFamilyProperty.register(Style);
var fontScaleInternalProperty = new InheritedCssProperty({
  name: "fontScaleInternal",
  cssName: "_fontScaleInternal",
  defaultValue: 1,
  valueConverter: (v) => parseFloat(v)
});
fontScaleInternalProperty.register(Style);
var fontSizeProperty = new InheritedCssProperty({
  name: "fontSize",
  cssName: "font-size",
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    if (target.viewRef["handleFontSize"] === true) {
      return;
    }
    const currentFont = target.fontInternal || Font2.default;
    if (currentFont.fontSize !== newValue) {
      const newFont = currentFont.withFontSize(newValue);
      target.fontInternal = Font2.equals(Font2.default, newFont) ? unsetValue : newFont;
    }
  },
  valueConverter: (v) => parseFloat(v)
});
fontSizeProperty.register(Style);
var fontStyleProperty = new InheritedCssProperty({
  name: "fontStyle",
  cssName: "font-style",
  affectsLayout: global.isIOS,
  defaultValue: FontStyle.NORMAL,
  valueConverter: FontStyle.parse,
  valueChanged: (target, oldValue, newValue) => {
    const currentFont = target.fontInternal || Font2.default;
    if (currentFont.fontStyle !== newValue) {
      const newFont = currentFont.withFontStyle(newValue);
      target.fontInternal = Font2.equals(Font2.default, newFont) ? unsetValue : newFont;
    }
  }
});
fontStyleProperty.register(Style);
var fontWeightProperty = new InheritedCssProperty({
  name: "fontWeight",
  cssName: "font-weight",
  affectsLayout: global.isIOS,
  defaultValue: FontWeight.NORMAL,
  valueConverter: FontWeight.parse,
  valueChanged: (target, oldValue, newValue) => {
    const currentFont = target.fontInternal || Font2.default;
    if (currentFont.fontWeight !== newValue) {
      const newFont = currentFont.withFontWeight(newValue);
      target.fontInternal = Font2.equals(Font2.default, newFont) ? unsetValue : newFont;
    }
  }
});
fontWeightProperty.register(Style);
var fontProperty = new ShorthandProperty({
  name: "font",
  cssName: "font",
  getter: function() {
    return `${this.fontStyle} ${this.fontWeight} ${this.fontSize} ${this.fontFamily}`;
  },
  converter: function(value) {
    if (value === unsetValue) {
      return [
        [fontStyleProperty, unsetValue],
        [fontWeightProperty, unsetValue],
        [fontSizeProperty, unsetValue],
        [fontFamilyProperty, unsetValue]
      ];
    } else {
      const font = parseFont(value);
      const fontSize = parseFloat(font.fontSize);
      return [
        [fontStyleProperty, font.fontStyle],
        [fontWeightProperty, font.fontWeight],
        [fontSizeProperty, fontSize],
        [fontFamilyProperty, font.fontFamily]
      ];
    }
  }
});
fontProperty.register(Style);
var fontVariationSettingsProperty = new InheritedCssProperty({
  name: "fontVariationSettings",
  cssName: "font-variation-settings",
  affectsLayout: global.isIOS,
  valueChanged: (target, oldValue, newValue) => {
    const currentFont = target.fontInternal || Font2.default;
    if (currentFont.fontVariationSettings !== newValue) {
      const newFont = currentFont.withFontVariationSettings(newValue);
      target.fontInternal = Font2.equals(Font2.default, newFont) ? unsetValue : newFont;
    }
  },
  valueConverter: (value) => {
    return FontVariationSettings.parse(value);
  }
});
fontVariationSettingsProperty.register(Style);
var visibilityProperty = new CssProperty({
  name: "visibility",
  cssName: "visibility",
  defaultValue: CoreTypes.Visibility.visible,
  affectsLayout: global.isIOS,
  valueConverter: CoreTypes.Visibility.parse,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.isCollapsed = newValue === CoreTypes.Visibility.collapse;
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  }
});
visibilityProperty.register(Style);
var androidElevationProperty = new CssProperty({
  name: "androidElevation",
  cssName: "android-elevation",
  valueConverter: parseFloat
});
androidElevationProperty.register(Style);
var androidDynamicElevationOffsetProperty = new CssProperty({
  name: "androidDynamicElevationOffset",
  cssName: "android-dynamic-elevation-offset",
  valueConverter: parseFloat
});
androidDynamicElevationOffsetProperty.register(Style);

// node_modules/@nativescript/core/debugger/dom-types.js
var ELEMENT_NODE_TYPE = 1;
var ROOT_NODE_TYPE = 9;
var propertyBlacklist = ["effectivePaddingLeft", "effectivePaddingBottom", "effectivePaddingRight", "effectivePaddingTop", "effectiveBorderTopWidth", "effectiveBorderRightWidth", "effectiveBorderBottomWidth", "effectiveBorderLeftWidth", "effectiveMinWidth", "effectiveMinHeight", "effectiveWidth", "effectiveHeight", "effectiveMarginLeft", "effectiveMarginTop", "effectiveMarginRight", "effectiveMarginBottom", "nodeName", "nodeType", "decodeWidth", "decodeHeight", "ng-reflect-items", "domNode", "touchListenerIsSet", "bindingContext", "nativeView"];
function lazy2(action) {
  let _value;
  return () => _value || (_value = action());
}
var percentLengthToStringLazy = lazy2(() => PercentLength.convertToString);
var getSetPropertiesLazy = lazy2(() => getSetProperties);
var getComputedCssValuesLazy = lazy2(() => getComputedCssValues);
var registeredDomNodes = {};
var inspectorFrontendInstance;
function notifyInspector(callback) {
  if (inspectorFrontendInstance) {
    callback(inspectorFrontendInstance);
  }
}
function valueToString(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  } else if (typeof value === "object" && value.unit) {
    return percentLengthToStringLazy()(value);
  } else {
    return value + "";
  }
}
function propertyFilter([name, value]) {
  if (name[0] === "_") {
    return false;
  }
  if (value !== null && typeof value === "object") {
    return false;
  }
  if (propertyBlacklist.indexOf(name) >= 0) {
    return false;
  }
  return true;
}
function registerNode(domNode) {
  registeredDomNodes[domNode.nodeId] = domNode;
}
function unregisterNode(domNode) {
  delete registeredDomNodes[domNode.nodeId];
}

class DOMNode {
  constructor(view) {
    this.nodeValue = "";
    this.attributes = [];
    this.viewRef = new WeakRef(view);
    this.nodeType = view.typeName === "Frame" ? ROOT_NODE_TYPE : ELEMENT_NODE_TYPE;
    this.nodeId = view._domId;
    this.nodeName = view.typeName;
    this.localName = this.nodeName;
    this.loadAttributes();
    registerNode(this);
  }
  loadAttributes() {
    this.attributes = [];
    getSetPropertiesLazy()(this.viewRef.get()).filter(propertyFilter).forEach((pair) => this.attributes.push(pair[0], pair[1] + ""));
  }
  get children() {
    const view = this.viewRef.get();
    if (!view) {
      return [];
    }
    const res = [];
    view.eachChild((child) => {
      child.ensureDomNode();
      res.push(child.domNode);
      return true;
    });
    return res;
  }
  onChildAdded(childView) {
    notifyInspector((ins) => {
      const view = this.viewRef.get();
      let previousChild;
      view.eachChild((child) => {
        if (child === childView) {
          return false;
        }
        previousChild = child;
        return true;
      });
      const index = previousChild ? previousChild._domId : 0;
      childView.ensureDomNode();
      ins.childNodeInserted(this.nodeId, index, childView.domNode);
    });
  }
  onChildRemoved(view) {
    notifyInspector((ins) => {
      ins.childNodeRemoved(this.nodeId, view._domId);
    });
  }
  attributeModified(name, value) {
    notifyInspector((ins) => {
      if (propertyBlacklist.indexOf(name) < 0) {
        ins.attributeModified(this.nodeId, name, valueToString(value));
      }
    });
  }
  attributeRemoved(name) {
    notifyInspector((ins) => {
      ins.attributeRemoved(this.nodeId, name);
    });
  }
  getComputedProperties() {
    const view = this.viewRef.get();
    if (!view) {
      return [];
    }
    const result = getComputedCssValuesLazy()(view).filter((pair) => pair[0][0] !== "_").map((pair) => {
      return {
        name: pair[0],
        value: valueToString(pair[1])
      };
    });
    return result;
  }
  dispose() {
    unregisterNode(this);
  }
  toObject() {
    return {
      nodeId: this.nodeId,
      nodeType: this.nodeType,
      nodeName: this.nodeName,
      localName: this.localName,
      nodeValue: this.nodeValue,
      children: this.children.map((c3) => c3.toObject()),
      attributes: this.attributes,
      backendNodeId: 0
    };
  }
}

// node_modules/css-what/dist/esm/types.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
// node_modules/css-what/dist/esm/parse.js
var reName = /^[^#\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\u00B0-\uFFFF-])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var CharCode;
(function(CharCode2) {
  CharCode2[CharCode2["LeftParenthesis"] = 40] = "LeftParenthesis";
  CharCode2[CharCode2["RightParenthesis"] = 41] = "RightParenthesis";
  CharCode2[CharCode2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
  CharCode2[CharCode2["RightSquareBracket"] = 93] = "RightSquareBracket";
  CharCode2[CharCode2["Comma"] = 44] = "Comma";
  CharCode2[CharCode2["Period"] = 46] = "Period";
  CharCode2[CharCode2["Colon"] = 58] = "Colon";
  CharCode2[CharCode2["SingleQuote"] = 39] = "SingleQuote";
  CharCode2[CharCode2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCode2[CharCode2["Plus"] = 43] = "Plus";
  CharCode2[CharCode2["Tilde"] = 126] = "Tilde";
  CharCode2[CharCode2["QuestionMark"] = 63] = "QuestionMark";
  CharCode2[CharCode2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCode2[CharCode2["Slash"] = 47] = "Slash";
  CharCode2[CharCode2["Equal"] = 61] = "Equal";
  CharCode2[CharCode2["Dollar"] = 36] = "Dollar";
  CharCode2[CharCode2["Pipe"] = 124] = "Pipe";
  CharCode2[CharCode2["Circumflex"] = 94] = "Circumflex";
  CharCode2[CharCode2["Asterisk"] = 42] = "Asterisk";
  CharCode2[CharCode2["GreaterThan"] = 62] = "GreaterThan";
  CharCode2[CharCode2["LessThan"] = 60] = "LessThan";
  CharCode2[CharCode2["Hash"] = 35] = "Hash";
  CharCode2[CharCode2["LowerI"] = 105] = "LowerI";
  CharCode2[CharCode2["LowerS"] = 115] = "LowerS";
  CharCode2[CharCode2["BackSlash"] = 92] = "BackSlash";
  CharCode2[CharCode2["Space"] = 32] = "Space";
  CharCode2[CharCode2["Tab"] = 9] = "Tab";
  CharCode2[CharCode2["NewLine"] = 10] = "NewLine";
  CharCode2[CharCode2["FormFeed"] = 12] = "FormFeed";
  CharCode2[CharCode2["CarriageReturn"] = 13] = "CarriageReturn";
})(CharCode || (CharCode = {}));
var actionTypes = new Map([
  [CharCode.Tilde, AttributeAction.Element],
  [CharCode.Circumflex, AttributeAction.Start],
  [CharCode.Dollar, AttributeAction.End],
  [CharCode.Asterisk, AttributeAction.Any],
  [CharCode.ExclamationMark, AttributeAction.Not],
  [CharCode.Pipe, AttributeAction.Hyphen]
]);
var unpackPseudos = new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
var pseudosToPseudoElements = new Set([
  "before",
  "after",
  "first-line",
  "first-letter"
]);
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator: {
      return true;
    }
    default: {
      return false;
    }
  }
}
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
function funescape(_3, escaped, escapedWhitespace) {
  const high = Number.parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
}
function unescapeCSS(cssString) {
  return cssString.replace(reEscape, funescape);
}
function isQuote(c3) {
  return c3 === CharCode.SingleQuote || c3 === CharCode.DoubleQuote;
}
function isWhitespace2(c3) {
  return c3 === CharCode.Space || c3 === CharCode.Tab || c3 === CharCode.NewLine || c3 === CharCode.FormFeed || c3 === CharCode.CarriageReturn;
}
function parse6(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset2) {
    const match = selector.slice(selectorIndex + offset2).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset2 + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset2) {
    selectorIndex += offset2;
    while (selectorIndex < selector.length && isWhitespace2(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start2 = selectorIndex;
    for (let counter = 1;selectorIndex < selector.length; selectorIndex++) {
      switch (selector.charCodeAt(selectorIndex)) {
        case CharCode.BackSlash: {
          selectorIndex += 1;
          break;
        }
        case CharCode.LeftParenthesis: {
          counter += 1;
          break;
        }
        case CharCode.RightParenthesis: {
          counter -= 1;
          if (counter === 0) {
            return unescapeCSS(selector.slice(start2, selectorIndex++));
          }
          break;
        }
      }
    }
    throw new Error("Parenthesis not matched");
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case CharCode.Space:
        case CharCode.Tab:
        case CharCode.NewLine:
        case CharCode.FormFeed:
        case CharCode.CarriageReturn: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case CharCode.GreaterThan: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case CharCode.LessThan: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case CharCode.Tilde: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case CharCode.Plus: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case CharCode.Period: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case CharCode.Hash: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case CharCode.LeftSquareBracket: {
          stripWhitespace(1);
          let name;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === CharCode.Pipe) {
            name = getName(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name = getName(2);
          } else {
            name = getName(0);
            if (selector.charCodeAt(selectorIndex) === CharCode.Pipe && selector.charCodeAt(selectorIndex + 1) !== CharCode.Equal) {
              namespace = name;
              name = getName(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== CharCode.Equal) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === CharCode.Equal) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              selectorIndex += 1;
              const sectionStart = selectorIndex;
              while (selectorIndex < selector.length && selector.charCodeAt(selectorIndex) !== quote) {
                selectorIndex += selector.charCodeAt(selectorIndex) === CharCode.BackSlash ? 2 : 1;
              }
              if (selector.charCodeAt(selectorIndex) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(sectionStart, selectorIndex));
              selectorIndex += 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && !isWhitespace2(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== CharCode.RightSquareBracket) {
                selectorIndex += selector.charCodeAt(selectorIndex) === CharCode.BackSlash ? 2 : 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            switch (selector.charCodeAt(selectorIndex) | 32) {
              case CharCode.LowerI: {
                ignoreCase = true;
                stripWhitespace(1);
                break;
              }
              case CharCode.LowerS: {
                ignoreCase = false;
                stripWhitespace(1);
                break;
              }
            }
          }
          if (selector.charCodeAt(selectorIndex) !== CharCode.RightSquareBracket) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case CharCode.Colon: {
          if (selector.charCodeAt(selectorIndex + 1) === CharCode.Colon) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === CharCode.LeftParenthesis ? readValueWithParenthesis() : null
            });
            break;
          }
          const name = getName(1).toLowerCase();
          if (pseudosToPseudoElements.has(name)) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name,
              data: null
            });
            break;
          }
          let data2 = null;
          if (selector.charCodeAt(selectorIndex) === CharCode.LeftParenthesis) {
            if (unpackPseudos.has(name)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector(data2, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== CharCode.RightParenthesis) {
                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name, data: data2 });
          break;
        }
        case CharCode.Comma: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name;
          if (firstChar === CharCode.Asterisk) {
            selectorIndex += 1;
            name = "*";
          } else if (firstChar === CharCode.Pipe) {
            name = "";
            if (selector.charCodeAt(selectorIndex + 1) === CharCode.Pipe) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name = getName(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === CharCode.Pipe && selector.charCodeAt(selectorIndex + 1) !== CharCode.Pipe) {
            namespace = name;
            if (selector.charCodeAt(selectorIndex + 1) === CharCode.Asterisk) {
              name = "*";
              selectorIndex += 2;
            } else {
              name = getName(1);
            }
          }
          tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
// node_modules/css-what/dist/esm/stringify.js
var attribValueChars = ["\\", '"'];
var pseudoValueChars = [...attribValueChars, "(", ")"];
var charsToEscapeInAttributeValue = new Set(attribValueChars.map((c3) => c3.charCodeAt(0)));
var charsToEscapeInPseudoValue = new Set(pseudoValueChars.map((c3) => c3.charCodeAt(0)));
var charsToEscapeInName = new Set([
  ...pseudoValueChars,
  "~",
  "^",
  "$",
  "*",
  "+",
  "!",
  "|",
  ":",
  "[",
  "]",
  " ",
  ".",
  "%"
].map((c3) => c3.charCodeAt(0)));
// node_modules/@nativescript/core/ui/styling/css-selector.js
var MEDIA_QUERY_SEPARATOR = "&&";
var Combinator;
(function(Combinator2) {
  Combinator2["descendant"] = " ";
  Combinator2["child"] = ">";
  Combinator2["adjacent"] = "+";
  Combinator2["sibling"] = "~";
  Combinator2["parent"] = "<";
  Combinator2["column-combinator"] = "||";
})(Combinator || (Combinator = {}));
var AttributeSelectorOperator;
(function(AttributeSelectorOperator2) {
  AttributeSelectorOperator2["exists"] = "";
  AttributeSelectorOperator2["equals"] = "=";
  AttributeSelectorOperator2["start"] = "^=";
  AttributeSelectorOperator2["end"] = "$=";
  AttributeSelectorOperator2["any"] = "*=";
  AttributeSelectorOperator2["element"] = "~=";
  AttributeSelectorOperator2["hyphen"] = "|=";
})(AttributeSelectorOperator || (AttributeSelectorOperator = {}));
var Match;
(function(Match2) {
  Match2.Dynamic = true;
  Match2.Static = false;
})(Match || (Match = {}));
function eachNodePreviousGeneralSibling(node, callback) {
  if (!node.parent || !node.parent.getChildIndex || !node.parent.getChildAt || !node.parent.getChildrenCount) {
    return;
  }
  const nodeIndex = node.parent.getChildIndex(node);
  if (nodeIndex === 0) {
    return;
  }
  const count = node.parent.getChildrenCount();
  let retVal = true;
  for (let i4 = nodeIndex - 1;i4 >= 0 && retVal; i4--) {
    const sibling2 = node.parent.getChildAt(i4);
    retVal = callback(sibling2);
  }
}
function getNodePreviousDirectSibling(node) {
  if (!node.parent || !node.parent.getChildIndex || !node.parent.getChildAt) {
    return null;
  }
  const nodeIndex = node.parent.getChildIndex(node);
  if (nodeIndex === 0) {
    return null;
  }
  return node.parent.getChildAt(nodeIndex - 1);
}
function SelectorProperties(specificity, rarity, dynamic = false) {
  return (cls) => {
    cls.prototype.specificity = specificity;
    cls.prototype.rarity = rarity;
    cls.prototype.combinator = undefined;
    cls.prototype.dynamic = dynamic;
    return cls;
  };
}
function FunctionalPseudoClassProperties(specificity, rarity, pseudoSelectorListType) {
  return (cls) => {
    cls.prototype.specificity = specificity;
    cls.prototype.rarity = rarity;
    cls.prototype.combinator = undefined;
    cls.prototype.dynamic = false;
    cls.prototype.pseudoSelectorListType = pseudoSelectorListType;
    return cls;
  };
}

class SelectorBase {
}
var SelectorCore = class SelectorCore2 extends SelectorBase {
  lookupSort(sorter, base) {
    sorter.sortAsUniversal(base || this);
  }
};
SelectorCore = __decorate([
  SelectorProperties(0, 0, Match.Static)
], SelectorCore);
class SimpleSelector extends SelectorCore {
  accumulateChanges(node, map) {
    if (!this.dynamic) {
      return this.match(node);
    } else if (this.mayMatch(node)) {
      this.trackChanges(node, map);
      return true;
    }
    return false;
  }
  mayMatch(node) {
    return this.match(node);
  }
  trackChanges(node, map) {}
}
function wrap(text) {
  return text ? ` ${text} ` : "";
}
var InvalidSelector = class InvalidSelector2 extends SimpleSelector {
  constructor(e3) {
    super();
    this.e = e3;
  }
  toString() {
    return `<${this.e}>`;
  }
  match(node) {
    return false;
  }
  lookupSort(sorter, base) {}
};
InvalidSelector = __decorate([
  SelectorProperties(0, 4, Match.Static),
  __metadata("design:paramtypes", [Error])
], InvalidSelector);
var UniversalSelector = class UniversalSelector2 extends SimpleSelector {
  toString() {
    return `*${wrap(this.combinator)}`;
  }
  match(node) {
    return true;
  }
};
UniversalSelector = __decorate([
  SelectorProperties(0, 0, Match.Static)
], UniversalSelector);
var IdSelector = class IdSelector2 extends SimpleSelector {
  constructor(id) {
    super();
    this.id = id;
  }
  toString() {
    return `#${this.id}${wrap(this.combinator)}`;
  }
  match(node) {
    return node.id === this.id;
  }
  lookupSort(sorter, base) {
    sorter.sortById(this.id, base || this);
  }
};
IdSelector = __decorate([
  SelectorProperties(100, 3, Match.Static),
  __metadata("design:paramtypes", [String])
], IdSelector);
var TypeSelector = class TypeSelector2 extends SimpleSelector {
  constructor(cssType) {
    super();
    this.cssType = cssType;
  }
  toString() {
    return `${this.cssType}${wrap(this.combinator)}`;
  }
  match(node) {
    return node.cssType === this.cssType;
  }
  lookupSort(sorter, base) {
    sorter.sortByType(this.cssType, base || this);
  }
};
TypeSelector = __decorate([
  SelectorProperties(1, 1, Match.Static),
  __metadata("design:paramtypes", [String])
], TypeSelector);
var ClassSelector = class ClassSelector2 extends SimpleSelector {
  constructor(cssClass) {
    super();
    this.cssClass = cssClass;
  }
  toString() {
    return `.${this.cssClass}${wrap(this.combinator)}`;
  }
  match(node) {
    return node.cssClasses && node.cssClasses.has(this.cssClass);
  }
  lookupSort(sorter, base) {
    sorter.sortByClass(this.cssClass, base || this);
  }
};
ClassSelector = __decorate([
  SelectorProperties(10, 2, Match.Static),
  __metadata("design:paramtypes", [String])
], ClassSelector);
var AttributeSelector = class AttributeSelector2 extends SimpleSelector {
  constructor(attribute, test, value, ignoreCase) {
    super();
    this.attribute = attribute;
    this.test = test;
    this.value = value;
    this.ignoreCase = ignoreCase;
  }
  toString() {
    return `[${this.attribute}${wrap(AttributeSelectorOperator[this.test] ?? this.test)}${this.value || ""}]${wrap(this.combinator)}`;
  }
  match(node) {
    let attr = node[this.attribute];
    if (this.test === "exists") {
      return !isNullOrUndefined(attr);
    }
    if (!this.value) {
      return false;
    }
    attr += "";
    if (this.ignoreCase) {
      attr = attr.toLowerCase();
      this.value = this.value.toLowerCase();
    }
    if (this.test === "equals") {
      return attr === this.value;
    }
    if (this.test === "start") {
      return attr.startsWith(this.value);
    }
    if (this.test === "end") {
      return attr.endsWith(this.value);
    }
    if (this.test === "any") {
      return attr.indexOf(this.value) !== -1;
    }
    if (this.test === "element") {
      const words = attr.split(" ");
      return words && words.indexOf(this.value) !== -1;
    }
    if (this.test === "hyphen") {
      return attr === this.value || attr.startsWith(this.value + "-");
    }
    return false;
  }
  mayMatch(node) {
    return true;
  }
  trackChanges(node, map) {
    map.addAttribute(node, this.attribute);
  }
};
AttributeSelector = __decorate([
  SelectorProperties(10, 0, Match.Dynamic),
  __metadata("design:paramtypes", [String, String, String, Boolean])
], AttributeSelector);
var PseudoClassSelector = class PseudoClassSelector2 extends SimpleSelector {
  constructor(cssPseudoClass) {
    super();
    this.cssPseudoClass = cssPseudoClass;
  }
  toString() {
    return `:${this.cssPseudoClass}${wrap(this.combinator)}`;
  }
  match(node) {
    return node.cssPseudoClasses && node.cssPseudoClasses.has(this.cssPseudoClass);
  }
  mayMatch(node) {
    return true;
  }
  trackChanges(node, map) {
    map.addPseudoClass(node, this.cssPseudoClass);
  }
};
PseudoClassSelector = __decorate([
  SelectorProperties(10, 0, Match.Dynamic),
  __metadata("design:paramtypes", [String])
], PseudoClassSelector);
class FunctionalPseudoClassSelector extends PseudoClassSelector {
  constructor(cssPseudoClass, dataType) {
    super(cssPseudoClass);
    const selectors = [];
    const needsHighestSpecificity = this.specificity === -1;
    let specificity = 0;
    if (Array.isArray(dataType)) {
      for (const asts of dataType) {
        const selector = createSelectorFromAst(asts);
        if (selector instanceof InvalidSelector) {
          if (this.selectorListType !== 1) {
            selectors.splice(0);
            specificity = 0;
            break;
          }
          continue;
        }
        if (needsHighestSpecificity && selector.specificity > specificity) {
          specificity = selector.specificity;
        }
        selectors.push(selector);
      }
    }
    this.selectors = selectors;
    this.specificity = specificity;
    this.dynamic = this.selectors.some((sel) => sel.dynamic);
  }
  toString() {
    return `:${this.cssPseudoClass}(${this.selectors.join(", ")})${wrap(this.combinator)}`;
  }
  match(node) {
    return false;
  }
  mayMatch(node) {
    return true;
  }
  trackChanges(node, map) {
    this.selectors.forEach((sel) => sel.trackChanges(node, map));
  }
}
var NotFunctionalPseudoClassSelector = class NotFunctionalPseudoClassSelector2 extends FunctionalPseudoClassSelector {
  match(node) {
    return !this.selectors.some((sel) => sel.match(node));
  }
};
NotFunctionalPseudoClassSelector = __decorate([
  FunctionalPseudoClassProperties(-1, 0, 0)
], NotFunctionalPseudoClassSelector);
var IsFunctionalPseudoClassSelector = class IsFunctionalPseudoClassSelector2 extends FunctionalPseudoClassSelector {
  match(node) {
    return this.selectors.some((sel) => sel.match(node));
  }
  lookupSort(sorter, base) {
    if (this.selectors.length === 1) {
      this.selectors[0].lookupSort(sorter, base || this);
    } else {
      super.lookupSort(sorter, base || this);
    }
  }
};
IsFunctionalPseudoClassSelector = __decorate([
  FunctionalPseudoClassProperties(-1, 0, 1)
], IsFunctionalPseudoClassSelector);
var WhereFunctionalPseudoClassSelector = class WhereFunctionalPseudoClassSelector2 extends FunctionalPseudoClassSelector {
  match(node) {
    return this.selectors.some((sel) => sel.match(node));
  }
  lookupSort(sorter, base) {
    if (this.selectors.length === 1) {
      this.selectors[0].lookupSort(sorter, base || this);
    } else {
      super.lookupSort(sorter, base || this);
    }
  }
};
WhereFunctionalPseudoClassSelector = __decorate([
  FunctionalPseudoClassProperties(0, 0, 1)
], WhereFunctionalPseudoClassSelector);
class SimpleSelectorSequence extends SimpleSelector {
  constructor(selectors) {
    super();
    this.selectors = selectors;
    this.specificity = selectors.reduce((sum, sel) => sel.specificity + sum, 0);
    this.head = selectors.reduce((prev, curr) => !prev || curr.rarity > prev.rarity ? curr : prev, null);
    this.dynamic = selectors.some((sel) => sel.dynamic);
  }
  toString() {
    return `${this.selectors.join("")}${wrap(this.combinator)}`;
  }
  match(node) {
    return this.selectors.every((sel) => sel.match(node));
  }
  mayMatch(node) {
    return this.selectors.every((sel) => sel.mayMatch(node));
  }
  trackChanges(node, map) {
    this.selectors.forEach((sel) => sel.trackChanges(node, map));
  }
  lookupSort(sorter, base) {
    this.head.lookupSort(sorter, base || this);
  }
}

class ComplexSelector extends SelectorCore {
  constructor(selectors) {
    super();
    this.selectors = selectors;
    let siblingsToGroup;
    let currentGroup;
    const groups = [];
    this.specificity = 0;
    this.dynamic = false;
    for (let i4 = selectors.length - 1;i4 >= 0; i4--) {
      const sel = selectors[i4];
      switch (sel.combinator) {
        case undefined:
        case Combinator.descendant:
          siblingsToGroup = [];
          currentGroup = [siblingsToGroup];
          groups.push(currentGroup);
          break;
        case Combinator.child:
          siblingsToGroup = [];
          currentGroup.push(siblingsToGroup);
          break;
        case Combinator.adjacent:
        case Combinator.sibling:
          break;
        default:
          throw new Error(`Unsupported combinator "${sel.combinator}" for selector ${sel}.`);
      }
      this.specificity += sel.specificity;
      if (sel.dynamic) {
        this.dynamic = true;
      }
      siblingsToGroup.push(sel);
    }
    this.groups = groups.map((g3) => new Selector.ChildGroup(g3.map((selectors2) => selectors2.length > 1 ? new Selector.SiblingGroup(selectors2) : selectors2[0])));
    this.last = selectors[selectors.length - 1];
  }
  toString() {
    return this.selectors.join("");
  }
  match(node) {
    return this.groups.every((group, i4) => {
      if (i4 === 0) {
        node = group.getMatchingNode(node, true);
        return !!node;
      } else {
        let ancestor = node;
        while (ancestor = ancestor.parent ?? ancestor._modalParent) {
          if (node = group.getMatchingNode(ancestor, true)) {
            return true;
          }
        }
        return false;
      }
    });
  }
  mayMatch(node) {
    return false;
  }
  trackChanges(node, map) {
    this.selectors.forEach((sel) => sel.trackChanges(node, map));
  }
  lookupSort(sorter, base) {
    this.last.lookupSort(sorter, base || this);
  }
  accumulateChanges(node, map) {
    if (!this.dynamic) {
      return this.match(node);
    }
    const bounds = [];
    const mayMatch = this.groups.every((group, i4) => {
      if (i4 === 0) {
        const nextNode = group.getMatchingNode(node, false);
        bounds.push({ left: node, right: node });
        node = nextNode;
        return !!node;
      } else {
        let ancestor = node;
        while (ancestor = ancestor.parent) {
          const nextNode = group.getMatchingNode(ancestor, false);
          if (nextNode) {
            bounds.push({ left: ancestor, right: null });
            node = nextNode;
            return true;
          }
        }
        return false;
      }
    });
    if (!mayMatch) {
      return false;
    }
    if (!map) {
      return mayMatch;
    }
    for (let i4 = 0;i4 < this.groups.length; i4++) {
      const group = this.groups[i4];
      if (!group.dynamic) {
        continue;
      }
      const bound = bounds[i4];
      let node2 = bound.left;
      do {
        if (group.mayMatch(node2)) {
          group.trackChanges(node2, map);
        }
      } while (node2 !== bound.right && (node2 = node2.parent));
    }
    return mayMatch;
  }
}
var Selector;
(function(Selector2) {

  class ChildGroup extends SelectorBase {
    constructor(selectors) {
      super();
      this.selectors = selectors;
      this.dynamic = selectors.some((sel) => sel.dynamic);
    }
    getMatchingNode(node, strict) {
      const funcName = strict ? "match" : "mayMatch";
      return this.selectors.every((sel, i4) => (node = i4 === 0 ? node : node.parent) && sel[funcName](node)) ? node : null;
    }
    match(node) {
      return this.getMatchingNode(node, true) != null;
    }
    mayMatch(node) {
      return this.getMatchingNode(node, false) != null;
    }
    trackChanges(node, map) {
      this.selectors.forEach((sel, i4) => {
        if (i4 === 0) {
          node && sel.trackChanges(node, map);
        } else {
          node = node.parent;
          if (node && sel.mayMatch(node)) {
            sel.trackChanges(node, map);
          }
        }
      });
    }
  }
  Selector2.ChildGroup = ChildGroup;

  class SiblingGroup extends SelectorBase {
    constructor(selectors) {
      super();
      this.selectors = selectors;
      this.dynamic = selectors.some((sel) => sel.dynamic);
    }
    match(node) {
      return this.selectors.every((sel, i4) => {
        if (i4 === 0) {
          return node && sel.match(node);
        }
        if (sel.combinator === Combinator.adjacent) {
          node = getNodePreviousDirectSibling(node);
          return node && sel.match(node);
        }
        let isMatching = false;
        eachNodePreviousGeneralSibling(node, (sibling2) => {
          isMatching = sel.match(sibling2);
          return !isMatching;
        });
        return isMatching;
      });
    }
    mayMatch(node) {
      return this.selectors.every((sel, i4) => {
        if (i4 === 0) {
          return node && sel.mayMatch(node);
        }
        if (sel.combinator === Combinator.adjacent) {
          node = getNodePreviousDirectSibling(node);
          return node && sel.mayMatch(node);
        }
        let isMatching = false;
        eachNodePreviousGeneralSibling(node, (sibling2) => {
          isMatching = sel.mayMatch(sibling2);
          return !isMatching;
        });
        return isMatching;
      });
    }
    trackChanges(node, map) {
      this.selectors.forEach((sel, i4) => {
        if (i4 === 0) {
          if (node) {
            sel.trackChanges(node, map);
          }
        } else {
          if (sel.combinator === Combinator.adjacent) {
            node = getNodePreviousDirectSibling(node);
            if (node && sel.mayMatch(node)) {
              sel.trackChanges(node, map);
            }
          } else {
            let matchingSibling;
            eachNodePreviousGeneralSibling(node, (sibling2) => {
              const isMatching = sel.mayMatch(sibling2);
              if (isMatching) {
                matchingSibling = sibling2;
              }
              return !isMatching;
            });
            if (matchingSibling) {
              sel.trackChanges(matchingSibling, map);
            }
          }
        }
      });
    }
  }
  Selector2.SiblingGroup = SiblingGroup;
})(Selector || (Selector = {}));

class RuleSet {
  constructor(selectors, declarations) {
    this.selectors = selectors;
    this.declarations = declarations;
    this.selectors.forEach((sel) => sel.ruleset = this);
  }
  toString() {
    let desc = `${this.selectors.join(", ")} {${this.declarations.map((d3, i4) => `${i4 === 0 ? " " : ""}${d3.property}: ${d3.value}`).join("; ")} }`;
    if (this.mediaQueryString) {
      desc = `@media ${this.mediaQueryString} { ${desc} }`;
    }
    return desc;
  }
  lookupSort(sorter) {
    this.selectors.forEach((sel) => sel.lookupSort(sorter));
  }
}
function fromAstNode(astRule) {
  const declarations = astRule.declarations.filter(isDeclaration).map(createDeclaration);
  const selectors = astRule.selectors.map(createSelector);
  return new RuleSet(selectors, declarations);
}
function createDeclaration(decl) {
  return { property: isCssVariable(decl.property) ? decl.property : decl.property.toLowerCase(), value: decl.value };
}
function createSimpleSelectorFromAst(ast) {
  if (ast.type === "attribute") {
    if (ast.name === "class") {
      return new ClassSelector(ast.value);
    }
    if (ast.name === "id") {
      return new IdSelector(ast.value);
    }
    return new AttributeSelector(ast.name, ast.action, ast.value, !!ast.ignoreCase);
  }
  if (ast.type === "tag") {
    return new TypeSelector(ast.name.replace("-", "").toLowerCase());
  }
  if (ast.type === "pseudo") {
    if (ast.name === "is") {
      return new IsFunctionalPseudoClassSelector(ast.name, ast.data);
    }
    if (ast.name === "where") {
      return new WhereFunctionalPseudoClassSelector(ast.name, ast.data);
    }
    if (ast.name === "not") {
      return new NotFunctionalPseudoClassSelector(ast.name, ast.data);
    }
    return new PseudoClassSelector(ast.name);
  }
  if (ast.type === "universal") {
    return new UniversalSelector;
  }
  return new InvalidSelector(new Error(ast.type));
}
function createSimpleSelectorSequenceFromAst(asts) {
  if (asts.length === 0) {
    return new InvalidSelector(new Error("Empty simple selector sequence."));
  }
  if (asts.length === 1) {
    return createSimpleSelectorFromAst(asts[0]);
  }
  const sequenceSelectors = [];
  for (const ast of asts) {
    const selector = createSimpleSelectorFromAst(ast);
    if (selector instanceof InvalidSelector) {
      return selector;
    }
    sequenceSelectors.push(selector);
  }
  return new SimpleSelectorSequence(sequenceSelectors);
}
function createSelectorFromAst(asts) {
  let result;
  if (asts.length === 0) {
    return new InvalidSelector(new Error("Empty selector."));
  }
  if (asts.length === 1) {
    return createSimpleSelectorFromAst(asts[0]);
  }
  const simpleSelectorSequences = [];
  let sequenceAsts = [];
  let combinatorCount = 0;
  for (const ast of asts) {
    const combinator = Combinator[ast.type];
    if (combinator != null) {
      const selector = createSimpleSelectorSequenceFromAst(sequenceAsts);
      if (selector instanceof InvalidSelector) {
        return selector;
      }
      selector.combinator = combinator;
      simpleSelectorSequences.push(selector);
      combinatorCount++;
      sequenceAsts = [];
    } else {
      sequenceAsts.push(ast);
    }
  }
  if (combinatorCount > 0) {
    if (sequenceAsts.length) {
      const selector = createSimpleSelectorSequenceFromAst(sequenceAsts);
      if (selector instanceof InvalidSelector) {
        return selector;
      }
      simpleSelectorSequences.push(selector);
    }
    return new ComplexSelector(simpleSelectorSequences);
  }
  return createSimpleSelectorSequenceFromAst(sequenceAsts);
}
function createSelector(sel) {
  try {
    const result = parse6(sel);
    if (!result?.length) {
      return new InvalidSelector(new Error("Empty selector"));
    }
    return createSelectorFromAst(result[0]);
  } catch (e3) {
    return new InvalidSelector(e3);
  }
}
function isDeclaration(node) {
  return node.type === "declaration";
}
function matchMediaQueryString(mediaQueryString, cachedQueries) {
  const mediaQueryStrings = mediaQueryString.split(MEDIA_QUERY_SEPARATOR);
  return mediaQueryStrings.every((mq) => {
    let isMatching;
    if (cachedQueries.includes(mq)) {
      isMatching = true;
    } else {
      isMatching = checkIfMediaQueryMatches(mq);
      if (isMatching) {
        cachedQueries.push(mq);
      }
    }
    return isMatching;
  });
}

class SelectorScope {
  constructor() {
    this.id = {};
    this.class = {};
    this.type = {};
    this.universal = [];
    this.position = 0;
  }
  getSelectorCandidates(node) {
    const { cssClasses: cssClasses2, id, cssType } = node;
    const selectorClasses = [this.universal, this.id[id], this.type[cssType]];
    if (cssClasses2 && cssClasses2.size) {
      cssClasses2.forEach((c3) => selectorClasses.push(this.class[c3]));
    }
    return selectorClasses.reduce((cur, next) => cur.concat(next || []), []);
  }
  sortById(id, sel) {
    this.addToMap(this.id, id, sel);
  }
  sortByClass(cssClass, sel) {
    this.addToMap(this.class, cssClass, sel);
  }
  sortByType(cssType, sel) {
    this.addToMap(this.type, cssType, sel);
  }
  sortAsUniversal(sel) {
    this.universal.push(this.makeDocSelector(sel));
  }
  addToMap(map, head, sel) {
    if (!map[head]) {
      map[head] = [];
    }
    map[head].push(this.makeDocSelector(sel));
  }
  makeDocSelector(sel) {
    sel.pos = this.position++;
    return sel;
  }
}

class MediaQuerySelectorScope extends SelectorScope {
  constructor(mediaQueryString) {
    super();
    this._mediaQueryString = mediaQueryString;
  }
  get mediaQueryString() {
    return this._mediaQueryString;
  }
}

class StyleSheetSelectorScope extends SelectorScope {
  constructor(rulesets) {
    super();
    this.lookupRulesets(rulesets);
  }
  createMediaQuerySelectorScope(mediaQueryString) {
    const selectorScope = new MediaQuerySelectorScope(mediaQueryString);
    selectorScope.position = this.position;
    if (this.mediaQuerySelectorScopes) {
      this.mediaQuerySelectorScopes.push(selectorScope);
    } else {
      this.mediaQuerySelectorScopes = [selectorScope];
    }
    return selectorScope;
  }
  lookupRulesets(rulesets) {
    let lastMediaSelectorScope;
    for (let i4 = 0, length = rulesets.length;i4 < length; i4++) {
      const ruleset = rulesets[i4];
      if (lastMediaSelectorScope && lastMediaSelectorScope.mediaQueryString !== ruleset.mediaQueryString) {
        this.position = lastMediaSelectorScope.position;
        lastMediaSelectorScope = null;
      }
      if (ruleset.mediaQueryString) {
        if (!lastMediaSelectorScope) {
          lastMediaSelectorScope = this.createMediaQuerySelectorScope(ruleset.mediaQueryString);
        }
        ruleset.lookupSort(lastMediaSelectorScope);
      } else {
        ruleset.lookupSort(this);
      }
    }
    if (lastMediaSelectorScope) {
      this.position = lastMediaSelectorScope.position;
      lastMediaSelectorScope = null;
    }
  }
  query(node) {
    const selectorsMatch = new SelectorsMatch;
    const selectors = this.getSelectorCandidates(node);
    if (this.mediaQuerySelectorScopes) {
      const validatedMediaQueries = [];
      for (let i4 = 0, length = this.mediaQuerySelectorScopes.length;i4 < length; i4++) {
        const selectorScope = this.mediaQuerySelectorScopes[i4];
        const isMatchingAllQueries = matchMediaQueryString(selectorScope.mediaQueryString, validatedMediaQueries);
        if (isMatchingAllQueries) {
          const mediaQuerySelectors = selectorScope.getSelectorCandidates(node);
          selectors.push(...mediaQuerySelectors);
        }
      }
    }
    selectorsMatch.selectors = selectors.filter((sel) => sel.accumulateChanges(node, selectorsMatch)).sort((a3, b2) => a3.specificity - b2.specificity || a3.pos - b2.pos);
    return selectorsMatch;
  }
}

class SelectorsMatch {
  constructor() {
    this.changeMap = new Map;
  }
  addAttribute(node, attribute) {
    const deps = this.properties(node);
    if (!deps.attributes) {
      deps.attributes = new Set;
    }
    deps.attributes.add(attribute);
  }
  addPseudoClass(node, pseudoClass) {
    const deps = this.properties(node);
    if (!deps.pseudoClasses) {
      deps.pseudoClasses = new Set;
    }
    deps.pseudoClasses.add(pseudoClass);
  }
  properties(node) {
    let set2 = this.changeMap.get(node);
    if (!set2) {
      this.changeMap.set(node, set2 = {});
    }
    return set2;
  }
}
// node_modules/@nativescript/core/ui/animation/animation-common.js
var Properties;
(function(Properties2) {
  Properties2.opacity = "opacity";
  Properties2.backgroundColor = "backgroundColor";
  Properties2.translate = "translate";
  Properties2.rotate = "rotate";
  Properties2.scale = "scale";
  Properties2.height = "height";
  Properties2.width = "width";
})(Properties || (Properties = {}));

class AnimationBase {
  constructor(animationDefinitions, playSequentially) {
    if (!animationDefinitions || animationDefinitions.length === 0) {
      console.error("No animation definitions specified");
      return;
    }
    if (Trace.isEnabled()) {
      Trace.write("Analyzing " + animationDefinitions.length + " animation definitions...", Trace.categories.Animation);
    }
    this._propertyAnimations = new Array;
    for (let i4 = 0, length = animationDefinitions.length;i4 < length; i4++) {
      if (animationDefinitions[i4].curve) {
        animationDefinitions[i4].curve = this._resolveAnimationCurve(animationDefinitions[i4].curve);
      }
      this._propertyAnimations = this._propertyAnimations.concat(AnimationBase._createPropertyAnimations(animationDefinitions[i4]));
    }
    if (this._propertyAnimations.length === 0) {
      if (Trace.isEnabled()) {
        Trace.write("Nothing to animate.", Trace.categories.Animation);
      }
      return;
    }
    if (Trace.isEnabled()) {
      Trace.write("Created " + this._propertyAnimations.length + " individual property animations.", Trace.categories.Animation);
    }
    this._playSequentially = playSequentially;
  }
  _rejectAlreadyPlaying() {
    const reason = "Animation is already playing.";
    Trace.write(reason, Trace.categories.Animation, Trace.messageType.warn);
    return new Promise((resolve, reject) => {
      reject(reason);
    });
  }
  play() {
    const animationFinishedPromise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this.fixupAnimationPromise(animationFinishedPromise);
    this._isPlaying = true;
    return animationFinishedPromise;
  }
  fixupAnimationPromise(promise) {
    const _this = this;
    promise.cancel = () => {
      _this.cancel();
    };
    const _then = promise.then;
    promise.then = function() {
      const r3 = _then.apply(promise, arguments);
      _this.fixupAnimationPromise(r3);
      return r3;
    };
    const _catch = promise.catch;
    promise.catch = function() {
      const r3 = _catch.apply(promise, arguments);
      _this.fixupAnimationPromise(r3);
      return r3;
    };
  }
  cancel() {}
  get isPlaying() {
    return this._isPlaying;
  }
  _resolveAnimationFinishedPromise() {
    this._isPlaying = false;
    this._resolve();
  }
  _rejectAnimationFinishedPromise() {
    this._isPlaying = false;
    this._reject(new Error("Animation cancelled."));
  }
  static _createPropertyAnimations(animationDefinition) {
    if (!animationDefinition.target) {
      console.error("No animation target specified.");
      return;
    }
    for (const item in animationDefinition) {
      const value = animationDefinition[item];
      if (value === undefined) {
        continue;
      }
      if ((item === Properties.opacity || item === "duration" || item === "delay" || item === "iterations") && typeof value !== "number") {
        console.error(`Property ${item} must be valid number. Value: ${value}`);
        return;
      } else if ((item === Properties.scale || item === Properties.translate) && (typeof value.x !== "number" || typeof value.y !== "number")) {
        console.error(`Property ${item} must be valid Pair. Value: ${value}`);
        return;
      } else if (item === Properties.backgroundColor && !Color.isValid(animationDefinition.backgroundColor)) {
        console.error(`Property ${item} must be valid color. Value: ${value}`);
        return;
      } else if (item === Properties.width || item === Properties.height) {
        animationDefinition[item] = PercentLength.parse(value);
      } else if (item === Properties.rotate) {
        const rotate = value;
        if (typeof rotate !== "number" && !(typeof rotate.x === "number" && typeof rotate.y === "number" && typeof rotate.z === "number")) {
          console.error(`Property ${rotate} must be valid number or Point3D. Value: ${value}`);
          return;
        }
      }
    }
    const propertyAnimations = new Array;
    if (animationDefinition.opacity !== undefined) {
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.opacity,
        value: animationDefinition.opacity,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (animationDefinition.backgroundColor !== undefined) {
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.backgroundColor,
        value: typeof animationDefinition.backgroundColor === "string" ? new Color(animationDefinition.backgroundColor) : animationDefinition.backgroundColor,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (animationDefinition.translate !== undefined) {
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.translate,
        value: animationDefinition.translate,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (animationDefinition.scale !== undefined) {
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.scale,
        value: animationDefinition.scale,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (animationDefinition.rotate !== undefined) {
      let rotationValue;
      if (typeof animationDefinition.rotate === "number") {
        rotationValue = { x: 0, y: 0, z: animationDefinition.rotate };
      } else {
        rotationValue = animationDefinition.rotate;
      }
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.rotate,
        value: rotationValue,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (animationDefinition.height !== undefined) {
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.height,
        value: animationDefinition.height,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (animationDefinition.width !== undefined) {
      propertyAnimations.push({
        target: animationDefinition.target,
        property: Properties.width,
        value: animationDefinition.width,
        duration: animationDefinition.duration,
        delay: animationDefinition.delay,
        iterations: animationDefinition.iterations,
        curve: animationDefinition.curve
      });
    }
    if (propertyAnimations.length === 0) {
      console.error("No known animation properties specified");
    }
    return propertyAnimations;
  }
  static _getAnimationInfo(animation) {
    return JSON.stringify({
      target: animation.target.id,
      property: animation.property,
      value: animation.value,
      duration: animation.duration,
      delay: animation.delay,
      iterations: animation.iterations,
      curve: animation.curve
    });
  }
}

// node_modules/@nativescript/core/ui/animation/index.android.js
var argbEvaluator;
function ensureArgbEvaluator() {
  if (!argbEvaluator) {
    argbEvaluator = new android.animation.ArgbEvaluator;
  }
}
var easeIn = lazy(() => new android.view.animation.AccelerateInterpolator(1));
var easeOut = lazy(() => new android.view.animation.DecelerateInterpolator(1));
var easeInOut = lazy(() => new android.view.animation.AccelerateDecelerateInterpolator);
var linear = lazy(() => new android.view.animation.LinearInterpolator);
var bounce = lazy(() => new android.view.animation.BounceInterpolator);
function _resolveAnimationCurve(curve) {
  switch (curve) {
    case "easeIn":
      if (Trace.isEnabled()) {
        Trace.write("Animation curve resolved to android.view.animation.AccelerateInterpolator(1).", Trace.categories.Animation);
      }
      return easeIn();
    case "easeOut":
      if (Trace.isEnabled()) {
        Trace.write("Animation curve resolved to android.view.animation.DecelerateInterpolator(1).", Trace.categories.Animation);
      }
      return easeOut();
    case "easeInOut":
      if (Trace.isEnabled()) {
        Trace.write("Animation curve resolved to android.view.animation.AccelerateDecelerateInterpolator().", Trace.categories.Animation);
      }
      return easeInOut();
    case "linear":
      if (Trace.isEnabled()) {
        Trace.write("Animation curve resolved to android.view.animation.LinearInterpolator().", Trace.categories.Animation);
      }
      return linear();
    case "spring":
      if (Trace.isEnabled()) {
        Trace.write("Animation curve resolved to android.view.animation.BounceInterpolator().", Trace.categories.Animation);
      }
      return bounce();
    case "ease":
      return androidx.core.view.animation.PathInterpolatorCompat.create(0.25, 0.1, 0.25, 1);
    default:
      if (Trace.isEnabled()) {
        Trace.write("Animation curve resolved to original: " + curve, Trace.categories.Animation);
      }
      if (curve instanceof CubicBezierAnimationCurve) {
        return androidx.core.view.animation.PathInterpolatorCompat.create(curve.x1, curve.y1, curve.x2, curve.y2);
      } else if (curve && curve.getInterpolation) {
        return curve;
      } else if (curve instanceof android.view.animation.LinearInterpolator) {
        return curve;
      } else {
        throw new Error(`Invalid animation curve: ${curve}`);
      }
  }
}
function getAndroidRepeatCount(iterations) {
  return iterations === Number.POSITIVE_INFINITY ? android.view.animation.Animation.INFINITE : iterations - 1;
}
function createObjectAnimator(nativeView, propertyName, value) {
  const arr = Array.create("float", 1);
  arr[0] = value;
  return android.animation.ObjectAnimator.ofFloat(nativeView, propertyName, arr);
}
function createAnimationSet(animators, iterations) {
  iterations = getAndroidRepeatCount(iterations);
  const animatorSet = new android.animation.AnimatorSet;
  const animatorsArray = Array.create(android.animation.Animator, animators.length);
  animators.forEach((animator, index) => {
    animatorsArray[index] = animator;
    animatorsArray[index].setRepeatCount(iterations);
  });
  animatorSet.playTogether(animatorsArray);
  animatorSet.setupStartValues();
  return animatorSet;
}

class Animation extends AnimationBase {
  constructor(animationDefinitions, playSequentially) {
    super(animationDefinitions, playSequentially);
    this._resetOnFinish = true;
    this._valueSource = "animation";
    if (animationDefinitions.length > 0 && animationDefinitions[0].valueSource !== undefined) {
      this._valueSource = animationDefinitions[0].valueSource;
    }
    const that = new WeakRef(this);
    this._animatorListener = new android.animation.Animator.AnimatorListener({
      onAnimationStart: function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("MainAnimatorListener.onAndroidAnimationStart(" + animator + ")", Trace.categories.Animation);
        }
      },
      onAnimationRepeat: function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("MainAnimatorListener.onAnimationRepeat(" + animator + ")", Trace.categories.Animation);
        }
      },
      onAnimationEnd: function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("MainAnimatorListener.onAnimationEnd(" + animator + ")", Trace.categories.Animation);
        }
        const thisRef = that?.get();
        if (thisRef) {
          thisRef._onAndroidAnimationEnd();
        }
      },
      onAnimationCancel: function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("MainAnimatorListener.onAnimationCancel(" + animator + ")", Trace.categories.Animation);
        }
        const thisRef = that?.get();
        if (thisRef) {
          thisRef._onAndroidAnimationCancel();
        }
      }
    });
  }
  play(resetOnFinish) {
    if (resetOnFinish !== undefined) {
      this._resetOnFinish = resetOnFinish;
    }
    if (this.isPlaying) {
      return this._rejectAlreadyPlaying();
    }
    const animationFinishedPromise = super.play();
    if (!this._animatorSet) {
      this._animators = new Array;
      this._propertyUpdateCallbacks = new Array;
      this._propertyResetCallbacks = new Array;
      for (let i4 = 0, length = this._propertyAnimations.length;i4 < length; i4++) {
        this._createAnimators(this._propertyAnimations[i4]);
      }
      this._nativeAnimatorsArray = Array.create(android.animation.Animator, this._animators.length);
      for (let i4 = 0, length = this._animators.length;i4 < length; i4++) {
        this._nativeAnimatorsArray[i4] = this._animators[i4];
      }
      this._animatorSet = new android.animation.AnimatorSet;
      this._animatorSet.addListener(this._animatorListener);
    }
    this._play();
    return animationFinishedPromise;
  }
  cancel() {
    if (!this.isPlaying) {
      Trace.write("Animation is not currently playing.", Trace.categories.Animation, Trace.messageType.warn);
      return;
    }
    Trace.write("Cancelling AnimatorSet.", Trace.categories.Animation);
    this._animatorSet.cancel();
  }
  _resolveAnimationCurve(curve) {
    return _resolveAnimationCurve(curve);
  }
  _play() {
    if (SDK_VERSION <= 23) {
      this._animatorSet = new android.animation.AnimatorSet;
      this._animatorSet.addListener(this._animatorListener);
    }
    if (this._animators.length > 0) {
      if (this._playSequentially) {
        this._animatorSet.playSequentially(this._nativeAnimatorsArray);
      } else {
        this._animatorSet.playTogether(this._nativeAnimatorsArray);
      }
    }
    if (Trace.isEnabled()) {
      Trace.write("Starting " + this._nativeAnimatorsArray.length + " animations " + (this._playSequentially ? "sequentially." : "together."), Trace.categories.Animation);
    }
    this._animatorSet.setupStartValues();
    this._animatorSet.start();
  }
  _onAndroidAnimationEnd() {
    if (!this.isPlaying) {
      return;
    }
    this._propertyUpdateCallbacks.forEach((v) => v());
    this._resolveAnimationFinishedPromise();
    if (this._resetOnFinish && this._target) {
      this._target._removeAnimation(this);
    }
  }
  _onAndroidAnimationCancel() {
    this._propertyResetCallbacks.forEach((v) => v());
    this._resolveAnimationFinishedPromise();
    if (this._target) {
      this._target._removeAnimation(this);
    }
  }
  _createAnimators(propertyAnimation) {
    if (!propertyAnimation.target.nativeViewProtected) {
      return;
    }
    if (Trace.isEnabled()) {
      Trace.write("Creating ObjectAnimator(s) for animation: " + Animation._getAnimationInfo(propertyAnimation) + "...", Trace.categories.Animation);
    }
    if (propertyAnimation.target === null || propertyAnimation.target === undefined) {
      throw new Error(`Animation target cannot be null or undefined; property: ${propertyAnimation.property}; value: ${propertyAnimation.value};`);
    }
    if (propertyAnimation.property === null || propertyAnimation.property === undefined) {
      throw new Error(`Animation property cannot be null or undefined; target: ${propertyAnimation.target}; value: ${propertyAnimation.value};`);
    }
    if (propertyAnimation.value === null || propertyAnimation.value === undefined) {
      throw new Error(`Animation value cannot be null or undefined; target: ${propertyAnimation.target}; property: ${propertyAnimation.property};`);
    }
    this._target = propertyAnimation.target;
    const nativeView = propertyAnimation.target.nativeViewProtected;
    const animators = new Array;
    const propertyUpdateCallbacks = new Array;
    const propertyResetCallbacks = new Array;
    let originalValue1;
    let originalValue2;
    let originalValue3;
    const density2 = layout.getDisplayDensity();
    const setLocal = this._valueSource === "animation";
    const style = propertyAnimation.target.style;
    switch (propertyAnimation.property) {
      case Properties.opacity:
        opacityProperty._initDefaultNativeValue(style);
        originalValue1 = nativeView.getAlpha();
        propertyUpdateCallbacks.push(() => {
          propertyAnimation.target.style[setLocal ? opacityProperty.name : opacityProperty.keyframe] = propertyAnimation.value;
        });
        propertyResetCallbacks.push(() => {
          if (setLocal) {
            propertyAnimation.target.style[opacityProperty.name] = originalValue1;
          } else {
            propertyAnimation.target.style[opacityProperty.keyframe] = originalValue1;
          }
          if (propertyAnimation.target.nativeViewProtected) {
            propertyAnimation.target[opacityProperty.setNative](propertyAnimation.target.style.opacity);
          }
        });
        animators.push(createObjectAnimator(nativeView, "alpha", propertyAnimation.value));
        break;
      case Properties.backgroundColor: {
        backgroundColorProperty._initDefaultNativeValue(style);
        ensureArgbEvaluator();
        originalValue1 = propertyAnimation.target.backgroundColor;
        const nativeArray = Array.create(java.lang.Object, 2);
        nativeArray[0] = propertyAnimation.target.backgroundColor ? java.lang.Integer.valueOf(propertyAnimation.target.backgroundColor.argb) : java.lang.Integer.valueOf(-1);
        nativeArray[1] = java.lang.Integer.valueOf(propertyAnimation.value.argb);
        const animator = android.animation.ValueAnimator.ofObject(argbEvaluator, nativeArray);
        animator.addUpdateListener(new android.animation.ValueAnimator.AnimatorUpdateListener({
          onAnimationUpdate(animator2) {
            const argb = animator2.getAnimatedValue().intValue();
            propertyAnimation.target.style[setLocal ? backgroundColorProperty.name : backgroundColorProperty.keyframe] = new Color(argb);
          }
        }));
        propertyUpdateCallbacks.push(() => {
          propertyAnimation.target.style[setLocal ? backgroundColorProperty.name : backgroundColorProperty.keyframe] = propertyAnimation.value;
        });
        propertyResetCallbacks.push(() => {
          if (setLocal) {
            propertyAnimation.target.style[backgroundColorProperty.name] = originalValue1;
          } else {
            propertyAnimation.target.style[backgroundColorProperty.keyframe] = originalValue1;
          }
          if (propertyAnimation.target.nativeViewProtected && propertyAnimation.target[backgroundColorProperty.setNative]) {
            propertyAnimation.target[backgroundColorProperty.setNative](propertyAnimation.target.style.backgroundColor);
          }
        });
        animators.push(animator);
        break;
      }
      case Properties.translate:
        translateXProperty._initDefaultNativeValue(style);
        translateYProperty._initDefaultNativeValue(style);
        originalValue1 = nativeView.getTranslationX() / density2;
        originalValue2 = nativeView.getTranslationY() / density2;
        propertyUpdateCallbacks.push(() => {
          propertyAnimation.target.style[setLocal ? translateXProperty.name : translateXProperty.keyframe] = propertyAnimation.value.x;
          propertyAnimation.target.style[setLocal ? translateYProperty.name : translateYProperty.keyframe] = propertyAnimation.value.y;
        });
        propertyResetCallbacks.push(() => {
          if (setLocal) {
            propertyAnimation.target.style[translateXProperty.name] = originalValue1;
            propertyAnimation.target.style[translateYProperty.name] = originalValue2;
          } else {
            propertyAnimation.target.style[translateXProperty.keyframe] = originalValue1;
            propertyAnimation.target.style[translateYProperty.keyframe] = originalValue2;
          }
          if (propertyAnimation.target.nativeViewProtected) {
            propertyAnimation.target[translateXProperty.setNative](propertyAnimation.target.style.translateX);
            propertyAnimation.target[translateYProperty.setNative](propertyAnimation.target.style.translateY);
          }
        });
        animators.push(createAnimationSet([createObjectAnimator(nativeView, "translationX", propertyAnimation.value.x * density2), createObjectAnimator(nativeView, "translationY", propertyAnimation.value.y * density2)], propertyAnimation.iterations));
        break;
      case Properties.scale:
        scaleXProperty._initDefaultNativeValue(style);
        scaleYProperty._initDefaultNativeValue(style);
        originalValue1 = nativeView.getScaleX();
        originalValue2 = nativeView.getScaleY();
        propertyUpdateCallbacks.push(() => {
          propertyAnimation.target.style[setLocal ? scaleXProperty.name : scaleXProperty.keyframe] = propertyAnimation.value.x;
          propertyAnimation.target.style[setLocal ? scaleYProperty.name : scaleYProperty.keyframe] = propertyAnimation.value.y;
        });
        propertyResetCallbacks.push(() => {
          if (setLocal) {
            propertyAnimation.target.style[scaleXProperty.name] = originalValue1;
            propertyAnimation.target.style[scaleYProperty.name] = originalValue2;
          } else {
            propertyAnimation.target.style[scaleXProperty.keyframe] = originalValue1;
            propertyAnimation.target.style[scaleYProperty.keyframe] = originalValue2;
          }
          if (propertyAnimation.target.nativeViewProtected) {
            propertyAnimation.target[scaleXProperty.setNative](propertyAnimation.target.style.scaleX);
            propertyAnimation.target[scaleYProperty.setNative](propertyAnimation.target.style.scaleY);
          }
        });
        animators.push(createAnimationSet([createObjectAnimator(nativeView, "scaleX", propertyAnimation.value.x), createObjectAnimator(nativeView, "scaleY", propertyAnimation.value.y)], propertyAnimation.iterations));
        break;
      case Properties.rotate:
        rotateProperty._initDefaultNativeValue(style);
        rotateXProperty._initDefaultNativeValue(style);
        rotateYProperty._initDefaultNativeValue(style);
        originalValue1 = nativeView.getRotationX();
        originalValue2 = nativeView.getRotationY();
        originalValue3 = nativeView.getRotation();
        propertyUpdateCallbacks.push(() => {
          propertyAnimation.target.style[setLocal ? rotateXProperty.name : rotateXProperty.keyframe] = propertyAnimation.value.x;
          propertyAnimation.target.style[setLocal ? rotateYProperty.name : rotateYProperty.keyframe] = propertyAnimation.value.y;
          propertyAnimation.target.style[setLocal ? rotateProperty.name : rotateProperty.keyframe] = propertyAnimation.value.z;
        });
        propertyResetCallbacks.push(() => {
          if (setLocal) {
            propertyAnimation.target.style[rotateXProperty.name] = originalValue1;
            propertyAnimation.target.style[rotateYProperty.name] = originalValue2;
            propertyAnimation.target.style[rotateProperty.name] = originalValue3;
          } else {
            propertyAnimation.target.style[rotateXProperty.keyframe] = originalValue1;
            propertyAnimation.target.style[rotateYProperty.keyframe] = originalValue2;
            propertyAnimation.target.style[rotateProperty.keyframe] = originalValue3;
          }
          if (propertyAnimation.target.nativeViewProtected) {
            propertyAnimation.target[rotateProperty.setNative](propertyAnimation.target.style.rotate);
            propertyAnimation.target[rotateXProperty.setNative](propertyAnimation.target.style.rotateX);
            propertyAnimation.target[rotateYProperty.setNative](propertyAnimation.target.style.rotateY);
          }
        });
        animators.push(createAnimationSet([createObjectAnimator(nativeView, "rotationX", propertyAnimation.value.x), createObjectAnimator(nativeView, "rotationY", propertyAnimation.value.y), createObjectAnimator(nativeView, "rotation", propertyAnimation.value.z)], propertyAnimation.iterations));
        break;
      case Properties.width:
      case Properties.height: {
        const isVertical = propertyAnimation.property === "height";
        const extentProperty = isVertical ? heightProperty : widthProperty;
        extentProperty._initDefaultNativeValue(style);
        const nativeArray = Array.create("float", 2);
        let toValue = propertyAnimation.value;
        const parent = propertyAnimation.target.parent;
        if (!parent) {
          throw new Error(`cannot animate ${propertyAnimation.property} on root view`);
        }
        const parentExtent = isVertical ? parent.getMeasuredHeight() : parent.getMeasuredWidth();
        toValue = PercentLength.toDevicePixels(toValue, parentExtent, parentExtent) / Screen.mainScreen.scale;
        const nativeHeight = isVertical ? nativeView.getHeight() : nativeView.getWidth();
        const targetStyle = setLocal ? extentProperty.name : extentProperty.keyframe;
        originalValue1 = nativeHeight / Screen.mainScreen.scale;
        nativeArray[0] = originalValue1;
        nativeArray[1] = toValue;
        const extentAnimator = android.animation.ValueAnimator.ofFloat(nativeArray);
        extentAnimator.addUpdateListener(new android.animation.ValueAnimator.AnimatorUpdateListener({
          onAnimationUpdate(animator) {
            const argb = animator.getAnimatedValue().floatValue();
            propertyAnimation.target.style[setLocal ? extentProperty.name : extentProperty.keyframe] = argb;
          }
        }));
        propertyUpdateCallbacks.push(() => {
          propertyAnimation.target.style[targetStyle] = propertyAnimation.value;
        });
        propertyResetCallbacks.push(() => {
          propertyAnimation.target.style[targetStyle] = originalValue1;
          if (propertyAnimation.target.nativeViewProtected) {
            const setter = propertyAnimation.target[extentProperty.setNative];
            setter(propertyAnimation.target.style[propertyAnimation.property]);
          }
        });
        animators.push(extentAnimator);
        break;
      }
      default:
        throw new Error(`Animating property '${propertyAnimation.property}' is unsupported`);
    }
    for (let i4 = 0, length = animators.length;i4 < length; i4++) {
      if (propertyAnimation.duration !== undefined) {
        animators[i4].setDuration(propertyAnimation.duration);
      }
      if (propertyAnimation.delay !== undefined) {
        animators[i4].setStartDelay(propertyAnimation.delay);
      }
      if (propertyAnimation.iterations !== undefined && animators[i4] instanceof android.animation.ValueAnimator) {
        animators[i4].setRepeatCount(getAndroidRepeatCount(propertyAnimation.iterations));
      }
      if (propertyAnimation.curve !== undefined) {
        animators[i4].setInterpolator(propertyAnimation.curve);
      }
      if (Trace.isEnabled()) {
        Trace.write("Animator created: " + animators[i4], Trace.categories.Animation);
      }
    }
    this._animators = this._animators.concat(animators);
    this._propertyUpdateCallbacks = this._propertyUpdateCallbacks.concat(propertyUpdateCallbacks);
    this._propertyResetCallbacks = this._propertyResetCallbacks.concat(propertyResetCallbacks);
  }
}

// node_modules/@nativescript/core/ui/animation/keyframe-animation.js
class KeyframeAnimationInfo {
  constructor() {
    this.name = "";
    this.duration = 0.3;
    this.delay = 0;
    this.iterations = 1;
    this.curve = "ease";
    this.isForwards = false;
    this.isReverse = false;
  }
}

class KeyframeAnimation {
  constructor() {
    this.delay = 0;
    this.iterations = 1;
  }
  static keyframeAnimationFromInfo(info) {
    if (!info?.keyframes?.length) {
      Trace.write(`No keyframes found for animation '${info.name}'.`, Trace.categories.Animation, Trace.messageType.warn);
      return null;
    }
    const length = info.keyframes.length;
    const animations = new Array;
    let startDuration = 0;
    if (info.isReverse) {
      for (let index = length - 1;index >= 0; index--) {
        const keyframe = info.keyframes[index];
        startDuration = KeyframeAnimation.parseKeyframe(info, keyframe, animations, startDuration);
      }
    } else {
      for (let index = 0;index < length; index++) {
        const keyframe = info.keyframes[index];
        startDuration = KeyframeAnimation.parseKeyframe(info, keyframe, animations, startDuration);
      }
      for (let index = length - 1;index > 0; index--) {
        const a1 = animations[index];
        const a22 = animations[index - 1];
        if (a22["curve"] !== undefined) {
          a1["curve"] = a22["curve"];
          a22["curve"] = undefined;
        }
      }
    }
    animations.map((a3) => a3["curve"] ? a3 : Object.assign(a3, { curve: info.curve }));
    const animation = new KeyframeAnimation;
    animation.delay = info.delay;
    animation.iterations = info.iterations;
    animation.animations = animations;
    animation._isForwards = info.isForwards;
    return animation;
  }
  static parseKeyframe(info, keyframe, animations, startDuration) {
    const animation = {};
    for (const declaration of keyframe.declarations) {
      animation[declaration.property] = declaration.value;
    }
    let duration = keyframe.duration;
    if (duration === 0) {
      duration = 0.01;
    } else {
      duration = info.duration * duration - startDuration;
      startDuration += duration;
    }
    animation.duration = info.isReverse ? info.duration - duration : duration;
    animation.curve = keyframe.curve;
    animation.forceLayer = true;
    animation.valueSource = "keyframe";
    animations.push(animation);
    return startDuration;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  cancel() {
    if (!this.isPlaying) {
      Trace.write("Keyframe animation is already playing.", Trace.categories.Animation, Trace.messageType.warn);
      return;
    }
    this._isPlaying = false;
    for (let i4 = this._nativeAnimations.length - 1;i4 >= 0; i4--) {
      const animation = this._nativeAnimations[i4];
      if (animation.isPlaying) {
        animation.cancel();
      }
    }
    if (this._nativeAnimations.length > 0) {
      const animation = this._nativeAnimations[0];
      this._resetAnimationValues(this._target, animation);
    }
    this._resetAnimations();
  }
  play(view) {
    if (this._isPlaying) {
      Trace.write("Keyframe animation is already playing.", Trace.categories.Animation, Trace.messageType.warn);
      return new Promise((resolve) => {
        resolve();
      });
    }
    const animationFinishedPromise = new Promise((resolve) => {
      this._resolve = resolve;
    });
    this._isPlaying = true;
    this._nativeAnimations = new Array;
    this._target = view;
    if (this.delay !== 0) {
      setTimeout(() => this.animate(view, 0, this.iterations), this.delay);
    } else {
      this.animate(view, 0, this.iterations);
    }
    return animationFinishedPromise;
  }
  animate(view, index, iterations) {
    if (!this._isPlaying) {
      return;
    }
    if (index === 0) {
      const animation = this.animations[0];
      if ("backgroundColor" in animation) {
        view.style[backgroundColorProperty.keyframe] = animation.backgroundColor;
      }
      if ("scale" in animation) {
        view.style[scaleXProperty.keyframe] = animation.scale.x;
        view.style[scaleYProperty.keyframe] = animation.scale.y;
      }
      if ("translate" in animation) {
        view.style[translateXProperty.keyframe] = animation.translate.x;
        view.style[translateYProperty.keyframe] = animation.translate.y;
      }
      if ("rotate" in animation) {
        view.style[rotateXProperty.keyframe] = animation.rotate.x;
        view.style[rotateYProperty.keyframe] = animation.rotate.y;
        view.style[rotateProperty.keyframe] = animation.rotate.z;
      }
      if ("opacity" in animation) {
        view.style[opacityProperty.keyframe] = animation.opacity;
      }
      if ("height" in animation) {
        view.style[heightProperty.keyframe] = animation.height;
      }
      if ("width" in animation) {
        view.style[widthProperty.keyframe] = animation.width;
      }
      setTimeout(() => this.animate(view, 1, iterations), 1);
    } else if (index < 0 || index >= this.animations.length) {
      iterations -= 1;
      if (iterations > 0) {
        this.animate(view, 0, iterations);
      } else {
        if (this._isForwards === false) {
          const animation = this.animations[this.animations.length - 1];
          this._resetAnimationValues(view, animation);
        }
        this._resolveAnimationFinishedPromise();
      }
    } else {
      let animation;
      const cachedAnimation = this._nativeAnimations[index - 1];
      if (cachedAnimation) {
        animation = cachedAnimation;
      } else {
        const animationDef = { ...this.animations[index], target: view };
        animation = new Animation([animationDef]);
        this._nativeAnimations.push(animation);
      }
      const isLastIteration = iterations - 1 <= 0;
      animation.play(isLastIteration).then(() => {
        this.animate(view, index + 1, iterations);
      }, (error) => {
        Trace.write(typeof error === "string" ? error : error.message, Trace.categories.Animation, Trace.messageType.warn);
      }).catch((error) => {
        Trace.write(typeof error === "string" ? error : error.message, Trace.categories.Animation, Trace.messageType.warn);
      });
    }
  }
  _resolveAnimationFinishedPromise() {
    this._nativeAnimations = new Array;
    this._isPlaying = false;
    this._target = null;
    this._resolve();
  }
  _resetAnimations() {
    this._nativeAnimations = new Array;
    this._isPlaying = false;
    this._target = null;
  }
  _resetAnimationValues(view, animation) {
    if ("backgroundColor" in animation) {
      view.style[backgroundColorProperty.keyframe] = unsetValue;
    }
    if ("scale" in animation) {
      view.style[scaleXProperty.keyframe] = unsetValue;
      view.style[scaleYProperty.keyframe] = unsetValue;
    }
    if ("translate" in animation) {
      view.style[translateXProperty.keyframe] = unsetValue;
      view.style[translateYProperty.keyframe] = unsetValue;
    }
    if ("rotate" in animation) {
      view.style[rotateProperty.keyframe] = unsetValue;
    }
    if ("opacity" in animation) {
      view.style[opacityProperty.keyframe] = unsetValue;
    }
    if ("height" in animation) {
      view.style[heightProperty.keyframe] = unsetValue;
    }
    if ("width" in animation) {
      view.style[widthProperty.keyframe] = unsetValue;
    }
  }
}

// node_modules/@nativescript/core/ui/styling/converters.js
var STYLE_CURVE_MAP = Object.freeze({
  ease: CoreTypes.AnimationCurve.ease,
  linear: CoreTypes.AnimationCurve.linear,
  "ease-in": CoreTypes.AnimationCurve.easeIn,
  "ease-out": CoreTypes.AnimationCurve.easeOut,
  "ease-in-out": CoreTypes.AnimationCurve.easeInOut,
  spring: CoreTypes.AnimationCurve.spring
});
function timeConverter(value) {
  let result = parseFloat(value);
  if (value.indexOf("ms") === -1) {
    result = result * 1000;
  }
  return Math.max(0, result);
}
function animationTimingFunctionConverter(value) {
  return value ? STYLE_CURVE_MAP[value] || parseCubicBezierCurve(value) : CoreTypes.AnimationCurve.ease;
}
function parseCubicBezierCurve(value) {
  const coordsString = /\((.*?)\)/.exec(value);
  const coords = coordsString && coordsString[1].split(",").map(stringToBezieCoords);
  if (value.startsWith("cubic-bezier") && coordsString && coords.length === 4) {
    const [x1, x2, y1, y2] = [...coords];
    return CoreTypes.AnimationCurve.cubicBezier(x1, x2, y1, y2);
  } else {
    throw new Error(`Invalid value for animation: ${value}`);
  }
}
function stringToBezieCoords(value) {
  const result = parseFloat(value);
  if (result < 0) {
    return 0;
  } else if (result > 1) {
    return 1;
  }
  return result;
}

// node_modules/@nativescript/core/ui/styling/css-animation-parser.js
var ANIMATION_PROPERTY_HANDLERS = Object.freeze({
  "animation-name": (info, value) => info.name = value.replace(/['"]/g, ""),
  "animation-duration": (info, value) => info.duration = timeConverter(value),
  "animation-delay": (info, value) => info.delay = timeConverter(value),
  "animation-timing-function": (info, value) => info.curve = animationTimingFunctionConverter(value),
  "animation-iteration-count": (info, value) => info.iterations = value === "infinite" ? Number.POSITIVE_INFINITY : parseFloat(value),
  "animation-direction": (info, value) => info.isReverse = value === "reverse",
  "animation-fill-mode": (info, value) => info.isForwards = value === "forwards" || value === "both"
});

class CssAnimationParser {
  static keyframeAnimationsFromCSSDeclarations(declarations) {
    if (declarations === null || declarations === undefined) {
      return;
    }
    const animations = new Array;
    let animationInfo = undefined;
    declarations.forEach(({ property, value }) => {
      if (property === "animation") {
        keyframeAnimationsFromCSSProperty(value, animations);
      } else {
        const propertyHandler = ANIMATION_PROPERTY_HANDLERS[property];
        if (propertyHandler) {
          if (animationInfo === undefined) {
            animationInfo = new KeyframeAnimationInfo;
            animations.push(animationInfo);
          }
          propertyHandler(animationInfo, value);
        }
      }
    });
    return animations.length === 0 ? undefined : animations;
  }
  static keyframesArrayFromCSS(keyframes) {
    const parsedKeyframes = new Array;
    for (const keyframe of keyframes) {
      const declarations = parseKeyframeDeclarations(keyframe.declarations);
      for (let time2 of keyframe.values) {
        if (time2 === "from") {
          time2 = 0;
        } else if (time2 === "to") {
          time2 = 1;
        } else {
          time2 = parseFloat(time2) / 100;
          if (time2 < 0) {
            time2 = 0;
          }
          if (time2 > 100) {
            time2 = 100;
          }
        }
        let current2 = parsedKeyframes[time2];
        if (current2 === undefined) {
          current2 = {};
          current2.duration = time2;
          current2.declarations = [];
          parsedKeyframes[time2] = current2;
        }
        for (const declaration of keyframe.declarations) {
          if (declaration.property === "animation-timing-function") {
            current2.curve = animationTimingFunctionConverter(declaration.value);
          }
        }
        current2.declarations = current2.declarations.concat(declarations);
      }
    }
    const array = [];
    for (const parsedKeyframe in parsedKeyframes) {
      array.push(parsedKeyframes[parsedKeyframe]);
    }
    array.sort(function(a3, b2) {
      return a3.duration - b2.duration;
    });
    return array;
  }
}
function keyframeAnimationsFromCSSProperty(value, animations) {
  if (typeof value !== "string") {
    return;
  }
  if (value.trim().length === 0) {
    return;
  }
  const VALUE_SPLIT_RE = /\s(?![^(]*\))/;
  const MULTIPLE_SPLIT_RE = /,(?![^(]*\))/;
  const isTime = (v) => !!v.match(/\dm?s$/g);
  const isTimingFunction = (v) => !!v.match(/ease|linear|ease-in|ease-out|ease-in-out|spring|cubic-bezier/g);
  const isIterationCount = (v) => !!v.match(/infinite|[\d.]+$/g);
  const isDirection = (v) => !!v.match(/normal|reverse|alternate|alternate-reverse/g);
  const isFillMode = (v) => !!v.match(/none|forwards|backwards|both/g);
  const isPlayState = (v) => !!v.match(/running|paused/g);
  const values = value.split(MULTIPLE_SPLIT_RE);
  for (const parsedValue of values) {
    const animationInfo = new KeyframeAnimationInfo;
    const parts = parsedValue.trim().split(VALUE_SPLIT_RE);
    const [duration, delay] = parts.filter(isTime);
    const [timing] = parts.filter(isTimingFunction);
    const [iterationCount] = parts.filter(isIterationCount);
    const [direction] = parts.filter(isDirection);
    const [fillMode] = parts.filter(isFillMode);
    const [playState] = parts.filter(isPlayState);
    const [name] = parts.filter((v) => {
      return ![duration, delay, timing, iterationCount, direction, fillMode, playState].filter(Boolean).includes(v);
    });
    if (duration) {
      ANIMATION_PROPERTY_HANDLERS["animation-duration"](animationInfo, duration);
    }
    if (delay) {
      ANIMATION_PROPERTY_HANDLERS["animation-delay"](animationInfo, delay);
    }
    if (timing) {
      ANIMATION_PROPERTY_HANDLERS["animation-timing-function"](animationInfo, timing);
    }
    if (iterationCount) {
      ANIMATION_PROPERTY_HANDLERS["animation-iteration-count"](animationInfo, iterationCount);
    }
    if (direction) {
      ANIMATION_PROPERTY_HANDLERS["animation-direction"](animationInfo, direction);
    }
    if (fillMode) {
      ANIMATION_PROPERTY_HANDLERS["animation-fill-mode"](animationInfo, fillMode);
    }
    if (playState) {}
    if (name) {
      ANIMATION_PROPERTY_HANDLERS["animation-name"](animationInfo, name);
    } else {}
    animations.push(animationInfo);
  }
}
function parseKeyframeDeclarations(unparsedKeyframeDeclarations) {
  const declarations = unparsedKeyframeDeclarations.reduce((declarations2, { property: unparsedProperty, value: unparsedValue }) => {
    const property = CssAnimationProperty._getByCssName(unparsedProperty);
    unparsedValue = cleanupImportantFlags(unparsedValue, property?.cssLocalName);
    if (typeof unparsedProperty === "string" && property?._valueConverter) {
      declarations2[property.name] = property._valueConverter(unparsedValue);
    } else if (unparsedProperty === "transform") {
      const transformations = transformConverter(unparsedValue);
      Object.assign(declarations2, transformations);
    }
    return declarations2;
  }, {});
  return Object.keys(declarations).map((property) => ({
    property,
    value: declarations[property]
  }));
}

// node_modules/css-tree/lib/tokenizer/types.js
var EOF = 0;
var Ident = 1;
var Function2 = 2;
var AtKeyword = 3;
var Hash = 4;
var String2 = 5;
var BadString = 6;
var Url = 7;
var BadUrl = 8;
var Delim = 9;
var Number2 = 10;
var Percentage = 11;
var Dimension = 12;
var WhiteSpace = 13;
var CDO = 14;
var CDC = 15;
var Colon = 16;
var Semicolon = 17;
var Comma = 18;
var LeftSquareBracket = 19;
var RightSquareBracket = 20;
var LeftParenthesis = 21;
var RightParenthesis = 22;
var LeftCurlyBracket = 23;
var RightCurlyBracket = 24;
var Comment2 = 25;

// node_modules/css-tree/lib/tokenizer/char-code-definitions.js
var EOF2 = 0;
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isHexDigit2(code) {
  return isDigit(code) || code >= 65 && code <= 70 || code >= 97 && code <= 102;
}
function isUppercaseLetter(code) {
  return code >= 65 && code <= 90;
}
function isLowercaseLetter(code) {
  return code >= 97 && code <= 122;
}
function isLetter(code) {
  return isUppercaseLetter(code) || isLowercaseLetter(code);
}
function isNonAscii(code) {
  return code >= 128;
}
function isNameStart(code) {
  return isLetter(code) || isNonAscii(code) || code === 95;
}
function isName(code) {
  return isNameStart(code) || isDigit(code) || code === 45;
}
function isNonPrintable(code) {
  return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
}
function isNewline(code) {
  return code === 10 || code === 13 || code === 12;
}
function isWhiteSpace(code) {
  return isNewline(code) || code === 32 || code === 9;
}
function isValidEscape(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF2) {
    return false;
  }
  return true;
}
function isIdentifierStart2(first, second, third) {
  if (first === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape(first, second);
  }
  return false;
}
function isNumberStart(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit(second)) {
      return 2;
    }
    return second === 46 && isDigit(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit(second) ? 2 : 0;
  }
  if (isDigit(first)) {
    return 1;
  }
  return 0;
}
function isBOM(code) {
  if (code === 65279) {
    return 1;
  }
  if (code === 65534) {
    return 1;
  }
  return 0;
}
var CATEGORY = new Array(128);
var EofCategory = 128;
var WhiteSpaceCategory = 130;
var DigitCategory = 131;
var NameStartCategory = 132;
var NonPrintableCategory = 133;
for (let i4 = 0;i4 < CATEGORY.length; i4++) {
  CATEGORY[i4] = isWhiteSpace(i4) && WhiteSpaceCategory || isDigit(i4) && DigitCategory || isNameStart(i4) && NameStartCategory || isNonPrintable(i4) && NonPrintableCategory || i4 || EofCategory;
}
function charCodeCategory(code) {
  return code < 128 ? CATEGORY[code] : NameStartCategory;
}

// node_modules/css-tree/lib/tokenizer/utils.js
function getCharCode(source, offset2) {
  return offset2 < source.length ? source.charCodeAt(offset2) : 0;
}
function getNewlineLength(source, offset2, code) {
  if (code === 13 && getCharCode(source, offset2 + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset2, referenceCode) {
  let code = testStr.charCodeAt(offset2);
  if (isUppercaseLetter(code)) {
    code = code | 32;
  }
  return code === referenceCode;
}
function cmpStr(testStr, start2, end, referenceStr) {
  if (end - start2 !== referenceStr.length) {
    return false;
  }
  if (start2 < 0 || end > testStr.length) {
    return false;
  }
  for (let i4 = start2;i4 < end; i4++) {
    const referenceCode = referenceStr.charCodeAt(i4 - start2);
    let testCode = testStr.charCodeAt(i4);
    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset2) {
  for (;offset2 >= 0; offset2--) {
    if (!isWhiteSpace(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2 + 1;
}
function findWhiteSpaceEnd(source, offset2) {
  for (;offset2 < source.length; offset2++) {
    if (!isWhiteSpace(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function findDecimalNumberEnd(source, offset2) {
  for (;offset2 < source.length; offset2++) {
    if (!isDigit(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function consumeEscaped(source, offset2) {
  offset2 += 2;
  if (isHexDigit2(getCharCode(source, offset2 - 1))) {
    for (const maxOffset = Math.min(source.length, offset2 + 5);offset2 < maxOffset; offset2++) {
      if (!isHexDigit2(getCharCode(source, offset2))) {
        break;
      }
    }
    const code = getCharCode(source, offset2);
    if (isWhiteSpace(code)) {
      offset2 += getNewlineLength(source, offset2, code);
    }
  }
  return offset2;
}
function consumeName(source, offset2) {
  for (;offset2 < source.length; offset2++) {
    const code = source.charCodeAt(offset2);
    if (isName(code)) {
      continue;
    }
    if (isValidEscape(code, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2) - 1;
      continue;
    }
    break;
  }
  return offset2;
}
function consumeNumber2(source, offset2) {
  let code = source.charCodeAt(offset2);
  if (code === 43 || code === 45) {
    code = source.charCodeAt(offset2 += 1);
  }
  if (isDigit(code)) {
    offset2 = findDecimalNumberEnd(source, offset2 + 1);
    code = source.charCodeAt(offset2);
  }
  if (code === 46 && isDigit(source.charCodeAt(offset2 + 1))) {
    offset2 += 2;
    offset2 = findDecimalNumberEnd(source, offset2);
  }
  if (cmpChar(source, offset2, 101)) {
    let sign2 = 0;
    code = source.charCodeAt(offset2 + 1);
    if (code === 45 || code === 43) {
      sign2 = 1;
      code = source.charCodeAt(offset2 + 2);
    }
    if (isDigit(code)) {
      offset2 = findDecimalNumberEnd(source, offset2 + 1 + sign2 + 1);
    }
  }
  return offset2;
}
function consumeBadUrlRemnants(source, offset2) {
  for (;offset2 < source.length; offset2++) {
    const code = source.charCodeAt(offset2);
    if (code === 41) {
      offset2++;
      break;
    }
    if (isValidEscape(code, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2);
    }
  }
  return offset2;
}
function decodeEscaped(escaped) {
  if (escaped.length === 1 && !isHexDigit2(escaped.charCodeAt(0))) {
    return escaped[0];
  }
  let code = parseInt(escaped, 16);
  if (code === 0 || code >= 55296 && code <= 57343 || code > 1114111) {
    code = 65533;
  }
  return String.fromCodePoint(code);
}
// node_modules/css-tree/lib/tokenizer/names.js
var names_default = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token",
  "comment-token"
];
// node_modules/css-tree/lib/tokenizer/adopt-buffer.js
var MIN_SIZE = 16 * 1024;
function adoptBuffer(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer;
}

// node_modules/css-tree/lib/tokenizer/OffsetToLocation.js
var N = 10;
var F = 12;
var R3 = 13;
function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i4 = startOffset;i4 < sourceLength; i4++) {
    const code = source.charCodeAt(i4);
    lines[i4] = line;
    columns[i4] = column++;
    if (code === N || code === R3 || code === F) {
      if (code === R3 && i4 + 1 < sourceLength && source.charCodeAt(i4 + 1) === N) {
        i4++;
        lines[i4] = line;
        columns[i4] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns[sourceLength] = column;
  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}

class OffsetToLocation {
  constructor(source, startOffset, startLine, startColumn) {
    this.setSource(source, startOffset, startLine, startColumn);
    this.lines = null;
    this.columns = null;
  }
  setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset2, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      offset: this.startOffset + offset2,
      line: this.lines[offset2],
      column: this.columns[offset2]
    };
  }
  getLocationRange(start2, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      start: {
        offset: this.startOffset + start2,
        line: this.lines[start2],
        column: this.columns[start2]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
}
// node_modules/css-tree/lib/tokenizer/TokenStream.js
var OFFSET_MASK = 16777215;
var TYPE_SHIFT = 24;
var balancePair = new Uint8Array(32);
balancePair[Function2] = RightParenthesis;
balancePair[LeftParenthesis] = RightParenthesis;
balancePair[LeftSquareBracket] = RightSquareBracket;
balancePair[LeftCurlyBracket] = RightCurlyBracket;
function isBlockOpenerToken(tokenType) {
  return balancePair[tokenType] !== 0;
}

class TokenStream {
  constructor(source, tokenize2) {
    this.setSource(source, tokenize2);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize2 = () => {}) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let firstCharOffset = -1;
    let balanceCloseType = 0;
    let balanceStart = source.length;
    this.offsetAndType = null;
    this.balance = null;
    balance.fill(0);
    tokenize2(source, (type, start2, end) => {
      const index = tokenCount++;
      offsetAndType[index] = type << TYPE_SHIFT | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start2;
      }
      balance[index] = balanceStart;
      if (type === balanceCloseType) {
        const prevBalanceStart = balance[balanceStart];
        balance[balanceStart] = index;
        balanceStart = prevBalanceStart;
        balanceCloseType = balancePair[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];
      } else if (isBlockOpenerToken(type)) {
        balanceStart = index;
        balanceCloseType = balancePair[type];
      }
    });
    offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength;
    balance[tokenCount] = tokenCount;
    for (let i4 = 0;i4 < tokenCount; i4++) {
      const balanceStart2 = balance[i4];
      if (balanceStart2 <= i4) {
        const balanceEnd = balance[balanceStart2];
        if (balanceEnd !== i4) {
          balance[i4] = balanceEnd;
        }
      } else if (balanceStart2 > tokenCount) {
        balance[i4] = tokenCount;
      }
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2] >> TYPE_SHIFT;
    }
    return EOF;
  }
  lookupTypeNonSC(idx) {
    for (let offset2 = this.tokenIndex;offset2 < this.tokenCount; offset2++) {
      const tokenType = this.offsetAndType[offset2] >> TYPE_SHIFT;
      if (tokenType !== WhiteSpace && tokenType !== Comment2) {
        if (idx-- === 0) {
          return tokenType;
        }
      }
    }
    return EOF;
  }
  lookupOffset(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2 - 1] & OFFSET_MASK;
    }
    return this.source.length;
  }
  lookupOffsetNonSC(idx) {
    for (let offset2 = this.tokenIndex;offset2 < this.tokenCount; offset2++) {
      const tokenType = this.offsetAndType[offset2] >> TYPE_SHIFT;
      if (tokenType !== WhiteSpace && tokenType !== Comment2) {
        if (idx-- === 0) {
          return offset2 - this.tokenIndex;
        }
      }
    }
    return EOF;
  }
  lookupValue(offset2, referenceStr) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return cmpStr(this.source, this.offsetAndType[offset2 - 1] & OFFSET_MASK, this.offsetAndType[offset2] & OFFSET_MASK, referenceStr);
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start2) {
    return this.source.substring(start2, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code, offset2) {
    if (offset2) {
      return this.lookupType(offset2) === Delim && this.source.charCodeAt(this.lookupOffset(offset2)) === code;
    }
    return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code;
  }
  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace || this.tokenType === Comment2) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd = 0;
    let offset2 = 0;
    loop:
      for (;cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset2 = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset2))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn) {
    for (let i4 = 0, offset2 = this.firstCharOffset;i4 < this.tokenCount; i4++) {
      const start2 = offset2;
      const item = this.offsetAndType[i4];
      const end = item & OFFSET_MASK;
      const type = item >> TYPE_SHIFT;
      offset2 = end;
      fn(type, start2, end, i4);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type, start2, end, index) => {
      tokens[index] = {
        idx: index,
        type: names_default[type],
        chunk: this.source.substring(start2, end),
        balance: this.balance[index]
      };
    });
    return tokens;
  }
}

// node_modules/css-tree/lib/tokenizer/index.js
function tokenize2(source, onToken) {
  function getCharCode2(offset3) {
    return offset3 < sourceLength ? source.charCodeAt(offset3) : 0;
  }
  function consumeNumericToken2() {
    offset2 = consumeNumber2(source, offset2);
    if (isIdentifierStart2(getCharCode2(offset2), getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
      type = Dimension;
      offset2 = consumeName(source, offset2);
      return;
    }
    if (getCharCode2(offset2) === 37) {
      type = Percentage;
      offset2++;
      return;
    }
    type = Number2;
  }
  function consumeIdentLikeToken2() {
    const nameStartOffset = offset2;
    offset2 = consumeName(source, offset2);
    if (cmpStr(source, nameStartOffset, offset2, "url") && getCharCode2(offset2) === 40) {
      offset2 = findWhiteSpaceEnd(source, offset2 + 1);
      if (getCharCode2(offset2) === 34 || getCharCode2(offset2) === 39) {
        type = Function2;
        offset2 = nameStartOffset + 4;
        return;
      }
      consumeUrlToken2();
      return;
    }
    if (getCharCode2(offset2) === 40) {
      type = Function2;
      offset2++;
      return;
    }
    type = Ident;
  }
  function consumeStringToken2(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset2++);
    }
    type = String2;
    for (;offset2 < source.length; offset2++) {
      const code = source.charCodeAt(offset2);
      switch (charCodeCategory(code)) {
        case endingCodePoint:
          offset2++;
          return;
        case WhiteSpaceCategory:
          if (isNewline(code)) {
            offset2 += getNewlineLength(source, offset2, code);
            type = BadString;
            return;
          }
          break;
        case 92:
          if (offset2 === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset2 + 1);
          if (isNewline(nextCode)) {
            offset2 += getNewlineLength(source, offset2 + 1, nextCode);
          } else if (isValidEscape(code, nextCode)) {
            offset2 = consumeEscaped(source, offset2) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken2() {
    type = Url;
    offset2 = findWhiteSpaceEnd(source, offset2);
    for (;offset2 < source.length; offset2++) {
      const code = source.charCodeAt(offset2);
      switch (charCodeCategory(code)) {
        case 41:
          offset2++;
          return;
        case WhiteSpaceCategory:
          offset2 = findWhiteSpaceEnd(source, offset2);
          if (getCharCode2(offset2) === 41 || offset2 >= source.length) {
            if (offset2 < source.length) {
              offset2++;
            }
            return;
          }
          offset2 = consumeBadUrlRemnants(source, offset2);
          type = BadUrl;
          return;
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory:
          offset2 = consumeBadUrlRemnants(source, offset2);
          type = BadUrl;
          return;
        case 92:
          if (isValidEscape(code, getCharCode2(offset2 + 1))) {
            offset2 = consumeEscaped(source, offset2) - 1;
            break;
          }
          offset2 = consumeBadUrlRemnants(source, offset2);
          type = BadUrl;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start2 = isBOM(getCharCode2(0));
  let offset2 = start2;
  let type;
  while (offset2 < sourceLength) {
    const code = source.charCodeAt(offset2);
    switch (charCodeCategory(code)) {
      case WhiteSpaceCategory:
        type = WhiteSpace;
        offset2 = findWhiteSpaceEnd(source, offset2 + 1);
        break;
      case 34:
        consumeStringToken2();
        break;
      case 35:
        if (isName(getCharCode2(offset2 + 1)) || isValidEscape(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          type = Hash;
          offset2 = consumeName(source, offset2 + 1);
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 39:
        consumeStringToken2();
        break;
      case 40:
        type = LeftParenthesis;
        offset2++;
        break;
      case 41:
        type = RightParenthesis;
        offset2++;
        break;
      case 43:
        if (isNumberStart(code, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken2();
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 44:
        type = Comma;
        offset2++;
        break;
      case 45:
        if (isNumberStart(code, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken2();
        } else {
          if (getCharCode2(offset2 + 1) === 45 && getCharCode2(offset2 + 2) === 62) {
            type = CDC;
            offset2 = offset2 + 3;
          } else {
            if (isIdentifierStart2(code, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
              consumeIdentLikeToken2();
            } else {
              type = Delim;
              offset2++;
            }
          }
        }
        break;
      case 46:
        if (isNumberStart(code, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken2();
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 47:
        if (getCharCode2(offset2 + 1) === 42) {
          type = Comment2;
          offset2 = source.indexOf("*/", offset2 + 2);
          offset2 = offset2 === -1 ? source.length : offset2 + 2;
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 58:
        type = Colon;
        offset2++;
        break;
      case 59:
        type = Semicolon;
        offset2++;
        break;
      case 60:
        if (getCharCode2(offset2 + 1) === 33 && getCharCode2(offset2 + 2) === 45 && getCharCode2(offset2 + 3) === 45) {
          type = CDO;
          offset2 = offset2 + 4;
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 64:
        if (isIdentifierStart2(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2), getCharCode2(offset2 + 3))) {
          type = AtKeyword;
          offset2 = consumeName(source, offset2 + 1);
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 91:
        type = LeftSquareBracket;
        offset2++;
        break;
      case 92:
        if (isValidEscape(code, getCharCode2(offset2 + 1))) {
          consumeIdentLikeToken2();
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 93:
        type = RightSquareBracket;
        offset2++;
        break;
      case 123:
        type = LeftCurlyBracket;
        offset2++;
        break;
      case 125:
        type = RightCurlyBracket;
        offset2++;
        break;
      case DigitCategory:
        consumeNumericToken2();
        break;
      case NameStartCategory:
        consumeIdentLikeToken2();
        break;
      default:
        type = Delim;
        offset2++;
    }
    onToken(type, start2, start2 = offset2);
  }
}

// node_modules/css-tree/lib/utils/List.js
var releasedCursors = null;

class List {
  static createItem(data2) {
    return {
      prev: null,
      next: null,
      data: data2
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data2) {
    return List.createItem(data2);
  }
  allocateCursor(prev, next) {
    let cursor;
    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  get size() {
    let size = 0;
    for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data2 of array) {
      const item = List.createItem(data2);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  forEach(fn, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn, thisArg = this) {
    for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn, thisArg = this) {
    const result = new List;
    for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
      result.appendData(fn.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn, thisArg = this) {
    const result = new List;
    for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start2, fn, thisArg = this) {
    if (start2 === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start2);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start2, fn, thisArg = this) {
    if (start2 === null) {
      return;
    }
    const cursor = this.allocateCursor(start2, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List;
    for (let data2 of this) {
      result.appendData(data2);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data2) {
    return this.prepend(List.createItem(data2));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data2) {
    return this.insert(List.createItem(data2));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data2, before) {
    return this.insert(List.createItem(data2), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data2) {
    this.insert(List.createItem(data2));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data2) {
    this.prepend(List.createItem(data2));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list2) {
    return this.insertList(list2, this.head);
  }
  appendList(list2) {
    return this.insertList(list2);
  }
  insertList(list2, before) {
    if (list2.head === null) {
      return this;
    }
    if (before !== undefined && before !== null) {
      this.updateCursors(before.prev, list2.tail, before, list2.head);
      if (before.prev !== null) {
        before.prev.next = list2.head;
        list2.head.prev = before.prev;
      } else {
        this.head = list2.head;
      }
      before.prev = list2.tail;
      list2.tail.next = before;
    } else {
      this.updateCursors(this.tail, list2.tail, null, list2.head);
      if (this.tail !== null) {
        this.tail.next = list2.head;
        list2.head.prev = this.tail;
      } else {
        this.head = list2.head;
      }
      this.tail = list2.tail;
    }
    list2.head = null;
    list2.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
}

// node_modules/css-tree/lib/utils/create-custom-error.js
function createCustomError(name, message) {
  const error = Object.create(SyntaxError.prototype);
  const errorStack = new Error;
  return Object.assign(error, {
    name,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
    }
  });
}

// node_modules/css-tree/lib/parser/SyntaxError.js
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = "    ";
function sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {
  function processLines(start2, end) {
    return lines.slice(start2, end).map((line2, idx) => String(start2 + idx + 1).padStart(maxNumLength) + " |" + line2).join(`
`);
  }
  const prelines = `
`.repeat(Math.max(baseLine - 1, 0));
  const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
  const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (let i4 = startLine;i4 <= endLine; i4++) {
    if (i4 >= 0 && i4 < lines.length) {
      lines[i4] = lines[i4].replace(/\t/g, TAB_REPLACEMENT);
      lines[i4] = (cutLeft > 0 && lines[i4].length > cutLeft ? "" : "") + lines[i4].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i4].length > cutLeft + MAX_LINE_LENGTH - 1 ? "" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join(`
`).replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
}
function SyntaxError2(message, source, offset2, line, column, baseLine = 1, baseColumn = 1) {
  const error = Object.assign(createCustomError("SyntaxError", message), {
    source,
    offset: offset2,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment({ source, line, column, baseLine, baseColumn }, 2);
    }
  });
  return error;
}

// node_modules/css-tree/lib/parser/sequence.js
function readSequence(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment2:
        this.next();
        continue;
      case WhiteSpace:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context);
    if (child === undefined) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }
  return children;
}

// node_modules/css-tree/lib/parser/create.js
var NOOP = () => {};
var EXCLAMATIONMARK = 33;
var NUMBERSIGN = 35;
var SEMICOLON = 59;
var LEFTCURLYBRACKET = 123;
var NULL = 0;
function createParseContext(name) {
  return function() {
    return this[name]();
  };
}
function fetchParseValues(dict) {
  const result = Object.create(null);
  for (const name of Object.keys(dict)) {
    const item = dict[name];
    const fn = item.parse || item;
    if (fn) {
      result[name] = fn;
    }
  }
  return result;
}
function processConfig(config) {
  const parseConfig = {
    context: Object.create(null),
    features: Object.assign(Object.create(null), config.features),
    scope: Object.assign(Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node)
  };
  for (const [name, context] of Object.entries(config.parseContext)) {
    switch (typeof context) {
      case "function":
        parseConfig.context[name] = context;
        break;
      case "string":
        parseConfig.context[name] = createParseContext(context);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation;
  const parser = Object.assign(new TokenStream, processConfig(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code) {
      return code === LEFTCURLYBRACKET ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code) {
      return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code) {
      return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code) {
      return code === SEMICOLON ? 2 : 0;
    },
    createList() {
      return new List;
    },
    createSingleNodeList(node) {
      return new List().appendData(node);
    },
    getFirstListNode(list2) {
      return list2 && list2.first;
    },
    getLastListNode(list2) {
      return list2 && list2.last;
    },
    parseWithFallback(consumer, fallback) {
      const startIndex = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e3) {
        if (onParseErrorThrow) {
          throw e3;
        }
        this.skip(startIndex - this.tokenIndex);
        const fallbackNode = fallback.call(this);
        onParseErrorThrow = true;
        onParseError(e3, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset2) {
      let type;
      do {
        type = this.lookupType(offset2++);
        if (type !== WhiteSpace && type !== Comment2) {
          return type;
        }
      } while (type !== NULL);
      return NULL;
    },
    charCodeAt(offset2) {
      return offset2 >= 0 && offset2 < source.length ? source.charCodeAt(offset2) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start2) {
      return this.source.substring(start2, this.tokenStart);
    },
    cmpChar(offset2, charCode) {
      return cmpChar(source, offset2, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType) {
      const start2 = this.tokenStart;
      this.eat(tokenType);
      return this.substrToCursor(start2);
    },
    consumeFunctionName() {
      const name = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function2);
      return name;
    },
    consumeNumber(type) {
      const number = source.substring(this.tokenStart, consumeNumber2(source, this.tokenStart));
      this.eat(type);
      return number;
    },
    eat(tokenType) {
      if (this.tokenType !== tokenType) {
        const tokenName = names_default[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m2) => m2.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset2 = this.tokenStart;
        switch (tokenType) {
          case Ident:
            if (this.tokenType === Function2 || this.tokenType === Url) {
              offset2 = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash:
            if (this.isDelim(NUMBERSIGN)) {
              this.next();
              offset2++;
              message = "Name is expected";
            }
            break;
          case Percentage:
            if (this.tokenType === Number2) {
              offset2 = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset2);
      }
      this.next();
    },
    eatIdent(name) {
      if (this.tokenType !== Ident || this.lookupValue(0, name) === false) {
        this.error(`Identifier "${name}" is expected`);
      }
      this.next();
    },
    eatDelim(code) {
      if (!this.isDelim(code)) {
        this.error(`Delim "${String.fromCharCode(code)}" is expected`);
      }
      this.next();
    },
    getLocation(start2, end) {
      if (needPositions) {
        return locationMap.getLocationRange(start2, end, filename);
      }
      return null;
    },
    getLocationFromList(list2) {
      if (needPositions) {
        const head = this.getFirstListNode(list2);
        const tail = this.getLastListNode(list2);
        return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);
      }
      return null;
    },
    error(message, offset2) {
      const location = typeof offset2 !== "undefined" && offset2 < source.length ? locationMap.getLocation(offset2) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError2(message || "Unexpected input", source, location.offset, location.line, location.column, locationMap.startLine, locationMap.startColumn);
    }
  });
  const parse7 = function(source_, options) {
    source = source_;
    options = options || {};
    parser.setSource(source, tokenize2);
    locationMap.setSource(source, options.offset, options.line, options.column);
    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
    const { context = "default", onComment } = options;
    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type, start2, end) => {
        if (type === Comment2) {
          const loc = parser.getLocation(start2, end);
          const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start2 + 2, end - 2) : source.slice(start2 + 2, end);
          onComment(value, loc);
        }
      });
    }
    const ast = parser.context[context].call(parser, options);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse7, {
    SyntaxError: SyntaxError2,
    config: parser.config
  });
}

// node_modules/source-map-js/lib/source-map-generator.js
var base64VLQ = require_base64_vlq();
var util = require_util();
var ArraySet = require_array_set().ArraySet;
var MappingList = require_mapping_list().MappingList;
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, "file", null);
  this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
  this._skipValidation = util.getArg(aArgs, "skipValidation", false);
  this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
  this._sources = new ArraySet;
  this._names = new ArraySet;
  this._mappings = new MappingList;
  this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
    file: aSourceMapConsumer.file,
    sourceRoot
  }));
  aSourceMapConsumer.eachMapping(function(mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };
    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }
      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };
      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }
    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function(sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }
    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, "generated");
  var original = util.getArg(aArgs, "original", null);
  var source = util.getArg(aArgs, "source", null);
  var name = util.getArg(aArgs, "name", null);
  if (!this._skipValidation) {
    if (this._validateMapping(generated, original, source, name) === false) {
      return;
    }
  }
  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }
  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }
  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source,
    name
  });
};
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }
  if (aSourceContent != null) {
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    delete this._sourcesContents[util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " + `or the source map's "file" property. Both were omitted.`);
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  }
  var newSources = new ArraySet;
  var newNames = new ArraySet;
  this._mappings.unsortedForEach(function(mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }
    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }
    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;
  aSourceMapConsumer.sources.forEach(function(sourceFile2) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile2 = util.join(aSourceMapPath, sourceFile2);
      }
      if (sourceRoot != null) {
        sourceFile2 = util.relative(sourceRoot, sourceFile2);
      }
      this.setSourceContent(sourceFile2, content);
    }
  }, this);
};
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
    var message = "original.line and original.column are not numbers -- you probably meant to omit " + "the original mapping entirely and only map the generated position. If so, pass " + "null for the original mapping instead of an object with empty or null values.";
    if (this._ignoreInvalidMapping) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
      return false;
    } else {
      throw new Error(message);
    }
  }
  if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    return;
  } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    return;
  } else {
    var message = "Invalid mapping: " + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    });
    if (this._ignoreInvalidMapping) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
      return false;
    } else {
      throw new Error(message);
    }
  }
};
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = "";
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;
  var mappings = this._mappings.toArray();
  for (var i4 = 0, len = mappings.length;i4 < len; i4++) {
    mapping = mappings[i4];
    next = "";
    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ";";
        previousGeneratedLine++;
      }
    } else {
      if (i4 > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i4 - 1])) {
          continue;
        }
        next += ",";
      }
    }
    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;
    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;
      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;
      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }
    result += next;
  }
  return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function(source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }
    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }
  return map;
};
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};
var $SourceMapGenerator = SourceMapGenerator;

// node_modules/css-tree/lib/generator/sourceMap.js
var trackNodes = new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap(handlers) {
  const map = new $SourceMapGenerator;
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers.node;
  handlers.node = function(node) {
    if (node.loc && node.loc.start && trackNodes.has(node.type)) {
      const nodeLine = node.loc.start.line;
      const nodeColumn = node.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node);
    if (sourceMappingActive && trackNodes.has(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers.emit;
  handlers.emit = function(value, type, auto) {
    for (let i4 = 0;i4 < value.length; i4++) {
      if (value.charCodeAt(i4) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value, type, auto);
  };
  const origHandlersResult = handlers.result;
  handlers.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers;
}

// node_modules/css-tree/lib/generator/token-before.js
var exports_token_before = {};
__export(exports_token_before, {
  spec: () => spec,
  safe: () => safe
});
var PLUSSIGN = 43;
var HYPHENMINUS = 45;
var code = (type, value) => {
  if (type === Delim) {
    type = value;
  }
  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type;
};
var specPairs = [
  [Ident, Ident],
  [Ident, Function2],
  [Ident, Url],
  [Ident, BadUrl],
  [Ident, "-"],
  [Ident, Number2],
  [Ident, Percentage],
  [Ident, Dimension],
  [Ident, CDC],
  [Ident, LeftParenthesis],
  [AtKeyword, Ident],
  [AtKeyword, Function2],
  [AtKeyword, Url],
  [AtKeyword, BadUrl],
  [AtKeyword, "-"],
  [AtKeyword, Number2],
  [AtKeyword, Percentage],
  [AtKeyword, Dimension],
  [AtKeyword, CDC],
  [Hash, Ident],
  [Hash, Function2],
  [Hash, Url],
  [Hash, BadUrl],
  [Hash, "-"],
  [Hash, Number2],
  [Hash, Percentage],
  [Hash, Dimension],
  [Hash, CDC],
  [Dimension, Ident],
  [Dimension, Function2],
  [Dimension, Url],
  [Dimension, BadUrl],
  [Dimension, "-"],
  [Dimension, Number2],
  [Dimension, Percentage],
  [Dimension, Dimension],
  [Dimension, CDC],
  ["#", Ident],
  ["#", Function2],
  ["#", Url],
  ["#", BadUrl],
  ["#", "-"],
  ["#", Number2],
  ["#", Percentage],
  ["#", Dimension],
  ["#", CDC],
  ["-", Ident],
  ["-", Function2],
  ["-", Url],
  ["-", BadUrl],
  ["-", "-"],
  ["-", Number2],
  ["-", Percentage],
  ["-", Dimension],
  ["-", CDC],
  [Number2, Ident],
  [Number2, Function2],
  [Number2, Url],
  [Number2, BadUrl],
  [Number2, Number2],
  [Number2, Percentage],
  [Number2, Dimension],
  [Number2, "%"],
  [Number2, CDC],
  ["@", Ident],
  ["@", Function2],
  ["@", Url],
  ["@", BadUrl],
  ["@", "-"],
  ["@", CDC],
  [".", Number2],
  [".", Percentage],
  [".", Dimension],
  ["+", Number2],
  ["+", Percentage],
  ["+", Dimension],
  ["/", "*"]
];
var safePairs = specPairs.concat([
  [Ident, Hash],
  [Dimension, Hash],
  [Hash, Hash],
  [AtKeyword, LeftParenthesis],
  [AtKeyword, String2],
  [AtKeyword, Colon],
  [Percentage, Percentage],
  [Percentage, Dimension],
  [Percentage, Function2],
  [Percentage, "-"],
  [RightParenthesis, Ident],
  [RightParenthesis, Function2],
  [RightParenthesis, Percentage],
  [RightParenthesis, Dimension],
  [RightParenthesis, Hash],
  [RightParenthesis, "-"]
]);
function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(pairs.map(([prev, next]) => code(prev) << 16 | code(next)));
  return function(prevCode, type, value) {
    const nextCode = code(type, value);
    const nextCharCode = value.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS && type !== Ident && type !== Function2 && type !== CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace, true);
    }
    return nextCode;
  };
}
var spec = createMap(specPairs);
var safe = createMap(safePairs);

// node_modules/css-tree/lib/generator/create.js
var REVERSESOLIDUS = 92;
function processChildren(node, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node.children.forEach((node2) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node2);
      prev = node2;
    });
    return;
  }
  node.children.forEach(this.node, this);
}
function processChunk(chunk) {
  tokenize2(chunk, (type, start2, end) => {
    this.token(type, chunk.slice(start2, end));
  });
}
function createGenerator(config) {
  const types5 = new Map;
  for (let [name, item] of Object.entries(config.node)) {
    const fn = item.generate || item;
    if (typeof fn === "function") {
      types5.set(name, item.generate || item);
    }
  }
  return function(node, options) {
    let buffer = "";
    let prevCode = 0;
    let handlers = {
      node(node2) {
        if (types5.has(node2.type)) {
          types5.get(node2.type).call(publicApi, node2);
        } else {
          throw new Error("Unknown node type: " + node2.type);
        }
      },
      tokenBefore: safe,
      token(type, value) {
        prevCode = this.tokenBefore(prevCode, type, value);
        this.emit(value, type, false);
        if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit(`
`, WhiteSpace, true);
        }
      },
      emit(value) {
        buffer += value;
      },
      result() {
        return buffer;
      }
    };
    if (options) {
      if (typeof options.decorator === "function") {
        handlers = options.decorator(handlers);
      }
      if (options.sourceMap) {
        handlers = generateSourceMap(handlers);
      }
      if (options.mode in exports_token_before) {
        handlers.tokenBefore = exports_token_before[options.mode];
      }
    }
    const publicApi = {
      node: (node2) => handlers.node(node2),
      children: processChildren,
      token: (type, value) => handlers.token(type, value),
      tokenize: processChunk
    };
    handlers.node(node);
    return handlers.result();
  };
}

// node_modules/css-tree/lib/convertor/create.js
function createConvertor(walk2) {
  return {
    fromPlainObject(ast) {
      walk2(ast, {
        enter(node) {
          if (node.children && node.children instanceof List === false) {
            node.children = new List().fromArray(node.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk2(ast, {
        leave(node) {
          if (node.children && node.children instanceof List) {
            node.children = node.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}

// node_modules/css-tree/lib/walker/create.js
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var noop2 = function() {};
function ensureFunction(value) {
  return typeof value === "function" ? value : noop2;
}
function invokeForType(fn, type) {
  return function(node, item, list2) {
    if (node.type === type) {
      fn.call(this, node, item, list2);
    }
  };
}
function getWalkersFromStructure(name, nodeType) {
  const structure = nodeType.structure;
  const walkers = [];
  for (const key in structure) {
    if (hasOwnProperty3.call(structure, key) === false) {
      continue;
    }
    let fieldTypes = structure[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig(config) {
  const types5 = {};
  for (const name in config.node) {
    if (hasOwnProperty3.call(config.node, name)) {
      const nodeType = config.node[name];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name + "` node type definition");
      }
      types5[name] = getWalkersFromStructure(name, nodeType);
    }
  }
  return types5;
}
function createTypeIterator(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse) {
    fields.reverse();
  }
  return function(node, context, walk2, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }
    for (const field of fields) {
      const ref2 = node[field.name];
      if (!field.nullable || ref2) {
        if (field.type === "list") {
          const breakWalk = reverse ? ref2.reduceRight(walkReducer, false) : ref2.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk2(ref2)) {
          return true;
        }
      }
    }
    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap({
  StyleSheet,
  Atrule,
  Rule,
  Block,
  DeclarationList
}) {
  return {
    Atrule: {
      StyleSheet,
      Atrule,
      Rule,
      Block
    },
    Rule: {
      StyleSheet,
      Atrule,
      Rule,
      Block
    },
    Declaration: {
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList
    }
  };
}
function createWalker(config) {
  const types5 = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name in types5) {
    if (hasOwnProperty3.call(types5, name) && types5[name] !== null) {
      iteratorsNatural[name] = createTypeIterator(types5[name], false);
      iteratorsReverse[name] = createTypeIterator(types5[name], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
  const walk2 = function(root, options) {
    function walkNode(node, item, list2) {
      const enterRet = enter.call(context, node, item, list2);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node.type)) {
        if (iterators[node.type](node, context, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context, node, item, list2) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop2;
    let leave = noop2;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data2, item, list2) => ret || walkNode(data2, item, list2);
    const context = {
      break: breakWalk,
      skip: skipNode,
      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
      if (options.reverse) {
        iterators = iteratorsReverse;
      }
      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types5.hasOwnProperty(options.visit)) {
          throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types5).sort().join(", ") + ")");
        }
        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }
    if (enter === noop2 && leave === noop2) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root);
  };
  walk2.break = breakWalk;
  walk2.skip = skipNode;
  walk2.find = function(ast, fn) {
    let found = null;
    walk2(ast, function(node, item, list2) {
      if (fn.call(this, node, item, list2)) {
        found = node;
        return breakWalk;
      }
    });
    return found;
  };
  walk2.findLast = function(ast, fn) {
    let found = null;
    walk2(ast, {
      reverse: true,
      enter(node, item, list2) {
        if (fn.call(this, node, item, list2)) {
          found = node;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk2.findAll = function(ast, fn) {
    const found = [];
    walk2(ast, function(node, item, list2) {
      if (fn.call(this, node, item, list2)) {
        found.push(node);
      }
    });
    return found;
  };
  return walk2;
}

// node_modules/css-tree/lib/definition-syntax/generate.js
function noop3(value) {
  return value;
}
function generateMultiplier(multiplier) {
  const { min: min2, max: max2, comma } = multiplier;
  if (min2 === 0 && max2 === 0) {
    return comma ? "#?" : "*";
  }
  if (min2 === 0 && max2 === 1) {
    return "?";
  }
  if (min2 === 1 && max2 === 0) {
    return comma ? "#" : "+";
  }
  if (min2 === 1 && max2 === 1) {
    return "";
  }
  return (comma ? "#" : "") + (min2 === max2 ? "{" + min2 + "}" : "{" + min2 + "," + (max2 !== 0 ? max2 : "") + "}");
}
function generateTypeOpts(node) {
  switch (node.type) {
    case "Range":
      return " [" + (node.min === null ? "-" : node.min) + "," + (node.max === null ? "" : node.max) + "]";
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
}
function generateSequence(node, decorate, forceBraces, compact) {
  const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
  const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
  if (node.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate(node, decorate, forceBraces, compact) {
  let result;
  switch (node.type) {
    case "Group":
      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
    case "Boolean":
      result = "<boolean-expr[" + internalGenerate(node.term, decorate, forceBraces, compact) + "]>";
      break;
    case "Type":
      result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node.name + "'>";
      break;
    case "Keyword":
      result = node.name;
      break;
    case "AtKeyword":
      result = "@" + node.name;
      break;
    case "Function":
      result = node.name + "(";
      break;
    case "String":
    case "Token":
      result = node.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
  return decorate(result, node);
}
function generate(node, options) {
  let decorate = noop3;
  let forceBraces = false;
  let compact = false;
  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }
  return internalGenerate(node, decorate, forceBraces, compact);
}

// node_modules/css-tree/lib/lexer/error.js
var defaultLoc = { offset: 0, line: 1, column: 1 };
function locateMismatch(matchResult, node) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start2;
  let end;
  for (let i4 = 0;i4 < tokens.length; i4++) {
    const token = tokens[i4].value;
    if (i4 === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i4].node === badNode) {
      if (i4 <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start2 = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start2);
  } else {
    start2 = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, "end") || buildLoc(start2, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start: start2,
    end
  };
}
function fromLoc(node, point) {
  const value = node && node.loc && node.loc[point];
  if (value) {
    return "line" in value ? buildLoc(value) : value;
  }
  return null;
}
function buildLoc({ offset: offset2, line, column }, extra) {
  const loc = {
    offset: offset2,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
var SyntaxReferenceError = function(type, referenceName) {
  const error = createCustomError("SyntaxReferenceError", type + (referenceName ? " `" + referenceName + "`" : ""));
  error.reference = referenceName;
  return error;
};
var SyntaxMatchError = function(message, syntax, node, matchResult) {
  const error = createCustomError("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start: start2,
    end
  } = locateMismatch(matchResult, node);
  error.rawMessage = message;
  error.syntax = syntax ? generate(syntax) : "<generic>";
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message = message + `
` + "  syntax: " + error.syntax + `
` + "   value: " + (css || "<empty string>") + `
` + "  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
  Object.assign(error, start2);
  error.loc = {
    source: node && node.loc && node.loc.source || "<unknown>",
    start: start2,
    end
  };
  return error;
};

// node_modules/css-tree/lib/utils/names.js
var keywords2 = new Map;
var properties = new Map;
var HYPHENMINUS2 = 45;
var keyword = getKeywordDescriptor;
var property = getPropertyDescriptor;
function isCustomProperty(str, offset2) {
  offset2 = offset2 || 0;
  return str.length - offset2 >= 2 && str.charCodeAt(offset2) === HYPHENMINUS2 && str.charCodeAt(offset2 + 1) === HYPHENMINUS2;
}
function getVendorPrefix(str, offset2) {
  offset2 = offset2 || 0;
  if (str.length - offset2 >= 3) {
    if (str.charCodeAt(offset2) === HYPHENMINUS2 && str.charCodeAt(offset2 + 1) !== HYPHENMINUS2) {
      const secondDashIndex = str.indexOf("-", offset2 + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset2, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword2) {
  if (keywords2.has(keyword2)) {
    return keywords2.get(keyword2);
  }
  const name = keyword2.toLowerCase();
  let descriptor = keywords2.get(name);
  if (descriptor === undefined) {
    const custom = isCustomProperty(name, 0);
    const vendor = !custom ? getVendorPrefix(name, 0) : "";
    descriptor = Object.freeze({
      basename: name.substr(vendor.length),
      name,
      prefix: vendor,
      vendor,
      custom
    });
  }
  keywords2.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor(property2) {
  if (properties.has(property2)) {
    return properties.get(property2);
  }
  let name = property2;
  let hack = property2[0];
  if (hack === "/") {
    hack = property2[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom = isCustomProperty(name, hack.length);
  if (!custom) {
    name = name.toLowerCase();
    if (properties.has(name)) {
      const descriptor2 = properties.get(name);
      properties.set(property2, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
  const prefix = name.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name.substr(prefix.length),
    name: name.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
  properties.set(property2, descriptor);
  return descriptor;
}

// node_modules/css-tree/lib/lexer/generic-const.js
var cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];

// node_modules/css-tree/lib/lexer/generic-an-plus-b.js
var PLUSSIGN2 = 43;
var HYPHENMINUS3 = 45;
var N2 = 110;
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;
function isDelim(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function skipSC(token, offset2, getNextToken) {
  while (token !== null && (token.type === WhiteSpace || token.type === Comment2)) {
    token = getNextToken(++offset2);
  }
  return offset2;
}
function checkInteger(token, valueOffset, disallowSign, offset2) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN2 || code2 === HYPHENMINUS3) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (;valueOffset < token.value.length; valueOffset++) {
    if (!isDigit(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset2 + 1;
}
function consumeB(token, offset_, getNextToken) {
  let sign2 = false;
  let offset2 = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset2);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number2) {
    if (isDelim(token, PLUSSIGN2) || isDelim(token, HYPHENMINUS3)) {
      sign2 = true;
      offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
      token = getNextToken(offset2);
      if (token === null || token.type !== Number2) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign2) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN2 && code2 !== HYPHENMINUS3) {
      return 0;
    }
  }
  return checkInteger(token, sign2 ? 0 : 1, sign2, offset2);
}
function anPlusB(token, getNextToken) {
  let offset2 = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number2) {
    return checkInteger(token, 0, ALLOW_SIGN, offset2);
  } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS3) {
    if (!cmpChar(token.value, 1, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 2:
        return consumeB(getNextToken(++offset2), offset2, getNextToken);
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger(token, 0, DISALLOW_SIGN, offset2);
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 3, DISALLOW_SIGN, offset2);
    }
  } else if (token.type === Ident || isDelim(token, PLUSSIGN2) && getNextToken(offset2 + 1).type === Ident) {
    if (token.type !== Ident) {
      token = getNextToken(++offset2);
    }
    if (token === null || !cmpChar(token.value, 0, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 1:
        return consumeB(getNextToken(++offset2), offset2, getNextToken);
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger(token, 0, DISALLOW_SIGN, offset2);
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 2, DISALLOW_SIGN, offset2);
    }
  } else if (token.type === Dimension) {
    let code2 = token.value.charCodeAt(0);
    let sign2 = code2 === PLUSSIGN2 || code2 === HYPHENMINUS3 ? 1 : 0;
    let i4 = sign2;
    for (;i4 < token.value.length; i4++) {
      if (!isDigit(token.value.charCodeAt(i4))) {
        break;
      }
    }
    if (i4 === sign2) {
      return 0;
    }
    if (!cmpChar(token.value, i4, N2)) {
      return 0;
    }
    if (i4 + 1 === token.value.length) {
      return consumeB(getNextToken(++offset2), offset2, getNextToken);
    } else {
      if (token.value.charCodeAt(i4 + 1) !== HYPHENMINUS3) {
        return 0;
      }
      if (i4 + 2 === token.value.length) {
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger(token, 0, DISALLOW_SIGN, offset2);
      } else {
        return checkInteger(token, i4 + 2, DISALLOW_SIGN, offset2);
      }
    }
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic-urange.js
var PLUSSIGN3 = 43;
var HYPHENMINUS4 = 45;
var QUESTIONMARK = 63;
var U2 = 117;
function isDelim2(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function startsWith(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence(token, offset2, allowDash) {
  let hexlen = 0;
  for (let pos = offset2;pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS4 && allowDash && hexlen !== 0) {
      hexSequence(token, offset2 + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit2(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
  }
  return hexlen;
}
function withQuestionMarkSequence(consumed2, length, getNextToken) {
  if (!consumed2) {
    return 0;
  }
  while (isDelim2(getNextToken(length), QUESTIONMARK)) {
    if (++consumed2 > 6) {
      return 0;
    }
    length++;
  }
  return length;
}
function urange(token, getNextToken) {
  let length = 0;
  if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U2)) {
    return 0;
  }
  token = getNextToken(++length);
  if (token === null) {
    return 0;
  }
  if (isDelim2(token, PLUSSIGN3)) {
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident) {
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
    }
    if (isDelim2(token, QUESTIONMARK)) {
      return withQuestionMarkSequence(1, ++length, getNextToken);
    }
    return 0;
  }
  if (token.type === Number2) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length);
    if (token === null) {
      return length;
    }
    if (token.type === Dimension || token.type === Number2) {
      if (!startsWith(token, HYPHENMINUS4) || !hexSequence(token, 1, false)) {
        return 0;
      }
      return length + 1;
    }
    return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
  }
  if (token.type === Dimension) {
    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic.js
var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
var balancePair2 = new Map([
  [Function2, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
function charCodeAt(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}
function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}
function eqStrAny(actual, expected) {
  for (let i4 = 0;i4 < expected.length; i4++) {
    if (eqStr(actual, expected[i4])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack(str, offset2) {
  if (offset2 !== str.length - 2) {
    return false;
  }
  return charCodeAt(str, offset2) === 92 && isDigit(charCodeAt(str, offset2 + 1));
}
function outOfRange(opts, value, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(numEnd !== undefined && numEnd !== value.length ? value.substr(0, numEnd) : value);
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction2(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length++;
            break scan;
          }
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length++;
    } while (token = getNextToken(length));
  return length;
}
function calc2(next) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function2 && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction2(token, getNextToken);
    }
    return next(token, getNextToken, opts);
  };
}
function tokenType(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  const name = token.value.toLowerCase();
  if (eqStrAny(name, cssWideKeywords)) {
    return 0;
  }
  if (eqStr(name, "default")) {
    return 0;
  }
  return 1;
}
function dashedIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function customPropertyName(token) {
  if (!dashedIdent(token)) {
    return 0;
  }
  if (token.value === "--") {
    return 0;
  }
  return 1;
}
function hexColor(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  const length = token.value.length;
  if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
    return 0;
  }
  for (let i4 = 1;i4 < length; i4++) {
    if (!isHexDigit2(charCodeAt(token.value, i4))) {
      return 0;
    }
  }
  return 1;
}
function idSelector(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  if (!isIdentifierStart2(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length++;
    } while (token = getNextToken(length));
  return length;
}
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length++;
    } while (token = getNextToken(length));
  return length;
}
function dimension(type) {
  if (type) {
    type = new Set(type);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension) {
      return 0;
    }
    const numberEnd = consumeNumber2(token.value, 0);
    if (type !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage) {
    return 0;
  }
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero(next) {
  if (typeof next !== "function") {
    next = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number2) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next(token, getNextToken, opts);
  };
}
function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber2(token.value, 0);
  const isNumber2 = numberEnd === token.value.length;
  if (!isNumber2 && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer(token, getNextToken, opts) {
  if (token === null || token.type !== Number2) {
    return 0;
  }
  let i4 = charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45 ? 1 : 0;
  for (;i4 < token.value.length; i4++) {
    if (!isDigit(charCodeAt(token.value, i4))) {
      return 0;
    }
  }
  if (outOfRange(opts, token.value, i4)) {
    return 0;
  }
  return 1;
}
var tokenTypes = {
  "ident-token": tokenType(Ident),
  "function-token": tokenType(Function2),
  "at-keyword-token": tokenType(AtKeyword),
  "hash-token": tokenType(Hash),
  "string-token": tokenType(String2),
  "bad-string-token": tokenType(BadString),
  "url-token": tokenType(Url),
  "bad-url-token": tokenType(BadUrl),
  "delim-token": tokenType(Delim),
  "number-token": tokenType(Number2),
  "percentage-token": tokenType(Percentage),
  "dimension-token": tokenType(Dimension),
  "whitespace-token": tokenType(WhiteSpace),
  "CDO-token": tokenType(CDO),
  "CDC-token": tokenType(CDC),
  "colon-token": tokenType(Colon),
  "semicolon-token": tokenType(Semicolon),
  "comma-token": tokenType(Comma),
  "[-token": tokenType(LeftSquareBracket),
  "]-token": tokenType(RightSquareBracket),
  "(-token": tokenType(LeftParenthesis),
  ")-token": tokenType(RightParenthesis),
  "{-token": tokenType(LeftCurlyBracket),
  "}-token": tokenType(RightCurlyBracket)
};
var productionTypes = {
  string: tokenType(String2),
  ident: tokenType(Ident),
  percentage: calc2(percentage),
  zero: zero(),
  number: calc2(number),
  integer: calc2(integer),
  "custom-ident": customIdent,
  "dashed-ident": dashedIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector,
  "an-plus-b": anPlusB,
  urange,
  "declaration-value": declarationValue,
  "any-value": anyValue
};
function createDemensionTypes(units) {
  const {
    angle,
    decibel,
    frequency,
    flex,
    length,
    resolution,
    semitones,
    time: time2
  } = units || {};
  return {
    dimension: calc2(dimension(null)),
    angle: calc2(dimension(angle)),
    decibel: calc2(dimension(decibel)),
    frequency: calc2(dimension(frequency)),
    flex: calc2(dimension(flex)),
    length: calc2(zero(dimension(length))),
    resolution: calc2(dimension(resolution)),
    semitones: calc2(dimension(semitones)),
    time: calc2(dimension(time2))
  };
}
function createGenericTypes(units) {
  return {
    ...tokenTypes,
    ...productionTypes,
    ...createDemensionTypes(units)
  };
}

// node_modules/css-tree/lib/lexer/units.js
var exports_units = {};
__export(exports_units, {
  time: () => time2,
  semitones: () => semitones,
  resolution: () => resolution,
  length: () => length,
  frequency: () => frequency,
  flex: () => flex,
  decibel: () => decibel,
  angle: () => angle
});
var length = [
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
var angle = ["deg", "grad", "rad", "turn"];
var time2 = ["s", "ms"];
var frequency = ["hz", "khz"];
var resolution = ["dpi", "dpcm", "dppx", "x"];
var flex = ["fr"];
var decibel = ["db"];
var semitones = ["st"];

// node_modules/css-tree/lib/definition-syntax/SyntaxError.js
function SyntaxError3(message, input, offset2) {
  return Object.assign(createCustomError("SyntaxError", message), {
    input,
    offset: offset2,
    rawMessage: message,
    message: message + `
` + "  " + input + `
` + "--" + new Array((offset2 || input.length) + 1).join("-") + "^"
  });
}
// node_modules/css-tree/lib/definition-syntax/scanner.js
var TAB = 9;
var N3 = 10;
var F2 = 12;
var R4 = 13;
var SPACE = 32;
var NAME_CHAR = new Uint8Array(128).map((_3, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0);

class Scanner {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  isNameCharCode(code2 = this.charCode()) {
    return code2 < 128 && NAME_CHAR[code2] === 1;
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  skipWs() {
    this.pos = this.findWsEnd(this.pos);
  }
  findWsEnd(pos) {
    for (;pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R4 && code2 !== N3 && code2 !== F2 && code2 !== SPACE && code2 !== TAB) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError3(message, this.str, this.pos);
  }
  scanSpaces() {
    return this.substringToPos(this.findWsEnd(this.pos));
  }
  scanWord() {
    let end = this.pos;
    for (;end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 >= 128 || NAME_CHAR[code2] === 0) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a keyword");
    }
    return this.substringToPos(end);
  }
  scanNumber() {
    let end = this.pos;
    for (;end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 < 48 || code2 > 57) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a number");
    }
    return this.substringToPos(end);
  }
  scanString() {
    const end = this.str.indexOf("'", this.pos + 1);
    if (end === -1) {
      this.pos = this.str.length;
      this.error("Expect an apostrophe");
    }
    return this.substringToPos(end + 1);
  }
}

// node_modules/css-tree/lib/definition-syntax/parse.js
var TAB2 = 9;
var N4 = 10;
var F3 = 12;
var R5 = 13;
var SPACE2 = 32;
var EXCLAMATIONMARK2 = 33;
var NUMBERSIGN2 = 35;
var AMPERSAND = 38;
var APOSTROPHE = 39;
var LEFTPARENTHESIS = 40;
var RIGHTPARENTHESIS = 41;
var ASTERISK = 42;
var PLUSSIGN4 = 43;
var COMMA = 44;
var HYPERMINUS = 45;
var LESSTHANSIGN = 60;
var GREATERTHANSIGN = 62;
var QUESTIONMARK2 = 63;
var COMMERCIALAT = 64;
var LEFTSQUAREBRACKET = 91;
var RIGHTSQUAREBRACKET = 93;
var LEFTCURLYBRACKET2 = 123;
var VERTICALLINE = 124;
var RIGHTCURLYBRACKET = 125;
var INFINITY = 8734;
var COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function readMultiplierRange(scanner) {
  let min2 = null;
  let max2 = null;
  scanner.eat(LEFTCURLYBRACKET2);
  scanner.skipWs();
  min2 = scanner.scanNumber(scanner);
  scanner.skipWs();
  if (scanner.charCode() === COMMA) {
    scanner.pos++;
    scanner.skipWs();
    if (scanner.charCode() !== RIGHTCURLYBRACKET) {
      max2 = scanner.scanNumber(scanner);
      scanner.skipWs();
    }
  } else {
    max2 = min2;
  }
  scanner.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min2),
    max: max2 ? Number(max2) : 0
  };
}
function readMultiplier(scanner) {
  let range = null;
  let comma = false;
  switch (scanner.charCode()) {
    case ASTERISK:
      scanner.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN4:
      scanner.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK2:
      scanner.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN2:
      scanner.pos++;
      comma = true;
      if (scanner.charCode() === LEFTCURLYBRACKET2) {
        range = readMultiplierRange(scanner);
      } else if (scanner.charCode() === QUESTIONMARK2) {
        scanner.pos++;
        range = {
          min: 0,
          max: 0
        };
      } else {
        range = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET2:
      range = readMultiplierRange(scanner);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null
  };
}
function maybeMultiplied(scanner, node) {
  const multiplier = readMultiplier(scanner);
  if (multiplier !== null) {
    multiplier.term = node;
    if (scanner.charCode() === NUMBERSIGN2 && scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN4) {
      return maybeMultiplied(scanner, multiplier);
    }
    return multiplier;
  }
  return node;
}
function maybeToken(scanner) {
  const ch = scanner.peek();
  if (ch === "") {
    return null;
  }
  return maybeMultiplied(scanner, {
    type: "Token",
    value: ch
  });
}
function readProperty(scanner) {
  let name;
  scanner.eat(LESSTHANSIGN);
  scanner.eat(APOSTROPHE);
  name = scanner.scanWord();
  scanner.eat(APOSTROPHE);
  scanner.eat(GREATERTHANSIGN);
  return maybeMultiplied(scanner, {
    type: "Property",
    name
  });
}
function readTypeRange(scanner) {
  let min2 = null;
  let max2 = null;
  let sign2 = 1;
  scanner.eat(LEFTSQUAREBRACKET);
  if (scanner.charCode() === HYPERMINUS) {
    scanner.peek();
    sign2 = -1;
  }
  if (sign2 == -1 && scanner.charCode() === INFINITY) {
    scanner.peek();
  } else {
    min2 = sign2 * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      min2 += scanner.scanWord();
    }
  }
  scanner.skipWs();
  scanner.eat(COMMA);
  scanner.skipWs();
  if (scanner.charCode() === INFINITY) {
    scanner.peek();
  } else {
    sign2 = 1;
    if (scanner.charCode() === HYPERMINUS) {
      scanner.peek();
      sign2 = -1;
    }
    max2 = sign2 * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      max2 += scanner.scanWord();
    }
  }
  scanner.eat(RIGHTSQUAREBRACKET);
  return {
    type: "Range",
    min: min2,
    max: max2
  };
}
function readType(scanner) {
  let name;
  let opts = null;
  scanner.eat(LESSTHANSIGN);
  name = scanner.scanWord();
  if (name === "boolean-expr") {
    scanner.eat(LEFTSQUAREBRACKET);
    const implicitGroup = readImplicitGroup(scanner, RIGHTSQUAREBRACKET);
    scanner.eat(RIGHTSQUAREBRACKET);
    scanner.eat(GREATERTHANSIGN);
    return maybeMultiplied(scanner, {
      type: "Boolean",
      term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
    });
  }
  if (scanner.charCode() === LEFTPARENTHESIS && scanner.nextCharCode() === RIGHTPARENTHESIS) {
    scanner.pos += 2;
    name += "()";
  }
  if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET) {
    scanner.skipWs();
    opts = readTypeRange(scanner);
  }
  scanner.eat(GREATERTHANSIGN);
  return maybeMultiplied(scanner, {
    type: "Type",
    name,
    opts
  });
}
function readKeywordOrFunction(scanner) {
  const name = scanner.scanWord();
  if (scanner.charCode() === LEFTPARENTHESIS) {
    scanner.pos++;
    return {
      type: "Function",
      name
    };
  }
  return maybeMultiplied(scanner, {
    type: "Keyword",
    name
  });
}
function regroupTerms(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a3, b2) => COMBINATOR_PRECEDENCE[a3] - COMBINATOR_PRECEDENCE[b2]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i4 = 0;
    let subgroupStart = 0;
    for (;i4 < terms.length; i4++) {
      const term = terms[i4];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i4 - 1;
          }
          terms.splice(i4, 1);
          i4--;
        } else {
          if (subgroupStart !== -1 && i4 - subgroupStart > 1) {
            terms.splice(subgroupStart, i4 - subgroupStart, createGroup(terms.slice(subgroupStart, i4), combinator));
            i4 = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(subgroupStart, i4 - subgroupStart, createGroup(terms.slice(subgroupStart, i4), combinator));
    }
  }
  return combinator;
}
function readImplicitGroup(scanner, stopCharCode) {
  const combinators = Object.create(null);
  const terms = [];
  let token;
  let prevToken = null;
  let prevTokenPos = scanner.pos;
  while (scanner.charCode() !== stopCharCode && (token = peek(scanner, stopCharCode))) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          scanner.pos = prevTokenPos;
          scanner.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = scanner.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    scanner.pos -= prevTokenPos;
    scanner.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup(scanner, stopCharCode) {
  let result;
  scanner.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(scanner, stopCharCode);
  scanner.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;
  if (scanner.charCode() === EXCLAMATIONMARK2) {
    scanner.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek(scanner, stopCharCode) {
  let code2 = scanner.charCode();
  switch (code2) {
    case RIGHTSQUAREBRACKET:
      break;
    case LEFTSQUAREBRACKET:
      return maybeMultiplied(scanner, readGroup(scanner, stopCharCode));
    case LESSTHANSIGN:
      return scanner.nextCharCode() === APOSTROPHE ? readProperty(scanner) : readType(scanner);
    case VERTICALLINE:
      return {
        type: "Combinator",
        value: scanner.substringToPos(scanner.pos + (scanner.nextCharCode() === VERTICALLINE ? 2 : 1))
      };
    case AMPERSAND:
      scanner.pos++;
      scanner.eat(AMPERSAND);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA:
      scanner.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE:
      return maybeMultiplied(scanner, {
        type: "String",
        value: scanner.scanString()
      });
    case SPACE2:
    case TAB2:
    case N4:
    case R5:
    case F3:
      return {
        type: "Spaces",
        value: scanner.scanSpaces()
      };
    case COMMERCIALAT:
      code2 = scanner.nextCharCode();
      if (scanner.isNameCharCode(code2)) {
        scanner.pos++;
        return {
          type: "AtKeyword",
          name: scanner.scanWord()
        };
      }
      return maybeToken(scanner);
    case ASTERISK:
    case PLUSSIGN4:
    case QUESTIONMARK2:
    case NUMBERSIGN2:
    case EXCLAMATIONMARK2:
      break;
    case LEFTCURLYBRACKET2:
      code2 = scanner.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken(scanner);
      }
      break;
    default:
      if (scanner.isNameCharCode(code2)) {
        return readKeywordOrFunction(scanner);
      }
      return maybeToken(scanner);
  }
}
function parse7(source) {
  const scanner = new Scanner(source);
  const result = readImplicitGroup(scanner);
  if (scanner.pos !== source.length) {
    scanner.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}
// node_modules/css-tree/lib/definition-syntax/walk.js
var noop4 = function() {};
function ensureFunction2(value) {
  return typeof value === "function" ? value : noop4;
}
function walk2(node, options, context) {
  function walk3(node2) {
    enter.call(context, node2);
    switch (node2.type) {
      case "Group":
        node2.terms.forEach(walk3);
        break;
      case "Multiplier":
      case "Boolean":
        walk3(node2.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node2.type);
    }
    leave.call(context, node2);
  }
  let enter = noop4;
  let leave = noop4;
  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction2(options.enter);
    leave = ensureFunction2(options.leave);
  }
  if (enter === noop4 && leave === noop4) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk3(node, context);
}
// node_modules/css-tree/lib/lexer/prepare-tokens.js
var astToTokens = {
  decorator(handlers) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers,
      node(node) {
        const tmp = curNode;
        curNode = node;
        handlers.node.call(this, node);
        curNode = tmp;
      },
      emit(value, type, auto) {
        tokens.push({
          type,
          value,
          node: auto ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens(str) {
  const tokens = [];
  tokenize2(str, (type, start2, end) => tokens.push({
    type,
    value: str.slice(start2, end),
    node: null
  }));
  return tokens;
}
function prepare_tokens_default(value, syntax) {
  if (typeof value === "string") {
    return stringToTokens(value);
  }
  return syntax.generate(value, astToTokens);
}

// node_modules/css-tree/lib/lexer/match-graph.js
var MATCH = { type: "Match" };
var MISMATCH = { type: "Mismatch" };
var DISALLOW_EMPTY = { type: "DisallowEmpty" };
var LEFTPARENTHESIS2 = 40;
var RIGHTPARENTHESIS2 = 41;
function createCondition(match, thenBranch, elseBranch) {
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }
  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }
  if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }
  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType(name) {
  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS2 && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS2;
}
function isEnumCapatible(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
}
function groupNode(terms, combinator = " ", explicit = false) {
  return {
    type: "Group",
    terms,
    combinator,
    disallowEmpty: false,
    explicit
  };
}
function replaceTypeInGraph(node, replacements, visited = new Set) {
  if (!visited.has(node)) {
    visited.add(node);
    switch (node.type) {
      case "If":
        node.match = replaceTypeInGraph(node.match, replacements, visited);
        node.then = replaceTypeInGraph(node.then, replacements, visited);
        node.else = replaceTypeInGraph(node.else, replacements, visited);
        break;
      case "Type":
        return replacements[node.name] || node;
    }
  }
  return node;
}
function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH;
      for (let i4 = terms.length - 1;i4 >= 0; i4--) {
        const term = terms[i4];
        result = createCondition(term, result, MISMATCH);
      }
      return result;
    }
    case "|": {
      let result = MISMATCH;
      let map = null;
      for (let i4 = terms.length - 1;i4 >= 0; i4--) {
        let term = terms[i4];
        if (isEnumCapatible(term)) {
          if (map === null && i4 > 0 && isEnumCapatible(terms[i4 - 1])) {
            map = Object.create(null);
            result = createCondition({
              type: "Enum",
              map
            }, MATCH, result);
          }
          if (map !== null) {
            const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition(term, MATCH, result);
      }
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH;
      for (let i4 = terms.length - 1;i4 >= 0; i4--) {
        const term = terms[i4];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
            return newGroupTerm !== term;
          }), false);
        } else {
          thenClause = MATCH;
        }
        result = createCondition(term, thenClause, result);
      }
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;
      for (let i4 = terms.length - 1;i4 >= 0; i4--) {
        const term = terms[i4];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
            return newGroupTerm !== term;
          }), true);
        } else {
          thenClause = MATCH;
        }
        result = createCondition(term, thenClause, result);
      }
      return result;
    }
  }
}
function buildMultiplierMatchGraph(node) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node.term);
  if (node.max === 0) {
    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
    result = createCondition(matchTerm, null, MISMATCH);
    result.then = createCondition(MATCH, MATCH, result);
    if (node.comma) {
      result.then.else = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
    }
  } else {
    for (let i4 = node.min || 1;i4 <= node.max; i4++) {
      if (node.comma && result !== MATCH) {
        result = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
      }
      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
    }
  }
  if (node.min === 0) {
    result = createCondition(MATCH, MATCH, result);
  } else {
    for (let i4 = 0;i4 < node.min - 1; i4++) {
      if (node.comma && result !== MATCH) {
        result = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
      }
      result = createCondition(matchTerm, result, MISMATCH);
    }
  }
  return result;
}
function buildMatchGraphInternal(node) {
  if (typeof node === "function") {
    return {
      type: "Generic",
      fn: node
    };
  }
  switch (node.type) {
    case "Group": {
      let result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraphInternal), false);
      if (node.disallowEmpty) {
        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph(node);
    case "Boolean": {
      const term = buildMatchGraphInternal(node.term);
      const matchNode = buildMatchGraphInternal(groupNode([
        groupNode([
          { type: "Keyword", name: "not" },
          { type: "Type", name: "!boolean-group" }
        ]),
        groupNode([
          { type: "Type", name: "!boolean-group" },
          groupNode([
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "and" },
              { type: "Type", name: "!boolean-group" }
            ]) },
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "or" },
              { type: "Type", name: "!boolean-group" }
            ]) }
          ], "|")
        ])
      ], "|"));
      const booleanGroup = buildMatchGraphInternal(groupNode([
        { type: "Type", name: "!term" },
        groupNode([
          { type: "Token", value: "(" },
          { type: "Type", name: "!self" },
          { type: "Token", value: ")" }
        ]),
        { type: "Type", name: "general-enclosed" }
      ], "|"));
      replaceTypeInGraph(booleanGroup, { "!term": term, "!self": matchNode });
      replaceTypeInGraph(matchNode, { "!boolean-group": booleanGroup });
      return matchNode;
    }
    case "Type":
    case "Property":
      return {
        type: node.type,
        name: node.name,
        syntax: node
      };
    case "Keyword":
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node
      };
    case "AtKeyword":
      return {
        type: node.type,
        name: "@" + node.name.toLowerCase(),
        syntax: node
      };
    case "Function":
      return {
        type: node.type,
        name: node.name.toLowerCase() + "(",
        syntax: node
      };
    case "String":
      if (node.value.length === 3) {
        return {
          type: "Token",
          value: node.value.charAt(1),
          syntax: node
        };
      }
      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
        syntax: node
      };
    case "Token":
      return {
        type: node.type,
        value: node.value,
        syntax: node
      };
    case "Comma":
      return {
        type: node.type,
        syntax: node
      };
    default:
      throw new Error("Unknown node type:", node.type);
  }
}
function buildMatchGraph(syntaxTree, ref2) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse7(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref2 || null,
    source: syntaxTree
  };
}

// node_modules/css-tree/lib/lexer/match.js
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;
var EXIT_REASON_MATCH = "Match";
var EXIT_REASON_MISMATCH = "Mismatch";
var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
var ITERATION_LIMIT = 15000;
var totalIterationCount = 0;
function reverseList(list2) {
  let prev = null;
  let next = null;
  let item = list2;
  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }
  return prev;
}
function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i4 = 0;i4 < testStr.length; i4++) {
    const referenceCode = referenceStr.charCodeAt(i4);
    let testCode = testStr.charCodeAt(i4);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim(token) {
  if (token.type !== Delim) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma || token.type === Function2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
}
function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
}
function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace || token.type === Comment2));
  }
  function getNextToken(offset2) {
    const nextIndex2 = tokenIndex + offset2;
    return nextIndex2 < tokens.length ? tokens[nextIndex2] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          }
          state = MATCH;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }
        for (;state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name = token.value.toLowerCase();
          if (name.indexOf("\\") !== -1) {
            name = name.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty4.call(state.map, name)) {
            state = state.map[name];
            break;
          }
        }
        state = MISMATCH;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty4.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error("Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>"));
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = state.name === "custom-ident" && token.type === Ident || state.name === "length" && token.value === "0";
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.matchRef || dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive(keywordName, name)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }
        state = MISMATCH;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Comma":
        if (token !== null && token.type === Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (;lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  totalIterationCount += iterationCount;
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}

// node_modules/css-tree/lib/lexer/trace.js
var exports_trace = {};
__export(exports_trace, {
  isType: () => isType,
  isProperty: () => isProperty,
  isKeyword: () => isKeyword,
  getTrace: () => getTrace
});
function getTrace(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }
    return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i4 = 0;i4 < matchNode.match.length; i4++) {
        if (hasMatch(matchNode.match[i4])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType(node, type) {
  return testNode(this, node, (match) => match.type === "Type" && match.name === type);
}
function isProperty(node, property2) {
  return testNode(this, node, (match) => match.type === "Property" && match.name === property2);
}
function isKeyword(node) {
  return testNode(this, node, (match) => match.type === "Keyword");
}
function testNode(match, node, fn) {
  const trace2 = getTrace.call(match, node);
  if (trace2 === null) {
    return false;
  }
  return trace2.some(fn);
}

// node_modules/css-tree/lib/lexer/search.js
function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode(matchNode.match[0]);
}
function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments(lexer, ast, match, type, name) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
      const start2 = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);
      lexer.syntax.walk(ast, function(node, item, list2) {
        if (node === start2) {
          const nodes = new List;
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list2,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match.matched !== null) {
    findFragments(match.matched);
  }
  return fragments;
}

// node_modules/css-tree/lib/lexer/structure.js
var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
function isValidNumber(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
}
function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}
function createNodeStructureChecker(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, "Type of node should be an Object");
    }
    for (let key in node) {
      let valid = true;
      if (hasOwnProperty5.call(node, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node.type !== type) {
          warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
        }
      } else if (key === "loc") {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i4 = 0;!valid && i4 < fields[key].length; i4++) {
          const fieldType = fields[key][i4];
          switch (fieldType) {
            case String:
              valid = typeof node[key] === "string";
              break;
            case Boolean:
              valid = typeof node[key] === "boolean";
              break;
            case null:
              valid = node[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List;
              }
          }
        }
      } else {
        warn(node, "Unknown field `" + key + "` for " + type + " node type");
      }
      if (!valid) {
        warn(node, "Bad value for `" + type + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty5.call(fields, key) && hasOwnProperty5.call(node, key) === false) {
        warn(node, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}
function genTypesList(fieldTypes, path2) {
  const docsTypes = [];
  for (let i4 = 0;i4 < fieldTypes.length; i4++) {
    const fieldType = fieldTypes[i4];
    if (fieldType === String || fieldType === Boolean) {
      docsTypes.push(fieldType.name.toLowerCase());
    } else if (fieldType === null) {
      docsTypes.push("null");
    } else if (typeof fieldType === "string") {
      docsTypes.push(fieldType);
    } else if (Array.isArray(fieldType)) {
      docsTypes.push("List<" + (genTypesList(fieldType, path2) || "any") + ">");
    } else {
      throw new Error("Wrong value `" + fieldType + "` in `" + path2 + "` structure definition");
    }
  }
  return docsTypes.join(" | ");
}
function processStructure(name, nodeType) {
  const structure = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name + '"'
  };
  for (const key in structure) {
    if (hasOwnProperty5.call(structure, key) === false) {
      continue;
    }
    const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
    docs[key] = genTypesList(fieldTypes, name + "." + key);
  }
  return {
    docs,
    check: createNodeStructureChecker(name, fields)
  };
}
function getStructureFromConfig(config) {
  const structure = {};
  if (config.node) {
    for (const name in config.node) {
      if (hasOwnProperty5.call(config.node, name)) {
        const nodeType = config.node[name];
        if (nodeType.structure) {
          structure[name] = processStructure(name, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name + "` node type definition");
        }
      }
    }
  }
  return structure;
}

// node_modules/css-tree/lib/lexer/Lexer.js
function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const name in map) {
    if (map[name].syntax) {
      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name, atrule] of Object.entries(map)) {
    result[name] = {
      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar(tokens) {
  for (let i4 = 0;i4 < tokens.length; i4++) {
    if (tokens[i4].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function syntaxHasTopLevelCommaMultiplier(syntax) {
  const singleTerm = syntax.terms[0];
  return syntax.explicit === false && syntax.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
}
function buildMatchResult(matched, error, iterations) {
  return {
    matched,
    iterations,
    error,
    ...exports_trace
  };
}
function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
  const tokens = prepare_tokens_default(value, lexer.syntax);
  let result;
  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree(tokens, syntax.match, lexer);
    if (!result.match) {
      return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);
    }
  }
  return buildMatchResult(result.match, null, result.iterations);
}

class Lexer {
  constructor(config, syntax, structure) {
    this.cssWideKeywords = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.units = { ...exports_units };
    this.atrules = Object.create(null);
    this.properties = Object.create(null);
    this.types = Object.create(null);
    this.structure = structure || getStructureFromConfig(config);
    if (config) {
      if (config.cssWideKeywords) {
        this.cssWideKeywords = config.cssWideKeywords;
      }
      if (config.units) {
        for (const group of Object.keys(exports_units)) {
          if (Array.isArray(config.units[group])) {
            this.units[group] = config.units[group];
          }
        }
      }
      if (config.types) {
        for (const [name, type] of Object.entries(config.types)) {
          this.addType_(name, type);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const [name, value] of Object.entries(createGenericTypes(this.units))) {
          this.addType_(name, value);
        }
      }
      if (config.atrules) {
        for (const [name, atrule] of Object.entries(config.atrules)) {
          this.addAtrule_(name, atrule);
        }
      }
      if (config.properties) {
        for (const [name, property2] of Object.entries(config.properties)) {
          this.addProperty_(name, property2);
        }
      }
    }
    this.cssWideKeywordsSyntax = buildMatchGraph(this.cssWideKeywords.join(" |  "));
  }
  checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({ node, message });
    }
    const structure = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node) {
      if (structure.hasOwnProperty(node.type)) {
        structure[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, "Unknown node type `" + node.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax, type, name, parent = null) {
    const ref2 = {
      type,
      name
    };
    const descriptor = {
      type,
      name,
      parent,
      serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
      syntax: null,
      match: null,
      matchRef: null
    };
    if (typeof syntax === "function") {
      descriptor.match = buildMatchGraph(syntax, ref2);
    } else {
      if (typeof syntax === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse7(syntax)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph(descriptor.syntax, ref2)
          });
          return descriptor.match;
        }
      });
      if (type === "Property") {
        Object.defineProperty(descriptor, "matchRef", {
          get() {
            const syntax2 = descriptor.syntax;
            const value = syntaxHasTopLevelCommaMultiplier(syntax2) ? buildMatchGraph({
              ...syntax2,
              terms: [syntax2.terms[0].term]
            }, ref2) : null;
            Object.defineProperty(descriptor, "matchRef", {
              value
            });
            return value;
          }
        });
      }
    }
    return descriptor;
  }
  addAtrule_(name, syntax) {
    if (!syntax) {
      return;
    }
    this.atrules[name] = {
      type: "Atrule",
      name,
      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((map, descName) => {
        map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
        return map;
      }, Object.create(null)) : null
    };
  }
  addProperty_(name, syntax) {
    if (!syntax) {
      return;
    }
    this.properties[name] = this.createDescriptor(syntax, "Property", name);
  }
  addType_(name, syntax) {
    if (!syntax) {
      return;
    }
    this.types[name] = this.createDescriptor(syntax, "Type", name);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule.prelude && !prelude) {
      if (!matchSyntax(this, atrule.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    if (!atrule.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtrulePrelude(atruleName, prelude);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude) {
      return buildMatchResult(null, null);
    }
    return matchSyntax(this, atrule.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value) {
    const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
  }
  matchDeclaration(node) {
    if (node.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node.property, node.value);
  }
  matchProperty(propertyName, value) {
    if (property(propertyName).custom) {
      return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error = this.checkPropertyName(propertyName);
    if (error) {
      return buildMatchResult(null, error);
    }
    return matchSyntax(this, this.getProperty(propertyName), value, true);
  }
  matchType(typeName, value) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
    }
    return matchSyntax(this, typeSyntax, value, false);
  }
  match(syntax, value) {
    if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
      return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
    }
    if (typeof syntax === "string" || !syntax.match) {
      syntax = this.createDescriptor(syntax, "Type", "anonymous");
    }
    return matchSyntax(this, syntax, value, false);
  }
  findValueFragments(propertyName, value, type, name) {
    return matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
  }
  findDeclarationValueFragments(declaration, type, name) {
    return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
  }
  findAllFragments(ast, type, name) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule = keyword(atruleName);
    const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule = this.getAtrule(atruleName, fallbackBasename);
    return atrule && atrule.prelude || null;
  }
  getAtruleDescriptor(atruleName, name) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property2 = property(propertyName);
    const propertyEntry = property2.vendor && fallbackBasename ? this.properties[property2.name] || this.properties[property2.basename] : this.properties[property2.name];
    return propertyEntry || null;
  }
  getType(name) {
    return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
  }
  validate() {
    function syntaxRef(name, isType2) {
      return isType2 ? `<${name}>` : `<'${name}'>`;
    }
    function validate(syntax, name, broken, descriptor) {
      if (broken.has(name)) {
        return broken.get(name);
      }
      broken.set(name, false);
      if (descriptor.syntax !== null) {
        walk2(descriptor.syntax, function(node) {
          if (node.type !== "Type" && node.type !== "Property") {
            return;
          }
          const map = node.type === "Type" ? syntax.types : syntax.properties;
          const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node.name)) {
            errors.push(`${syntaxRef(name, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node.name, node.type === "Type")}`);
            broken.set(name, true);
          } else if (validate(syntax, node.name, brokenMap, map[node.name])) {
            errors.push(`${syntaxRef(name, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node.name, node.type === "Type")}`);
            broken.set(name, true);
          }
        }, this);
      }
    }
    const errors = [];
    let brokenTypes = new Map;
    let brokenProperties = new Map;
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    const brokenTypesArray = [...brokenTypes.keys()].filter((name) => brokenTypes.get(name));
    const brokenPropertiesArray = [...brokenProperties.keys()].filter((name) => brokenProperties.get(name));
    if (brokenTypesArray.length || brokenPropertiesArray.length) {
      return {
        errors,
        types: brokenTypesArray,
        properties: brokenPropertiesArray
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      cssWideKeywords: this.cssWideKeywords,
      units: this.units,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
}

// node_modules/css-tree/lib/syntax/config/mix.js
function appendOrSet(a3, b2) {
  if (typeof b2 === "string" && /^\s*\|/.test(b2)) {
    return typeof a3 === "string" ? a3 + b2 : b2.replace(/^\s*\|\s*/, "");
  }
  return b2 || null;
}
function sliceProps(obj, props) {
  const result = Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    if (value) {
      result[key] = {};
      for (const prop of Object.keys(value)) {
        if (props.includes(prop)) {
          result[key][prop] = value[prop];
        }
      }
    }
  }
  return result;
}
function mix(dest, src) {
  const result = { ...dest };
  for (const [prop, value] of Object.entries(src)) {
    switch (prop) {
      case "generic":
        result[prop] = Boolean(value);
        break;
      case "cssWideKeywords":
        result[prop] = dest[prop] ? [...dest[prop], ...value] : value || [];
        break;
      case "units":
        result[prop] = { ...dest[prop] };
        for (const [name, patch] of Object.entries(value)) {
          result[prop][name] = Array.isArray(patch) ? patch : [];
        }
        break;
      case "atrules":
        result[prop] = { ...dest[prop] };
        for (const [name, atrule] of Object.entries(value)) {
          const exists = result[prop][name] || {};
          const current2 = result[prop][name] = {
            prelude: exists.prelude || null,
            descriptors: {
              ...exists.descriptors
            }
          };
          if (!atrule) {
            continue;
          }
          current2.prelude = atrule.prelude ? appendOrSet(current2.prelude, atrule.prelude) : current2.prelude || null;
          for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
            current2.descriptors[descriptorName] = descriptorValue ? appendOrSet(current2.descriptors[descriptorName], descriptorValue) : null;
          }
          if (!Object.keys(current2.descriptors).length) {
            current2.descriptors = null;
          }
        }
        break;
      case "types":
      case "properties":
        result[prop] = { ...dest[prop] };
        for (const [name, syntax] of Object.entries(value)) {
          result[prop][name] = appendOrSet(result[prop][name], syntax);
        }
        break;
      case "scope":
      case "features":
        result[prop] = { ...dest[prop] };
        for (const [name, props] of Object.entries(value)) {
          result[prop][name] = { ...result[prop][name], ...props };
        }
        break;
      case "parseContext":
        result[prop] = {
          ...dest[prop],
          ...value
        };
        break;
      case "atrule":
      case "pseudo":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["parse"])
        };
        break;
      case "node":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["name", "structure", "parse", "generate", "walkContext"])
        };
        break;
    }
  }
  return result;
}

// node_modules/css-tree/lib/syntax/create.js
function createSyntax(config) {
  const parse8 = createParser(config);
  const walk3 = createWalker(config);
  const generate2 = createGenerator(config);
  const { fromPlainObject, toPlainObject } = createConvertor(walk3);
  const syntax = {
    lexer: null,
    createLexer: (config2) => new Lexer(config2, syntax, syntax.lexer.structure),
    tokenize: tokenize2,
    parse: parse8,
    generate: generate2,
    walk: walk3,
    find: walk3.find,
    findLast: walk3.findLast,
    findAll: walk3.findAll,
    fromPlainObject,
    toPlainObject,
    fork(extension) {
      const base = mix({}, config);
      return createSyntax(typeof extension === "function" ? extension(base) : mix(base, extension));
    }
  };
  syntax.lexer = new Lexer({
    generic: config.generic,
    cssWideKeywords: config.cssWideKeywords,
    units: config.units,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax);
  return syntax;
}
var create_default = (config) => createSyntax(mix({}, config));

// deps/mock-module.js
var Screen2 = {
  mainScreen: {
    widthDIPs: typeof window !== "undefined" ? window.innerWidth : 1024,
    heightDIPs: typeof window !== "undefined" ? window.innerHeight : 768,
    scale: typeof window !== "undefined" ? window.devicePixelRatio : 1
  }
};
var createRequire = () => () => ({});

// node_modules/css-tree/lib/data-patch.js
var require2 = createRequire(import.meta.url);
var patch = require2("../data/patch.json");
var data_patch_default = patch;

// node_modules/css-tree/lib/data.js
var require3 = createRequire(import.meta.url);
var mdnAtrules = require3("mdn-data/css/at-rules.json");
var mdnProperties = require3("mdn-data/css/properties.json");
var mdnSyntaxes = require3("mdn-data/css/syntaxes.json");
var hasOwn2 = Object.hasOwn || ((object, property2) => Object.prototype.hasOwnProperty.call(object, property2));
var extendSyntax = /^\s*\|\s*/;
function preprocessAtrules(dict) {
  const result = Object.create(null);
  for (const [atruleName, atrule] of Object.entries(dict)) {
    let descriptors = null;
    if (atrule.descriptors) {
      descriptors = Object.create(null);
      for (const [name, descriptor] of Object.entries(atrule.descriptors)) {
        descriptors[name] = descriptor.syntax;
      }
    }
    result[atruleName.substr(1)] = {
      prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
      descriptors
    };
  }
  return result;
}
function patchDictionary(dict, patchDict) {
  const result = Object.create(null);
  for (const [key, value] of Object.entries(dict)) {
    if (value) {
      result[key] = value.syntax || value;
    }
  }
  for (const key of Object.keys(patchDict)) {
    if (hasOwn2(dict, key)) {
      if (patchDict[key].syntax) {
        result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
      } else {
        delete result[key];
      }
    } else {
      if (patchDict[key].syntax) {
        result[key] = patchDict[key].syntax.replace(extendSyntax, "");
      }
    }
  }
  return result;
}
function preprocessPatchAtrulesDescritors(declarations) {
  const result = {};
  for (const [key, value] of Object.entries(declarations || {})) {
    result[key] = typeof value === "string" ? { syntax: value } : value;
  }
  return result;
}
function patchAtrules(dict, patchDict) {
  const result = {};
  for (const key in dict) {
    if (patchDict[key] === null) {
      continue;
    }
    const atrulePatch = patchDict[key] || {};
    result[key] = {
      prelude: key in patchDict && "prelude" in atrulePatch ? atrulePatch.prelude : dict[key].prelude || null,
      descriptors: patchDictionary(dict[key].descriptors || {}, preprocessPatchAtrulesDescritors(atrulePatch.descriptors))
    };
  }
  for (const [key, atrulePatch] of Object.entries(patchDict)) {
    if (atrulePatch && !hasOwn2(dict, key)) {
      result[key] = {
        prelude: atrulePatch.prelude || null,
        descriptors: atrulePatch.descriptors ? patchDictionary({}, preprocessPatchAtrulesDescritors(atrulePatch.descriptors)) : null
      };
    }
  }
  return result;
}
var data_default = {
  types: patchDictionary(mdnSyntaxes, data_patch_default.types),
  atrules: patchAtrules(preprocessAtrules(mdnAtrules), data_patch_default.atrules),
  properties: patchDictionary(mdnProperties, data_patch_default.properties)
};

// node_modules/css-tree/lib/syntax/node/index.js
var exports_node = {};
__export(exports_node, {
  WhiteSpace: () => exports_WhiteSpace,
  Value: () => exports_Value,
  Url: () => exports_Url,
  UnicodeRange: () => exports_UnicodeRange,
  TypeSelector: () => exports_TypeSelector,
  SupportsDeclaration: () => exports_SupportsDeclaration,
  StyleSheet: () => exports_StyleSheet,
  String: () => exports_String,
  SelectorList: () => exports_SelectorList,
  Selector: () => exports_Selector,
  Scope: () => exports_Scope,
  Rule: () => exports_Rule,
  Raw: () => exports_Raw,
  Ratio: () => exports_Ratio,
  PseudoElementSelector: () => exports_PseudoElementSelector,
  PseudoClassSelector: () => exports_PseudoClassSelector,
  Percentage: () => exports_Percentage,
  Parentheses: () => exports_Parentheses,
  Operator: () => exports_Operator,
  Number: () => exports_Number,
  Nth: () => exports_Nth,
  NestingSelector: () => exports_NestingSelector,
  MediaQueryList: () => exports_MediaQueryList,
  MediaQuery: () => exports_MediaQuery,
  LayerList: () => exports_LayerList,
  Layer: () => exports_Layer,
  Identifier: () => exports_Identifier,
  IdSelector: () => exports_IdSelector,
  Hash: () => exports_Hash,
  GeneralEnclosed: () => exports_GeneralEnclosed,
  Function: () => exports_Function,
  FeatureRange: () => exports_FeatureRange,
  FeatureFunction: () => exports_FeatureFunction,
  Feature: () => exports_Feature,
  Dimension: () => exports_Dimension,
  DeclarationList: () => exports_DeclarationList,
  Declaration: () => exports_Declaration,
  Condition: () => exports_Condition,
  Comment: () => exports_Comment,
  Combinator: () => exports_Combinator,
  ClassSelector: () => exports_ClassSelector,
  CDO: () => exports_CDO,
  CDC: () => exports_CDC,
  Brackets: () => exports_Brackets,
  Block: () => exports_Block,
  AttributeSelector: () => exports_AttributeSelector,
  AtrulePrelude: () => exports_AtrulePrelude,
  Atrule: () => exports_Atrule,
  AnPlusB: () => exports_AnPlusB
});

// node_modules/css-tree/lib/syntax/node/AnPlusB.js
var exports_AnPlusB = {};
__export(exports_AnPlusB, {
  structure: () => structure,
  parse: () => parse8,
  name: () => name,
  generate: () => generate2
});
var PLUSSIGN5 = 43;
var HYPHENMINUS5 = 45;
var N5 = 110;
var DISALLOW_SIGN2 = true;
var ALLOW_SIGN2 = false;
function checkInteger2(offset2, disallowSign) {
  let pos = this.tokenStart + offset2;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN5 || code2 === HYPHENMINUS5) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (;pos < this.tokenEnd; pos++) {
    if (!isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger2.call(this, 0, disallowSign);
}
function expectCharCode(offset2, code2) {
  if (!this.cmpChar(this.tokenStart + offset2, code2)) {
    let msg = "";
    switch (code2) {
      case N5:
        msg = "N is expected";
        break;
      case HYPHENMINUS5:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset2);
  }
}
function consumeB2() {
  let offset2 = 0;
  let sign2 = 0;
  let type = this.tokenType;
  while (type === WhiteSpace || type === Comment2) {
    type = this.lookupType(++offset2);
  }
  if (type !== Number2) {
    if (this.isDelim(PLUSSIGN5, offset2) || this.isDelim(HYPHENMINUS5, offset2)) {
      sign2 = this.isDelim(PLUSSIGN5, offset2) ? PLUSSIGN5 : HYPHENMINUS5;
      do {
        type = this.lookupType(++offset2);
      } while (type === WhiteSpace || type === Comment2);
      if (type !== Number2) {
        this.skip(offset2);
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
      }
    } else {
      return null;
    }
  }
  if (offset2 > 0) {
    this.skip(offset2);
  }
  if (sign2 === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN5 && type !== HYPHENMINUS5) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign2 !== 0);
  return sign2 === HYPHENMINUS5 ? "-" + this.consume(Number2) : this.consume(Number2);
}
var name = "AnPlusB";
var structure = {
  a: [String, null],
  b: [String, null]
};
function parse8() {
  const start2 = this.tokenStart;
  let a3 = null;
  let b2 = null;
  if (this.tokenType === Number2) {
    checkTokenIsInteger.call(this, ALLOW_SIGN2);
    b2 = this.consume(Number2);
  } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS5)) {
    a3 = "-1";
    expectCharCode.call(this, 1, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 2:
        this.next();
        b2 = consumeB2.call(this);
        break;
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b2 = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        checkInteger2.call(this, 3, DISALLOW_SIGN2);
        this.next();
        b2 = this.substrToCursor(start2 + 2);
    }
  } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN5) && this.lookupType(1) === Ident) {
    let sign2 = 0;
    a3 = "1";
    if (this.isDelim(PLUSSIGN5)) {
      sign2 = 1;
      this.next();
    }
    expectCharCode.call(this, 0, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 1:
        this.next();
        b2 = consumeB2.call(this);
        break;
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b2 = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        checkInteger2.call(this, 2, DISALLOW_SIGN2);
        this.next();
        b2 = this.substrToCursor(start2 + sign2 + 1);
    }
  } else if (this.tokenType === Dimension) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign2 = code2 === PLUSSIGN5 || code2 === HYPHENMINUS5;
    let i4 = this.tokenStart + sign2;
    for (;i4 < this.tokenEnd; i4++) {
      if (!isDigit(this.charCodeAt(i4))) {
        break;
      }
    }
    if (i4 === this.tokenStart + sign2) {
      this.error("Integer is expected", this.tokenStart + sign2);
    }
    expectCharCode.call(this, i4 - this.tokenStart, N5);
    a3 = this.substring(start2, i4);
    if (i4 + 1 === this.tokenEnd) {
      this.next();
      b2 = consumeB2.call(this);
    } else {
      expectCharCode.call(this, i4 - this.tokenStart + 1, HYPHENMINUS5);
      if (i4 + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b2 = "-" + this.consume(Number2);
      } else {
        checkInteger2.call(this, i4 - this.tokenStart + 2, DISALLOW_SIGN2);
        this.next();
        b2 = this.substrToCursor(i4 + 1);
      }
    }
  } else {
    this.error();
  }
  if (a3 !== null && a3.charCodeAt(0) === PLUSSIGN5) {
    a3 = a3.substr(1);
  }
  if (b2 !== null && b2.charCodeAt(0) === PLUSSIGN5) {
    b2 = b2.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start2, this.tokenStart),
    a: a3,
    b: b2
  };
}
function generate2(node) {
  if (node.a) {
    const a3 = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
    if (node.b) {
      const b2 = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
      this.tokenize(a3 + b2);
    } else {
      this.tokenize(a3);
    }
  } else {
    this.tokenize(node.b);
  }
}
// node_modules/css-tree/lib/syntax/node/Atrule.js
var exports_Atrule = {};
__export(exports_Atrule, {
  walkContext: () => walkContext,
  structure: () => structure2,
  parse: () => parse9,
  name: () => name2,
  generate: () => generate3
});
function consumeRaw() {
  return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (let offset2 = 1, type;type = this.lookupType(offset2); offset2++) {
    if (type === RightCurlyBracket) {
      return true;
    }
    if (type === LeftCurlyBracket || type === AtKeyword) {
      return false;
    }
  }
  return false;
}
var name2 = "Atrule";
var walkContext = "atrule";
var structure2 = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse9(isDeclaration2 = false) {
  const start2 = this.tokenStart;
  let name3;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword);
  name3 = this.substrToCursor(start2 + 1);
  nameLowerCase = name3.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name3, isDeclaration2), consumeRaw);
    } else {
      prelude = consumeRaw.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon:
      this.next();
      break;
    case LeftCurlyBracket:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this, isDeclaration2);
      } else {
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start2, this.tokenStart),
    name: name3,
    prelude,
    block
  };
}
function generate3(node) {
  this.token(AtKeyword, "@" + node.name);
  if (node.prelude !== null) {
    this.node(node.prelude);
  }
  if (node.block) {
    this.node(node.block);
  } else {
    this.token(Semicolon, ";");
  }
}
// node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var exports_AtrulePrelude = {};
__export(exports_AtrulePrelude, {
  walkContext: () => walkContext2,
  structure: () => structure3,
  parse: () => parse10,
  name: () => name3,
  generate: () => generate4
});
var name3 = "AtrulePrelude";
var walkContext2 = "atrulePrelude";
var structure3 = {
  children: [[]]
};
function parse10(name4) {
  let children = null;
  if (name4 !== null) {
    name4 = name4.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name4) && typeof this.atrule[name4].prelude === "function") {
    children = this.atrule[name4].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate4(node) {
  this.children(node);
}
// node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var exports_AttributeSelector = {};
__export(exports_AttributeSelector, {
  structure: () => structure4,
  parse: () => parse11,
  name: () => name4,
  generate: () => generate5
});
var DOLLARSIGN = 36;
var ASTERISK2 = 42;
var EQUALSSIGN = 61;
var CIRCUMFLEXACCENT = 94;
var VERTICALLINE2 = 124;
var TILDE = 126;
function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start2 = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK2)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE2)) {
    this.eat(Ident);
  }
  if (this.isDelim(VERTICALLINE2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
      this.next();
      this.eat(Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start2, this.tokenStart),
    name: this.substrToCursor(start2)
  };
}
function getOperator() {
  const start2 = this.tokenStart;
  const code2 = this.charCodeAt(start2);
  if (code2 !== EQUALSSIGN && code2 !== TILDE && code2 !== CIRCUMFLEXACCENT && code2 !== DOLLARSIGN && code2 !== ASTERISK2 && code2 !== VERTICALLINE2) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN) {
    if (!this.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start2);
}
var name4 = "AttributeSelector";
var structure4 = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse11() {
  const start2 = this.tokenStart;
  let name5;
  let matcher = null;
  let value = null;
  let flags = null;
  this.eat(LeftSquareBracket);
  this.skipSC();
  name5 = getAttributeName.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket) {
    if (this.tokenType !== Ident) {
      matcher = getOperator.call(this);
      this.skipSC();
      value = this.tokenType === String2 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident) {
      flags = this.consume(Ident);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start2, this.tokenStart),
    name: name5,
    matcher,
    value,
    flags
  };
}
function generate5(node) {
  this.token(Delim, "[");
  this.node(node.name);
  if (node.matcher !== null) {
    this.tokenize(node.matcher);
    this.node(node.value);
  }
  if (node.flags !== null) {
    this.token(Ident, node.flags);
  }
  this.token(Delim, "]");
}
// node_modules/css-tree/lib/syntax/node/Block.js
var exports_Block = {};
__export(exports_Block, {
  walkContext: () => walkContext3,
  structure: () => structure5,
  parse: () => parse12,
  name: () => name5,
  generate: () => generate6
});
var AMPERSAND2 = 38;
function consumeRaw2() {
  return this.Raw(null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw2);
}
function consumeRawDeclaration() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }
  const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.tokenType === Semicolon) {
    this.next();
  }
  return node;
}
var name5 = "Block";
var walkContext3 = "block";
var structure5 = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse12(isStyleBlock) {
  const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
  const start2 = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace:
        case Comment2:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw2));
          break;
        default:
          if (isStyleBlock && this.isDelim(AMPERSAND2)) {
            children.push(consumeRule.call(this));
          } else {
            children.push(consumer.call(this));
          }
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket);
  }
  return {
    type: "Block",
    loc: this.getLocation(start2, this.tokenStart),
    children
  };
}
function generate6(node) {
  this.token(LeftCurlyBracket, "{");
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
  this.token(RightCurlyBracket, "}");
}
// node_modules/css-tree/lib/syntax/node/Brackets.js
var exports_Brackets = {};
__export(exports_Brackets, {
  structure: () => structure6,
  parse: () => parse13,
  name: () => name6,
  generate: () => generate7
});
var name6 = "Brackets";
var structure6 = {
  children: [[]]
};
function parse13(readSequence2, recognizer) {
  const start2 = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start2, this.tokenStart),
    children
  };
}
function generate7(node) {
  this.token(Delim, "[");
  this.children(node);
  this.token(Delim, "]");
}
// node_modules/css-tree/lib/syntax/node/CDC.js
var exports_CDC = {};
__export(exports_CDC, {
  structure: () => structure7,
  parse: () => parse14,
  name: () => name7,
  generate: () => generate8
});
var name7 = "CDC";
var structure7 = [];
function parse14() {
  const start2 = this.tokenStart;
  this.eat(CDC);
  return {
    type: "CDC",
    loc: this.getLocation(start2, this.tokenStart)
  };
}
function generate8() {
  this.token(CDC, "-->");
}
// node_modules/css-tree/lib/syntax/node/CDO.js
var exports_CDO = {};
__export(exports_CDO, {
  structure: () => structure8,
  parse: () => parse15,
  name: () => name8,
  generate: () => generate9
});
var name8 = "CDO";
var structure8 = [];
function parse15() {
  const start2 = this.tokenStart;
  this.eat(CDO);
  return {
    type: "CDO",
    loc: this.getLocation(start2, this.tokenStart)
  };
}
function generate9() {
  this.token(CDO, "<!--");
}
// node_modules/css-tree/lib/syntax/node/ClassSelector.js
var exports_ClassSelector = {};
__export(exports_ClassSelector, {
  structure: () => structure9,
  parse: () => parse16,
  name: () => name9,
  generate: () => generate10
});
var FULLSTOP = 46;
var name9 = "ClassSelector";
var structure9 = {
  name: String
};
function parse16() {
  this.eatDelim(FULLSTOP);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate10(node) {
  this.token(Delim, ".");
  this.token(Ident, node.name);
}
// node_modules/css-tree/lib/syntax/node/Combinator.js
var exports_Combinator = {};
__export(exports_Combinator, {
  structure: () => structure10,
  parse: () => parse17,
  name: () => name10,
  generate: () => generate11
});
var PLUSSIGN6 = 43;
var SOLIDUS = 47;
var GREATERTHANSIGN2 = 62;
var TILDE2 = 126;
var name10 = "Combinator";
var structure10 = {
  name: String
};
function parse17() {
  const start2 = this.tokenStart;
  let name11;
  switch (this.tokenType) {
    case WhiteSpace:
      name11 = " ";
      break;
    case Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN2:
        case PLUSSIGN6:
        case TILDE2:
          this.next();
          break;
        case SOLIDUS:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS);
          break;
        default:
          this.error("Combinator is expected");
      }
      name11 = this.substrToCursor(start2);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start2, this.tokenStart),
    name: name11
  };
}
function generate11(node) {
  this.tokenize(node.name);
}
// node_modules/css-tree/lib/syntax/node/Comment.js
var exports_Comment = {};
__export(exports_Comment, {
  structure: () => structure11,
  parse: () => parse18,
  name: () => name11,
  generate: () => generate12
});
var ASTERISK3 = 42;
var SOLIDUS2 = 47;
var name11 = "Comment";
var structure11 = {
  value: String
};
function parse18() {
  const start2 = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment2);
  if (end - start2 + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK3 && this.charCodeAt(end - 1) === SOLIDUS2) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start2, this.tokenStart),
    value: this.substring(start2 + 2, end)
  };
}
function generate12(node) {
  this.token(Comment2, "/*" + node.value + "*/");
}
// node_modules/css-tree/lib/syntax/node/Condition.js
var exports_Condition = {};
__export(exports_Condition, {
  structure: () => structure12,
  parse: () => parse19,
  name: () => name12,
  generate: () => generate13
});
var likelyFeatureToken = new Set([Colon, RightParenthesis, EOF]);
var name12 = "Condition";
var structure12 = {
  kind: String,
  children: [[
    "Identifier",
    "Feature",
    "FeatureFunction",
    "FeatureRange",
    "SupportsDeclaration"
  ]]
};
function featureOrRange(kind) {
  if (this.lookupTypeNonSC(1) === Ident && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
    return this.Feature(kind);
  }
  return this.FeatureRange(kind);
}
var parentheses = {
  media: featureOrRange,
  container: featureOrRange,
  supports() {
    return this.SupportsDeclaration();
  }
};
function parse19(kind = "media") {
  const children = this.createList();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment2:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          children.push(this.Identifier());
          break;
        case LeftParenthesis: {
          let term = this.parseWithFallback(() => parentheses[kind].call(this, kind), () => null);
          if (!term) {
            term = this.parseWithFallback(() => {
              this.eat(LeftParenthesis);
              const res = this.Condition(kind);
              this.eat(RightParenthesis);
              return res;
            }, () => {
              return this.GeneralEnclosed(kind);
            });
          }
          children.push(term);
          break;
        }
        case Function2: {
          let term = this.parseWithFallback(() => this.FeatureFunction(kind), () => null);
          if (!term) {
            term = this.GeneralEnclosed(kind);
          }
          children.push(term);
          break;
        }
        default:
          break scan;
      }
    }
  if (children.isEmpty) {
    this.error("Condition is expected");
  }
  return {
    type: "Condition",
    loc: this.getLocationFromList(children),
    kind,
    children
  };
}
function generate13(node) {
  node.children.forEach((child) => {
    if (child.type === "Condition") {
      this.token(LeftParenthesis, "(");
      this.node(child);
      this.token(RightParenthesis, ")");
    } else {
      this.node(child);
    }
  });
}
// node_modules/css-tree/lib/syntax/node/Declaration.js
var exports_Declaration = {};
__export(exports_Declaration, {
  walkContext: () => walkContext4,
  structure: () => structure13,
  parse: () => parse20,
  name: () => name13,
  generate: () => generate14
});
var EXCLAMATIONMARK3 = 33;
var NUMBERSIGN3 = 35;
var DOLLARSIGN2 = 36;
var AMPERSAND3 = 38;
var ASTERISK4 = 42;
var PLUSSIGN7 = 43;
var SOLIDUS3 = 47;
function consumeValueRaw() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value = this.Value();
  if (value.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK3) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value;
}
var name13 = "Declaration";
var walkContext4 = "declaration";
var structure13 = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse20() {
  const start2 = this.tokenStart;
  const startToken = this.tokenIndex;
  const property2 = readProperty2.call(this);
  const customProperty = isCustomProperty(property2);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw3 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
  let important = false;
  let value;
  this.skipSC();
  this.eat(Colon);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value = this.parseWithFallback(consumeValue, consumeRaw3);
  } else {
    value = consumeRaw3.call(this, this.tokenIndex);
  }
  if (customProperty && value.type === "Value" && value.children.isEmpty) {
    for (let offset2 = valueStart - this.tokenIndex;offset2 <= 0; offset2++) {
      if (this.lookupType(offset2) === WhiteSpace) {
        value.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK3)) {
    important = getImportant.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start2, this.tokenStart),
    important,
    property: property2,
    value
  };
}
function generate14(node) {
  this.token(Ident, node.property);
  this.token(Colon, ":");
  this.node(node.value);
  if (node.important) {
    this.token(Delim, "!");
    this.token(Ident, node.important === true ? "important" : node.important);
  }
}
function readProperty2() {
  const start2 = this.tokenStart;
  if (this.tokenType === Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK4:
      case DOLLARSIGN2:
      case PLUSSIGN7:
      case NUMBERSIGN3:
      case AMPERSAND3:
        this.next();
        break;
      case SOLIDUS3:
        this.next();
        if (this.isDelim(SOLIDUS3)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash) {
    this.eat(Hash);
  } else {
    this.eat(Ident);
  }
  return this.substrToCursor(start2);
}
function getImportant() {
  this.eat(Delim);
  this.skipSC();
  const important = this.consume(Ident);
  return important === "important" ? true : important;
}
// node_modules/css-tree/lib/syntax/node/DeclarationList.js
var exports_DeclarationList = {};
__export(exports_DeclarationList, {
  structure: () => structure14,
  parse: () => parse21,
  name: () => name14,
  generate: () => generate15
});
var AMPERSAND4 = 38;
function consumeRaw3() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
var name14 = "DeclarationList";
var structure14 = {
  children: [[
    "Declaration",
    "Atrule",
    "Rule"
  ]]
};
function parse21() {
  const children = this.createList();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
        case Comment2:
        case Semicolon:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw3));
          break;
        default:
          if (this.isDelim(AMPERSAND4)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw3));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw3));
          }
      }
    }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate15(node) {
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
}
// node_modules/css-tree/lib/syntax/node/Dimension.js
var exports_Dimension = {};
__export(exports_Dimension, {
  structure: () => structure15,
  parse: () => parse22,
  name: () => name15,
  generate: () => generate16
});
var name15 = "Dimension";
var structure15 = {
  value: String,
  unit: String
};
function parse22() {
  const start2 = this.tokenStart;
  const value = this.consumeNumber(Dimension);
  return {
    type: "Dimension",
    loc: this.getLocation(start2, this.tokenStart),
    value,
    unit: this.substring(start2 + value.length, this.tokenStart)
  };
}
function generate16(node) {
  this.token(Dimension, node.value + node.unit);
}
// node_modules/css-tree/lib/syntax/node/Feature.js
var exports_Feature = {};
__export(exports_Feature, {
  structure: () => structure16,
  parse: () => parse23,
  name: () => name16,
  generate: () => generate17
});
var SOLIDUS4 = 47;
var name16 = "Feature";
var structure16 = {
  kind: String,
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function parse23(kind) {
  const start2 = this.tokenStart;
  let name17;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  name17 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Ident:
        value = this.Identifier();
        break;
      case Function2:
        value = this.parseWithFallback(() => {
          const res = this.Function(this.readSequence, this.scope.Value);
          this.skipSC();
          if (this.isDelim(SOLIDUS4)) {
            this.error();
          }
          return res;
        }, () => {
          return this.Ratio();
        });
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Feature",
    loc: this.getLocation(start2, this.tokenStart),
    kind,
    name: name17,
    value
  };
}
function generate17(node) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/FeatureFunction.js
var exports_FeatureFunction = {};
__export(exports_FeatureFunction, {
  structure: () => structure17,
  parse: () => parse24,
  name: () => name17,
  generate: () => generate18
});
var name17 = "FeatureFunction";
var structure17 = {
  kind: String,
  feature: String,
  value: ["Declaration", "Selector"]
};
function getFeatureParser(kind, name18) {
  const featuresOfKind = this.features[kind] || {};
  const parser = featuresOfKind[name18];
  if (typeof parser !== "function") {
    this.error(`Unknown feature ${name18}()`);
  }
  return parser;
}
function parse24(kind = "unknown") {
  const start2 = this.tokenStart;
  const functionName = this.consumeFunctionName();
  const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
  this.skipSC();
  const value = this.parseWithFallback(() => {
    const startValueToken = this.tokenIndex;
    const value2 = valueParser.call(this);
    if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return value2;
  }, () => this.Raw(null, false));
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "FeatureFunction",
    loc: this.getLocation(start2, this.tokenStart),
    kind,
    feature: functionName,
    value
  };
}
function generate18(node) {
  this.token(Function2, node.feature + "(");
  this.node(node.value);
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/FeatureRange.js
var exports_FeatureRange = {};
__export(exports_FeatureRange, {
  structure: () => structure18,
  parse: () => parse25,
  name: () => name18,
  generate: () => generate19
});
var SOLIDUS5 = 47;
var LESSTHANSIGN2 = 60;
var EQUALSSIGN2 = 61;
var GREATERTHANSIGN3 = 62;
var name18 = "FeatureRange";
var structure18 = {
  kind: String,
  left: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  leftComparison: String,
  middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  rightComparison: [String, null],
  right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function readTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number2:
      if (this.isDelim(SOLIDUS5, this.lookupOffsetNonSC(1))) {
        return this.Ratio();
      } else {
        return this.Number();
      }
    case Dimension:
      return this.Dimension();
    case Ident:
      return this.Identifier();
    case Function2:
      return this.parseWithFallback(() => {
        const res = this.Function(this.readSequence, this.scope.Value);
        this.skipSC();
        if (this.isDelim(SOLIDUS5)) {
          this.error();
        }
        return res;
      }, () => {
        return this.Ratio();
      });
    default:
      this.error("Number, dimension, ratio or identifier is expected");
  }
}
function readComparison(expectColon) {
  this.skipSC();
  if (this.isDelim(LESSTHANSIGN2) || this.isDelim(GREATERTHANSIGN3)) {
    const value = this.source[this.tokenStart];
    this.next();
    if (this.isDelim(EQUALSSIGN2)) {
      this.next();
      return value + "=";
    }
    return value;
  }
  if (this.isDelim(EQUALSSIGN2)) {
    return "=";
  }
  this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
}
function parse25(kind = "unknown") {
  const start2 = this.tokenStart;
  this.skipSC();
  this.eat(LeftParenthesis);
  const left = readTerm.call(this);
  const leftComparison = readComparison.call(this, left.type === "Identifier");
  const middle = readTerm.call(this);
  let rightComparison = null;
  let right = null;
  if (this.lookupNonWSType(0) !== RightParenthesis) {
    rightComparison = readComparison.call(this);
    right = readTerm.call(this);
  }
  this.skipSC();
  this.eat(RightParenthesis);
  return {
    type: "FeatureRange",
    loc: this.getLocation(start2, this.tokenStart),
    kind,
    left,
    leftComparison,
    middle,
    rightComparison,
    right
  };
}
function generate19(node) {
  this.token(LeftParenthesis, "(");
  this.node(node.left);
  this.tokenize(node.leftComparison);
  this.node(node.middle);
  if (node.right) {
    this.tokenize(node.rightComparison);
    this.node(node.right);
  }
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/Function.js
var exports_Function = {};
__export(exports_Function, {
  walkContext: () => walkContext5,
  structure: () => structure19,
  parse: () => parse26,
  name: () => name19,
  generate: () => generate20
});
var name19 = "Function";
var walkContext5 = "function";
var structure19 = {
  name: String,
  children: [[]]
};
function parse26(readSequence2, recognizer) {
  const start2 = this.tokenStart;
  const name20 = this.consumeFunctionName();
  const nameLowerCase = name20.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Function",
    loc: this.getLocation(start2, this.tokenStart),
    name: name20,
    children
  };
}
function generate20(node) {
  this.token(Function2, node.name + "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/GeneralEnclosed.js
var exports_GeneralEnclosed = {};
__export(exports_GeneralEnclosed, {
  structure: () => structure20,
  parse: () => parse27,
  name: () => name20,
  generate: () => generate21
});
var name20 = "GeneralEnclosed";
var structure20 = {
  kind: String,
  function: [String, null],
  children: [[]]
};
function parse27(kind) {
  const start2 = this.tokenStart;
  let functionName = null;
  if (this.tokenType === Function2) {
    functionName = this.consumeFunctionName();
  } else {
    this.eat(LeftParenthesis);
  }
  const children = this.parseWithFallback(() => {
    const startValueToken = this.tokenIndex;
    const children2 = this.readSequence(this.scope.Value);
    if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return children2;
  }, () => this.createSingleNodeList(this.Raw(null, false)));
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "GeneralEnclosed",
    loc: this.getLocation(start2, this.tokenStart),
    kind,
    function: functionName,
    children
  };
}
function generate21(node) {
  if (node.function) {
    this.token(Function2, node.function + "(");
  } else {
    this.token(LeftParenthesis, "(");
  }
  this.children(node);
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/Hash.js
var exports_Hash = {};
__export(exports_Hash, {
  xxx: () => xxx,
  structure: () => structure21,
  parse: () => parse28,
  name: () => name21,
  generate: () => generate22
});
var xxx = "XXX";
var name21 = "Hash";
var structure21 = {
  value: String
};
function parse28() {
  const start2 = this.tokenStart;
  this.eat(Hash);
  return {
    type: "Hash",
    loc: this.getLocation(start2, this.tokenStart),
    value: this.substrToCursor(start2 + 1)
  };
}
function generate22(node) {
  this.token(Hash, "#" + node.value);
}
// node_modules/css-tree/lib/syntax/node/Identifier.js
var exports_Identifier = {};
__export(exports_Identifier, {
  structure: () => structure22,
  parse: () => parse29,
  name: () => name22,
  generate: () => generate23
});
var name22 = "Identifier";
var structure22 = {
  name: String
};
function parse29() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate23(node) {
  this.token(Ident, node.name);
}
// node_modules/css-tree/lib/syntax/node/IdSelector.js
var exports_IdSelector = {};
__export(exports_IdSelector, {
  structure: () => structure23,
  parse: () => parse30,
  name: () => name23,
  generate: () => generate24
});
var name23 = "IdSelector";
var structure23 = {
  name: String
};
function parse30() {
  const start2 = this.tokenStart;
  this.eat(Hash);
  return {
    type: "IdSelector",
    loc: this.getLocation(start2, this.tokenStart),
    name: this.substrToCursor(start2 + 1)
  };
}
function generate24(node) {
  this.token(Delim, "#" + node.name);
}
// node_modules/css-tree/lib/syntax/node/Layer.js
var exports_Layer = {};
__export(exports_Layer, {
  structure: () => structure24,
  parse: () => parse31,
  name: () => name24,
  generate: () => generate25
});
var FULLSTOP2 = 46;
var name24 = "Layer";
var structure24 = {
  name: String
};
function parse31() {
  let tokenStart = this.tokenStart;
  let name25 = this.consume(Ident);
  while (this.isDelim(FULLSTOP2)) {
    this.eat(Delim);
    name25 += "." + this.consume(Ident);
  }
  return {
    type: "Layer",
    loc: this.getLocation(tokenStart, this.tokenStart),
    name: name25
  };
}
function generate25(node) {
  this.tokenize(node.name);
}
// node_modules/css-tree/lib/syntax/node/LayerList.js
var exports_LayerList = {};
__export(exports_LayerList, {
  structure: () => structure25,
  parse: () => parse32,
  name: () => name25,
  generate: () => generate26
});
var name25 = "LayerList";
var structure25 = {
  children: [[
    "Layer"
  ]]
};
function parse32() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.Layer());
    if (this.lookupTypeNonSC(0) !== Comma) {
      break;
    }
    this.skipSC();
    this.next();
    this.skipSC();
  }
  return {
    type: "LayerList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate26(node) {
  this.children(node, () => this.token(Comma, ","));
}
// node_modules/css-tree/lib/syntax/node/MediaQuery.js
var exports_MediaQuery = {};
__export(exports_MediaQuery, {
  structure: () => structure26,
  parse: () => parse33,
  name: () => name26,
  generate: () => generate27
});
var name26 = "MediaQuery";
var structure26 = {
  modifier: [String, null],
  mediaType: [String, null],
  condition: ["Condition", null]
};
function parse33() {
  const start2 = this.tokenStart;
  let modifier = null;
  let mediaType = null;
  let condition = null;
  this.skipSC();
  if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {
    const ident = this.consume(Ident);
    const identLowerCase = ident.toLowerCase();
    if (identLowerCase === "not" || identLowerCase === "only") {
      this.skipSC();
      modifier = identLowerCase;
      mediaType = this.consume(Ident);
    } else {
      mediaType = ident;
    }
    switch (this.lookupTypeNonSC(0)) {
      case Ident: {
        this.skipSC();
        this.eatIdent("and");
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket:
      case Semicolon:
      case Comma:
      case EOF:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  } else {
    switch (this.tokenType) {
      case Ident:
      case LeftParenthesis:
      case Function2: {
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket:
      case Semicolon:
      case EOF:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  }
  return {
    type: "MediaQuery",
    loc: this.getLocation(start2, this.tokenStart),
    modifier,
    mediaType,
    condition
  };
}
function generate27(node) {
  if (node.mediaType) {
    if (node.modifier) {
      this.token(Ident, node.modifier);
    }
    this.token(Ident, node.mediaType);
    if (node.condition) {
      this.token(Ident, "and");
      this.node(node.condition);
    }
  } else if (node.condition) {
    this.node(node.condition);
  }
}
// node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var exports_MediaQueryList = {};
__export(exports_MediaQueryList, {
  structure: () => structure27,
  parse: () => parse34,
  name: () => name27,
  generate: () => generate28
});
var name27 = "MediaQueryList";
var structure27 = {
  children: [[
    "MediaQuery"
  ]]
};
function parse34() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate28(node) {
  this.children(node, () => this.token(Comma, ","));
}
// node_modules/css-tree/lib/syntax/node/NestingSelector.js
var exports_NestingSelector = {};
__export(exports_NestingSelector, {
  structure: () => structure28,
  parse: () => parse35,
  name: () => name28,
  generate: () => generate29
});
var AMPERSAND5 = 38;
var name28 = "NestingSelector";
var structure28 = {};
function parse35() {
  const start2 = this.tokenStart;
  this.eatDelim(AMPERSAND5);
  return {
    type: "NestingSelector",
    loc: this.getLocation(start2, this.tokenStart)
  };
}
function generate29() {
  this.token(Delim, "&");
}
// node_modules/css-tree/lib/syntax/node/Nth.js
var exports_Nth = {};
__export(exports_Nth, {
  structure: () => structure29,
  parse: () => parse36,
  name: () => name29,
  generate: () => generate30
});
var name29 = "Nth";
var structure29 = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse36() {
  this.skipSC();
  const start2 = this.tokenStart;
  let end = start2;
  let selector = null;
  let nth;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth = this.Identifier();
  } else {
    nth = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start2, end),
    nth,
    selector
  };
}
function generate30(node) {
  this.node(node.nth);
  if (node.selector !== null) {
    this.token(Ident, "of");
    this.node(node.selector);
  }
}
// node_modules/css-tree/lib/syntax/node/Number.js
var exports_Number = {};
__export(exports_Number, {
  structure: () => structure30,
  parse: () => parse37,
  name: () => name30,
  generate: () => generate31
});
var name30 = "Number";
var structure30 = {
  value: String
};
function parse37() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number2)
  };
}
function generate31(node) {
  this.token(Number2, node.value);
}
// node_modules/css-tree/lib/syntax/node/Operator.js
var exports_Operator = {};
__export(exports_Operator, {
  structure: () => structure31,
  parse: () => parse38,
  name: () => name31,
  generate: () => generate32
});
var name31 = "Operator";
var structure31 = {
  value: String
};
function parse38() {
  const start2 = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start2, this.tokenStart),
    value: this.substrToCursor(start2)
  };
}
function generate32(node) {
  this.tokenize(node.value);
}
// node_modules/css-tree/lib/syntax/node/Parentheses.js
var exports_Parentheses = {};
__export(exports_Parentheses, {
  structure: () => structure32,
  parse: () => parse39,
  name: () => name32,
  generate: () => generate33
});
var name32 = "Parentheses";
var structure32 = {
  children: [[]]
};
function parse39(readSequence2, recognizer) {
  const start2 = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start2, this.tokenStart),
    children
  };
}
function generate33(node) {
  this.token(LeftParenthesis, "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/Percentage.js
var exports_Percentage = {};
__export(exports_Percentage, {
  structure: () => structure33,
  parse: () => parse40,
  name: () => name33,
  generate: () => generate34
});
var name33 = "Percentage";
var structure33 = {
  value: String
};
function parse40() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage)
  };
}
function generate34(node) {
  this.token(Percentage, node.value + "%");
}
// node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var exports_PseudoClassSelector = {};
__export(exports_PseudoClassSelector, {
  walkContext: () => walkContext6,
  structure: () => structure34,
  parse: () => parse41,
  name: () => name34,
  generate: () => generate35
});
var name34 = "PseudoClassSelector";
var walkContext6 = "function";
var structure34 = {
  name: String,
  children: [["Raw"], null]
};
function parse41() {
  const start2 = this.tokenStart;
  let children = null;
  let name35;
  let nameLowerCase;
  this.eat(Colon);
  if (this.tokenType === Function2) {
    name35 = this.consumeFunctionName();
    nameLowerCase = name35.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(this.Raw(null, false));
    }
    this.eat(RightParenthesis);
  } else {
    name35 = this.consume(Ident);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start2, this.tokenStart),
    name: name35,
    children
  };
}
function generate35(node) {
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}
// node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var exports_PseudoElementSelector = {};
__export(exports_PseudoElementSelector, {
  walkContext: () => walkContext7,
  structure: () => structure35,
  parse: () => parse42,
  name: () => name35,
  generate: () => generate36
});
var name35 = "PseudoElementSelector";
var walkContext7 = "function";
var structure35 = {
  name: String,
  children: [["Raw"], null]
};
function parse42() {
  const start2 = this.tokenStart;
  let children = null;
  let name36;
  let nameLowerCase;
  this.eat(Colon);
  this.eat(Colon);
  if (this.tokenType === Function2) {
    name36 = this.consumeFunctionName();
    nameLowerCase = name36.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(this.Raw(null, false));
    }
    this.eat(RightParenthesis);
  } else {
    name36 = this.consume(Ident);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start2, this.tokenStart),
    name: name36,
    children
  };
}
function generate36(node) {
  this.token(Colon, ":");
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}
// node_modules/css-tree/lib/syntax/node/Ratio.js
var exports_Ratio = {};
__export(exports_Ratio, {
  structure: () => structure36,
  parse: () => parse43,
  name: () => name36,
  generate: () => generate37
});
var SOLIDUS6 = 47;
function consumeTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number2:
      return this.Number();
    case Function2:
      return this.Function(this.readSequence, this.scope.Value);
    default:
      this.error("Number of function is expected");
  }
}
var name36 = "Ratio";
var structure36 = {
  left: ["Number", "Function"],
  right: ["Number", "Function", null]
};
function parse43() {
  const start2 = this.tokenStart;
  const left = consumeTerm.call(this);
  let right = null;
  this.skipSC();
  if (this.isDelim(SOLIDUS6)) {
    this.eatDelim(SOLIDUS6);
    right = consumeTerm.call(this);
  }
  return {
    type: "Ratio",
    loc: this.getLocation(start2, this.tokenStart),
    left,
    right
  };
}
function generate37(node) {
  this.node(node.left);
  this.token(Delim, "/");
  if (node.right) {
    this.node(node.right);
  } else {
    this.node(Number2, 1);
  }
}
// node_modules/css-tree/lib/syntax/node/Raw.js
var exports_Raw = {};
__export(exports_Raw, {
  structure: () => structure37,
  parse: () => parse44,
  name: () => name37,
  generate: () => generate38
});
function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
var name37 = "Raw";
var structure37 = {
  value: String
};
function parse44(consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(this.tokenIndex);
  let endOffset;
  this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate38(node) {
  this.tokenize(node.value);
}
// node_modules/css-tree/lib/syntax/node/Rule.js
var exports_Rule = {};
__export(exports_Rule, {
  walkContext: () => walkContext8,
  structure: () => structure38,
  parse: () => parse45,
  name: () => name38,
  generate: () => generate39
});
function consumeRaw4() {
  return this.Raw(this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
    this.error();
  }
  return prelude;
}
var name38 = "Rule";
var walkContext8 = "rule";
var structure38 = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse45() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw4);
  } else {
    prelude = consumeRaw4.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate39(node) {
  this.node(node.prelude);
  this.node(node.block);
}
// node_modules/css-tree/lib/syntax/node/Scope.js
var exports_Scope = {};
__export(exports_Scope, {
  structure: () => structure39,
  parse: () => parse46,
  name: () => name39,
  generate: () => generate40
});
var name39 = "Scope";
var structure39 = {
  root: ["SelectorList", "Raw", null],
  limit: ["SelectorList", "Raw", null]
};
function parse46() {
  let root = null;
  let limit = null;
  this.skipSC();
  const startOffset = this.tokenStart;
  if (this.tokenType === LeftParenthesis) {
    this.next();
    this.skipSC();
    root = this.parseWithFallback(this.SelectorList, () => this.Raw(false, true));
    this.skipSC();
    this.eat(RightParenthesis);
  }
  if (this.lookupNonWSType(0) === Ident) {
    this.skipSC();
    this.eatIdent("to");
    this.skipSC();
    this.eat(LeftParenthesis);
    this.skipSC();
    limit = this.parseWithFallback(this.SelectorList, () => this.Raw(false, true));
    this.skipSC();
    this.eat(RightParenthesis);
  }
  return {
    type: "Scope",
    loc: this.getLocation(startOffset, this.tokenStart),
    root,
    limit
  };
}
function generate40(node) {
  if (node.root) {
    this.token(LeftParenthesis, "(");
    this.node(node.root);
    this.token(RightParenthesis, ")");
  }
  if (node.limit) {
    this.token(Ident, "to");
    this.token(LeftParenthesis, "(");
    this.node(node.limit);
    this.token(RightParenthesis, ")");
  }
}
// node_modules/css-tree/lib/syntax/node/Selector.js
var exports_Selector = {};
__export(exports_Selector, {
  structure: () => structure40,
  parse: () => parse47,
  name: () => name40,
  generate: () => generate41
});
var name40 = "Selector";
var structure40 = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator"
  ]]
};
function parse47() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate41(node) {
  this.children(node);
}
// node_modules/css-tree/lib/syntax/node/SelectorList.js
var exports_SelectorList = {};
__export(exports_SelectorList, {
  walkContext: () => walkContext9,
  structure: () => structure41,
  parse: () => parse48,
  name: () => name41,
  generate: () => generate42
});
var name41 = "SelectorList";
var walkContext9 = "selector";
var structure41 = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse48() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate42(node) {
  this.children(node, () => this.token(Comma, ","));
}
// node_modules/css-tree/lib/syntax/node/String.js
var exports_String = {};
__export(exports_String, {
  structure: () => structure42,
  parse: () => parse49,
  name: () => name42,
  generate: () => generate43
});

// node_modules/css-tree/lib/utils/string.js
var REVERSE_SOLIDUS = 92;
var QUOTATION_MARK = 34;
var APOSTROPHE2 = 39;
function decode2(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start2 = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE2 ? 1 : 0;
  const end = start2 === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i4 = start2;i4 <= end; i4++) {
    let code2 = str.charCodeAt(i4);
    if (code2 === REVERSE_SOLIDUS) {
      if (i4 === end) {
        if (i4 !== len - 1) {
          decoded = str.substr(i4 + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i4);
      if (isValidEscape(REVERSE_SOLIDUS, code2)) {
        const escapeStart = i4 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i4 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i4 + 1) === 10) {
          i4++;
        }
      }
    } else {
      decoded += str[i4];
    }
  }
  return decoded;
}
function encode(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE2 : QUOTATION_MARK;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i4 = 0;i4 < str.length; i4++) {
    const code2 = str.charCodeAt(i4);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS) {
      encoded += "\\" + str.charAt(i4);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit2(code2) || isWhiteSpace(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i4);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}

// node_modules/css-tree/lib/syntax/node/String.js
var name42 = "String";
var structure42 = {
  value: String
};
function parse49() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode2(this.consume(String2))
  };
}
function generate43(node) {
  this.token(String2, encode(node.value));
}
// node_modules/css-tree/lib/syntax/node/StyleSheet.js
var exports_StyleSheet = {};
__export(exports_StyleSheet, {
  walkContext: () => walkContext10,
  structure: () => structure43,
  parse: () => parse50,
  name: () => name43,
  generate: () => generate44
});
var EXCLAMATIONMARK4 = 33;
function consumeRaw5() {
  return this.Raw(null, false);
}
var name43 = "StyleSheet";
var walkContext10 = "stylesheet";
var structure43 = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse50() {
  const start2 = this.tokenStart;
  const children = this.createList();
  let child;
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
          this.next();
          continue;
        case Comment2:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK4) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO:
          child = this.CDO();
          break;
        case CDC:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw5);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw5);
      }
      children.push(child);
    }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start2, this.tokenStart),
    children
  };
}
function generate44(node) {
  this.children(node);
}
// node_modules/css-tree/lib/syntax/node/SupportsDeclaration.js
var exports_SupportsDeclaration = {};
__export(exports_SupportsDeclaration, {
  structure: () => structure44,
  parse: () => parse51,
  name: () => name44,
  generate: () => generate45
});
var name44 = "SupportsDeclaration";
var structure44 = {
  declaration: "Declaration"
};
function parse51() {
  const start2 = this.tokenStart;
  this.eat(LeftParenthesis);
  this.skipSC();
  const declaration = this.Declaration();
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "SupportsDeclaration",
    loc: this.getLocation(start2, this.tokenStart),
    declaration
  };
}
function generate45(node) {
  this.token(LeftParenthesis, "(");
  this.node(node.declaration);
  this.token(RightParenthesis, ")");
}
// node_modules/css-tree/lib/syntax/node/TypeSelector.js
var exports_TypeSelector = {};
__export(exports_TypeSelector, {
  structure: () => structure45,
  parse: () => parse52,
  name: () => name45,
  generate: () => generate46
});
var ASTERISK5 = 42;
var VERTICALLINE3 = 124;
function eatIdentifierOrAsterisk() {
  if (this.tokenType !== Ident && this.isDelim(ASTERISK5) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
var name45 = "TypeSelector";
var structure45 = {
  name: String
};
function parse52() {
  const start2 = this.tokenStart;
  if (this.isDelim(VERTICALLINE3)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);
    if (this.isDelim(VERTICALLINE3)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start2, this.tokenStart),
    name: this.substrToCursor(start2)
  };
}
function generate46(node) {
  this.tokenize(node.name);
}
// node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var exports_UnicodeRange = {};
__export(exports_UnicodeRange, {
  structure: () => structure46,
  parse: () => parse53,
  name: () => name46,
  generate: () => generate47
});
var PLUSSIGN8 = 43;
var HYPHENMINUS6 = 45;
var QUESTIONMARK3 = 63;
function eatHexSequence(offset2, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset2;pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS6 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset2 + len + 1, false);
      return -1;
    }
    if (!isHexDigit2(code2)) {
      this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence(max2) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK3)) {
    if (++count > max2) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith2(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN8 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number2:
      hexLength = eatHexSequence.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK3)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension || this.tokenType === Number2) {
        startsWith2.call(this, HYPHENMINUS6);
        eatHexSequence.call(this, 1, false);
        break;
      }
      break;
    case Dimension:
      hexLength = eatHexSequence.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN8);
      if (this.tokenType === Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK3)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
var name46 = "UnicodeRange";
var structure46 = {
  value: String
};
function parse53() {
  const start2 = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start2, this.tokenStart),
    value: this.substrToCursor(start2)
  };
}
function generate47(node) {
  this.tokenize(node.value);
}
// node_modules/css-tree/lib/syntax/node/Url.js
var exports_Url = {};
__export(exports_Url, {
  structure: () => structure47,
  parse: () => parse54,
  name: () => name47,
  generate: () => generate48
});

// node_modules/css-tree/lib/utils/url.js
var SPACE3 = 32;
var REVERSE_SOLIDUS2 = 92;
var QUOTATION_MARK2 = 34;
var APOSTROPHE3 = 39;
var LEFTPARENTHESIS3 = 40;
var RIGHTPARENTHESIS3 = 41;
function decode3(str) {
  const len = str.length;
  let start2 = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS3 ? len - 2 : len - 1;
  let decoded = "";
  while (start2 < end && isWhiteSpace(str.charCodeAt(start2))) {
    start2++;
  }
  while (start2 < end && isWhiteSpace(str.charCodeAt(end))) {
    end--;
  }
  for (let i4 = start2;i4 <= end; i4++) {
    let code2 = str.charCodeAt(i4);
    if (code2 === REVERSE_SOLIDUS2) {
      if (i4 === end) {
        if (i4 !== len - 1) {
          decoded = str.substr(i4 + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i4);
      if (isValidEscape(REVERSE_SOLIDUS2, code2)) {
        const escapeStart = i4 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i4 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i4 + 1) === 10) {
          i4++;
        }
      }
    } else {
      decoded += str[i4];
    }
  }
  return decoded;
}
function encode2(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i4 = 0;i4 < str.length; i4++) {
    const code2 = str.charCodeAt(i4);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE3 || code2 === REVERSE_SOLIDUS2 || code2 === QUOTATION_MARK2 || code2 === APOSTROPHE3 || code2 === LEFTPARENTHESIS3 || code2 === RIGHTPARENTHESIS3) {
      encoded += "\\" + str.charAt(i4);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit2(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i4);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}

// node_modules/css-tree/lib/syntax/node/Url.js
var name47 = "Url";
var structure47 = {
  value: String
};
function parse54() {
  const start2 = this.tokenStart;
  let value;
  switch (this.tokenType) {
    case Url:
      value = decode3(this.consume(Url));
      break;
    case Function2:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function2);
      this.skipSC();
      value = decode2(this.consume(String2));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start2, this.tokenStart),
    value
  };
}
function generate48(node) {
  this.token(Url, encode2(node.value));
}
// node_modules/css-tree/lib/syntax/node/Value.js
var exports_Value = {};
__export(exports_Value, {
  structure: () => structure48,
  parse: () => parse55,
  name: () => name48,
  generate: () => generate49
});
var name48 = "Value";
var structure48 = {
  children: [[]]
};
function parse55() {
  const start2 = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start2, this.tokenStart),
    children
  };
}
function generate49(node) {
  this.children(node);
}
// node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var exports_WhiteSpace = {};
__export(exports_WhiteSpace, {
  structure: () => structure49,
  parse: () => parse56,
  name: () => name49,
  generate: () => generate50
});
var SPACE4 = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
var name49 = "WhiteSpace";
var structure49 = {
  value: String
};
function parse56() {
  this.eat(WhiteSpace);
  return SPACE4;
}
function generate50(node) {
  this.token(WhiteSpace, node.value);
}
// node_modules/css-tree/lib/syntax/config/lexer.js
var lexer_default = {
  generic: true,
  cssWideKeywords,
  ...data_default,
  node: exports_node
};

// node_modules/css-tree/lib/syntax/scope/index.js
var exports_scope = {};
__export(exports_scope, {
  Value: () => value_default,
  Selector: () => selector_default,
  AtrulePrelude: () => atrulePrelude_default
});

// node_modules/css-tree/lib/syntax/scope/default.js
var NUMBERSIGN4 = 35;
var ASTERISK6 = 42;
var PLUSSIGN9 = 43;
var HYPHENMINUS7 = 45;
var SOLIDUS7 = 47;
var U3 = 117;
function defaultRecognizer(context) {
  switch (this.tokenType) {
    case Hash:
      return this.Hash();
    case Comma:
      return this.Operator();
    case LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);
    case LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);
    case String2:
      return this.String();
    case Dimension:
      return this.Dimension();
    case Percentage:
      return this.Percentage();
    case Number2:
      return this.Number();
    case Function2:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
    case Url:
      return this.Url();
    case Ident:
      if (this.cmpChar(this.tokenStart, U3) && this.cmpChar(this.tokenStart + 1, PLUSSIGN9)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS7 || code2 === ASTERISK6 || code2 === PLUSSIGN9 || code2 === HYPHENMINUS7) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN4) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}

// node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
var atrulePrelude_default = {
  getNode: defaultRecognizer
};
// node_modules/css-tree/lib/syntax/scope/selector.js
var NUMBERSIGN5 = 35;
var AMPERSAND6 = 38;
var ASTERISK7 = 42;
var PLUSSIGN10 = 43;
var SOLIDUS8 = 47;
var FULLSTOP3 = 46;
var GREATERTHANSIGN4 = 62;
var VERTICALLINE4 = 124;
var TILDE3 = 126;
function onWhiteSpace(next, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
    children.push({
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode() {
  switch (this.tokenType) {
    case LeftSquareBracket:
      return this.AttributeSelector();
    case Hash:
      return this.IdSelector();
    case Colon:
      if (this.lookupType(1) === Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident:
      return this.TypeSelector();
    case Number2:
    case Percentage:
      return this.Percentage();
    case Dimension:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP3) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN10:
        case GREATERTHANSIGN4:
        case TILDE3:
        case SOLIDUS8:
          return this.Combinator();
        case FULLSTOP3:
          return this.ClassSelector();
        case ASTERISK7:
        case VERTICALLINE4:
          return this.TypeSelector();
        case NUMBERSIGN5:
          return this.IdSelector();
        case AMPERSAND6:
          return this.NestingSelector();
      }
      break;
    }
  }
}
var selector_default = {
  onWhiteSpace,
  getNode
};
// node_modules/css-tree/lib/syntax/function/expression.js
function expression_default() {
  return this.createSingleNodeList(this.Raw(null, false));
}

// node_modules/css-tree/lib/syntax/function/var.js
function var_default() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value.type === "Value" && value.children.isEmpty) {
      for (let offset2 = startIndex - this.tokenIndex;offset2 <= 0; offset2++) {
        if (this.lookupType(offset2) === WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value);
  }
  return children;
}

// node_modules/css-tree/lib/syntax/scope/value.js
function isPlusMinusOperator(node) {
  return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
}
var value_default = {
  getNode: defaultRecognizer,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  expression: expression_default,
  var: var_default
};
// node_modules/css-tree/lib/syntax/atrule/container.js
var nonContainerNameKeywords = new Set(["none", "and", "not", "or"]);
var container_default = {
  parse: {
    prelude() {
      const children = this.createList();
      if (this.tokenType === Ident) {
        const name50 = this.substring(this.tokenStart, this.tokenEnd);
        if (!nonContainerNameKeywords.has(name50.toLowerCase())) {
          children.push(this.Identifier());
        }
      }
      children.push(this.Condition("container"));
      return children;
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/font-face.js
var font_face_default = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/import.js
function parseWithFallback(parse57, fallback) {
  return this.parseWithFallback(() => {
    try {
      return parse57.call(this);
    } finally {
      this.skipSC();
      if (this.lookupNonWSType(0) !== RightParenthesis) {
        this.error();
      }
    }
  }, fallback || (() => this.Raw(null, true)));
}
var parseFunctions = {
  layer() {
    this.skipSC();
    const children = this.createList();
    const node = parseWithFallback.call(this, this.Layer);
    if (node.type !== "Raw" || node.value !== "") {
      children.push(node);
    }
    return children;
  },
  supports() {
    this.skipSC();
    const children = this.createList();
    const node = parseWithFallback.call(this, this.Declaration, () => parseWithFallback.call(this, () => this.Condition("supports")));
    if (node.type !== "Raw" || node.value !== "") {
      children.push(node);
    }
    return children;
  }
};
var import_default3 = {
  parse: {
    prelude() {
      const children = this.createList();
      switch (this.tokenType) {
        case String2:
          children.push(this.String());
          break;
        case Url:
        case Function2:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      this.skipSC();
      if (this.tokenType === Ident && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
        children.push(this.Identifier());
      } else if (this.tokenType === Function2 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
        children.push(this.Function(null, parseFunctions));
      }
      this.skipSC();
      if (this.tokenType === Function2 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
        children.push(this.Function(null, parseFunctions));
      }
      if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};

// node_modules/css-tree/lib/syntax/atrule/layer.js
var layer_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.LayerList());
    },
    block() {
      return this.Block(false);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/media.js
var media_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.MediaQueryList());
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/nest.js
var nest_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.SelectorList());
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/page.js
var page_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.SelectorList());
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/scope.js
var scope_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.Scope());
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/starting-style.js
var starting_style_default = {
  parse: {
    prelude: null,
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/supports.js
var supports_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(this.Condition("supports"));
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/index.js
var atrule_default = {
  container: container_default,
  "font-face": font_face_default,
  import: import_default3,
  layer: layer_default,
  media: media_default,
  nest: nest_default,
  page: page_default,
  scope: scope_default,
  "starting-style": starting_style_default,
  supports: supports_default
};

// node_modules/css-tree/lib/syntax/pseudo/lang.js
function parseLanguageRangeList() {
  const children = this.createList();
  this.skipSC();
  loop:
    while (!this.eof) {
      switch (this.tokenType) {
        case Ident:
          children.push(this.Identifier());
          break;
        case String2:
          children.push(this.String());
          break;
        case Comma:
          children.push(this.Operator());
          break;
        case RightParenthesis:
          break loop;
        default:
          this.error("Identifier, string or comma is expected");
      }
      this.skipSC();
    }
  return children;
}

// node_modules/css-tree/lib/syntax/pseudo/index.js
var selectorList = {
  parse() {
    return this.createSingleNodeList(this.SelectorList());
  }
};
var selector = {
  parse() {
    return this.createSingleNodeList(this.Selector());
  }
};
var identList = {
  parse() {
    return this.createSingleNodeList(this.Identifier());
  }
};
var langList = {
  parse: parseLanguageRangeList
};
var nth = {
  parse() {
    return this.createSingleNodeList(this.Nth());
  }
};
var pseudo_default = {
  dir: identList,
  has: selectorList,
  lang: langList,
  matches: selectorList,
  is: selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  where: selectorList,
  not: selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  slotted: selector,
  host: selector,
  "host-context": selector
};

// node_modules/css-tree/lib/syntax/node/index-parse.js
var exports_index_parse = {};
__export(exports_index_parse, {
  WhiteSpace: () => parse56,
  Value: () => parse55,
  Url: () => parse54,
  UnicodeRange: () => parse53,
  TypeSelector: () => parse52,
  SupportsDeclaration: () => parse51,
  StyleSheet: () => parse50,
  String: () => parse49,
  SelectorList: () => parse48,
  Selector: () => parse47,
  Scope: () => parse46,
  Rule: () => parse45,
  Raw: () => parse44,
  Ratio: () => parse43,
  PseudoElementSelector: () => parse42,
  PseudoClassSelector: () => parse41,
  Percentage: () => parse40,
  Parentheses: () => parse39,
  Operator: () => parse38,
  Number: () => parse37,
  Nth: () => parse36,
  NestingSelector: () => parse35,
  MediaQueryList: () => parse34,
  MediaQuery: () => parse33,
  LayerList: () => parse32,
  Layer: () => parse31,
  Identifier: () => parse29,
  IdSelector: () => parse30,
  Hash: () => parse28,
  GeneralEnclosed: () => parse27,
  Function: () => parse26,
  FeatureRange: () => parse25,
  FeatureFunction: () => parse24,
  Feature: () => parse23,
  Dimension: () => parse22,
  DeclarationList: () => parse21,
  Declaration: () => parse20,
  Condition: () => parse19,
  Comment: () => parse18,
  Combinator: () => parse17,
  ClassSelector: () => parse16,
  CDO: () => parse15,
  CDC: () => parse14,
  Brackets: () => parse13,
  Block: () => parse12,
  AttributeSelector: () => parse11,
  AtrulePrelude: () => parse10,
  Atrule: () => parse9,
  AnPlusB: () => parse8
});

// node_modules/css-tree/lib/syntax/config/parser.js
var parser_default = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    condition(options) {
      return this.Condition(options.kind);
    },
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  features: {
    supports: {
      selector() {
        return this.Selector();
      }
    },
    container: {
      style() {
        return this.Declaration();
      }
    }
  },
  scope: exports_scope,
  atrule: atrule_default,
  pseudo: pseudo_default,
  node: exports_index_parse
};

// node_modules/css-tree/lib/syntax/config/walker.js
var walker_default = {
  node: exports_node
};

// node_modules/css-tree/lib/syntax/index.js
var syntax_default = create_default({
  ...lexer_default,
  ...parser_default,
  ...walker_default
});

// node_modules/css-tree/lib/version.js
var require4 = createRequire(import.meta.url);
var { version: version2 } = require4("../package.json");

// node_modules/css-tree/lib/index.js
var {
  tokenize: tokenize3,
  parse: parse57,
  generate: generate51,
  lexer,
  createLexer,
  walk: walk3,
  find,
  findLast,
  findAll,
  toPlainObject,
  fromPlainObject,
  fork
} = syntax_default;

// node_modules/@nativescript/core/css/css-tree-parser.js
function mapSelectors(selector2) {
  if (!selector2) {
    return [];
  }
  return selector2.split(/\s*(?![^(]*\)),\s*/).map((s3) => s3.replace(/\u200C/g, ","));
}
function mapPosition(node, css) {
  const res = {
    start: {
      line: node.loc.start.line,
      column: node.loc.start.column
    },
    end: {
      line: node.loc.end.line,
      column: node.loc.end.column
    },
    content: css
  };
  if (node.loc.source && node.loc.source !== "<unknown>") {
    res.source = node.loc.source;
  }
  return res;
}
function transformAst(node, css, type = null) {
  if (!node) {
    return;
  }
  if (node.type === "StyleSheet") {
    return {
      type: "stylesheet",
      stylesheet: {
        rules: node.children.map((child) => transformAst(child, css)).filter((child) => child !== null).toArray(),
        parsingErrors: []
      }
    };
  }
  if (node.type === "Atrule") {
    const atrule = {
      type: node.name
    };
    if (node.name === "supports" || node.name === "media") {
      atrule[node.name] = node.prelude.value;
      atrule.rules = transformAst(node.block, css);
    } else if (node.name === "page") {
      atrule.selectors = node.prelude ? mapSelectors(node.prelude.value) : [];
      atrule.declarations = transformAst(node.block, css);
    } else if (node.name === "document") {
      atrule.document = node.prelude ? node.prelude.value : "";
      atrule.vendor = "";
      atrule.rules = transformAst(node.block, css);
    } else if (node.name === "font-face") {
      atrule.declarations = transformAst(node.block, css);
    } else if (node.name === "import" || node.name === "charset" || node.name === "namespace") {
      atrule[node.name] = node.prelude ? node.prelude.value : "";
    } else if (node.name === "keyframes") {
      atrule.name = node.prelude ? node.prelude.value : "";
      atrule.keyframes = transformAst(node.block, css, "keyframe");
      atrule.vendor = undefined;
    } else {
      atrule.rules = transformAst(node.block, css);
    }
    atrule.position = mapPosition(node, css);
    return atrule;
  }
  if (node.type === "Block") {
    return node.children.map((child) => transformAst(child, css, type)).filter((child) => child !== null).toArray();
  }
  if (node.type === "Rule") {
    const value = node.prelude.value;
    const res = {
      type: type != null ? type : "rule",
      declarations: transformAst(node.block, css),
      position: mapPosition(node, css)
    };
    if (type === "keyframe") {
      res.values = mapSelectors(value);
    } else {
      res.selectors = mapSelectors(value);
    }
    return res;
  }
  if (node.type === "Comment") {
    return {
      type: "comment",
      comment: node.value,
      position: mapPosition(node, css)
    };
  }
  if (node.type === "Declaration") {
    return {
      type: "declaration",
      property: node.property,
      value: node.value.value ? node.value.value.trim() : "",
      position: mapPosition(node, css)
    };
  }
  if (node.type === "Raw") {
    return null;
  }
  throw Error(`Unknown node type ${node.type}`);
}
function cssTreeParse(css, source) {
  const errors = [];
  const ast = parse57(css, {
    parseValue: false,
    parseAtrulePrelude: false,
    parseRulePrelude: false,
    positions: true,
    filename: source,
    onParseError: (error) => {
      errors.push(`${source}:${error.line}:${error.column}: ${error.formattedMessage}`);
    }
  });
  if (errors.length > 0) {
    throw new Error(errors[0]);
  }
  return transformAst(ast, css);
}

// node_modules/@nativescript/core/css/CSS3Parser.js
var commentRegEx = /(\/\*(?:[^\*]|\*[^\/])*\*\/)/gmy;
var nameRegEx = /-?(?:(?:[a-zA-Z_]|[^\x00-\x7F]|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))(?:[a-zA-Z_0-9\-]*|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)/gmy;
var numberRegEx = /[\+\-]?(?:\d+\.\d+|\d+|\.\d+)(?:[eE][\+\-]?\d+)?/gmy;
var doubleQuoteStringRegEx = /"((?:[^\n\r\f\"]|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)(:?"|$)/gmy;
var whitespaceRegEx = /[\s\t\n\r\f]*/gmy;
var singleQuoteStringRegEx = /'((?:[^\n\r\f\']|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)(:?'|$)/gmy;

class CSS3Parser {
  constructor(text) {
    this.text = text;
    this.nextInputCodePointIndex = 0;
  }
  tokenize() {
    const tokens = [];
    let inputToken;
    do {
      inputToken = this.consumeAToken();
      tokens.push(inputToken);
    } while (inputToken);
    return tokens;
  }
  consumeAToken() {
    if (this.reconsumedInputToken) {
      const result = this.reconsumedInputToken;
      this.reconsumedInputToken = null;
      return result;
    }
    const char = this.text[this.nextInputCodePointIndex];
    switch (char) {
      case '"':
        return this.consumeAStringToken();
      case "'":
        return this.consumeAStringToken();
      case "(":
      case ")":
      case ",":
      case ":":
      case ";":
      case "[":
      case "]":
      case "{":
      case "}":
        this.nextInputCodePointIndex++;
        return char;
      case "#":
        return this.consumeAHashToken() || this.consumeADelimToken();
      case " ":
      case "\t":
      case `
`:
      case "\r":
      case "\f":
        return this.consumeAWhitespace();
      case "@":
        return this.consumeAtKeyword() || this.consumeADelimToken();
      case "\\":
        return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        return this.consumeANumericToken();
      case "u":
      case "U":
        if (this.text[this.nextInputCodePointIndex + 1] === "+") {
          const thirdChar = this.text[this.nextInputCodePointIndex + 2];
          if (thirdChar >= "0" && thirdChar <= "9" || thirdChar === "?") {
            throw new Error("Unicode tokens not supported!");
          }
        }
        return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
      case "$":
      case "*":
      case "^":
      case "|":
      case "~":
        return this.consumeAMatchToken() || this.consumeADelimToken();
      case "-":
        return this.consumeANumericToken() || this.consumeAnIdentLikeToken() || this.consumeCDC() || this.consumeADelimToken();
      case "+":
      case ".":
        return this.consumeANumericToken() || this.consumeADelimToken();
      case "/":
        return this.consumeAComment() || this.consumeADelimToken();
      case "<":
        return this.consumeCDO() || this.consumeADelimToken();
      case undefined:
        return;
      default:
        return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
    }
  }
  consumeADelimToken() {
    return {
      type: 2,
      text: this.text[this.nextInputCodePointIndex++]
    };
  }
  consumeAWhitespace() {
    whitespaceRegEx.lastIndex = this.nextInputCodePointIndex;
    whitespaceRegEx.exec(this.text);
    this.nextInputCodePointIndex = whitespaceRegEx.lastIndex;
    return " ";
  }
  consumeAHashToken() {
    this.nextInputCodePointIndex++;
    const hashName = this.consumeAName();
    if (hashName) {
      return { type: 12, text: "#" + hashName.text };
    }
    this.nextInputCodePointIndex--;
    return null;
  }
  consumeCDO() {
    if (this.text.substr(this.nextInputCodePointIndex, 4) === "<!--") {
      this.nextInputCodePointIndex += 4;
      return "<!--";
    }
    return null;
  }
  consumeCDC() {
    if (this.text.substr(this.nextInputCodePointIndex, 3) === "-->") {
      this.nextInputCodePointIndex += 3;
      return "-->";
    }
    return null;
  }
  consumeAMatchToken() {
    if (this.text[this.nextInputCodePointIndex + 1] === "=") {
      const token = this.text.substr(this.nextInputCodePointIndex, 2);
      this.nextInputCodePointIndex += 2;
      return token;
    }
    return null;
  }
  consumeANumericToken() {
    numberRegEx.lastIndex = this.nextInputCodePointIndex;
    const result = numberRegEx.exec(this.text);
    if (!result) {
      return null;
    }
    this.nextInputCodePointIndex = numberRegEx.lastIndex;
    if (this.text[this.nextInputCodePointIndex] === "%") {
      return { type: 4, text: result[0] };
    }
    const name50 = this.consumeAName();
    if (name50) {
      return {
        type: 5,
        text: result[0] + name50.text
      };
    }
    return { type: 3, text: result[0] };
  }
  consumeAnIdentLikeToken() {
    const name50 = this.consumeAName();
    if (!name50) {
      return null;
    }
    if (this.text[this.nextInputCodePointIndex] === "(") {
      this.nextInputCodePointIndex++;
      if (name50.text.toLowerCase() === "url") {
        return this.consumeAURLToken();
      }
      return {
        type: 8,
        name: name50.text,
        text: name50.text + "("
      };
    }
    return name50;
  }
  consumeAStringToken() {
    const char = this.text[this.nextInputCodePointIndex];
    let result;
    if (char === "'") {
      singleQuoteStringRegEx.lastIndex = this.nextInputCodePointIndex;
      result = singleQuoteStringRegEx.exec(this.text);
      if (!result) {
        return null;
      }
      this.nextInputCodePointIndex = singleQuoteStringRegEx.lastIndex;
    } else if (char === '"') {
      doubleQuoteStringRegEx.lastIndex = this.nextInputCodePointIndex;
      result = doubleQuoteStringRegEx.exec(this.text);
      if (!result) {
        return null;
      }
      this.nextInputCodePointIndex = doubleQuoteStringRegEx.lastIndex;
    }
    return { type: 1, text: result[0] };
  }
  consumeAURLToken() {
    const start2 = this.nextInputCodePointIndex - 3 - 1;
    const urlToken = {
      type: 7,
      text: undefined
    };
    this.consumeAWhitespace();
    if (this.nextInputCodePointIndex >= this.text.length) {
      return urlToken;
    }
    const nextInputCodePoint = this.text[this.nextInputCodePointIndex];
    if (nextInputCodePoint === '"' || nextInputCodePoint === "'") {
      const stringToken = this.consumeAStringToken();
      urlToken.text = stringToken.text;
      this.consumeAWhitespace();
      if (this.text[this.nextInputCodePointIndex] === ")" || this.nextInputCodePointIndex >= this.text.length) {
        this.nextInputCodePointIndex++;
        const end = this.nextInputCodePointIndex;
        urlToken.text = this.text.substring(start2, end);
        return urlToken;
      } else {
        return null;
      }
    }
    while (this.nextInputCodePointIndex < this.text.length) {
      const char = this.text[this.nextInputCodePointIndex++];
      switch (char) {
        case ")":
          return urlToken;
        case " ":
        case "\t":
        case `
`:
        case "\r":
        case "\f":
          this.consumeAWhitespace();
          if (this.text[this.nextInputCodePointIndex] === ")") {
            this.nextInputCodePointIndex++;
            return urlToken;
          } else {
            return null;
          }
        case '"':
        case "'":
          return null;
        case "\\":
          throw new Error("Escaping not yet supported!");
        default:
          urlToken.text += char;
      }
    }
    return urlToken;
  }
  consumeAName() {
    nameRegEx.lastIndex = this.nextInputCodePointIndex;
    const result = nameRegEx.exec(this.text);
    if (!result) {
      return null;
    }
    this.nextInputCodePointIndex = nameRegEx.lastIndex;
    return { type: 6, text: result[0] };
  }
  consumeAtKeyword() {
    this.nextInputCodePointIndex++;
    const name50 = this.consumeAName();
    if (name50) {
      return { type: 11, text: name50.text };
    }
    this.nextInputCodePointIndex--;
    return null;
  }
  consumeAComment() {
    if (this.text[this.nextInputCodePointIndex + 1] === "*") {
      commentRegEx.lastIndex = this.nextInputCodePointIndex;
      const result = commentRegEx.exec(this.text);
      if (!result) {
        return null;
      }
      this.nextInputCodePointIndex = commentRegEx.lastIndex;
      return this.consumeAToken();
    }
    return null;
  }
  reconsumeTheCurrentInputToken(currentInputToken) {
    this.reconsumedInputToken = currentInputToken;
  }
  parseAStylesheet() {
    this.topLevelFlag = true;
    return {
      rules: this.consumeAListOfRules()
    };
  }
  consumeAListOfRules() {
    const rules = [];
    let inputToken;
    while (inputToken = this.consumeAToken()) {
      switch (inputToken) {
        case " ":
          continue;
        case "<!--":
        case "-->": {
          if (this.topLevelFlag) {
            continue;
          }
          this.reconsumeTheCurrentInputToken(inputToken);
          const atRule = this.consumeAnAtRule();
          if (atRule) {
            rules.push(atRule);
          }
          continue;
        }
      }
      if (inputToken.type === 11) {
        this.reconsumeTheCurrentInputToken(inputToken);
        const atRule = this.consumeAnAtRule();
        if (atRule) {
          rules.push(atRule);
        }
        continue;
      }
      this.reconsumeTheCurrentInputToken(inputToken);
      const qualifiedRule = this.consumeAQualifiedRule();
      if (qualifiedRule) {
        rules.push(qualifiedRule);
      }
    }
    return rules;
  }
  consumeAnAtRule() {
    let inputToken = this.consumeAToken();
    const atRule = {
      type: "at-rule",
      name: inputToken.text,
      prelude: [],
      block: undefined
    };
    while (inputToken = this.consumeAToken()) {
      if (inputToken === ";") {
        return atRule;
      } else if (inputToken === "{") {
        atRule.block = this.consumeASimpleBlock(inputToken);
        return atRule;
      } else if (inputToken.type === 9 && inputToken.associatedToken === "{") {
        atRule.block = inputToken;
        return atRule;
      }
      this.reconsumeTheCurrentInputToken(inputToken);
      const component = this.consumeAComponentValue();
      if (component) {
        atRule.prelude.push(component);
      }
    }
    return atRule;
  }
  consumeAQualifiedRule() {
    const qualifiedRule = {
      type: "qualified-rule",
      prelude: [],
      block: undefined
    };
    let inputToken;
    while (inputToken = this.consumeAToken()) {
      if (inputToken === "{") {
        qualifiedRule.block = this.consumeASimpleBlock(inputToken);
        return qualifiedRule;
      } else if (inputToken.type === 9) {
        const simpleBlock = inputToken;
        if (simpleBlock.associatedToken === "{") {
          qualifiedRule.block = simpleBlock;
          return qualifiedRule;
        }
      }
      this.reconsumeTheCurrentInputToken(inputToken);
      const componentValue = this.consumeAComponentValue();
      if (componentValue) {
        qualifiedRule.prelude.push(componentValue);
      }
    }
    return null;
  }
  consumeAComponentValue() {
    const inputToken = this.consumeAToken();
    switch (inputToken) {
      case "{":
      case "[":
      case "(":
        this.nextInputCodePointIndex++;
        return this.consumeASimpleBlock(inputToken);
    }
    if (typeof inputToken === "object" && inputToken.type === 8) {
      return this.consumeAFunction(inputToken.name);
    }
    return inputToken;
  }
  consumeASimpleBlock(associatedToken) {
    const endianToken = {
      "[": "]",
      "{": "}",
      "(": ")"
    }[associatedToken];
    const start2 = this.nextInputCodePointIndex - 1;
    const block = {
      type: 9,
      text: undefined,
      associatedToken,
      values: []
    };
    let nextInputToken;
    while (nextInputToken = this.text[this.nextInputCodePointIndex]) {
      if (nextInputToken === endianToken) {
        this.nextInputCodePointIndex++;
        const end = this.nextInputCodePointIndex;
        block.text = this.text.substring(start2, end);
        return block;
      }
      const value = this.consumeAComponentValue();
      if (value) {
        block.values.push(value);
      }
    }
    block.text = this.text.substring(start2);
    return block;
  }
  consumeAFunction(name50) {
    const start2 = this.nextInputCodePointIndex;
    const funcToken = {
      type: 14,
      name: name50,
      text: undefined,
      components: []
    };
    do {
      if (this.nextInputCodePointIndex >= this.text.length) {
        funcToken.text = name50 + "(" + this.text.substring(start2);
        return funcToken;
      }
      const nextInputToken = this.text[this.nextInputCodePointIndex];
      switch (nextInputToken) {
        case ")": {
          this.nextInputCodePointIndex++;
          const end = this.nextInputCodePointIndex;
          funcToken.text = name50 + "(" + this.text.substring(start2, end);
          return funcToken;
        }
        default: {
          const component = this.consumeAComponentValue();
          if (component) {
            funcToken.components.push(component);
          }
        }
      }
    } while (true);
  }
}

// node_modules/@nativescript/core/css/CSSNativeScript.js
class CSSNativeScript {
  parseStylesheet(stylesheet) {
    return {
      type: "stylesheet",
      stylesheet: {
        rules: this.parseRules(stylesheet.rules)
      }
    };
  }
  parseRules(rules) {
    return rules.map((rule) => this.parseRule(rule));
  }
  parseRule(rule) {
    if (rule.type === "at-rule") {
      return this.parseAtRule(rule);
    } else if (rule.type === "qualified-rule") {
      return this.parseQualifiedRule(rule);
    }
  }
  parseAtRule(rule) {
    if (rule.name === "import") {
      return {
        import: rule.prelude.map((m2) => typeof m2 === "string" ? m2 : m2.text).join("").trim(),
        type: "import"
      };
    }
    return;
  }
  parseQualifiedRule(rule) {
    return {
      type: "rule",
      selectors: this.preludeToSelectorsStringArray(rule.prelude),
      declarations: this.ruleBlockToDeclarations(rule.block.values)
    };
  }
  ruleBlockToDeclarations(declarationsInputTokens) {
    const declarations = [];
    let property2 = "";
    let value = "";
    let reading = "property";
    for (let i4 = 0;i4 < declarationsInputTokens.length; i4++) {
      const inputToken = declarationsInputTokens[i4];
      if (reading === "property") {
        if (inputToken === ":") {
          reading = "value";
        } else if (typeof inputToken === "string") {
          property2 += inputToken;
        } else {
          property2 += inputToken.text;
        }
      } else {
        if (inputToken === ";") {
          property2 = property2.trim();
          value = value.trim();
          declarations.push({ type: "declaration", property: property2, value });
          property2 = "";
          value = "";
          reading = "property";
        } else if (typeof inputToken === "string") {
          value += inputToken;
        } else {
          value += inputToken.text;
        }
      }
    }
    property2 = property2.trim();
    value = value.trim();
    if (property2 || value) {
      declarations.push({ type: "declaration", property: property2, value });
    }
    return declarations;
  }
  preludeToSelectorsStringArray(prelude) {
    const selectors = [];
    let selector2 = "";
    prelude.forEach((inputToken) => {
      if (typeof inputToken === "string") {
        if (inputToken === ",") {
          if (selector2) {
            selectors.push(selector2.trim());
          }
          selector2 = "";
        } else {
          selector2 += inputToken;
        }
      } else if (typeof inputToken === "object") {
        selector2 += inputToken.text;
      }
    });
    if (selector2) {
      selectors.push(selector2.trim());
    }
    return selectors;
  }
}

// node_modules/@nativescript/core/css/lib/parse/index.js
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
function parse58(css, options) {
  options = options || {};
  var lineno = 1;
  var column = 1;
  function updatePosition(str) {
    var lines = str.match(/\n/g);
    if (lines)
      lineno += lines.length;
    var i4 = str.lastIndexOf(`
`);
    column = ~i4 ? str.length - i4 : column + str.length;
  }
  function position() {
    var start2 = { line: lineno, column };
    return function(node) {
      node.position = new Position3(start2);
      whitespace();
      return node;
    };
  }
  function Position3(start2) {
    this.start = start2;
    this.end = { line: lineno, column };
    this.source = options.source;
  }
  Position3.prototype.content = css;
  var errorsList = [];
  function error(msg) {
    var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;
    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }
  function stylesheet() {
    var rulesList = rules();
    return {
      type: "stylesheet",
      stylesheet: {
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }
  function open() {
    return match(/^{\s*/);
  }
  function close() {
    return match(/^}/);
  }
  function rules() {
    var node;
    var rules2 = [];
    whitespace();
    comments(rules2);
    while (css.length && css.charAt(0) != "}" && (node = atrule() || rule())) {
      if (node !== false) {
        rules2.push(node);
        comments(rules2);
      }
    }
    return rules2;
  }
  function match(re) {
    var m2 = re.exec(css);
    if (!m2)
      return;
    var str = m2[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m2;
  }
  function whitespace() {
    match(/^\s*/);
  }
  function comments(rules2) {
    var c3;
    rules2 = rules2 || [];
    while (c3 = comment()) {
      if (c3 !== false) {
        rules2.push(c3);
      }
    }
    return rules2;
  }
  function comment() {
    var pos = position();
    if (css.charAt(0) != "/" || css.charAt(1) != "*")
      return;
    var i4 = 2;
    while (css.charAt(i4) != "" && (css.charAt(i4) != "*" || css.charAt(i4 + 1) != "/"))
      ++i4;
    i4 += 2;
    if (css.charAt(i4 - 1) === "") {
      return error("End of comment missing");
    }
    var str = css.slice(2, i4 - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i4);
    column += 2;
    return pos({
      type: "comment",
      comment: str
    });
  }
  function selector2() {
    var m2 = match(/^([^{]+)/);
    if (!m2)
      return;
    return trim(m2[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m3) {
      return m3.replace(/,/g, "");
    }).split(/\s*(?![^(]*\)),\s*/).map(function(s3) {
      return s3.replace(/\u200C/g, ",");
    });
  }
  function declaration() {
    var pos = position();
    var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop)
      return;
    prop = trim(prop[0]);
    if (!match(/^:\s*/))
      return error("property missing ':'");
    var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    var ret = pos({
      type: "declaration",
      property: prop.replace(commentre, ""),
      value: val ? trim(val[0]).replace(commentre, "") : ""
    });
    match(/^[;\s]*/);
    return ret;
  }
  function declarations() {
    var decls = [];
    if (!open())
      return error("missing '{'");
    comments(decls);
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    if (!close())
      return error("missing '}'");
    return decls;
  }
  function keyframe() {
    var m2;
    var vals = [];
    var pos = position();
    while (m2 = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m2[1]);
      match(/^,\s*/);
    }
    if (!vals.length)
      return;
    return pos({
      type: "keyframe",
      values: vals,
      declarations: declarations()
    });
  }
  function atkeyframes() {
    var pos = position();
    var m2 = match(/^@([-\w]+)?keyframes\s*/);
    if (!m2)
      return;
    var vendor = m2[1];
    var m2 = match(/^([-\w]+)\s*/);
    if (!m2)
      return error("@keyframes missing name");
    var name50 = m2[1];
    if (!open())
      return error("@keyframes missing '{'");
    var frame;
    var frames = comments();
    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }
    if (!close())
      return error("@keyframes missing '}'");
    return pos({
      type: "keyframes",
      name: name50,
      vendor,
      keyframes: frames
    });
  }
  function atsupports() {
    var pos = position();
    var m2 = match(/^@supports *([^{]+)/);
    if (!m2)
      return;
    var supports = trim(m2[1]);
    if (!open())
      return error("@supports missing '{'");
    var style = comments().concat(rules());
    if (!close())
      return error("@supports missing '}'");
    return pos({
      type: "supports",
      supports,
      rules: style
    });
  }
  function athost() {
    var pos = position();
    var m2 = match(/^@host\s*/);
    if (!m2)
      return;
    if (!open())
      return error("@host missing '{'");
    var style = comments().concat(rules());
    if (!close())
      return error("@host missing '}'");
    return pos({
      type: "host",
      rules: style
    });
  }
  function atmedia() {
    var pos = position();
    var m2 = match(/^@media *([^{]+)/);
    if (!m2)
      return;
    var media = trim(m2[1]);
    if (!open())
      return error("@media missing '{'");
    var style = comments().concat(rules());
    if (!close())
      return error("@media missing '}'");
    return pos({
      type: "media",
      media,
      rules: style
    });
  }
  function atcustommedia() {
    var pos = position();
    var m2 = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (!m2)
      return;
    return pos({
      type: "custom-media",
      name: trim(m2[1]),
      media: trim(m2[2])
    });
  }
  function atpage() {
    var pos = position();
    var m2 = match(/^@page */);
    if (!m2)
      return;
    var sel = selector2() || [];
    if (!open())
      return error("@page missing '{'");
    var decls = comments();
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }
    if (!close())
      return error("@page missing '}'");
    return pos({
      type: "page",
      selectors: sel,
      declarations: decls
    });
  }
  function atdocument() {
    var pos = position();
    var m2 = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m2)
      return;
    var vendor = trim(m2[1]);
    var doc = trim(m2[2]);
    if (!open())
      return error("@document missing '{'");
    var style = comments().concat(rules());
    if (!close())
      return error("@document missing '}'");
    return pos({
      type: "document",
      document: doc,
      vendor,
      rules: style
    });
  }
  function atfontface() {
    var pos = position();
    var m2 = match(/^@font-face\s*/);
    if (!m2)
      return;
    if (!open())
      return error("@font-face missing '{'");
    var decls = comments();
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }
    if (!close())
      return error("@font-face missing '}'");
    return pos({
      type: "font-face",
      declarations: decls
    });
  }
  var atimport = _compileAtrule("import");
  var atcharset = _compileAtrule("charset");
  var atnamespace = _compileAtrule("namespace");
  function _compileAtrule(name50) {
    var re = new RegExp("^@" + name50 + "\\s*([^;]+);");
    return function() {
      var pos = position();
      var m2 = match(re);
      if (!m2)
        return;
      var ret = { type: name50 };
      ret[name50] = m2[1].trim();
      return pos(ret);
    };
  }
  function atrule() {
    if (css[0] != "@")
      return;
    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  }
  function rule() {
    var pos = position();
    var sel = selector2();
    if (!sel)
      return error("selector missing");
    comments();
    return pos({
      type: "rule",
      selectors: sel,
      declarations: declarations()
    });
  }
  return addParent(stylesheet());
}
function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, "") : "";
}
function addParent(obj, parent) {
  var isNode = obj && typeof obj.type === "string";
  var childParent = isNode ? obj : parent;
  for (var k2 in obj) {
    var value = obj[k2];
    if (Array.isArray(value)) {
      value.forEach(function(v) {
        addParent(v, childParent);
      });
    } else if (value && typeof value === "object") {
      addParent(value, childParent);
    }
  }
  if (isNode) {
    Object.defineProperty(obj, "parent", {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }
  return obj;
}

// node_modules/@nativescript/core/ui/styling/style-scope.js
var parser = "css-tree";
try {
  if (package_default) {
    if (package_default.cssParser === "rework") {
      parser = "rework";
    } else if (package_default.cssParser === "nativescript") {
      parser = "nativescript";
    }
  }
} catch (e3) {}
var mergedApplicationCssSelectors = [];
var applicationCssSelectors = [];
var applicationAdditionalSelectors = [];
var mergedApplicationCssKeyframes = [];
var applicationCssKeyframes = [];
var applicationAdditionalKeyframes = [];
var applicationCssSelectorVersion = 0;
var tagToScopeTag = new Map;
var currentScopeTag = null;
var animationsSymbol = Symbol("animations");
var kebabCasePattern = /-([a-z])/g;
var pattern2 = /('|")(.*?)\1/;
function evaluateCssExpressions(view, property2, value) {
  const newValue = _evaluateCssVariableExpression(view, property2, value);
  if (newValue === "unset") {
    return unsetValue;
  }
  value = newValue;
  try {
    value = _evaluateCssCalcExpression(value);
  } catch (e3) {
    Trace.write(`Failed to evaluate css-calc for property [${property2}] for expression [${value}] to ${view}. ${e3.stack}`, Trace.categories.Error, Trace.messageType.error);
    return unsetValue;
  }
  return value;
}
function mergeCssSelectors() {
  mergedApplicationCssSelectors = applicationCssSelectors.slice();
  mergedApplicationCssSelectors.push(...applicationAdditionalSelectors);
}
function mergeCssKeyframes() {
  mergedApplicationCssKeyframes = applicationCssKeyframes.slice();
  mergedApplicationCssKeyframes.push(...applicationAdditionalKeyframes);
}

class CSSSource {
  constructor(_ast, _url, _file, _source) {
    this._ast = _ast;
    this._url = _url;
    this._file = _file;
    this._source = _source;
    this._selectors = [];
    this._keyframes = [];
    this.parse();
  }
  static fromDetect(cssOrAst, fileName) {
    if (typeof cssOrAst === "string") {
      return CSSSource.fromSource(cssOrAst, fileName);
    } else if (typeof cssOrAst === "object") {
      if (cssOrAst.default) {
        cssOrAst = cssOrAst.default;
      }
      if (cssOrAst.type === "stylesheet" && cssOrAst.stylesheet && cssOrAst.stylesheet.rules) {
        return CSSSource.fromAST(cssOrAst, fileName);
      }
    }
    return CSSSource.fromSource(cssOrAst.toString(), fileName);
  }
  static fromURI(uri) {
    const appRelativeUri = CSSSource.pathRelativeToApp(uri);
    const sanitizedModuleName = sanitizeModuleName(appRelativeUri);
    const resolvedModuleName = resolveModuleName(sanitizedModuleName, "css");
    try {
      const cssOrAst = global.loadModule(resolvedModuleName, true);
      if (cssOrAst) {
        return CSSSource.fromDetect(cssOrAst, resolvedModuleName);
      }
    } catch (e3) {
      if (Trace.isEnabled()) {
        Trace.write(`Could not load CSS from ${uri}: ${e3}`, Trace.categories.Error, Trace.messageType.warn);
      }
    }
    return CSSSource.fromFile(appRelativeUri);
  }
  static pathRelativeToApp(uri) {
    if (!uri.startsWith("/")) {
      return uri;
    }
    const appPath = knownFolders.currentApp().path;
    if (!uri.startsWith(appPath)) {
      Trace.write(`${uri} does not start with ${appPath}`, Trace.categories.Error, Trace.messageType.error);
      return uri;
    }
    const relativeUri = `.${uri.substring(appPath.length)}`;
    return relativeUri;
  }
  static fromFile(url) {
    const cssFileUrl = url.replace(/\..\w+$/, ".css");
    if (cssFileUrl !== url) {
      const cssFile = CSSSource.resolveCSSPathFromURL(cssFileUrl);
      if (cssFile) {
        return new CSSSource(undefined, url, cssFile, undefined);
      }
    }
    const file = CSSSource.resolveCSSPathFromURL(url);
    return new CSSSource(undefined, url, file, undefined);
  }
  static fromFileImport(url, importSource) {
    const file = CSSSource.resolveCSSPathFromURL(url, importSource);
    return new CSSSource(undefined, url, file, undefined);
  }
  static resolveCSSPathFromURL(url, importSource) {
    const app = knownFolders.currentApp().path;
    const file = resolveFileNameFromUrl(url, app, File.exists, importSource);
    return file;
  }
  static fromSource(source, url) {
    return new CSSSource(undefined, url, undefined, source);
  }
  static fromAST(ast, url) {
    return new CSSSource(ast, url, undefined, undefined);
  }
  get selectors() {
    return this._selectors;
  }
  get keyframes() {
    return this._keyframes;
  }
  get source() {
    return this._source;
  }
  load() {
    const file = File.fromPath(this._file);
    this._source = file.readTextSync();
  }
  parse() {
    try {
      if (!this._ast) {
        if (!this._source && this._file) {
          this.load();
        }
        if (this._source && this.source !== "[object Object]") {
          this.parseCSSAst();
        }
      }
      if (this._ast) {
        this.createSelectorsAndKeyframes();
      } else {
        this._selectors = [];
      }
    } catch (e3) {
      if (Trace.isEnabled()) {
        Trace.write("Css styling failed: " + e3, Trace.categories.Style, Trace.messageType.error);
      }
      this._selectors = [];
    }
  }
  async parseCSSAst() {
    if (this._source) {
      if (__CSS_PARSER__ === "css-tree") {
        this._ast = cssTreeParse(this._source, this._file);
      } else if (__CSS_PARSER__ === "nativescript") {
        const cssparser = new CSS3Parser(this._source);
        const stylesheet = cssparser.parseAStylesheet();
        const cssNS = new CSSNativeScript;
        this._ast = cssNS.parseStylesheet(stylesheet);
      } else if (__CSS_PARSER__ === "rework") {
        this._ast = parse58(this._source, { source: this._file });
      }
    }
  }
  createSelectorsAndKeyframes() {
    if (this._ast) {
      const nodes = this._ast.stylesheet.rules;
      const rulesets = [];
      const keyframes = [];
      populateRulesFromImports(nodes, rulesets, keyframes);
      _populateRules(nodes, rulesets, keyframes);
      if (rulesets && rulesets.length) {
        rulesets.forEach((rule) => {
          rule[animationsSymbol] = CssAnimationParser.keyframeAnimationsFromCSSDeclarations(rule.declarations);
        });
      }
      this._selectors = rulesets;
      this._keyframes = keyframes;
    }
  }
  toString() {
    return this._file || this._url || "(in-memory)";
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], CSSSource.prototype, "load", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], CSSSource.prototype, "parse", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", Promise)
], CSSSource.prototype, "parseCSSAst", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], CSSSource.prototype, "createSelectorsAndKeyframes", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String, String]),
  __metadata("design:returntype", String)
], CSSSource, "resolveCSSPathFromURL", null);
function populateRulesFromImports(nodes, rulesets, keyframes) {
  const imports = nodes.filter((r3) => r3.type === "import");
  if (!imports.length) {
    return;
  }
  const urlFromImportObject = (importObject) => {
    const importItem = importObject["import"];
    const urlMatch = importItem && importItem.match(pattern2);
    return urlMatch && urlMatch[2];
  };
  const sourceFromImportObject = (importObject) => importObject["position"] && importObject["position"]["source"];
  const toUrlSourcePair = (importObject) => ({
    url: urlFromImportObject(importObject),
    source: sourceFromImportObject(importObject)
  });
  const getCssFile = ({ url, source }) => source ? CSSSource.fromFileImport(url, source) : CSSSource.fromURI(url);
  const cssFiles = imports.map(toUrlSourcePair).filter(({ url }) => !!url).map(getCssFile);
  for (const cssFile of cssFiles) {
    if (cssFile) {
      rulesets.push(...cssFile.selectors);
      keyframes.push(...cssFile.keyframes);
    }
  }
}
function _populateRules(nodes, rulesets, keyframes, mediaQueryString) {
  for (const node of nodes) {
    if (isKeyframe(node)) {
      const keyframeRule = {
        name: node.name,
        keyframes: node.keyframes,
        mediaQueryString
      };
      keyframes.push(keyframeRule);
    } else if (isMedia(node)) {
      const compositeMediaQuery = mediaQueryString ? mediaQueryString + MEDIA_QUERY_SEPARATOR + node.media : node.media;
      _populateRules(node.rules, rulesets, keyframes, compositeMediaQuery);
    } else if (isRule(node)) {
      const ruleset = fromAstNode(node);
      ruleset.mediaQueryString = mediaQueryString;
      rulesets.push(ruleset);
    }
  }
}
var onCssChanged = profile('"style-scope".onCssChanged', (args) => {
  if (args.cssText) {
    const { selectors, keyframes } = CSSSource.fromSource(args.cssText, args.cssFile);
    let updated = false;
    if (selectors) {
      applicationAdditionalSelectors.push(...selectors);
      mergeCssSelectors();
      updated = true;
    }
    if (keyframes) {
      applicationAdditionalKeyframes.push(...keyframes);
      mergeCssKeyframes();
      updated = true;
    }
    if (updated) {
      applicationCssSelectorVersion++;
    }
  } else if (args.cssFile) {
    loadCss(args.cssFile, null, null);
  }
});
function onLiveSync2(args) {
  loadCss(Application.getCssFileName(), null, null);
}
var loadCss = profile(`"style-scope".loadCss`, (cssModule) => {
  if (!cssModule) {
    return;
  }
  if (cssModule.startsWith("./")) {
    cssModule = cssModule.substring(2);
  }
  const { selectors, keyframes } = CSSSource.fromURI(cssModule);
  let updated = false;
  if (selectors.length > 0 || applicationCssSelectors.length > 0) {
    applicationCssSelectors = selectors;
    mergeCssSelectors();
    updated = true;
  }
  if (keyframes.length > 0 || applicationCssKeyframes.length > 0) {
    applicationCssKeyframes = keyframes;
    mergeCssKeyframes();
    updated = true;
  }
  if (updated) {
    applicationCssSelectorVersion++;
  }
});
getNativeScriptGlobals().events.on("cssChanged", onCssChanged);
getNativeScriptGlobals().events.on("livesync", onLiveSync2);
var loadAppCSS = profile('"style-scope".loadAppCSS', (args) => {
  loadCss(args.cssFile, null, null);
  getNativeScriptGlobals().events.off("loadAppCss", loadAppCSS);
});
if (Application.hasLaunched()) {
  loadAppCSS({
    eventName: "loadAppCss",
    object: Application,
    cssFile: Application.getCssFileName()
  }, null, null);
} else {
  getNativeScriptGlobals().events.on("loadAppCss", loadAppCSS);
}

class CssState {
  constructor(viewRef) {
    this.viewRef = viewRef;
    this._appliedPropertyValues = CssState.emptyPropertyBag;
    this._onDynamicStateChangeHandler = () => this.updateDynamicState();
  }
  onChange() {
    const view = this.viewRef.get();
    if (view && view.isLoaded) {
      this.unsubscribeFromDynamicUpdates();
      this.updateMatch();
      this.subscribeForDynamicUpdates();
      this.updateDynamicState();
    } else {
      this._matchInvalid = true;
    }
  }
  isSelectorsLatestVersionApplied() {
    const view = this.viewRef.get();
    if (!view) {
      Trace.write(`isSelectorsLatestVersionApplied returns default value "false" because "this.viewRef" cleared.`, Trace.categories.Style, Trace.messageType.warn);
      return false;
    }
    return this.viewRef.get()._styleScope.getSelectorsVersion() === this._appliedSelectorsVersion;
  }
  onLoaded() {
    if (this._matchInvalid) {
      this.updateMatch();
    }
    this.subscribeForDynamicUpdates();
    this.updateDynamicState();
  }
  onUnloaded() {
    this.unsubscribeFromDynamicUpdates();
    this.stopKeyframeAnimations();
  }
  updateMatch() {
    const view = this.viewRef.get();
    if (view && view._styleScope) {
      this._match = view._styleScope.matchSelectors(view) ?? CssState.emptyMatch;
      this._appliedSelectorsVersion = view._styleScope.getSelectorsVersion();
    } else {
      this._match = CssState.emptyMatch;
    }
    this._matchInvalid = false;
  }
  updateDynamicState() {
    const view = this.viewRef.get();
    if (!view) {
      Trace.write(`updateDynamicState not executed to view because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
      return;
    }
    const matchingSelectors = this._match.selectors.filter((sel) => sel.dynamic ? sel.match(view) : true);
    view._batchUpdate(() => {
      this.stopKeyframeAnimations();
      this.setPropertyValues(matchingSelectors);
      this.playKeyframeAnimations(matchingSelectors);
    });
  }
  playKeyframeAnimations(matchingSelectors) {
    const animations = [];
    matchingSelectors.forEach((selector2) => {
      const ruleAnimations = selector2.ruleset?.[animationsSymbol];
      if (ruleAnimations) {
        for (const animationInfo of ruleAnimations) {
          const animation = KeyframeAnimation.keyframeAnimationFromInfo(animationInfo);
          if (animation) {
            animations.push(animation);
          }
        }
      }
    });
    if (this._playsKeyframeAnimations = animations.length > 0) {
      const view = this.viewRef.get();
      if (!view) {
        Trace.write(`KeyframeAnimations cannot play because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
        return;
      }
      animations.map((animation) => animation.play(view));
      Object.freeze(animations);
      this._appliedAnimations = animations;
    }
  }
  stopKeyframeAnimations() {
    if (!this._playsKeyframeAnimations) {
      return;
    }
    this._appliedAnimations.filter((animation) => animation.isPlaying).forEach((animation) => animation.cancel());
    this._appliedAnimations = CssState.emptyAnimationArray;
    const view = this.viewRef.get();
    if (view) {
      view.style["keyframe:rotate"] = unsetValue;
      view.style["keyframe:rotateX"] = unsetValue;
      view.style["keyframe:rotateY"] = unsetValue;
      view.style["keyframe:scaleX"] = unsetValue;
      view.style["keyframe:scaleY"] = unsetValue;
      view.style["keyframe:translateX"] = unsetValue;
      view.style["keyframe:translateY"] = unsetValue;
      view.style["keyframe:backgroundColor"] = unsetValue;
      view.style["keyframe:opacity"] = unsetValue;
    } else {
      Trace.write(`KeyframeAnimations cannot be stopped because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
    }
    this._playsKeyframeAnimations = false;
  }
  setPropertyValues(matchingSelectors) {
    const view = this.viewRef.get();
    if (!view) {
      Trace.write(`${matchingSelectors} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
      return;
    }
    const newPropertyValues = new view.style.PropertyBag;
    matchingSelectors.forEach((selector2) => selector2.ruleset.declarations.forEach((declaration) => newPropertyValues[declaration.property] = declaration.value));
    const oldProperties = this._appliedPropertyValues;
    view.style.resetScopedCssVariables();
    const valuesToApply = {};
    const cssExpsProperties = {};
    const replacementFunc = (g3) => g3[1].toUpperCase();
    for (const property2 in newPropertyValues) {
      const value = cleanupImportantFlags(newPropertyValues[property2], property2);
      const isCssExp = isCssVariableExpression(value) || isCssCalcExpression(value);
      if (isCssExp) {
        cssExpsProperties[property2] = value;
        continue;
      }
      delete oldProperties[property2];
      if (property2 in oldProperties && oldProperties[property2] === value) {
        continue;
      }
      if (isCssVariable(property2)) {
        view.style.setScopedCssVariable(property2, value);
        delete newPropertyValues[property2];
        continue;
      }
      valuesToApply[property2] = value;
    }
    for (const property2 in cssExpsProperties) {
      delete oldProperties[property2];
      const value = evaluateCssExpressions(view, property2, cssExpsProperties[property2]);
      if (property2 in oldProperties && oldProperties[property2] === value) {
        continue;
      }
      if (value === unsetValue) {
        delete newPropertyValues[property2];
      }
      if (isCssVariable(property2)) {
        view.style.setScopedCssVariable(property2, value);
        delete newPropertyValues[property2];
      }
      valuesToApply[property2] = value;
    }
    for (const property2 in oldProperties) {
      if (property2 in view.style) {
        view.style[`css:${property2}`] = unsetValue;
      } else {
        const camelCasedProperty = property2.replace(kebabCasePattern, replacementFunc);
        view[camelCasedProperty] = unsetValue;
      }
    }
    for (const property2 in valuesToApply) {
      const value = valuesToApply[property2];
      try {
        if (property2 in view.style) {
          view.style[`css:${property2}`] = value;
        } else {
          const camelCasedProperty = property2.replace(kebabCasePattern, replacementFunc);
          view[camelCasedProperty] = value;
        }
      } catch (e3) {
        Trace.write(`Failed to apply property [${property2}] with value [${value}] to ${view}. ${e3.stack}`, Trace.categories.Error, Trace.messageType.error);
      }
    }
    this._appliedPropertyValues = newPropertyValues;
  }
  subscribeForDynamicUpdates() {
    const changeMap = this._match.changeMap;
    changeMap.forEach((changes, view) => {
      if (changes.attributes) {
        changes.attributes.forEach((attribute) => {
          view.addEventListener(attribute + "Change", this._onDynamicStateChangeHandler);
        });
      }
      if (changes.pseudoClasses) {
        changes.pseudoClasses.forEach((pseudoClass) => {
          const eventName = ":" + pseudoClass;
          view.addEventListener(":" + pseudoClass, this._onDynamicStateChangeHandler);
          if (view[eventName]) {
            view[eventName](true);
          }
        });
      }
    });
    this._appliedChangeMap = changeMap;
  }
  unsubscribeFromDynamicUpdates() {
    this._appliedChangeMap.forEach((changes, view) => {
      if (changes.attributes) {
        changes.attributes.forEach((attribute) => {
          view.removeEventListener(attribute + "Change", this._onDynamicStateChangeHandler);
        });
      }
      if (changes.pseudoClasses) {
        changes.pseudoClasses.forEach((pseudoClass) => {
          const eventName = ":" + pseudoClass;
          view.removeEventListener(eventName, this._onDynamicStateChangeHandler);
          if (view[eventName]) {
            view[eventName](false);
          }
        });
      }
    });
    this._appliedChangeMap = CssState.emptyChangeMap;
  }
  toString() {
    const view = this.viewRef.get();
    if (!view) {
      Trace.write(`toString() of CssState cannot execute correctly because ".viewRef" is cleared`, Trace.categories.Animation, Trace.messageType.warn);
      return "";
    }
    return `${view}._cssState`;
  }
}
CssState.emptyChangeMap = Object.freeze(new Map);
CssState.emptyPropertyBag = {};
CssState.emptyAnimationArray = Object.freeze([]);
CssState.emptyMatch = {
  selectors: [],
  changeMap: new Map,
  addAttribute: () => {},
  addPseudoClass: () => {},
  properties: null
};
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], CssState.prototype, "updateMatch", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], CssState.prototype, "updateDynamicState", null);
CssState.prototype._appliedChangeMap = CssState.emptyChangeMap;
CssState.prototype._appliedAnimations = CssState.emptyAnimationArray;
CssState.prototype._matchInvalid = true;

class StyleScope {
  constructor() {
    this._css = "";
    this._localCssSelectors = [];
    this._localCssKeyframes = [];
    this._localCssSelectorVersion = 0;
    this._localCssSelectorsAppliedVersion = 0;
    this._applicationCssSelectorsAppliedVersion = 0;
    this._cssFiles = [];
  }
  get css() {
    return this._css;
  }
  set css(value) {
    this.setCss(value);
  }
  addCss(cssString, cssFileName) {
    this.appendCss(cssString, cssFileName);
  }
  addCssFile(cssFileName) {
    this.appendCss(null, cssFileName);
  }
  changeCssFile(cssFileName) {
    if (!cssFileName) {
      return;
    }
    this._cssFiles.push(cssFileName);
    currentScopeTag = cssFileName;
    const cssFile = CSSSource.fromURI(cssFileName);
    currentScopeTag = null;
    this._css = cssFile.source;
    this._localCssSelectors = cssFile.selectors;
    this._localCssKeyframes = cssFile.keyframes;
    this._localCssSelectorVersion++;
    this.ensureSelectors();
  }
  setCss(cssString, cssFileName) {
    this._css = cssString;
    const cssFile = CSSSource.fromSource(cssString, cssFileName);
    this._localCssSelectors = cssFile.selectors;
    this._localCssKeyframes = cssFile.keyframes;
    this._localCssSelectorVersion++;
    this.ensureSelectors();
  }
  appendCss(cssString, cssFileName) {
    if (!cssString && !cssFileName) {
      return;
    }
    if (cssFileName) {
      this._cssFiles.push(cssFileName);
      currentScopeTag = cssFileName;
    }
    const cssFile = cssString ? CSSSource.fromSource(cssString, cssFileName) : CSSSource.fromURI(cssFileName);
    currentScopeTag = null;
    this._css = this._css + cssFile.source;
    this._localCssSelectors.push(...cssFile.selectors);
    this._localCssKeyframes.push(...cssFile.keyframes);
    this._localCssSelectorVersion++;
    this.ensureSelectors();
  }
  getKeyframeAnimationWithName(animationName) {
    if (!this._mergedCssKeyframes) {
      return null;
    }
    const keyframeRule = this.findKeyframeRule(animationName);
    const animation = new KeyframeAnimationInfo;
    animation.keyframes = keyframeRule ? CssAnimationParser.keyframesArrayFromCSS(keyframeRule.keyframes) : null;
    return animation;
  }
  ensureSelectors() {
    if (!this.isApplicationCssSelectorsLatestVersionApplied() || !this.isLocalCssSelectorsLatestVersionApplied() || !this._mergedCssSelectors) {
      this._createSelectors();
    }
    return this.getSelectorsVersion();
  }
  _increaseApplicationCssSelectorVersion() {
    applicationCssSelectorVersion++;
  }
  isApplicationCssSelectorsLatestVersionApplied() {
    return this._applicationCssSelectorsAppliedVersion === applicationCssSelectorVersion;
  }
  isLocalCssSelectorsLatestVersionApplied() {
    return this._localCssSelectorsAppliedVersion === this._localCssSelectorVersion;
  }
  _createSelectors() {
    const toMerge = [];
    const toMergeKeyframes = [];
    toMerge.push(...mergedApplicationCssSelectors.filter((v) => !v.scopedTag || this._cssFiles.indexOf(v.scopedTag) >= 0));
    toMergeKeyframes.push(...mergedApplicationCssKeyframes.filter((v) => !v.scopedTag || this._cssFiles.indexOf(v.scopedTag) >= 0));
    this._applicationCssSelectorsAppliedVersion = applicationCssSelectorVersion;
    toMerge.push(...this._localCssSelectors);
    toMergeKeyframes.push(...this._localCssKeyframes);
    this._localCssSelectorsAppliedVersion = this._localCssSelectorVersion;
    if (toMerge.length > 0) {
      this._mergedCssSelectors = toMerge;
      this._selectorScope = new StyleSheetSelectorScope(this._mergedCssSelectors);
    } else {
      this._mergedCssSelectors = null;
      this._selectorScope = null;
    }
    this._mergedCssKeyframes = toMergeKeyframes.length > 0 ? toMergeKeyframes : null;
  }
  matchSelectors(view) {
    let match;
    this.ensureSelectors();
    if (this._selectorScope) {
      match = this._selectorScope.query(view);
      this._applyKeyframesToSelectors(match.selectors);
    } else {
      match = null;
    }
    return match;
  }
  query(node) {
    this.ensureSelectors();
    const match = this.matchSelectors(node);
    return match ? match.selectors : [];
  }
  getSelectorsVersion() {
    return 1e5 * this._applicationCssSelectorsAppliedVersion + this._localCssSelectorsAppliedVersion;
  }
  _applyKeyframesToSelectors(selectors) {
    if (!selectors?.length) {
      return;
    }
    for (let i4 = selectors.length - 1;i4 >= 0; i4--) {
      const ruleset = selectors[i4].ruleset;
      const animations = ruleset[animationsSymbol];
      if (animations != null && animations.length) {
        for (const animation of animations) {
          const keyframeRule = this.findKeyframeRule(animation.name);
          animation.keyframes = keyframeRule ? CssAnimationParser.keyframesArrayFromCSS(keyframeRule.keyframes) : null;
        }
      }
    }
  }
  getAnimations(ruleset) {
    return ruleset[animationsSymbol];
  }
  findKeyframeRule(animationName) {
    if (!this._mergedCssKeyframes) {
      return null;
    }
    let validatedMediaQueries;
    for (let i4 = this._mergedCssKeyframes.length - 1;i4 >= 0; i4--) {
      const rule = this._mergedCssKeyframes[i4];
      if (rule.name !== animationName) {
        continue;
      }
      if (!rule.mediaQueryString) {
        return rule;
      }
      if (!validatedMediaQueries) {
        validatedMediaQueries = [];
      }
      const isMatchingAllQueries = matchMediaQueryString(rule.mediaQueryString, validatedMediaQueries);
      if (isMatchingAllQueries) {
        return rule;
      }
    }
    return null;
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String, Object]),
  __metadata("design:returntype", undefined)
], StyleScope.prototype, "setCss", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String, Object]),
  __metadata("design:returntype", undefined)
], StyleScope.prototype, "appendCss", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], StyleScope.prototype, "_createSelectors", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", SelectorsMatch)
], StyleScope.prototype, "matchSelectors", null);
function resolveFileNameFromUrl(url, appDirectory, fileExists, importSource) {
  let fileName = typeof url === "string" ? url.trim() : "";
  if (fileName.indexOf("~/") === 0) {
    fileName = fileName.replace("~/", "");
  }
  const isAbsolutePath = fileName.indexOf("/") === 0;
  const absolutePath = isAbsolutePath ? fileName : path.join(appDirectory, fileName);
  if (fileExists(absolutePath)) {
    return absolutePath;
  }
  if (!isAbsolutePath) {
    if (fileName[0] === "~" && fileName[1] !== "/" && fileName[1] !== '"') {
      fileName = fileName.substring(1);
    }
    if (importSource) {
      const importFile = resolveFilePathFromImport(importSource, fileName);
      if (fileExists(importFile)) {
        return importFile;
      }
    }
    const external = path.join(appDirectory, "tns_modules", fileName);
    if (fileExists(external)) {
      return external;
    }
  }
  return null;
}
function resolveFilePathFromImport(importSource, fileName) {
  const importSourceParts = importSource.split(path.separator);
  const fileNameParts = fileName.split(path.separator).filter((p2) => !isCurrentDirectory(p2));
  importSourceParts.pop();
  fileNameParts.forEach((p2) => isParentDirectory(p2) ? importSourceParts.pop() : importSourceParts.push(p2));
  return importSourceParts.join(path.separator);
}
var applyInlineStyle = profile(function applyInlineStyle2(view, styleStr) {
  const localStyle = `local { ${styleStr} }`;
  const inlineRuleSet = CSSSource.fromSource(localStyle).selectors;
  view.style.resetUnscopedCssVariables();
  inlineRuleSet[0].declarations.forEach((d3) => {
    const property2 = d3.property;
    if (isCssVariable(property2)) {
      view.style.setUnscopedCssVariable(property2, d3.value);
    }
  });
  inlineRuleSet[0].declarations.forEach((d3) => {
    const property2 = d3.property;
    try {
      if (isCssVariable(property2)) {
        return;
      }
      const value = evaluateCssExpressions(view, property2, d3.value);
      if (property2 in view.style) {
        view.style[property2] = value;
      } else {
        view[property2] = value;
      }
    } catch (e3) {
      Trace.write(`Failed to apply property [${d3.property}] with value [${d3.value}] to ${view}. ${e3}`, Trace.categories.Error, Trace.messageType.error);
    }
  });
  view._onCssStateChange();
});
function isCurrentDirectory(uriPart) {
  return uriPart === ".";
}
function isParentDirectory(uriPart) {
  return uriPart === "..";
}
function isMedia(node) {
  return node.type === "media";
}
function isKeyframe(node) {
  return node.type === "keyframes";
}
function isRule(node) {
  return node.type === "rule";
}

// node_modules/@nativescript/core/ui/core/view-base/utils.js
function booleanConverter(v) {
  if (typeof v === "string") {
    v = v.trim().toLowerCase();
    return v === "true" || v === "1";
  }
  return !!v;
}

// node_modules/@nativescript/core/ui/core/view-base/index.js
var defaultBindingSource = {};
function getAncestor(view, criterion) {
  let matcher;
  if (typeof criterion === "string") {
    matcher = (view2) => view2.typeName === criterion;
  } else {
    matcher = (view2) => view2 instanceof criterion;
  }
  for (let parent = view.parent;parent != null; parent = parent.parent) {
    if (matcher(parent)) {
      return parent;
    }
  }
  return null;
}
function getViewById(view, id) {
  if (!view) {
    return;
  }
  if (view.id === id) {
    return view;
  }
  let retVal;
  const descendantsCallback = function(child) {
    if (child.id === id) {
      retVal = child;
      return false;
    }
    return true;
  };
  eachDescendant(view, descendantsCallback);
  return retVal;
}
function getViewByDomId(view, domId) {
  if (!view) {
    return;
  }
  if (view._domId === domId) {
    return view;
  }
  let retVal;
  const descendantsCallback = function(child) {
    if (view._domId === domId) {
      retVal = child;
      return false;
    }
    return true;
  };
  eachDescendant(view, descendantsCallback);
  return retVal;
}
function querySelectorAll(view, selector2) {
  if (!view) {
    return [];
  }
  const retVal = [];
  if (view[selector2]) {
    retVal.push(view);
  }
  const descendantsCallback = function(child) {
    if (child[selector2]) {
      retVal.push(child);
    }
    return true;
  };
  eachDescendant(view, descendantsCallback);
  return retVal;
}
function eachDescendant(view, callback) {
  if (!callback || !view) {
    return;
  }
  let continueIteration;
  const localCallback = function(child) {
    continueIteration = callback(child);
    if (continueIteration) {
      child.eachChild(localCallback);
    }
    return continueIteration;
  };
  view.eachChild(localCallback);
}
var viewIdCounter = 1;
var Flags;
(function(Flags2) {
  Flags2["superOnLoadedCalled"] = "Loaded";
  Flags2["superOnUnloadedCalled"] = "Unloaded";
})(Flags || (Flags = {}));
var SuspendType;
(function(SuspendType2) {
  SuspendType2[SuspendType2["Incremental"] = 0] = "Incremental";
  SuspendType2[SuspendType2["Loaded"] = 1048576] = "Loaded";
  SuspendType2[SuspendType2["NativeView"] = 2097152] = "NativeView";
  SuspendType2[SuspendType2["UISetup"] = 4194304] = "UISetup";
  SuspendType2[SuspendType2["IncrementalCountMask"] = -7340033] = "IncrementalCountMask";
})(SuspendType || (SuspendType = {}));
(function(SuspendType2) {
  function toString2(type) {
    return (type ? "suspended" : "resumed") + "(" + "Incremental: " + (type & SuspendType2.IncrementalCountMask) + ", " + "Loaded: " + !(type & SuspendType2.Loaded) + ", " + "NativeView: " + !(type & SuspendType2.NativeView) + ", " + "UISetup: " + !(type & SuspendType2.UISetup) + ")";
  }
  SuspendType2.toString = toString2;
})(SuspendType || (SuspendType = {}));
var DEFAULT_VIEW_PADDINGS = new Map;

class ViewBase extends Observable {
  constructor() {
    super();
    this._onLoadedCalled = false;
    this._onUnloadedCalled = false;
    this.defaultVisualState = "normal";
    this._cssState = new CssState(new WeakRef(this));
    this.pseudoClassAliases = {
      highlighted: ["active", "pressed"]
    };
    this.mIsRootView = false;
    this._domId = viewIdCounter++;
    this._style = new Style(new WeakRef(this));
    this.cssClasses = new Set;
    this.cssPseudoClasses = new Set;
    this.cssPseudoClasses.add(this.defaultVisualState);
    this.notify({ eventName: ViewBase.createdEvent, type: this.constructor.name, object: this });
  }
  get parentNode() {
    return this._templateParent || this.parent;
  }
  set parentNode(node) {
    this._templateParent = node;
  }
  get nativeView() {
    return this.nativeViewProtected;
  }
  set nativeView(value) {
    this.setNativeView(value);
  }
  get typeName() {
    return getClass(this);
  }
  get style() {
    return this._style;
  }
  set style(inlineStyle) {
    if (typeof inlineStyle === "string") {
      this.setInlineStyle(inlineStyle);
    } else {
      throw new Error("View.style property is read-only.");
    }
  }
  get android() {
    return this._androidView;
  }
  get ios() {
    return this._iosView;
  }
  get isLoaded() {
    return this._isLoaded;
  }
  get ["class"]() {
    return this.className;
  }
  set ["class"](v) {
    this.className = v;
  }
  getViewById(id) {
    return getViewById(this, id);
  }
  getViewByDomId(domId) {
    return getViewByDomId(this, domId);
  }
  get page() {
    if (this.parent) {
      return this.parent.page;
    }
    return null;
  }
  ensureDomNode() {
    if (!this.domNode) {
      this.domNode = new DOMNode(this);
    }
  }
  set(name50, value) {
    this[name50] = WrappedValue.unwrap(value);
  }
  onLoaded() {
    this.setFlag(Flags.superOnLoadedCalled, true);
    if (this._isLoaded) {
      return;
    }
    this._isLoaded = true;
    this._cssState.onLoaded();
    this._resumeNativeUpdates(SuspendType.Loaded);
    this.eachChild((child) => {
      this.loadView(child);
      return true;
    });
    this._emit("loaded");
  }
  onUnloaded() {
    this.setFlag(Flags.superOnUnloadedCalled, true);
    if (!this._isLoaded) {
      return;
    }
    this._suspendNativeUpdates(SuspendType.Loaded);
    this.eachChild((child) => {
      this.unloadView(child);
      return true;
    });
    this._isLoaded = false;
    this._cssState.onUnloaded();
    this._emit("unloaded");
  }
  _layoutParent() {
    if (this.parent) {
      this.parent._layoutParent();
    }
  }
  _suspendNativeUpdates(type) {
    if (type) {
      this._suspendNativeUpdatesCount = this._suspendNativeUpdatesCount | type;
    } else {
      this._suspendNativeUpdatesCount++;
    }
  }
  _resumeNativeUpdates(type) {
    if (type) {
      this._suspendNativeUpdatesCount = this._suspendNativeUpdatesCount & ~type;
    } else {
      if ((this._suspendNativeUpdatesCount & SuspendType.IncrementalCountMask) === 0) {
        throw new Error(`Invalid call to ${this}._resumeNativeUpdates`);
      }
      this._suspendNativeUpdatesCount--;
    }
    if (!this._suspendNativeUpdatesCount) {
      this.onResumeNativeUpdates();
    }
  }
  _batchUpdate(callback) {
    try {
      this._suspendNativeUpdates(SuspendType.Incremental);
      return callback();
    } finally {
      this._resumeNativeUpdates(SuspendType.Incremental);
    }
  }
  setFlag(flag, value) {
    switch (flag) {
      case Flags.superOnLoadedCalled:
        this._onLoadedCalled = value;
        break;
      case Flags.superOnUnloadedCalled:
        this._onUnloadedCalled = value;
        break;
    }
  }
  isFlagSet(flag) {
    switch (flag) {
      case Flags.superOnLoadedCalled:
        return this._onLoadedCalled;
      case Flags.superOnUnloadedCalled:
        return this._onUnloadedCalled;
    }
  }
  callFunctionWithSuper(flag, func) {
    this.setFlag(flag, false);
    func();
    if (!this.isFlagSet(flag)) {
      throw new Error(`super.${flag} not called in ${this}`);
    }
  }
  callLoaded() {
    this.callFunctionWithSuper(Flags.superOnLoadedCalled, () => this.onLoaded());
  }
  callUnloaded() {
    this.callFunctionWithSuper(Flags.superOnUnloadedCalled, () => this.onUnloaded());
  }
  notifyPseudoClassChanged(pseudoClass) {
    this.notify({ eventName: ":" + pseudoClass, object: this });
  }
  getAllAliasedStates(name50) {
    const allStates = [name50];
    if (name50 in this.pseudoClassAliases) {
      for (let i4 = 0, length2 = this.pseudoClassAliases[name50].length;i4 < length2; i4++) {
        allStates.push(this.pseudoClassAliases[name50][i4]);
      }
    }
    return allStates;
  }
  addPseudoClass(name50) {
    const allStates = this.getAllAliasedStates(name50);
    for (let i4 = 0, length2 = allStates.length;i4 < length2; i4++) {
      if (!this.cssPseudoClasses.has(allStates[i4])) {
        this.cssPseudoClasses.add(allStates[i4]);
        this.notifyPseudoClassChanged(allStates[i4]);
      }
    }
  }
  deletePseudoClass(name50) {
    const allStates = this.getAllAliasedStates(name50);
    for (let i4 = 0, length2 = allStates.length;i4 < length2; i4++) {
      if (this.cssPseudoClasses.has(allStates[i4])) {
        this.cssPseudoClasses.delete(allStates[i4]);
        this.notifyPseudoClassChanged(allStates[i4]);
      }
    }
  }
  bindingContextChanged(data2) {
    this.bindings.get("bindingContext").bind(data2.value);
  }
  bind(options, source = defaultBindingSource) {
    const targetProperty = options.targetProperty;
    this.unbind(targetProperty);
    if (!this.bindings) {
      this.bindings = new Map;
    }
    const binding = new Binding(this, options);
    this.bindings.set(targetProperty, binding);
    let bindingSource = source;
    if (bindingSource === defaultBindingSource) {
      bindingSource = this.bindingContext;
      binding.sourceIsBindingContext = true;
      if (targetProperty === "bindingContext") {
        this.bindingContextBoundToParentBindingContextChanged = true;
        const parent = this.parent;
        if (parent) {
          parent.on("bindingContextChange", this.bindingContextChanged, this);
        } else {
          this.shouldAddHandlerToParentBindingContextChanged = true;
        }
      }
    }
    binding.bind(bindingSource);
  }
  unbind(property2) {
    const bindings = this.bindings;
    if (!bindings) {
      return;
    }
    const binding = bindings.get(property2);
    if (binding) {
      binding.unbind();
      bindings.delete(property2);
      if (binding.sourceIsBindingContext) {
        if (property2 === "bindingContext") {
          this.shouldAddHandlerToParentBindingContextChanged = false;
          this.bindingContextBoundToParentBindingContextChanged = false;
          const parent = this.parent;
          if (parent) {
            parent.off("bindingContextChange", this.bindingContextChanged, this);
          }
        }
      }
    }
  }
  performLayout(currentRun = 0) {
    if (this._shouldDelayLayout() && currentRun < 100) {
      setTimeout(() => this.performLayout(currentRun), currentRun);
      currentRun++;
    } else {
      this.parent.requestLayout();
    }
  }
  requestLayout() {
    const parent = this.parent;
    if (parent) {
      this.performLayout();
    }
  }
  eachChild(callback) {}
  _inheritStyles(view) {
    propagateInheritableProperties(this, view);
    view._inheritStyleScope(this._styleScope);
    propagateInheritableCssProperties(this.style, view.style);
  }
  _addView(view, atIndex) {
    if (Trace.isEnabled()) {
      Trace.write(`${this}._addView(${view}, ${atIndex})`, Trace.categories.ViewHierarchy);
    }
    if (!view) {
      throw new Error("Expecting a valid View instance.");
    }
    if (!(view instanceof ViewBase)) {
      throw new Error(view + " is not a valid View instance.");
    }
    if (view.parent) {
      throw new Error("View already has a parent. View: " + view + " Parent: " + view.parent);
    }
    view.parent = this;
    this._addViewCore(view, atIndex);
    view._parentChanged(null);
    if (this.domNode) {
      this.domNode.onChildAdded(view);
    }
  }
  _addViewCore(view, atIndex) {
    this._inheritStyles(view);
    if (this._context) {
      view._setupUI(this._context, atIndex);
    }
    if (this._isLoaded) {
      this.loadView(view);
    }
  }
  loadView(view) {
    if (view && !view.isLoaded) {
      view.callLoaded();
    }
  }
  _shouldDelayLayout() {
    return false;
  }
  unloadView(view) {
    if (view && view.isLoaded) {
      view.callUnloaded();
    }
  }
  _removeView(view) {
    if (Trace.isEnabled()) {
      Trace.write(`${this}._removeView(${view})`, Trace.categories.ViewHierarchy);
    }
    if (view.parent !== this) {
      throw new Error("View not added to this instance. View: " + view + " CurrentParent: " + view.parent + " ExpectedParent: " + this);
    }
    if (this.domNode) {
      this.domNode.onChildRemoved(view);
    }
    this._removeViewCore(view);
    view.parent = undefined;
    view._parentChanged(this);
  }
  _removeViewCore(view) {
    this.unloadView(view);
    if (view._context) {
      view._tearDownUI();
    }
  }
  createNativeView() {
    return;
  }
  disposeNativeView() {
    this._oldLeft = 0;
    this._oldTop = 0;
    this._oldRight = 0;
    this._oldBottom = 0;
    this.notify({
      eventName: ViewBase.disposeNativeViewEvent,
      object: this
    });
  }
  initNativeView() {}
  resetNativeView() {}
  resetNativeViewInternal() {}
  _setupAsRootView(context) {
    this.mIsRootView = true;
    this._setupUI(context);
    this.mIsRootView = false;
  }
  _setupUI(context, atIndex, parentIsLoaded) {
    if (this._context === context) {
      if (this.reusable) {
        if (!this.mIsRootView && this.parent && !this._isAddedToNativeVisualTree) {
          const nativeIndex = this.parent._childIndexToNativeChildIndex(atIndex);
          this._isAddedToNativeVisualTree = this.parent._addViewToNativeVisualTree(this, nativeIndex);
        }
      }
      return;
    } else if (this._context) {
      this._tearDownUI(true);
    }
    this._context = context;
    let nativeView = this.nativeViewProtected;
    if (!nativeView) {
      nativeView = this.createNativeView();
    }
    if (__ANDROID__) {
      if (this._androidView !== nativeView || !this.reusable) {
        this._androidView = nativeView;
        if (nativeView) {
          const className = this.constructor.name;
          if (this._isPaddingRelative === undefined) {
            this._isPaddingRelative = nativeView.isPaddingRelative();
          }
          let result = DEFAULT_VIEW_PADDINGS.get(className) || nativeView.defaultPaddings;
          if (result === undefined) {
            DEFAULT_VIEW_PADDINGS.set(className, org.nativescript.widgets.ViewHelper.getPadding(nativeView));
            nativeView.defaultPaddings = DEFAULT_VIEW_PADDINGS.get(className);
            result = DEFAULT_VIEW_PADDINGS.get(className);
          }
          if (!nativeView.defaultPaddings) {
            nativeView.defaultPaddings = DEFAULT_VIEW_PADDINGS.get(className);
          }
          this._defaultPaddingTop = result.top;
          this._defaultPaddingRight = result.right;
          this._defaultPaddingBottom = result.bottom;
          this._defaultPaddingLeft = result.left;
          const style = this.style;
          if (!paddingTopProperty.isSet(style)) {
            this.effectivePaddingTop = this._defaultPaddingTop;
          }
          if (!paddingRightProperty.isSet(style)) {
            this.effectivePaddingRight = this._defaultPaddingRight;
          }
          if (!paddingBottomProperty.isSet(style)) {
            this.effectivePaddingBottom = this._defaultPaddingBottom;
          }
          if (!paddingLeftProperty.isSet(style)) {
            this.effectivePaddingLeft = this._defaultPaddingLeft;
          }
        }
      }
    } else {
      this._iosView = nativeView;
    }
    this.setNativeView(nativeView);
    if (!this.mIsRootView && this.parent) {
      const nativeIndex = this.parent._childIndexToNativeChildIndex(atIndex);
      this._isAddedToNativeVisualTree = this.parent._addViewToNativeVisualTree(this, nativeIndex);
    }
    this._resumeNativeUpdates(SuspendType.UISetup);
    this.eachChild((child) => {
      child._setupUI(context);
      return true;
    });
  }
  setNativeView(value) {
    if (this.__nativeView === value) {
      return;
    }
    if (this.__nativeView) {
      this._suspendNativeUpdates(SuspendType.NativeView);
    }
    this.__nativeView = this.nativeViewProtected = value;
    if (this.__nativeView) {
      this._suspendedUpdates = undefined;
      this.initNativeView();
      this._resumeNativeUpdates(SuspendType.NativeView);
    }
  }
  destroyNode(forceDestroyChildren) {
    this.reusable = false;
    this.callUnloaded();
    this._tearDownUI(forceDestroyChildren);
  }
  _tearDownUI(force) {
    if (!this._context) {
      return;
    }
    const preserveNativeView = this.reusable && !force;
    this.resetNativeViewInternal();
    if (!preserveNativeView) {
      this.eachChild((child) => {
        child._tearDownUI(force);
        return true;
      });
    }
    if (this.parent) {
      this.parent._removeViewFromNativeVisualTree(this);
    }
    if (!preserveNativeView) {
      this.disposeNativeView();
      this._suspendNativeUpdates(SuspendType.UISetup);
      this.setNativeView(null);
      this._androidView = null;
      this._iosView = null;
      this._context = null;
    }
    if (this.domNode) {
      this.domNode.dispose();
      this.domNode = undefined;
    }
  }
  _childIndexToNativeChildIndex(index) {
    return index;
  }
  _addViewToNativeVisualTree(view, atIndex) {
    if (view._isAddedToNativeVisualTree) {
      throw new Error("Child already added to the native visual tree.");
    }
    return true;
  }
  _removeViewFromNativeVisualTree(view) {
    view._isAddedToNativeVisualTree = false;
  }
  get visualState() {
    return this._visualState;
  }
  _addVisualState(state) {
    this.deletePseudoClass(this.defaultVisualState);
    this.addPseudoClass(state);
  }
  _removeVisualState(state) {
    this.deletePseudoClass(state);
    if (!this.cssPseudoClasses.size) {
      this.addPseudoClass(this.defaultVisualState);
    }
  }
  _goToVisualState(state) {
    console.log("_goToVisualState() is deprecated. Use View._addVisualState() and View._removeVisualState() instead.");
    if (Trace.isEnabled()) {
      Trace.write(this + " going to state: " + state, Trace.categories.Style);
    }
    if (state === this._visualState) {
      return;
    }
    this.deletePseudoClass(this._visualState);
    this._visualState = state;
    this.addPseudoClass(state);
  }
  _applyXmlAttribute(attribute, value) {
    console.log("ViewBase._applyXmlAttribute(...) is deprecated; set attributes as plain properties instead");
    if (attribute === "style" || attribute === "rows" || attribute === "columns" || attribute === "fontAttributes") {
      this[attribute] = value;
      return true;
    }
    return false;
  }
  setInlineStyle(style) {
    if (typeof style !== "string") {
      throw new Error("Parameter should be valid CSS string!");
    }
    applyInlineStyle(this, style, undefined);
  }
  _parentChanged(oldParent) {
    const newParent = this.parent;
    if (oldParent) {
      clearInheritedProperties(this);
      if (this.bindingContextBoundToParentBindingContextChanged) {
        oldParent.off("bindingContextChange", this.bindingContextChanged, this);
      }
    } else if (this.shouldAddHandlerToParentBindingContextChanged) {
      newParent.on("bindingContextChange", this.bindingContextChanged, this);
      this.bindings.get("bindingContext").bind(newParent.bindingContext);
    }
  }
  onResumeNativeUpdates() {
    initNativeView(this, undefined, undefined);
  }
  toString() {
    let str = this.typeName;
    if (this.id) {
      str += `<${this.id}>`;
    } else {
      str += `(${this._domId})`;
    }
    const source = Source.get(this);
    if (source) {
      str += `@${source};`;
    }
    return str;
  }
  _onCssStateChange() {
    this._cssState.onChange();
    eachDescendant(this, (child) => {
      child._cssState.onChange();
      return true;
    });
  }
  _inheritStyleScope(styleScope) {
    if (this._isStyleScopeHost) {
      return;
    }
    if (this._styleScope !== styleScope) {
      this._styleScope = styleScope;
      this._onCssStateChange();
      this.eachChild((child) => {
        child._inheritStyleScope(styleScope);
        return true;
      });
    }
  }
  showModal(moduleOrView, modalOptions) {
    const parent = this.parent;
    return parent && parent.showModal(moduleOrView, modalOptions);
  }
  closeModal(...args) {
    const parent = this.parent;
    if (parent) {
      parent.closeModal(...args);
    }
  }
  _dialogClosed() {
    eachDescendant(this, (child) => {
      child._dialogClosed();
      return true;
    });
  }
  _onRootViewReset() {
    eachDescendant(this, (child) => {
      child._onRootViewReset();
      return true;
    });
  }
}
ViewBase.loadedEvent = "loaded";
ViewBase.unloadedEvent = "unloaded";
ViewBase.createdEvent = "created";
ViewBase.disposeNativeViewEvent = "disposeNativeView";
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "onLoaded", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "onUnloaded", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "addPseudoClass", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "deletePseudoClass", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "requestLayout", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [ViewBase, Number]),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "_addView", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Number, Boolean]),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "_setupUI", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", undefined)
], ViewBase.prototype, "_tearDownUI", null);
ViewBase.prototype.isCollapsed = false;
ViewBase.prototype._oldLeft = 0;
ViewBase.prototype._oldTop = 0;
ViewBase.prototype._oldRight = 0;
ViewBase.prototype._oldBottom = 0;
ViewBase.prototype.effectiveMinWidth = 0;
ViewBase.prototype.effectiveMinHeight = 0;
ViewBase.prototype.effectiveWidth = 0;
ViewBase.prototype.effectiveHeight = 0;
ViewBase.prototype.effectiveMarginTop = 0;
ViewBase.prototype.effectiveMarginRight = 0;
ViewBase.prototype.effectiveMarginBottom = 0;
ViewBase.prototype.effectiveMarginLeft = 0;
ViewBase.prototype.effectivePaddingTop = 0;
ViewBase.prototype.effectivePaddingRight = 0;
ViewBase.prototype.effectivePaddingBottom = 0;
ViewBase.prototype.effectivePaddingLeft = 0;
ViewBase.prototype.effectiveBorderTopWidth = 0;
ViewBase.prototype.effectiveBorderRightWidth = 0;
ViewBase.prototype.effectiveBorderBottomWidth = 0;
ViewBase.prototype.effectiveBorderLeftWidth = 0;
ViewBase.prototype._defaultPaddingTop = 0;
ViewBase.prototype._defaultPaddingRight = 0;
ViewBase.prototype._defaultPaddingBottom = 0;
ViewBase.prototype._defaultPaddingLeft = 0;
ViewBase.prototype._isViewBase = true;
ViewBase.prototype.recycleNativeView = "never";
ViewBase.prototype.reusable = false;
ViewBase.prototype._suspendNativeUpdatesCount = SuspendType.Loaded | SuspendType.NativeView | SuspendType.UISetup;
var bindingContextProperty = new InheritedProperty({
  name: "bindingContext"
});
bindingContextProperty.register(ViewBase);
var hiddenProperty = new Property({
  name: "hidden",
  defaultValue: false,
  affectsLayout: __APPLE__,
  valueConverter: booleanConverter,
  valueChanged: (target, oldValue, newValue) => {
    if (target) {
      target.isCollapsed = !!newValue;
    }
  }
});
hiddenProperty.register(ViewBase);
var classNameProperty = new Property({
  name: "className",
  valueChanged(view, oldValue, newValue) {
    const cssClasses2 = view.cssClasses;
    const rootViewsCssClasses = CSSUtils.getSystemCssClasses();
    const shouldAddModalRootViewCssClasses = cssClasses2.has(CSSUtils.MODAL_ROOT_VIEW_CSS_CLASS);
    const shouldAddRootViewCssClasses = cssClasses2.has(CSSUtils.ROOT_VIEW_CSS_CLASS);
    cssClasses2.clear();
    if (shouldAddModalRootViewCssClasses) {
      cssClasses2.add(CSSUtils.MODAL_ROOT_VIEW_CSS_CLASS);
    } else if (shouldAddRootViewCssClasses) {
      cssClasses2.add(CSSUtils.ROOT_VIEW_CSS_CLASS);
    }
    rootViewsCssClasses.forEach((c3) => cssClasses2.add(c3));
    if (typeof newValue === "string" && newValue !== "") {
      newValue.split(" ").forEach((c3) => cssClasses2.add(c3));
    }
    view._onCssStateChange();
  }
});
classNameProperty.register(ViewBase);
var idProperty = new Property({
  name: "id",
  valueChanged: (view, oldValue, newValue) => view._onCssStateChange()
});
idProperty.register(ViewBase);
var defaultVisualStateProperty = new Property({
  name: "defaultVisualState",
  defaultValue: "normal",
  valueChanged(target, oldValue, newValue) {
    const value = newValue || "normal";
    if (target.cssPseudoClasses && target.cssPseudoClasses.has(oldValue)) {
      target.deletePseudoClass(oldValue);
      target.addPseudoClass(newValue);
    }
  }
});
defaultVisualStateProperty.register(ViewBase);

// node_modules/@nativescript/core/ui/core/view/view-helper/view-helper-common.js
class ViewHelper {
  static measureChild(parent, child, widthMeasureSpec, heightMeasureSpec) {
    let measureWidth = 0;
    let measureHeight = 0;
    if (child && !child.isCollapsed) {
      const widthSpec = parent ? parent._currentWidthMeasureSpec : widthMeasureSpec;
      const heightSpec = parent ? parent._currentHeightMeasureSpec : heightMeasureSpec;
      const width = layout.getMeasureSpecSize(widthSpec);
      const widthMode = layout.getMeasureSpecMode(widthSpec);
      const height = layout.getMeasureSpecSize(heightSpec);
      const heightMode = layout.getMeasureSpecMode(heightSpec);
      child._updateEffectiveLayoutValues(width, widthMode, height, heightMode);
      const style = child.style;
      const horizontalMargins = child.effectiveMarginLeft + child.effectiveMarginRight;
      const verticalMargins = child.effectiveMarginTop + child.effectiveMarginBottom;
      const childWidthMeasureSpec = ViewHelper.getMeasureSpec(widthMeasureSpec, horizontalMargins, child.effectiveWidth, style.horizontalAlignment === "stretch");
      const childHeightMeasureSpec = ViewHelper.getMeasureSpec(heightMeasureSpec, verticalMargins, child.effectiveHeight, style.verticalAlignment === "stretch");
      if (Trace.isEnabled()) {
        Trace.write(`${child.parent} :measureChild: ${child} ${layout.measureSpecToString(childWidthMeasureSpec)}, ${layout.measureSpecToString(childHeightMeasureSpec)}}`, Trace.categories.Layout);
      }
      child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
      measureWidth = Math.round(child.getMeasuredWidth() + horizontalMargins);
      measureHeight = Math.round(child.getMeasuredHeight() + verticalMargins);
    }
    return { measuredWidth: measureWidth, measuredHeight: measureHeight };
  }
  static layoutChild(parent, child, left, top, right, bottom, setFrame = true) {
    if (!child || child.isCollapsed) {
      return;
    }
    const childStyle = child.style;
    let childTop;
    let childLeft;
    let childWidth = child.getMeasuredWidth();
    let childHeight = child.getMeasuredHeight();
    const effectiveMarginTop = child.effectiveMarginTop;
    const effectiveMarginBottom = child.effectiveMarginBottom;
    let vAlignment;
    if (child.effectiveHeight >= 0 && childStyle.verticalAlignment === "stretch") {
      vAlignment = "middle";
    } else {
      vAlignment = childStyle.verticalAlignment;
    }
    switch (vAlignment) {
      case "top":
        childTop = top + effectiveMarginTop;
        break;
      case "middle":
        childTop = top + (bottom - top - childHeight + (effectiveMarginTop - effectiveMarginBottom)) / 2;
        break;
      case "bottom":
        childTop = bottom - childHeight - effectiveMarginBottom;
        break;
      case "stretch":
      default:
        childTop = top + effectiveMarginTop;
        childHeight = bottom - top - (effectiveMarginTop + effectiveMarginBottom);
        if (childHeight < 0) {
          childHeight = 0;
        }
        break;
    }
    const effectiveMarginLeft = child.effectiveMarginLeft;
    const effectiveMarginRight = child.effectiveMarginRight;
    let hAlignment;
    if (child.effectiveWidth >= 0 && childStyle.horizontalAlignment === "stretch") {
      hAlignment = "center";
    } else {
      hAlignment = childStyle.horizontalAlignment;
    }
    switch (hAlignment) {
      case "start":
        childLeft = child.direction === CoreTypes.LayoutDirection.rtl ? right - childWidth - effectiveMarginRight : left + effectiveMarginLeft;
        break;
      case "left":
        childLeft = left + effectiveMarginLeft;
        break;
      case "center":
        childLeft = left + (right - left - childWidth + (effectiveMarginLeft - effectiveMarginRight)) / 2;
        break;
      case "right":
        childLeft = right - childWidth - effectiveMarginRight;
        break;
      case "end":
        childLeft = child.direction === CoreTypes.LayoutDirection.rtl ? left + effectiveMarginLeft : right - childWidth - effectiveMarginRight;
        break;
      case "stretch":
      default:
        childLeft = left + effectiveMarginLeft;
        childWidth = right - left - (effectiveMarginLeft + effectiveMarginRight);
        if (childWidth < 0) {
          childWidth = 0;
        }
        break;
    }
    const childRight = Math.round(childLeft + childWidth);
    const childBottom = Math.round(childTop + childHeight);
    childLeft = Math.round(childLeft);
    childTop = Math.round(childTop);
    if (Trace.isEnabled()) {
      Trace.write(child.parent + " :layoutChild: " + child + " " + childLeft + ", " + childTop + ", " + childRight + ", " + childBottom, Trace.categories.Layout);
    }
    child.layout(childLeft, childTop, childRight, childBottom, setFrame);
  }
  static resolveSizeAndState(size, specSize, specMode, childMeasuredState) {
    let result = size;
    switch (specMode) {
      case layout.UNSPECIFIED:
        result = Math.ceil(size);
        break;
      case layout.AT_MOST:
        if (specSize < size) {
          result = Math.ceil(specSize) | layout.MEASURED_STATE_TOO_SMALL;
        }
        break;
      case layout.EXACTLY:
        result = Math.ceil(specSize);
        break;
    }
    return result | childMeasuredState & layout.MEASURED_STATE_MASK;
  }
  static combineMeasuredStates(curState, newState) {
    return curState | newState;
  }
  static getMeasureSpec(parentSpec, margins, childLength, stretched) {
    const parentLength = layout.getMeasureSpecSize(parentSpec);
    const parentSpecMode = layout.getMeasureSpecMode(parentSpec);
    let resultSize;
    let resultMode;
    if (childLength >= 0) {
      resultSize = parentSpecMode === layout.UNSPECIFIED ? childLength : Math.min(parentLength, childLength);
      resultMode = layout.EXACTLY;
    } else {
      switch (parentSpecMode) {
        case layout.EXACTLY:
          resultSize = Math.max(0, parentLength - margins);
          resultMode = stretched ? layout.EXACTLY : layout.AT_MOST;
          break;
        case layout.AT_MOST:
          resultSize = Math.max(0, parentLength - margins);
          resultMode = layout.AT_MOST;
          break;
        case layout.UNSPECIFIED:
          resultSize = 0;
          resultMode = layout.UNSPECIFIED;
          break;
      }
    }
    return layout.makeMeasureSpec(resultSize, resultMode);
  }
}
// node_modules/@nativescript/core/ui/core/view/view-helper/index.android.js
var androidxGraphics = androidx.core.graphics;

class AndroidHelper {
  static getDrawableColor(drawable) {
    if (!drawable) {
      return null;
    }
    let color2;
    if (drawable instanceof org.nativescript.widgets.BorderDrawable) {
      color2 = drawable.getBackgroundColor();
    } else if (drawable instanceof android.graphics.drawable.ColorDrawable) {
      color2 = drawable.getColor();
    } else {
      color2 = drawable._backgroundColor;
    }
    return new Color(color2);
  }
  static setDrawableColor(color2, drawable, blendMode) {
    if (SDK_VERSION < 21 && drawable instanceof android.graphics.drawable.ColorDrawable) {
      drawable.setColor(color2);
    } else {
      drawable.setColorFilter(androidxGraphics.BlendModeColorFilterCompat.createBlendModeColorFilterCompat(color2, blendMode ?? androidxGraphics.BlendModeCompat.SRC_IN));
      drawable._backgroundColor = color2;
    }
  }
  static clearDrawableColor(drawable) {
    if (SDK_VERSION < 21 && drawable instanceof android.graphics.drawable.ColorDrawable) {
      drawable.setColor(-1);
    } else {
      drawable.clearColorFilter();
      delete drawable._backgroundColor;
    }
  }
  static getCopyOrDrawable(drawable, resources3) {
    if (drawable) {
      const constantState = drawable.getConstantState();
      if (constantState) {
        return resources3 ? constantState.newDrawable(resources3) : constantState.newDrawable();
      }
    }
    return drawable;
  }
}

// node_modules/@nativescript/core/ui/gestures/gestures-types.js
var GestureEvents;
(function(GestureEvents2) {
  GestureEvents2["gestureAttached"] = "gestureAttached";
  GestureEvents2["touchDown"] = "touchDown";
  GestureEvents2["touchUp"] = "touchUp";
})(GestureEvents || (GestureEvents = {}));
var GestureTypes;
(function(GestureTypes2) {
  GestureTypes2[GestureTypes2["tap"] = 1] = "tap";
  GestureTypes2[GestureTypes2["doubleTap"] = 2] = "doubleTap";
  GestureTypes2[GestureTypes2["pinch"] = 4] = "pinch";
  GestureTypes2[GestureTypes2["pan"] = 8] = "pan";
  GestureTypes2[GestureTypes2["swipe"] = 16] = "swipe";
  GestureTypes2[GestureTypes2["rotation"] = 32] = "rotation";
  GestureTypes2[GestureTypes2["longPress"] = 64] = "longPress";
  GestureTypes2[GestureTypes2["touch"] = 128] = "touch";
})(GestureTypes || (GestureTypes = {}));
var GestureStateTypes;
(function(GestureStateTypes2) {
  GestureStateTypes2[GestureStateTypes2["cancelled"] = 0] = "cancelled";
  GestureStateTypes2[GestureStateTypes2["began"] = 1] = "began";
  GestureStateTypes2[GestureStateTypes2["changed"] = 2] = "changed";
  GestureStateTypes2[GestureStateTypes2["ended"] = 3] = "ended";
})(GestureStateTypes || (GestureStateTypes = {}));
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2[SwipeDirection2["right"] = 1] = "right";
  SwipeDirection2[SwipeDirection2["left"] = 2] = "left";
  SwipeDirection2[SwipeDirection2["up"] = 4] = "up";
  SwipeDirection2[SwipeDirection2["down"] = 8] = "down";
})(SwipeDirection || (SwipeDirection = {}));
var TouchAction;
(function(TouchAction2) {
  TouchAction2["down"] = "down";
  TouchAction2["up"] = "up";
  TouchAction2["move"] = "move";
  TouchAction2["cancel"] = "cancel";
})(TouchAction || (TouchAction = {}));

// node_modules/@nativescript/core/ui/gestures/gestures-common.js
function toString2(type) {
  switch (type) {
    case GestureTypes.tap:
      return GestureTypes[GestureTypes.tap];
    case GestureTypes.doubleTap:
      return GestureTypes[GestureTypes.doubleTap];
    case GestureTypes.pinch:
      return GestureTypes[GestureTypes.pinch];
    case GestureTypes.pan:
      return GestureTypes[GestureTypes.pan];
    case GestureTypes.swipe:
      return GestureTypes[GestureTypes.swipe];
    case GestureTypes.rotation:
      return GestureTypes[GestureTypes.rotation];
    case GestureTypes.longPress:
      return GestureTypes[GestureTypes.longPress];
    case GestureTypes.touch:
      return GestureTypes[GestureTypes.touch];
  }
}
function fromString(type) {
  const t3 = type.trim().toLowerCase();
  switch (t3) {
    case "tap":
      return GestureTypes.tap;
    case "doubletap":
      return GestureTypes.doubleTap;
    case "pinch":
      return GestureTypes.pinch;
    case "pan":
      return GestureTypes.pan;
    case "swipe":
      return GestureTypes.swipe;
    case "rotation":
      return GestureTypes.rotation;
    case "longpress":
      return GestureTypes.longPress;
    case "touch":
      return GestureTypes.touch;
  }
  return;
}

class GesturesObserverBase {
  get callback() {
    return this._callback;
  }
  get target() {
    return this._target;
  }
  get context() {
    return this._context;
  }
  constructor(target, callback, context) {
    this._target = target;
    this._callback = callback;
    this._context = context;
  }
  disconnect() {
    this._target = null;
    this._callback = null;
    this._context = null;
  }
}
// node_modules/@nativescript/core/ui/gestures/touch-manager.js
var TouchAnimationTypes;
(function(TouchAnimationTypes2) {
  TouchAnimationTypes2["up"] = "up";
  TouchAnimationTypes2["down"] = "down";
})(TouchAnimationTypes || (TouchAnimationTypes = {}));

class TouchManager {
  static addAnimations(view) {
    const handleDown = view?.touchAnimation && (view?.touchAnimation).down || TouchManager.animations && TouchManager.animations.down;
    const handleUp = view?.touchAnimation && (view?.touchAnimation).up || TouchManager.animations && TouchManager.animations.up;
    if (__APPLE__) {
      if (view?.ios?.addTargetActionForControlEvents) {
        if (!TouchManager.touchHandlers) {
          TouchManager.touchHandlers = [];
        }
        TouchManager.touchHandlers.push({
          view,
          handler: TouchControlHandler.initWithOwner(new WeakRef(view))
        });
        if (handleDown) {
          view.ios.addTargetActionForControlEvents(TouchManager.touchHandlers[TouchManager.touchHandlers.length - 1].handler, GestureEvents.touchDown, 1 | 16);
          view.on(GestureEvents.touchDown, (args) => {
            TouchManager.startAnimationForType(view, TouchAnimationTypes.down);
          });
        }
        if (handleUp) {
          view.ios.addTargetActionForControlEvents(TouchManager.touchHandlers[TouchManager.touchHandlers.length - 1].handler, GestureEvents.touchUp, 32 | 256 | 64 | 128);
          view.on(GestureEvents.touchUp, (args) => {
            TouchManager.startAnimationForType(view, TouchAnimationTypes.up);
          });
        }
      } else {
        if (handleDown || handleUp) {
          view.on(GestureEvents.gestureAttached, (args) => {
            if (args.type === GestureTypes.longPress) {
              args.ios.minimumPressDuration = args.object?.touchDelay || 0;
            }
          });
          view.on(GestureTypes[GestureTypes.longPress], (args) => {
            switch (args.state) {
              case GestureStateTypes.began:
                if (handleDown) {
                  TouchManager.startAnimationForType(args.view, TouchAnimationTypes.down);
                }
                break;
              case GestureStateTypes.cancelled:
              case GestureStateTypes.ended:
                if (handleUp) {
                  TouchManager.startAnimationForType(args.view, TouchAnimationTypes.up);
                }
                break;
            }
          });
        }
      }
    } else {
      if (handleDown || handleUp) {
        view.on(GestureTypes[GestureTypes.touch], (args) => {
          switch (args.action) {
            case "down":
              if (handleDown) {
                view.notify({
                  eventName: GestureEvents.touchDown,
                  object: view,
                  data: args.android
                });
              }
              break;
            case "up":
            case "cancel":
              if (handleUp) {
                view.notify({
                  eventName: GestureEvents.touchUp,
                  object: view,
                  data: args.android
                });
              }
              break;
          }
        });
        if (handleDown) {
          view.on(GestureEvents.touchDown, (args) => {
            TouchManager.startAnimationForType(view, TouchAnimationTypes.down);
          });
        }
        if (handleUp) {
          view.on(GestureEvents.touchUp, (args) => {
            TouchManager.startAnimationForType(view, TouchAnimationTypes.up);
          });
        }
      }
    }
    view.on("disposeNativeView", (args) => {
      const index = TouchManager.touchHandlers?.findIndex((handler) => handler.view === args.object);
      if (index > -1) {
        TouchManager.touchHandlers.splice(index, 1);
      }
      TouchManager.touchAnimationDefinitions = TouchManager.touchAnimationDefinitions?.filter((d3) => d3.view !== args.object);
    });
  }
  static startAnimationForType(view, type) {
    if (view) {
      const animate = function(definition) {
        if (definition) {
          if (isFunction(definition)) {
            definition(view);
          } else {
            if (!TouchManager.touchAnimationDefinitions) {
              TouchManager.touchAnimationDefinitions = [];
            }
            let touchAnimation;
            for (const d3 of TouchManager.touchAnimationDefinitions) {
              if (d3.view === view && d3.animation) {
                d3.animation.cancel();
                if (d3.type === type) {
                  touchAnimation = d3.animation;
                }
              }
            }
            if (!touchAnimation) {
              touchAnimation = new Animation([
                {
                  target: view,
                  ...definition
                }
              ]);
              TouchManager.touchAnimationDefinitions.push({
                view,
                type,
                animation: touchAnimation
              });
            }
            touchAnimation.play().catch(() => {});
          }
        }
      };
      if (isObject(view.touchAnimation) && view.touchAnimation[type]) {
        animate(view.touchAnimation[type]);
      } else if (TouchManager.animations?.[type]) {
        animate(TouchManager.animations?.[type]);
      }
    }
  }
  static addHoverStyle(view) {
    if (__VISIONOS__ && view?.ios) {
      if (!TouchManager.visionHoverOptions) {
        TouchManager.visionHoverOptions = {};
      }
      if (!TouchManager.visionHoverOptions["default"]) {
        TouchManager.visionHoverOptions["default"] = {
          effect: "automatic"
        };
      }
      if (!TouchManager.visionHoverStyleCache) {
        TouchManager.visionHoverStyleCache = {};
      }
      const createHoverStyleFromOptions = function(options) {
        let effect;
        switch (options.effect) {
          case "automatic":
            effect = UIHoverAutomaticEffect.effect();
            break;
          case "highlight":
            effect = UIHoverHighlightEffect.effect();
            break;
          case "lift":
            effect = UIHoverLiftEffect.effect();
            break;
        }
        let shape;
        switch (options.shape) {
          case "circle":
            shape = UIShape.circleShape;
            break;
          case "rect":
            if (options.shapeCornerRadius) {
              shape = UIShape.rectShapeWithCornerRadius(options.shapeCornerRadius);
            } else {
              shape = UIShape.rectShape;
            }
            break;
        }
        return UIHoverStyle.styleWithEffectShape(effect, shape);
      };
      if (!TouchManager.visionHoverStyleCache["default"]) {
        const defaultOptions2 = TouchManager.visionHoverOptions["default"];
        TouchManager.visionHoverStyleCache["default"] = createHoverStyleFromOptions(defaultOptions2 || {
          effect: "automatic"
        });
      }
      if (view.visionHoverStyle) {
        if (typeof view.visionHoverStyle === "string") {
          view.ios.hoverStyle = TouchManager.visionHoverStyleCache[view.visionHoverStyle] || TouchManager.visionHoverStyleCache["default"];
        }
      } else {
        view.ios.hoverStyle = TouchManager.visionHoverStyleCache["default"];
      }
    }
  }
}
var TouchControlHandler;
ensureTouchControlHandlers();
function ensureTouchControlHandlers() {
  if (__APPLE__) {
    var TouchHandlerImpl = function(_super) {
      __extends(TouchHandlerImpl2, _super);
      function TouchHandlerImpl2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      TouchHandlerImpl2.initWithOwner = function(owner) {
        var handler = TouchHandlerImpl2.new();
        handler._owner = owner;
        return handler;
      };
      TouchHandlerImpl2.prototype.touchDown = function(args) {
        var _a4, _b4, _c2, _d;
        (_b4 = (_a4 = this._owner) === null || _a4 === undefined ? undefined : _a4.deref) === null || _b4 === undefined || _b4.call(_a4).notify({
          eventName: GestureEvents.touchDown,
          object: (_d = (_c2 = this._owner) === null || _c2 === undefined ? undefined : _c2.deref) === null || _d === undefined ? undefined : _d.call(_c2),
          data: args
        });
      };
      TouchHandlerImpl2.prototype.touchUp = function(args) {
        var _a4, _b4, _c2, _d;
        (_b4 = (_a4 = this._owner) === null || _a4 === undefined ? undefined : _a4.deref) === null || _b4 === undefined || _b4.call(_a4).notify({
          eventName: GestureEvents.touchUp,
          object: (_d = (_c2 = this._owner) === null || _c2 === undefined ? undefined : _c2.deref) === null || _d === undefined ? undefined : _d.call(_c2),
          data: args
        });
      };
      TouchHandlerImpl2.ObjCExposedMethods = {
        touchDown: { returns: interop.types.void, params: [interop.types.id] },
        touchUp: { returns: interop.types.void, params: [interop.types.id] }
      };
      return TouchHandlerImpl2;
    }(NSObject);
    TouchControlHandler = TouchHandlerImpl;
  }
}

// node_modules/@nativescript/core/ui/gestures/index.android.js
var TapAndDoubleTapGestureListener;
function initializeTapAndDoubleTapGestureListener() {
  if (TapAndDoubleTapGestureListener) {
    return;
  }
  var TapAndDoubleTapGestureListenerImpl = function(_super) {
    __extends(TapAndDoubleTapGestureListenerImpl2, _super);
    function TapAndDoubleTapGestureListenerImpl2(observer, target, type) {
      var _this = _super.call(this) || this;
      _this._lastUpTime = 0;
      _this._observer = observer;
      _this._target = target;
      _this._type = type;
      return global.__native(_this);
    }
    TapAndDoubleTapGestureListenerImpl2.prototype.onSingleTapUp = function(motionEvent) {
      this._handleSingleTap(motionEvent);
      this._lastUpTime = Date.now();
      return true;
    };
    TapAndDoubleTapGestureListenerImpl2.prototype.onDown = function(motionEvent) {
      var tapTime = Date.now();
      if (tapTime - this._lastUpTime <= TapAndDoubleTapGestureListenerImpl2.DoubleTapTimeout) {
        this._handleDoubleTap(motionEvent);
      }
      return true;
    };
    TapAndDoubleTapGestureListenerImpl2.prototype.onLongPress = function(motionEvent) {
      if (this._type === GestureTypes.longPress) {
        var args = _getLongPressArgs(GestureTypes.longPress, this._target, GestureStateTypes.began, motionEvent);
        _executeCallback(this._observer, args);
      }
    };
    TapAndDoubleTapGestureListenerImpl2.prototype._handleSingleTap = function(motionEvent) {
      var _this = this;
      if (this._target.getGestureObservers(GestureTypes.doubleTap)) {
        this._tapTimeoutId = setTimeout2(function() {
          if (_this._type === GestureTypes.tap) {
            var args2 = _getTapArgs(GestureTypes.tap, _this._target, motionEvent);
            _executeCallback(_this._observer, args2);
          }
          clearTimeout2(_this._tapTimeoutId);
        }, TapAndDoubleTapGestureListenerImpl2.DoubleTapTimeout);
      } else {
        if (this._type === GestureTypes.tap) {
          var args = _getTapArgs(GestureTypes.tap, this._target, motionEvent);
          _executeCallback(this._observer, args);
        }
      }
    };
    TapAndDoubleTapGestureListenerImpl2.prototype._handleDoubleTap = function(motionEvent) {
      if (this._tapTimeoutId) {
        clearTimeout2(this._tapTimeoutId);
      }
      if (this._type === GestureTypes.doubleTap) {
        var args = _getTapArgs(GestureTypes.doubleTap, this._target, motionEvent);
        _executeCallback(this._observer, args);
      }
    };
    TapAndDoubleTapGestureListenerImpl2.DoubleTapTimeout = android.view.ViewConfiguration.getDoubleTapTimeout();
    return TapAndDoubleTapGestureListenerImpl2;
  }(android.view.GestureDetector.SimpleOnGestureListener);
  TapAndDoubleTapGestureListener = TapAndDoubleTapGestureListenerImpl;
}
var PinchGestureListener;
function initializePinchGestureListener() {
  if (PinchGestureListener) {
    return;
  }
  var PinchGestureListenerImpl = function(_super) {
    __extends(PinchGestureListenerImpl2, _super);
    function PinchGestureListenerImpl2(observer, target) {
      var _this = _super.call(this) || this;
      _this._observer = observer;
      _this._target = target;
      return global.__native(_this);
    }
    PinchGestureListenerImpl2.prototype.onScaleBegin = function(detector) {
      this._scale = detector.getScaleFactor();
      var args = new PinchGestureEventData(this._target, detector, this._scale, this._target, GestureStateTypes.began);
      _executeCallback(this._observer, args);
      return true;
    };
    PinchGestureListenerImpl2.prototype.onScale = function(detector) {
      this._scale *= detector.getScaleFactor();
      var args = new PinchGestureEventData(this._target, detector, this._scale, this._target, GestureStateTypes.changed);
      _executeCallback(this._observer, args);
      return true;
    };
    PinchGestureListenerImpl2.prototype.onScaleEnd = function(detector) {
      this._scale *= detector.getScaleFactor();
      var args = new PinchGestureEventData(this._target, detector, this._scale, this._target, GestureStateTypes.ended);
      _executeCallback(this._observer, args);
    };
    return PinchGestureListenerImpl2;
  }(android.view.ScaleGestureDetector.SimpleOnScaleGestureListener);
  PinchGestureListener = PinchGestureListenerImpl;
}
var SwipeGestureListener;
function initializeSwipeGestureListener() {
  if (SwipeGestureListener) {
    return;
  }
  var SwipeGestureListenerImpl = function(_super) {
    __extends(SwipeGestureListenerImpl2, _super);
    function SwipeGestureListenerImpl2(observer, target) {
      var _this = _super.call(this) || this;
      _this._observer = observer;
      _this._target = target;
      return global.__native(_this);
    }
    SwipeGestureListenerImpl2.prototype.onDown = function(motionEvent) {
      return true;
    };
    SwipeGestureListenerImpl2.prototype.onFling = function(initialEvent, currentEvent, velocityX, velocityY) {
      var result = false;
      var args;
      try {
        var deltaY = currentEvent.getY() - initialEvent.getY();
        var deltaX = currentEvent.getX() - initialEvent.getX();
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(velocityX) > SWIPE_VELOCITY_THRESHOLD) {
            if (deltaX > 0) {
              args = _getSwipeArgs(SwipeDirection.right, this._target, initialEvent, currentEvent);
              _executeCallback(this._observer, args);
              result = true;
            } else {
              args = _getSwipeArgs(SwipeDirection.left, this._target, initialEvent, currentEvent);
              _executeCallback(this._observer, args);
              result = true;
            }
          }
        } else {
          if (Math.abs(deltaY) > SWIPE_THRESHOLD && Math.abs(velocityY) > SWIPE_VELOCITY_THRESHOLD) {
            if (deltaY > 0) {
              args = _getSwipeArgs(SwipeDirection.down, this._target, initialEvent, currentEvent);
              _executeCallback(this._observer, args);
              result = true;
            } else {
              args = _getSwipeArgs(SwipeDirection.up, this._target, initialEvent, currentEvent);
              _executeCallback(this._observer, args);
              result = true;
            }
          }
        }
      } catch (ex) {}
      return result;
    };
    return SwipeGestureListenerImpl2;
  }(android.view.GestureDetector.SimpleOnGestureListener);
  SwipeGestureListener = SwipeGestureListenerImpl;
}
var SWIPE_THRESHOLD = 100;
var SWIPE_VELOCITY_THRESHOLD = 100;
var INVALID_POINTER_ID = -1;
var TO_DEGREES = 180 / Math.PI;
function observe(target, type, callback, context) {
  const observer = new GesturesObserver(target, callback, context);
  observer.observe(type);
  return observer;
}

class GesturesObserver extends GesturesObserverBase {
  observe(type) {
    this.type = type;
    if (!this.target) {
      return;
    }
    this._onTargetLoaded = () => {
      this._attach(this.target, type);
    };
    this._onTargetUnloaded = () => {
      this._detach();
    };
    this.target.on("loaded", this._onTargetLoaded);
    this.target.on("unloaded", this._onTargetUnloaded);
    if (this.target.isLoaded) {
      this._attach(this.target, type);
    }
  }
  disconnect() {
    this._detach();
    if (this.target) {
      this.target.off("loaded", this._onTargetLoaded);
      this.target.off("unloaded", this._onTargetUnloaded);
      this._onTargetLoaded = null;
      this._onTargetUnloaded = null;
    }
    super.disconnect();
  }
  _detach() {
    this._notifyTouch = false;
    this._simpleGestureDetector = null;
    this._scaleGestureDetector = null;
    this._swipeGestureDetector = null;
    this._panGestureDetector = null;
    this._rotateGestureDetector = null;
    this._eventData = null;
  }
  _attach(target, type) {
    this._detach();
    let recognizer;
    switch (type) {
      case GestureTypes.tap:
      case GestureTypes.doubleTap:
      case GestureTypes.longPress: {
        initializeTapAndDoubleTapGestureListener();
        recognizer = this._simpleGestureDetector = new androidx.core.view.GestureDetectorCompat(target._context, new TapAndDoubleTapGestureListener(this, this.target, type));
        break;
      }
      case GestureTypes.pinch: {
        initializePinchGestureListener();
        recognizer = this._scaleGestureDetector = new android.view.ScaleGestureDetector(target._context, new PinchGestureListener(this, this.target));
        break;
      }
      case GestureTypes.swipe: {
        initializeSwipeGestureListener();
        recognizer = this._swipeGestureDetector = new androidx.core.view.GestureDetectorCompat(target._context, new SwipeGestureListener(this, this.target));
        break;
      }
      case GestureTypes.pan: {
        recognizer = this._panGestureDetector = new CustomPanGestureDetector(this, this.target);
        break;
      }
      case GestureTypes.rotation: {
        recognizer = this._rotateGestureDetector = new CustomRotateGestureDetector(this, this.target);
        break;
      }
      case GestureTypes.touch: {
        this._notifyTouch = true;
        return;
      }
    }
    this.target.notify({
      eventName: GestureEvents.gestureAttached,
      object: this.target,
      type,
      view: this.target,
      android: recognizer
    });
  }
  androidOnTouchEvent(motionEvent) {
    if (this._notifyTouch) {
      if (!this._eventData) {
        this._eventData = new TouchGestureEventData;
      }
      this._eventData.prepare(this.target, motionEvent);
      _executeCallback(this, this._eventData);
    }
    if (this._simpleGestureDetector) {
      this._simpleGestureDetector.onTouchEvent(motionEvent);
    }
    if (this._scaleGestureDetector) {
      this._scaleGestureDetector.onTouchEvent(motionEvent);
    }
    if (this._swipeGestureDetector) {
      this._swipeGestureDetector.onTouchEvent(motionEvent);
    }
    if (this._panGestureDetector) {
      this._panGestureDetector.onTouchEvent(motionEvent);
    }
    if (this._rotateGestureDetector) {
      this._rotateGestureDetector.onTouchEvent(motionEvent);
    }
  }
}
function _getTapArgs(type, view, e3) {
  return {
    type,
    view,
    android: e3,
    ios: undefined,
    object: view,
    eventName: toString2(type),
    getPointerCount: () => e3.getPointerCount(),
    getX: () => layout.toDeviceIndependentPixels(e3.getX()),
    getY: () => layout.toDeviceIndependentPixels(e3.getY())
  };
}
function _getLongPressArgs(type, view, state, e3) {
  return {
    type,
    view,
    android: e3,
    ios: undefined,
    object: view,
    eventName: toString2(type),
    state
  };
}
function _getSwipeArgs(direction, view, initialEvent, currentEvent) {
  return {
    type: GestureTypes.swipe,
    view,
    android: { initial: initialEvent, current: currentEvent },
    direction,
    ios: undefined,
    object: view,
    eventName: toString2(GestureTypes.swipe)
  };
}
function _getPanArgs(deltaX, deltaY, view, state, initialEvent, currentEvent) {
  return {
    type: GestureTypes.pan,
    view,
    android: { initial: initialEvent, current: currentEvent },
    deltaX,
    deltaY,
    ios: undefined,
    object: view,
    eventName: toString2(GestureTypes.pan),
    state
  };
}
function _executeCallback(observer, args) {
  if (observer && observer.callback) {
    observer.callback.call(observer.context, args);
  }
}

class PinchGestureEventData {
  constructor(view, android5, scale, object, state) {
    this.view = view;
    this.android = android5;
    this.scale = scale;
    this.object = object;
    this.state = state;
    this.type = GestureTypes.pinch;
    this.eventName = toString2(GestureTypes.pinch);
  }
  getFocusX() {
    return this.android.getFocusX() / layout.getDisplayDensity();
  }
  getFocusY() {
    return this.android.getFocusY() / layout.getDisplayDensity();
  }
}

class CustomPanGestureDetector {
  constructor(observer, target) {
    this.observer = observer;
    this.target = target;
    this.isTracking = false;
    this.density = layout.getDisplayDensity();
  }
  onTouchEvent(event) {
    switch (event.getActionMasked()) {
      case android.view.MotionEvent.ACTION_UP:
      case android.view.MotionEvent.ACTION_CANCEL:
        this.trackStop(event, false);
        break;
      case android.view.MotionEvent.ACTION_DOWN:
      case android.view.MotionEvent.ACTION_POINTER_DOWN:
      case android.view.MotionEvent.ACTION_POINTER_UP:
        this.trackStop(event, true);
        break;
      case android.view.MotionEvent.ACTION_MOVE:
        if (!this.isTracking) {
          this.trackStart(event);
        }
        this.trackChange(event);
        break;
    }
    return true;
  }
  trackStop(currentEvent, cacheEvent) {
    if (this.isTracking) {
      const args = _getPanArgs(this.deltaX, this.deltaY, this.target, GestureStateTypes.ended, null, currentEvent);
      _executeCallback(this.observer, args);
      this.deltaX = undefined;
      this.deltaY = undefined;
      this.isTracking = false;
    }
    if (cacheEvent) {
      this.lastEventCache = currentEvent;
    } else {
      this.lastEventCache = undefined;
    }
  }
  trackStart(currentEvent) {
    const inital = this.getEventCoordinates(this.lastEventCache ? this.lastEventCache : currentEvent);
    this.initialX = inital.x;
    this.initialY = inital.y;
    this.isTracking = true;
    const args = _getPanArgs(0, 0, this.target, GestureStateTypes.began, null, currentEvent);
    _executeCallback(this.observer, args);
  }
  trackChange(currentEvent) {
    const current2 = this.getEventCoordinates(currentEvent);
    this.deltaX = current2.x - this.initialX;
    this.deltaY = current2.y - this.initialY;
    const args = _getPanArgs(this.deltaX, this.deltaY, this.target, GestureStateTypes.changed, null, currentEvent);
    _executeCallback(this.observer, args);
  }
  getEventCoordinates(event) {
    const count = event.getPointerCount();
    if (count === 1) {
      return {
        x: event.getRawX() / this.density,
        y: event.getRawY() / this.density
      };
    } else {
      const offX = event.getRawX() - event.getX();
      const offY = event.getRawY() - event.getY();
      const res = { x: 0, y: 0 };
      for (let i4 = 0;i4 < count; i4++) {
        res.x += event.getX(i4) + offX;
        res.y += event.getY(i4) + offY;
      }
      res.x /= count * this.density;
      res.y /= count * this.density;
      return res;
    }
  }
}

class CustomRotateGestureDetector {
  get isTracking() {
    return this.trackedPtrId1 !== INVALID_POINTER_ID && this.trackedPtrId2 !== INVALID_POINTER_ID;
  }
  constructor(observer, target) {
    this.observer = observer;
    this.target = target;
    this.trackedPtrId1 = INVALID_POINTER_ID;
    this.trackedPtrId2 = INVALID_POINTER_ID;
  }
  onTouchEvent(event) {
    const pointerID = event.getPointerId(event.getActionIndex());
    const wasTracking = this.isTracking;
    switch (event.getActionMasked()) {
      case android.view.MotionEvent.ACTION_DOWN:
      case android.view.MotionEvent.ACTION_POINTER_DOWN: {
        let assigned = false;
        if (this.trackedPtrId1 === INVALID_POINTER_ID && pointerID !== this.trackedPtrId2) {
          this.trackedPtrId1 = pointerID;
          assigned = true;
        } else if (this.trackedPtrId2 === INVALID_POINTER_ID && pointerID !== this.trackedPtrId1) {
          this.trackedPtrId2 = pointerID;
          assigned = true;
        }
        if (assigned && this.isTracking) {
          this.angle = 0;
          this.initalPointersAngle = this.getPointersAngle(event);
          this.executeCallback(event, GestureStateTypes.began);
        }
        break;
      }
      case android.view.MotionEvent.ACTION_MOVE:
        if (this.isTracking) {
          this.updateAngle(event);
          this.executeCallback(event, GestureStateTypes.changed);
        }
        break;
      case android.view.MotionEvent.ACTION_UP:
      case android.view.MotionEvent.ACTION_POINTER_UP:
        if (pointerID === this.trackedPtrId1) {
          this.trackedPtrId1 = INVALID_POINTER_ID;
        } else if (pointerID === this.trackedPtrId2) {
          this.trackedPtrId2 = INVALID_POINTER_ID;
        }
        if (wasTracking && !this.isTracking) {
          this.executeCallback(event, GestureStateTypes.ended);
        }
        break;
      case android.view.MotionEvent.ACTION_CANCEL:
        this.trackedPtrId1 = INVALID_POINTER_ID;
        this.trackedPtrId2 = INVALID_POINTER_ID;
        if (wasTracking) {
          this.executeCallback(event, GestureStateTypes.cancelled);
        }
        break;
    }
    return true;
  }
  executeCallback(event, state) {
    const args = {
      type: GestureTypes.rotation,
      view: this.target,
      android: event,
      rotation: this.angle,
      ios: undefined,
      object: this.target,
      eventName: toString2(GestureTypes.rotation),
      state
    };
    _executeCallback(this.observer, args);
  }
  updateAngle(event) {
    const newPointersAngle = this.getPointersAngle(event);
    let result = (newPointersAngle - this.initalPointersAngle) * TO_DEGREES % 360;
    if (result < -180) {
      result += 360;
    }
    if (result > 180) {
      result -= 360;
    }
    this.angle = result;
  }
  getPointersAngle(event) {
    const firstX = event.getX(event.findPointerIndex(this.trackedPtrId1));
    const firstY = event.getY(event.findPointerIndex(this.trackedPtrId1));
    const secondX = event.getX(event.findPointerIndex(this.trackedPtrId2));
    const secondY = event.getY(event.findPointerIndex(this.trackedPtrId2));
    return Math.atan2(secondY - firstY, secondX - firstX);
  }
}

class Pointer {
  constructor(id, event) {
    this.event = event;
    this.ios = undefined;
    this.android = id;
  }
  getX() {
    return this.event.getX(this.android) / layout.getDisplayDensity();
  }
  getY() {
    return this.event.getY(this.android) / layout.getDisplayDensity();
  }
}

class TouchGestureEventData {
  constructor() {
    this.eventName = toString2(GestureTypes.touch);
    this.type = GestureTypes.touch;
    this.ios = undefined;
  }
  prepare(view, e3) {
    this.view = view;
    this.object = view;
    this.android = e3;
    this.action = this.getActionType(e3);
    this._activePointers = undefined;
    this._allPointers = undefined;
  }
  getPointerCount() {
    return this.android.getPointerCount();
  }
  getActivePointers() {
    if (!this._activePointers) {
      this._activePointers = [new Pointer(this.android.getActionIndex(), this.android)];
    }
    return this._activePointers;
  }
  getAllPointers() {
    if (!this._allPointers) {
      this._allPointers = [];
      for (let i4 = 0;i4 < this.getPointerCount(); i4++) {
        this._allPointers.push(new Pointer(i4, this.android));
      }
    }
    return this._allPointers;
  }
  getX() {
    return this.getActivePointers()[0].getX();
  }
  getY() {
    return this.getActivePointers()[0].getY();
  }
  getActionType(e3) {
    switch (e3.getActionMasked()) {
      case android.view.MotionEvent.ACTION_DOWN:
      case android.view.MotionEvent.ACTION_POINTER_DOWN:
        return TouchAction.down;
      case android.view.MotionEvent.ACTION_MOVE:
        return TouchAction.move;
      case android.view.MotionEvent.ACTION_UP:
      case android.view.MotionEvent.ACTION_POINTER_UP:
        return TouchAction.up;
      case android.view.MotionEvent.ACTION_CANCEL:
        return TouchAction.cancel;
    }
    return "";
  }
}

// node_modules/@nativescript/core/accessibility/accessibility-properties.js
function makePropertyEnumConverter(enumValues) {
  return (value) => {
    if (!value || typeof value !== "string") {
      return null;
    }
    for (const [enumKey, enumValue] of Object.entries(enumValues)) {
      if (typeof enumKey !== "string") {
        continue;
      }
      if (enumKey === value || `${enumValue}`.toLowerCase() === `${value}`.toLowerCase()) {
        return enumValue;
      }
    }
    return null;
  };
}
var accessibilityEnabledProperty = new CssProperty({
  name: "accessible",
  cssName: "a11y-enabled",
  valueConverter: booleanConverter
});
accessibilityEnabledProperty.register(Style);
var iosAccessibilityAdjustsFontSizeProperty = new InheritedCssProperty({
  defaultValue: false,
  name: "iosAccessibilityAdjustsFontSize",
  cssName: "ios-a11y-adjusts-font-size",
  valueConverter: booleanConverter
});
iosAccessibilityAdjustsFontSizeProperty.register(Style);
var iosAccessibilityMinFontScaleProperty = new InheritedCssProperty({
  defaultValue: 0,
  name: "iosAccessibilityMinFontScale",
  cssName: "ios-a11y-min-font-scale",
  valueConverter: parseFloat
});
iosAccessibilityMinFontScaleProperty.register(Style);
var iosAccessibilityMaxFontScaleProperty = new InheritedCssProperty({
  defaultValue: 0,
  name: "iosAccessibilityMaxFontScale",
  cssName: "ios-a11y-max-font-scale",
  valueConverter: parseFloat
});
iosAccessibilityMaxFontScaleProperty.register(Style);
var accessibilityHiddenProperty = new (__APPLE__ ? InheritedCssProperty : CssProperty)({
  name: "accessibilityHidden",
  cssName: "a11y-hidden",
  valueConverter: booleanConverter
});
accessibilityHiddenProperty.register(Style);
var accessibilityIdentifierProperty = new Property({
  name: "accessibilityIdentifier"
});
var accessibilityRoleProperty = new CssProperty({
  name: "accessibilityRole",
  cssName: "a11y-role",
  valueConverter: makePropertyEnumConverter(AccessibilityRole)
});
accessibilityRoleProperty.register(Style);
var accessibilityStateProperty = new CssProperty({
  name: "accessibilityState",
  cssName: "a11y-state",
  valueConverter: makePropertyEnumConverter(AccessibilityState)
});
accessibilityStateProperty.register(Style);
var accessibilityLabelProperty = new Property({
  name: "accessibilityLabel"
});
var accessibilityValueProperty = new Property({
  name: "accessibilityValue"
});
var accessibilityHintProperty = new Property({
  name: "accessibilityHint"
});
var accessibilityIgnoresInvertColorsProperty = new Property({
  name: "accessibilityIgnoresInvertColors",
  valueConverter: booleanConverter
});
var accessibilityLiveRegionProperty = new CssProperty({
  name: "accessibilityLiveRegion",
  cssName: "a11y-live-region",
  defaultValue: AccessibilityLiveRegion.None,
  valueConverter: makePropertyEnumConverter(AccessibilityLiveRegion)
});
accessibilityLiveRegionProperty.register(Style);
var accessibilityTraitsProperty = new Property({
  name: "accessibilityTraits"
});
var accessibilityLanguageProperty = new CssProperty({
  name: "accessibilityLanguage",
  cssName: "a11y-lang"
});
accessibilityLanguageProperty.register(Style);
var accessibilityMediaSessionProperty = new CssProperty({
  name: "accessibilityMediaSession",
  cssName: "a11y-media-session"
});
accessibilityMediaSessionProperty.register(Style);
var accessibilityStepProperty = new CssProperty({
  name: "accessibilityStep",
  cssName: "a11y-step",
  defaultValue: 10,
  valueConverter: (v) => {
    const step = parseFloat(v);
    if (isNaN(step) || step <= 0) {
      return 10;
    }
    return step;
  }
});
accessibilityStepProperty.register(Style);

// node_modules/@nativescript/core/ui/transition/shared-transition.js
var SharedTransitionAnimationType;
(function(SharedTransitionAnimationType2) {
  SharedTransitionAnimationType2[SharedTransitionAnimationType2["present"] = 0] = "present";
  SharedTransitionAnimationType2[SharedTransitionAnimationType2["dismiss"] = 1] = "dismiss";
})(SharedTransitionAnimationType || (SharedTransitionAnimationType = {}));

class SharedTransitionObservable extends Observable {
  on(eventNames, callback, thisArg) {
    super.on(eventNames, callback, thisArg);
  }
}
var sharedTransitionEvents;
var currentStack;

class SharedTransition {
  static custom(transition, options) {
    SharedTransition.updateState(transition.id, {
      ...options || {},
      instance: transition,
      activeType: SharedTransitionAnimationType.present
    });
    const pageEnd = options?.pageEnd;
    if (isNumber(pageEnd?.duration)) {
      transition.setDuration(__APPLE__ ? pageEnd?.duration / 1000 : pageEnd?.duration);
    }
    return { instance: transition };
  }
  static events() {
    if (!sharedTransitionEvents) {
      sharedTransitionEvents = new SharedTransitionObservable;
    }
    return sharedTransitionEvents;
  }
  static notifyEvent(eventName, data2) {
    switch (eventName) {
      case SharedTransition.startedEvent:
      case SharedTransition.interactiveUpdateEvent:
        SharedTransition.inProgress = true;
        break;
      default:
        SharedTransition.inProgress = false;
        break;
    }
    SharedTransition.events().notify({
      eventName,
      data: data2
    });
  }
  static updateState(id, state) {
    if (!currentStack) {
      currentStack = [];
    }
    const existingTransition = SharedTransition.getState(id);
    if (existingTransition) {
      for (const key in state) {
        existingTransition[key] = state[key];
      }
    } else {
      currentStack.push(state);
    }
  }
  static getState(id) {
    return currentStack?.find((t3) => t3.instance?.id === id);
  }
  static finishState(id) {
    const index = currentStack?.findIndex((t3) => t3.instance?.id === id);
    if (index > -1) {
      currentStack.splice(index, 1);
    }
  }
  static getSharedElements(fromPage, toPage) {
    const presentedSharedElements = querySelectorAll(toPage, "sharedTransitionTag").filter((v) => !v.sharedTransitionIgnore && typeof v.sharedTransitionTag === "string");
    const presentingSharedElements = querySelectorAll(fromPage, "sharedTransitionTag").filter((v) => !v.sharedTransitionIgnore && typeof v.sharedTransitionTag === "string");
    const presentedTags = presentedSharedElements.map((v) => v.sharedTransitionTag);
    return {
      sharedElements: presentingSharedElements.filter((v) => presentedTags.includes(v.sharedTransitionTag)),
      presented: presentedSharedElements,
      presenting: presentingSharedElements
    };
  }
}
SharedTransition.startedEvent = "SharedTransitionStartedEvent";
SharedTransition.finishedEvent = "SharedTransitionFinishedEvent";
SharedTransition.interactiveCancelledEvent = "SharedTransitionInteractiveCancelledEvent";
SharedTransition.interactiveUpdateEvent = "SharedTransitionInteractiveUpdateEvent";
SharedTransition.DEBUG = false;

// node_modules/@nativescript/core/ui/core/view/view-common.js
function CSSType(type) {
  return (cls) => {
    cls.prototype.cssType = type;
  };
}
function viewMatchesModuleContext(view, context, types5) {
  return context && view._moduleName && context.type && types5.some((type) => type === context.type) && context.path && context.path.includes(view._moduleName);
}
function PseudoClassHandler(...pseudoClasses) {
  const stateEventNames = pseudoClasses.map((s3) => ":" + s3);
  return (target, propertyKey, descriptor) => {
    const subscribeKey = Symbol(propertyKey + "_flag");
    function onSubscribe(subscribe) {
      if (subscribe != !!this[subscribeKey]) {
        this[subscribeKey] = subscribe;
        this[propertyKey](subscribe);
      }
    }
    for (const eventName of stateEventNames) {
      target[eventName] = onSubscribe;
    }
  };
}
var _rootModalViews = new Array;
var warnedEvent = new Set;

class ViewCommon extends ViewBase {
  constructor() {
    super(...arguments);
    this._gestureObservers = {};
  }
  get css() {
    const scope = this._styleScope;
    return scope && scope.css;
  }
  set css(value) {
    this._updateStyleScope(undefined, undefined, value);
  }
  addCss(cssString) {
    this._updateStyleScope(undefined, cssString);
  }
  addCssFile(cssFileName) {
    this._updateStyleScope(cssFileName);
  }
  changeCssFile(cssFileName) {
    const scope = this._styleScope;
    if (scope && cssFileName) {
      scope.changeCssFile(cssFileName);
      this._onCssStateChange();
    }
  }
  _updateStyleScope(cssFileName, cssString, css) {
    let scope = this._styleScope;
    if (!scope) {
      scope = new StyleScope;
      this.setScopeProperty(scope, cssFileName, cssString, css);
      this._inheritStyleScope(scope);
      this._isStyleScopeHost = true;
    } else {
      this.setScopeProperty(scope, cssFileName, cssString, css);
      this._onCssStateChange();
    }
  }
  setScopeProperty(scope, cssFileName, cssString, css) {
    if (cssFileName !== undefined) {
      scope.addCssFile(cssFileName);
    } else if (cssString !== undefined) {
      scope.addCss(cssString);
    } else if (css !== undefined) {
      scope.css = css;
    }
  }
  onLoaded() {
    if (!this.isLoaded) {
      const hasTap = this.hasListeners("tap") || this.hasListeners("tapChange") || !!this.getGestureObservers(GestureTypes.tap);
      const enableTapAnimations = TouchManager.enableGlobalTapAnimations && hasTap;
      if (!this.ignoreTouchAnimation && (this.touchAnimation || enableTapAnimations)) {
        TouchManager.addAnimations(this);
      }
      if (__VISIONOS__) {
        const enableHoverStyle = TouchManager.enableGlobalHoverWhereTap && hasTap;
        if (!this.visionIgnoreHoverStyle && (this.visionHoverStyle || enableHoverStyle)) {
          TouchManager.addHoverStyle(this);
        }
      }
    }
    super.onLoaded();
    setupAccessibleView(this);
    if (this.statusBarStyle) {
      this.updateStatusBarStyle(this.statusBarStyle);
    }
  }
  _closeAllModalViewsInternal() {
    if (_rootModalViews && _rootModalViews.length > 0) {
      _rootModalViews.forEach((v) => {
        v.closeModal();
      });
      return true;
    }
    return false;
  }
  _getRootModalViews() {
    return _rootModalViews;
  }
  _onLivesync(context) {
    if (Trace.isEnabled()) {
      Trace.write(`${this}._onLivesync(${JSON.stringify(context)})`, Trace.categories.Livesync);
    }
    let handled = false;
    if (this._closeAllModalViewsInternal()) {
      handled = true;
    }
    if (this._handleLivesync(context)) {
      return true;
    }
    this.eachChildView((child) => {
      if (child._onLivesync(context)) {
        handled = true;
        return false;
      }
    });
    return handled;
  }
  _handleLivesync(context) {
    if (Trace.isEnabled()) {
      Trace.write(`${this}._handleLivesync(${JSON.stringify(context)})`, Trace.categories.Livesync);
    }
    if (viewMatchesModuleContext(this, context, ["style"])) {
      if (Trace.isEnabled()) {
        Trace.write(`Change Handled: Changing CSS for ${this}`, Trace.categories.Livesync);
      }
      const cssModuleName = `${sanitizeModuleName(context.path)}.css`;
      this.changeCssFile(cssModuleName);
      return true;
    }
    if (viewMatchesModuleContext(this, context, ["markup", "script"]) && this.page && this.page.frame) {
      if (Trace.isEnabled()) {
        Trace.write(`Change Handled: Changing ${context.type} for ${this} inside ${this.page}`, Trace.categories.Livesync);
      }
      return this.page.frame._handleLivesync({
        type: context.type,
        path: this.page._moduleName
      });
    }
    return false;
  }
  _setupAsRootView(context) {
    super._setupAsRootView(context);
    if (!this._styleScope) {
      this._updateStyleScope();
    }
  }
  _observe(type, callback, thisArg) {
    thisArg = thisArg || undefined;
    if (this._gestureObservers[type]?.find((observer) => observer.callback === callback && observer.context === thisArg)) {
      return;
    }
    if (!this._gestureObservers[type]) {
      this._gestureObservers[type] = [];
    }
    this._gestureObservers[type].push(observe(this, type, callback, thisArg));
  }
  getGestureObservers(type) {
    return this._gestureObservers[type];
  }
  addEventListener(eventNames, callback, thisArg, once) {
    thisArg = thisArg || undefined;
    if (typeof eventNames === "number") {
      const gestureName = toString2(eventNames);
      if (!warnedEvent.has(gestureName)) {
        console.warn(`Using a gesture type (${gestureName}) as an event name is deprecated. Please use the event name instead.`);
        warnedEvent.add(gestureName);
      }
      eventNames = gestureName;
    }
    const normalizedName = getEventOrGestureName(eventNames);
    const gestureType = fromString(normalizedName);
    if (gestureType && !this._isEvent(normalizedName)) {
      this._observe(gestureType, callback, thisArg);
      return;
    }
    super.addEventListener(normalizedName, callback, thisArg, once);
  }
  removeEventListener(eventNames, callback, thisArg) {
    thisArg = thisArg || undefined;
    if (typeof eventNames === "number") {
      const gestureName = toString2(eventNames);
      if (!warnedEvent.has(gestureName)) {
        console.warn(`Using a gesture type (${gestureName}) as an event name is deprecated. Please use the event name instead.`);
        warnedEvent.add(gestureName);
      }
      eventNames = gestureName;
    }
    const normalizedName = getEventOrGestureName(eventNames);
    const gestureType = fromString(normalizedName);
    if (gestureType && !this._isEvent(normalizedName)) {
      this._disconnectGestureObservers(gestureType, callback, thisArg);
      return;
    }
    super.removeEventListener(normalizedName, callback, thisArg);
  }
  onBackPressed() {
    return false;
  }
  _getFragmentManager() {
    return;
  }
  getModalOptions(args) {
    if (args.length === 0) {
      throw new Error("showModal without parameters is deprecated. Please call showModal on a view instance instead.");
    } else {
      let options = null;
      if (args.length === 2) {
        options = args[1];
      } else {
        if (args[0] instanceof ViewCommon) {
          console.log("showModal(view: ViewBase, context: any, closeCallback: Function, fullscreen?: boolean, animated?: boolean, stretched?: boolean) " + "is deprecated. Use showModal(view: ViewBase, modalOptions: ShowModalOptions) instead.");
        } else {
          console.log("showModal(moduleName: string, context: any, closeCallback: Function, fullscreen?: boolean, animated?: boolean, stretched?: boolean) " + "is deprecated. Use showModal(moduleName: string, modalOptions: ShowModalOptions) instead.");
        }
        options = {
          context: args[1],
          closeCallback: args[2],
          fullscreen: args[3],
          animated: args[4],
          stretched: args[5]
        };
      }
      const firstArgument = args[0];
      const view = firstArgument instanceof ViewCommon ? firstArgument : Builder.createViewFromEntry({
        moduleName: firstArgument
      });
      return { view, options };
    }
  }
  showModal(...args) {
    const { view, options } = this.getModalOptions(args);
    if (options.transition?.instance) {
      SharedTransition.updateState(options.transition?.instance.id, {
        page: this,
        toPage: view
      });
    }
    view._showNativeModalView(this, options);
    return view;
  }
  closeModal(...args) {
    const closeCallback = this._closeModalCallback;
    if (closeCallback) {
      closeCallback(...args);
    } else {
      const parent = this.parent;
      if (parent) {
        parent.closeModal(...args);
      }
    }
  }
  get modal() {
    return this._modal;
  }
  _showNativeModalView(parent, options) {
    _rootModalViews.push(this);
    this.cssClasses.add(CSSUtils.MODAL_ROOT_VIEW_CSS_CLASS);
    const modalRootViewCssClasses = CSSUtils.getSystemCssClasses();
    modalRootViewCssClasses.forEach((c3) => this.cssClasses.add(c3));
    parent._modal = this;
    this.style.fontScaleInternal = getFontScale();
    this._modalParent = parent;
    this._modalContext = options.context;
    this._closeModalCallback = (...originalArgs) => {
      const cleanupModalViews = () => {
        const modalIndex = _rootModalViews.indexOf(this);
        if (modalIndex > -1) {
          _rootModalViews.splice(modalIndex, 1);
        }
        this._modalParent = null;
        this._modalContext = null;
        this._closeModalCallback = null;
        this._dialogClosed();
        parent._modal = null;
      };
      const whenClosedCallback = () => {
        const transitionState2 = SharedTransition.getState(this.transitionId);
        if (transitionState2?.interactiveBegan) {
          SharedTransition.updateState(this.transitionId, {
            interactiveBegan: false
          });
          if (!transitionState2?.interactiveCancelled) {
            cleanupModalViews();
          }
        }
        if (!transitionState2?.interactiveCancelled) {
          if (typeof options.closeCallback === "function") {
            options.closeCallback.apply(undefined, originalArgs);
          }
          this._tearDownUI(true);
        }
      };
      const transitionState = SharedTransition.getState(this.transitionId);
      if (!transitionState?.interactiveBegan) {
        cleanupModalViews();
      }
      this._hideNativeModalView(parent, whenClosedCallback);
    };
  }
  _hideNativeModalView(parent, whenClosedCallback) {}
  _raiseLayoutChangedEvent() {
    const args = {
      eventName: ViewCommon.layoutChangedEvent,
      object: this
    };
    this.notify(args);
  }
  _raiseShownModallyEvent() {
    const args = {
      eventName: ViewCommon.shownModallyEvent,
      object: this,
      context: this._modalContext,
      closeCallback: this._closeModalCallback
    };
    this.notify(args);
  }
  _raiseShowingModallyEvent() {
    const args = {
      eventName: ViewCommon.showingModallyEvent,
      object: this,
      context: this._modalContext,
      closeCallback: this._closeModalCallback
    };
    this.notify(args);
  }
  _isEvent(name50) {
    return this.constructor && `${name50}Event` in this.constructor;
  }
  _disconnectGestureObservers(type, callback, thisArg) {
    const observers = this.getGestureObservers(type);
    if (!observers) {
      return;
    }
    for (let i4 = 0;i4 < observers.length; i4++) {
      const observer = observers[i4];
      if (thisArg && (observer.callback !== callback || observer.context !== thisArg)) {
        continue;
      }
      if (callback && observer.callback !== callback) {
        continue;
      }
      observer.disconnect();
      observers.splice(i4, 1);
      i4--;
    }
    if (!observers.length) {
      delete this._gestureObservers[type];
    }
  }
  get flexFlow() {
    return this.style.flexFlow;
  }
  set flexFlow(value) {
    this.style.flexFlow = value;
  }
  get flex() {
    return this.style.flex;
  }
  set flex(value) {
    this.style.flex = value;
  }
  get borderColor() {
    return this.style.borderColor;
  }
  set borderColor(value) {
    this.style.borderColor = value;
  }
  get borderTopColor() {
    return this.style.borderTopColor;
  }
  set borderTopColor(value) {
    this.style.borderTopColor = value;
  }
  get borderRightColor() {
    return this.style.borderRightColor;
  }
  set borderRightColor(value) {
    this.style.borderRightColor = value;
  }
  get borderBottomColor() {
    return this.style.borderBottomColor;
  }
  set borderBottomColor(value) {
    this.style.borderBottomColor = value;
  }
  get borderLeftColor() {
    return this.style.borderLeftColor;
  }
  set borderLeftColor(value) {
    this.style.borderLeftColor = value;
  }
  get borderWidth() {
    return this.style.borderWidth;
  }
  set borderWidth(value) {
    this.style.borderWidth = value;
  }
  get borderTopWidth() {
    return this.style.borderTopWidth;
  }
  set borderTopWidth(value) {
    this.style.borderTopWidth = value;
  }
  get borderRightWidth() {
    return this.style.borderRightWidth;
  }
  set borderRightWidth(value) {
    this.style.borderRightWidth = value;
  }
  get borderBottomWidth() {
    return this.style.borderBottomWidth;
  }
  set borderBottomWidth(value) {
    this.style.borderBottomWidth = value;
  }
  get borderLeftWidth() {
    return this.style.borderLeftWidth;
  }
  set borderLeftWidth(value) {
    this.style.borderLeftWidth = value;
  }
  get borderRadius() {
    return this.style.borderRadius;
  }
  set borderRadius(value) {
    this.style.borderRadius = value;
  }
  get borderTopLeftRadius() {
    return this.style.borderTopLeftRadius;
  }
  set borderTopLeftRadius(value) {
    this.style.borderTopLeftRadius = value;
  }
  get borderTopRightRadius() {
    return this.style.borderTopRightRadius;
  }
  set borderTopRightRadius(value) {
    this.style.borderTopRightRadius = value;
  }
  get borderBottomRightRadius() {
    return this.style.borderBottomRightRadius;
  }
  set borderBottomRightRadius(value) {
    this.style.borderBottomRightRadius = value;
  }
  get borderBottomLeftRadius() {
    return this.style.borderBottomLeftRadius;
  }
  set borderBottomLeftRadius(value) {
    this.style.borderBottomLeftRadius = value;
  }
  get color() {
    return this.style.color;
  }
  set color(value) {
    this.style.color = value;
  }
  get background() {
    return this.style.background;
  }
  set background(value) {
    this.style.background = value;
  }
  get backgroundColor() {
    return this.style.backgroundColor;
  }
  set backgroundColor(value) {
    this.style.backgroundColor = value;
  }
  get backgroundImage() {
    return this.style.backgroundImage;
  }
  set backgroundImage(value) {
    this.style.backgroundImage = value;
  }
  get backgroundSize() {
    return this.style.backgroundSize;
  }
  set backgroundSize(value) {
    this.style.backgroundSize = value;
  }
  get backgroundPosition() {
    return this.style.backgroundPosition;
  }
  set backgroundPosition(value) {
    this.style.backgroundPosition = value;
  }
  get backgroundRepeat() {
    return this.style.backgroundRepeat;
  }
  set backgroundRepeat(value) {
    this.style.backgroundRepeat = value;
  }
  get boxShadow() {
    return this.style.boxShadow;
  }
  set boxShadow(value) {
    this.style.boxShadow = value;
  }
  get direction() {
    return this.style.direction;
  }
  set direction(value) {
    this.style.direction = value;
  }
  get minWidth() {
    return this.style.minWidth;
  }
  set minWidth(value) {
    this.style.minWidth = value;
  }
  get minHeight() {
    return this.style.minHeight;
  }
  set minHeight(value) {
    this.style.minHeight = value;
  }
  get width() {
    return this.style.width;
  }
  set width(value) {
    this.style.width = value;
  }
  get height() {
    return this.style.height;
  }
  set height(value) {
    this.style.height = value;
  }
  get margin() {
    return this.style.margin;
  }
  set margin(value) {
    this.style.margin = value;
  }
  get marginLeft() {
    return this.style.marginLeft;
  }
  set marginLeft(value) {
    this.style.marginLeft = value;
  }
  get marginTop() {
    return this.style.marginTop;
  }
  set marginTop(value) {
    this.style.marginTop = value;
  }
  get marginRight() {
    return this.style.marginRight;
  }
  set marginRight(value) {
    this.style.marginRight = value;
  }
  get marginBottom() {
    return this.style.marginBottom;
  }
  set marginBottom(value) {
    this.style.marginBottom = value;
  }
  get horizontalAlignment() {
    return this.style.horizontalAlignment;
  }
  set horizontalAlignment(value) {
    this.style.horizontalAlignment = value;
  }
  get verticalAlignment() {
    return this.style.verticalAlignment;
  }
  set verticalAlignment(value) {
    this.style.verticalAlignment = value;
  }
  get visibility() {
    return this.style.visibility;
  }
  set visibility(value) {
    this.style.visibility = value;
  }
  get opacity() {
    return this.style.opacity;
  }
  set opacity(value) {
    this.style.opacity = value;
  }
  get rotate() {
    return this.style.rotate;
  }
  set rotate(value) {
    this.style.rotate = value;
  }
  get rotateX() {
    return this.style.rotateX;
  }
  set rotateX(value) {
    this.style.rotateX = value;
  }
  get rotateY() {
    return this.style.rotateY;
  }
  set rotateY(value) {
    this.style.rotateY = value;
  }
  get perspective() {
    return this.style.perspective;
  }
  set perspective(value) {
    this.style.perspective = value;
  }
  get textTransform() {
    return this.style.textTransform;
  }
  set textTransform(value) {
    this.style.textTransform = value;
  }
  get translateX() {
    return this.style.translateX;
  }
  set translateX(value) {
    this.style.translateX = value;
  }
  get translateY() {
    return this.style.translateY;
  }
  set translateY(value) {
    this.style.translateY = value;
  }
  get scaleX() {
    return this.style.scaleX;
  }
  set scaleX(value) {
    this.style.scaleX = value;
  }
  get scaleY() {
    return this.style.scaleY;
  }
  set scaleY(value) {
    this.style.scaleY = value;
  }
  get accessible() {
    return this.style.accessible;
  }
  set accessible(value) {
    this.style.accessible = value;
  }
  get accessibilityHidden() {
    return this.style.accessibilityHidden;
  }
  set accessibilityHidden(value) {
    this.style.accessibilityHidden = value;
  }
  get accessibilityRole() {
    return this.style.accessibilityRole;
  }
  set accessibilityRole(value) {
    this.style.accessibilityRole = value;
  }
  get accessibilityState() {
    return this.style.accessibilityState;
  }
  set accessibilityState(value) {
    this.style.accessibilityState = value;
  }
  get accessibilityLiveRegion() {
    return this.style.accessibilityLiveRegion;
  }
  set accessibilityLiveRegion(value) {
    this.style.accessibilityLiveRegion = value;
  }
  get accessibilityLanguage() {
    return this.style.accessibilityLanguage;
  }
  set accessibilityLanguage(value) {
    this.style.accessibilityLanguage = value;
  }
  get accessibilityMediaSession() {
    return this.style.accessibilityMediaSession;
  }
  set accessibilityMediaSession(value) {
    this.style.accessibilityMediaSession = value;
  }
  get iosAccessibilityAdjustsFontSize() {
    return this.style.iosAccessibilityAdjustsFontSize;
  }
  set iosAccessibilityAdjustsFontSize(value) {
    this.style.iosAccessibilityAdjustsFontSize = value;
  }
  get iosAccessibilityMinFontScale() {
    return this.style.iosAccessibilityMinFontScale;
  }
  set iosAccessibilityMinFontScale(value) {
    this.style.iosAccessibilityMinFontScale = value;
  }
  get iosAccessibilityMaxFontScale() {
    return this.style.iosAccessibilityMaxFontScale;
  }
  set iosAccessibilityMaxFontScale(value) {
    this.style.iosAccessibilityMaxFontScale = value;
  }
  get automationText() {
    return this.accessibilityIdentifier;
  }
  set automationText(value) {
    this.accessibilityIdentifier = value;
  }
  get androidElevation() {
    return this.style.androidElevation;
  }
  set androidElevation(value) {
    this.style.androidElevation = value;
  }
  get androidDynamicElevationOffset() {
    return this.style.androidDynamicElevationOffset;
  }
  set androidDynamicElevationOffset(value) {
    this.style.androidDynamicElevationOffset = value;
  }
  getClosestWindow() {
    return null;
  }
  get isLayoutValid() {
    return this._isLayoutValid;
  }
  get cssType() {
    if (!this._cssType) {
      this._cssType = this.typeName.toLowerCase();
    }
    return this._cssType;
  }
  set cssType(type) {
    this._cssType = type.toLowerCase();
  }
  get statusBarStyle() {
    return this.style.statusBarStyle;
  }
  set statusBarStyle(value) {
    this.style.statusBarStyle = value;
  }
  updateStatusBarStyle(value) {}
  get isLayoutRequired() {
    return true;
  }
  get needsNativeDrawableFill() {
    return false;
  }
  measure(widthMeasureSpec, heightMeasureSpec) {
    this._setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec);
  }
  layout(left, top, right, bottom) {
    this._setCurrentLayoutBounds(left, top, right, bottom);
  }
  getMeasuredWidth() {
    return this._measuredWidth & layout.MEASURED_SIZE_MASK || 0;
  }
  getMeasuredHeight() {
    return this._measuredHeight & layout.MEASURED_SIZE_MASK || 0;
  }
  getMeasuredState() {
    return this._measuredWidth & layout.MEASURED_STATE_MASK | this._measuredHeight >> layout.MEASURED_HEIGHT_STATE_SHIFT & layout.MEASURED_STATE_MASK >> layout.MEASURED_HEIGHT_STATE_SHIFT;
  }
  setMeasuredDimension(measuredWidth, measuredHeight) {
    this._measuredWidth = measuredWidth;
    this._measuredHeight = measuredHeight;
    if (Trace.isEnabled()) {
      Trace.write(this + " :setMeasuredDimension: " + measuredWidth + ", " + measuredHeight, Trace.categories.Layout);
    }
  }
  requestLayout() {
    this._isLayoutValid = false;
    super.requestLayout();
  }
  static resolveSizeAndState(size, specSize, specMode, childMeasuredState) {
    return ViewHelper.resolveSizeAndState(size, specSize, specMode, childMeasuredState);
  }
  static combineMeasuredStates(curState, newState) {
    return ViewHelper.combineMeasuredStates(curState, newState);
  }
  static layoutChild(parent, child, left, top, right, bottom, setFrame = true) {
    ViewHelper.layoutChild(parent, child, left, top, right, bottom);
  }
  static measureChild(parent, child, widthMeasureSpec, heightMeasureSpec) {
    return ViewHelper.measureChild(parent, child, widthMeasureSpec, heightMeasureSpec);
  }
  _setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec) {
    const changed = this._currentWidthMeasureSpec !== widthMeasureSpec || this._currentHeightMeasureSpec !== heightMeasureSpec;
    this._currentWidthMeasureSpec = widthMeasureSpec;
    this._currentHeightMeasureSpec = heightMeasureSpec;
    return changed;
  }
  _getCurrentLayoutBounds() {
    return { left: 0, top: 0, right: 0, bottom: 0 };
  }
  _setCurrentLayoutBounds(left, top, right, bottom) {
    this._isLayoutValid = true;
    const boundsChanged = this._oldLeft !== left || this._oldTop !== top || this._oldRight !== right || this._oldBottom !== bottom;
    const sizeChanged = this._oldRight - this._oldLeft !== right - left || this._oldBottom - this._oldTop !== bottom - top;
    this._oldLeft = left;
    this._oldTop = top;
    this._oldRight = right;
    this._oldBottom = bottom;
    return { boundsChanged, sizeChanged };
  }
  eachChild(callback) {
    this.eachChildView(callback);
  }
  eachChildView(callback) {}
  _getNativeViewsCount() {
    return this._isAddedToNativeVisualTree ? 1 : 0;
  }
  _eachLayoutView(callback) {
    return callback(this);
  }
  focus() {
    return;
  }
  getSafeAreaInsets() {
    return { left: 0, top: 0, right: 0, bottom: 0 };
  }
  getLocationInWindow() {
    return;
  }
  getLocationOnScreen() {
    return;
  }
  getLocationRelativeTo(otherView) {
    return;
  }
  getActualSize() {
    const currentBounds = this._getCurrentLayoutBounds();
    if (!currentBounds) {
      return;
    }
    return {
      width: layout.toDeviceIndependentPixels(currentBounds.right - currentBounds.left),
      height: layout.toDeviceIndependentPixels(currentBounds.bottom - currentBounds.top)
    };
  }
  animate(animation) {
    const animationInstance = this.createAnimation(animation);
    const promise = animationInstance.play();
    promise.cancel = () => animationInstance.cancel();
    return promise;
  }
  createAnimation(animation) {
    if (!this._localAnimations) {
      this._localAnimations = new Set;
    }
    animation.target = this;
    const anim = new Animation([animation]);
    this._localAnimations.add(anim);
    return anim;
  }
  _removeAnimation(animation) {
    const localAnimations = this._localAnimations;
    if (localAnimations && localAnimations.has(animation)) {
      localAnimations.delete(animation);
      if (animation.isPlaying) {
        animation.cancel();
      }
      return true;
    }
    return false;
  }
  resetNativeView() {
    if (this._localAnimations) {
      this._localAnimations.forEach((a3) => this._removeAnimation(a3));
    }
    super.resetNativeView();
  }
  _modifyNativeViewFrame(nativeView, frame) {}
  _setNativeViewFrame(nativeView, frame) {}
  _getValue() {
    throw new Error("The View._getValue is obsolete. There is a new property system.");
  }
  _setValue() {
    throw new Error("The View._setValue is obsolete. There is a new property system.");
  }
  _updateEffectiveLayoutValues(parentWidthMeasureSize, parentWidthMeasureMode, parentHeightMeasureSize, parentHeightMeasureMode) {
    const style = this.style;
    const availableWidth = parentWidthMeasureMode === layout.UNSPECIFIED ? -1 : parentWidthMeasureSize;
    this.effectiveWidth = PercentLength.toDevicePixels(style.width, -2, availableWidth);
    this.effectiveMarginLeft = PercentLength.toDevicePixels(style.marginLeft, 0, availableWidth);
    this.effectiveMarginRight = PercentLength.toDevicePixels(style.marginRight, 0, availableWidth);
    const availableHeight = parentHeightMeasureMode === layout.UNSPECIFIED ? -1 : parentHeightMeasureSize;
    this.effectiveHeight = PercentLength.toDevicePixels(style.height, -2, availableHeight);
    this.effectiveMarginTop = PercentLength.toDevicePixels(style.marginTop, 0, availableHeight);
    this.effectiveMarginBottom = PercentLength.toDevicePixels(style.marginBottom, 0, availableHeight);
  }
  _setNativeClipToBounds() {}
  _redrawNativeBackground(value) {}
  _applyBackground(background, isBorderDrawable, onlyColor, backgroundDrawable) {}
  _onAttachedToWindow() {}
  _onDetachedFromWindow() {}
  _hasAncestorView(ancestorView) {
    const matcher = (view) => view === ancestorView;
    for (let parent = this.parent;parent != null; parent = parent.parent) {
      if (matcher(parent)) {
        return true;
      }
    }
    return false;
  }
  _applyGlassEffect(value, options) {
    return;
  }
  sendAccessibilityEvent(options) {
    return;
  }
  accessibilityAnnouncement(msg) {
    return;
  }
  accessibilityScreenChanged() {
    return;
  }
  setAccessibilityIdentifier(view, value) {
    return;
  }
}
ViewCommon.layoutChangedEvent = "layoutChanged";
ViewCommon.shownModallyEvent = "shownModally";
ViewCommon.showingModallyEvent = "showingModally";
ViewCommon.accessibilityBlurEvent = accessibilityBlurEvent;
ViewCommon.accessibilityFocusEvent = accessibilityFocusEvent;
ViewCommon.accessibilityFocusChangedEvent = accessibilityFocusChangedEvent;
ViewCommon.accessibilityPerformEscapeEvent = accessibilityPerformEscapeEvent;
ViewCommon.androidOverflowInsetEvent = "androidOverflowInset";
var originXProperty = new Property({
  name: "originX",
  defaultValue: 0.5,
  valueConverter: (v) => parseFloat(v)
});
originXProperty.register(ViewCommon);
var originYProperty = new Property({
  name: "originY",
  defaultValue: 0.5,
  valueConverter: (v) => parseFloat(v)
});
originYProperty.register(ViewCommon);
var isEnabledProperty = new Property({
  name: "isEnabled",
  defaultValue: true,
  valueConverter: booleanConverter,
  valueChanged(target, oldValue, newValue) {
    const state = "disabled";
    if (newValue) {
      target._removeVisualState(state);
    } else {
      target._addVisualState(state);
    }
  }
});
isEnabledProperty.register(ViewCommon);
var isUserInteractionEnabledProperty = new Property({
  name: "isUserInteractionEnabled",
  defaultValue: true,
  valueConverter: booleanConverter
});
isUserInteractionEnabledProperty.register(ViewCommon);
var statusBarStyleProperty = new CssProperty({
  name: "statusBarStyle",
  cssName: "status-bar-style"
});
statusBarStyleProperty.register(Style);
var iosOverflowSafeAreaProperty = new Property({
  name: "iosOverflowSafeArea",
  defaultValue: false,
  valueConverter: booleanConverter
});
iosOverflowSafeAreaProperty.register(ViewCommon);
var iosOverflowSafeAreaEnabledProperty = new InheritedProperty({
  name: "iosOverflowSafeAreaEnabled",
  defaultValue: true,
  valueConverter: booleanConverter
});
iosOverflowSafeAreaEnabledProperty.register(ViewCommon);
var iosIgnoreSafeAreaProperty = new InheritedProperty({
  name: "iosIgnoreSafeArea",
  defaultValue: false,
  valueConverter: booleanConverter
});
iosIgnoreSafeAreaProperty.register(ViewCommon);
var androidOverflowEdgeProperty = new Property({
  name: "androidOverflowEdge",
  defaultValue: "ignore"
});
androidOverflowEdgeProperty.register(ViewCommon);
var iosGlassEffectProperty = new Property({
  name: "iosGlassEffect"
});
iosGlassEffectProperty.register(ViewCommon);
var visionHoverStyleProperty = new Property({
  name: "visionHoverStyle",
  valueChanged(view, oldValue, newValue) {
    view.visionHoverStyle = newValue;
  }
});
visionHoverStyleProperty.register(ViewCommon);
var visionIgnoreHoverStyleProperty = new Property({
  name: "visionIgnoreHoverStyle",
  valueChanged(view, oldValue, newValue) {
    view.visionIgnoreHoverStyle = newValue;
  },
  valueConverter: booleanConverter
});
visionIgnoreHoverStyleProperty.register(ViewCommon);
var touchAnimationProperty = new Property({
  name: "touchAnimation",
  valueChanged(view, oldValue, newValue) {
    view.touchAnimation = newValue;
  },
  valueConverter(value) {
    if (isObject(value)) {
      return value;
    } else {
      return booleanConverter(value);
    }
  }
});
touchAnimationProperty.register(ViewCommon);
var ignoreTouchAnimationProperty = new Property({
  name: "ignoreTouchAnimation",
  valueChanged(view, oldValue, newValue) {
    view.ignoreTouchAnimation = newValue;
  },
  valueConverter: booleanConverter
});
ignoreTouchAnimationProperty.register(ViewCommon);
var touchDelayProperty = new Property({
  name: "touchDelay",
  valueChanged(view, oldValue, newValue) {
    view.touchDelay = newValue;
  },
  valueConverter: (v) => parseFloat(v)
});
touchDelayProperty.register(ViewCommon);
var testIDProperty = new Property({
  name: "testID"
});
testIDProperty.register(ViewCommon);
accessibilityIdentifierProperty.register(ViewCommon);
accessibilityLabelProperty.register(ViewCommon);
accessibilityValueProperty.register(ViewCommon);
accessibilityHintProperty.register(ViewCommon);
accessibilityIgnoresInvertColorsProperty.register(ViewCommon);

// node_modules/@nativescript/core/ui/core/view/index.android.js
var DOMID = "_domId";
var androidBackPressedEvent = "androidBackPressed";
var shortAnimTime = 17694720;
var statePressed = 16842919;
var stateEnabled = 16842910;
var styleAnimationDialog = 16973826;
var VERTICAL_GRAVITY_MASK = 112;
var HORIZONTAL_GRAVITY_MASK = 7;
var GRAVITY_LEFT = 3;
var GRAVITY_RIGHT = 5;
var GRAVITY_TOP = 48;
var GRAVITY_BOTTOM = 80;
var GRAVITY_CENTER_HORIZONTAL = 1;
var GRAVITY_FILL_HORIZONTAL = 7;
var GRAVITY_CENTER_VERTICAL = 16;
var GRAVITY_FILL_VERTICAL = 112;
var modalMap = new Map;
var TouchListener;
var DialogFragment;
var OnBackPressedCallback;
if (SDK_VERSION >= 33) {
  OnBackPressedCallback = androidx.activity.OnBackPressedCallback.extend({
    handleOnBackPressed() {
      console.log("OnBackPressedCallback handleOnBackPressed called");
      const dialog = this["_dialog"]?.get();
      if (!dialog) {
        this.setEnabled(false);
        return;
      }
      const view = dialog.fragment.owner;
      const args = {
        eventName: "activityBackPressed",
        object: view,
        activity: view._context,
        cancel: false
      };
      getNativeScriptGlobals().events.notify(args);
      if (args.cancel) {
        return;
      }
      view.notify(args);
      if (!args.cancel) {
        this.setEnabled(false);
        dialog.getOnBackPressedDispatcher().onBackPressed();
        this.setEnabled(true);
      }
    }
  });
}
function initializeTouchListener() {
  if (TouchListener) {
    return;
  }
  var TouchListenerImpl = function(_super) {
    __extends(TouchListenerImpl2, _super);
    function TouchListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = new WeakRef(owner);
      return global.__native(_this);
    }
    TouchListenerImpl2.prototype.onTouch = function(view, event) {
      var owner = this.owner.get();
      if (!owner) {
        return;
      }
      owner.handleGestureTouch(event);
      var nativeView = owner.nativeViewProtected;
      if (!nativeView || !nativeView.onTouchEvent) {
        return false;
      }
      return nativeView.onTouchEvent(event);
    };
    TouchListenerImpl2 = __decorate([
      Interfaces([android.view.View.OnTouchListener])
    ], TouchListenerImpl2);
    return TouchListenerImpl2;
  }(java.lang.Object);
  TouchListener = TouchListenerImpl;
}
function initializeDialogFragment() {
  if (DialogFragment) {
    return;
  }
  var DialogImpl = function(_super) {
    __extends(DialogImpl2, _super);
    function DialogImpl2(fragment, context, themeResId) {
      var _this = _super.call(this, context, themeResId) || this;
      _this.fragment = fragment;
      if (SDK_VERSION >= 33 && OnBackPressedCallback) {
        var callback = new OnBackPressedCallback(true);
        callback["_dialog"] = new WeakRef(_this);
        _this.getOnBackPressedDispatcher().addCallback(_this, callback);
      }
      return global.__native(_this);
    }
    DialogImpl2.prototype.onDetachedFromWindow = function() {
      _super.prototype.onDetachedFromWindow.call(this);
      this.fragment = null;
    };
    DialogImpl2.prototype.onBackPressed = function() {
      if (SDK_VERSION >= 33) {
        _super.prototype.onBackPressed.call(this);
        return;
      }
      var view = this.fragment.owner;
      var args = {
        eventName: "activityBackPressed",
        object: view,
        activity: view._context,
        cancel: false
      };
      getNativeScriptGlobals().events.notify(args);
      if (args.cancel) {
        return;
      }
      view.notify(args);
      if (!args.cancel && !view.onBackPressed()) {
        _super.prototype.onBackPressed.call(this);
      }
    };
    return DialogImpl2;
  }(androidx.appcompat.app.AppCompatDialog);
  var DialogFragmentImpl = function(_super) {
    __extends(DialogFragmentImpl2, _super);
    function DialogFragmentImpl2() {
      var _this = _super.call(this) || this;
      return global.__native(_this);
    }
    DialogFragmentImpl2.prototype.onCreate = function(savedInstanceState) {
      var _a4;
      _super.prototype.onCreate.call(this, savedInstanceState);
      var ownerId = (_a4 = this.getArguments()) === null || _a4 === undefined ? undefined : _a4.getInt(DOMID);
      var options = getModalOptions(ownerId);
      if (savedInstanceState != null && options === undefined) {
        this.dismissAllowingStateLoss();
      }
    };
    DialogFragmentImpl2.prototype.onCreateDialog = function(savedInstanceState) {
      var ownerId = this.getArguments().getInt(DOMID);
      var options = getModalOptions(ownerId);
      this.owner = options.owner;
      this.owner._dialogFragment = this;
      this._fullscreen = options.fullscreen;
      this._animated = options.animated;
      this._cancelable = options.cancelable;
      this._stretched = options.stretched;
      this._dismissCallback = options.dismissCallback;
      this._shownCallback = options.shownCallback;
      this._windowSoftInputMode = options.windowSoftInputMode;
      this.setStyle(androidx.fragment.app.DialogFragment.STYLE_NO_TITLE, 0);
      var theme = this.getTheme();
      if (this._fullscreen) {
        theme = this.getActivity().getApplicationInfo().theme;
      }
      var dialog = new DialogImpl(this, this.getActivity(), theme);
      if (!this._fullscreen && !this._stretched) {
        this.owner.horizontalAlignment = "center";
        this.owner.verticalAlignment = "middle";
      } else {
        this.owner.horizontalAlignment = "stretch";
        this.owner.verticalAlignment = "stretch";
      }
      if (this._animated) {
        dialog.getWindow().setWindowAnimations(styleAnimationDialog);
      }
      dialog.setCanceledOnTouchOutside(this._cancelable);
      return dialog;
    };
    DialogFragmentImpl2.prototype.onCreateView = function(inflater, container, savedInstanceState) {
      var owner = this.owner;
      this.activity = new WeakRef(this.getActivity());
      owner._setupAsRootView(this.getActivity());
      owner._isAddedToNativeVisualTree = true;
      var window2 = this.getDialog().getWindow();
      if (this._windowSoftInputMode !== undefined) {
        window2.setSoftInputMode(this._windowSoftInputMode);
      } else {
        window2.setSoftInputMode(owner._context.getWindow().getAttributes().softInputMode);
      }
      return owner.nativeViewProtected;
    };
    DialogFragmentImpl2.prototype.onStart = function() {
      _super.prototype.onStart.call(this);
      if (this._fullscreen) {
        var window2 = this.getDialog().getWindow();
        var length2 = android.view.ViewGroup.LayoutParams.MATCH_PARENT;
        window2.setLayout(length2, length2);
        window2.setBackgroundDrawable(new android.graphics.drawable.ColorDrawable(android.graphics.Color.WHITE));
      }
      var owner = this.owner;
      if (owner && !owner.isLoaded) {
        owner.callLoaded();
      }
      this._shownCallback();
    };
    DialogFragmentImpl2.prototype.onDismiss = function(dialog) {
      var _a4;
      _super.prototype.onDismiss.call(this, dialog);
      var manager = this.getFragmentManager();
      var activity = (_a4 = this.activity) === null || _a4 === undefined ? undefined : _a4.get();
      if (manager && !(activity === null || activity === undefined ? undefined : activity.isChangingConfigurations())) {
        removeModal(this.owner._domId);
        this._dismissCallback();
      }
      var owner = this.owner;
      if (owner && owner.isLoaded) {
        owner.callUnloaded();
      }
    };
    DialogFragmentImpl2.prototype.onDestroy = function() {
      var _a4;
      _super.prototype.onDestroy.call(this);
      var owner = this.owner;
      var activity = (_a4 = this.activity) === null || _a4 === undefined ? undefined : _a4.get();
      if (!(activity === null || activity === undefined ? undefined : activity.isChangingConfigurations())) {
        this.activity = null;
      }
      if (owner) {
        if (owner.isLoaded) {
          owner.callUnloaded();
        }
        owner._isAddedToNativeVisualTree = false;
        owner._tearDownUI(true);
      }
    };
    return DialogFragmentImpl2;
  }(androidx.fragment.app.DialogFragment);
  DialogFragment = DialogFragmentImpl;
}
function saveModal(options) {
  modalMap.set(options.owner._domId, options);
}
function removeModal(domId) {
  modalMap.delete(domId);
}
function getModalOptions(domId) {
  return modalMap.get(domId);
}
var INSET_LEFT = 0;
var INSET_TOP = 4;
var INSET_RIGHT = 8;
var INSET_BOTTOM = 12;
var INSET_LEFT_CONSUMED = 16;
var INSET_TOP_CONSUMED = 20;
var INSET_RIGHT_CONSUMED = 24;
var INSET_BOTTOM_CONSUMED = 28;
var OverflowEdgeIgnore = -1;
var OverflowEdgeNone = 0;
var OverflowEdgeLeft = 1 << 1;
var OverflowEdgeTop = 1 << 2;
var OverflowEdgeRight = 1 << 3;
var OverflowEdgeBottom = 1 << 4;
var OverflowEdgeDontApply = 1 << 5;
var OverflowEdgeLeftDontConsume = 1 << 6;
var OverflowEdgeTopDontConsume = 1 << 7;
var OverflowEdgeRightDontConsume = 1 << 8;
var OverflowEdgeBottomDontConsume = 1 << 9;
var OverflowEdgeAllButLeft = 1 << 10;
var OverflowEdgeAllButTop = 1 << 11;
var OverflowEdgeAllButRight = 1 << 12;
var OverflowEdgeAllButBottom = 1 << 13;

class Inset {
  constructor(data2) {
    this.data = ArrayBuffer.from(data2);
    this.view = new DataView(this.data);
  }
  get left() {
    return this.view.getInt32(INSET_LEFT, true);
  }
  set left(value) {
    this.view.setInt32(INSET_LEFT, value, true);
  }
  get top() {
    return this.view.getInt32(INSET_TOP, true);
  }
  set top(value) {
    this.view.setInt32(INSET_TOP, value, true);
  }
  get right() {
    return this.view.getInt32(INSET_RIGHT, true);
  }
  set right(value) {
    this.view.setInt32(INSET_RIGHT, value, true);
  }
  get bottom() {
    return this.view.getInt32(INSET_BOTTOM, true);
  }
  set bottom(value) {
    this.view.setInt32(INSET_BOTTOM, value, true);
  }
  get leftConsumed() {
    return this.view.getInt32(INSET_LEFT_CONSUMED, true) > 0;
  }
  set leftConsumed(value) {
    this.view.setInt32(INSET_LEFT_CONSUMED, value ? 1 : 0, true);
  }
  get topConsumed() {
    return this.view.getInt32(INSET_TOP_CONSUMED, true) > 0;
  }
  set topConsumed(value) {
    this.view.setInt32(INSET_TOP_CONSUMED, value ? 1 : 0, true);
  }
  get rightConsumed() {
    return this.view.getInt32(INSET_RIGHT_CONSUMED, true) > 0;
  }
  set rightConsumed(value) {
    this.view.setInt32(INSET_RIGHT_CONSUMED, value ? 1 : 0, true);
  }
  get bottomConsumed() {
    return this.view.getInt32(INSET_BOTTOM_CONSUMED, true) > 0;
  }
  set bottomConsumed(value) {
    this.view.setInt32(INSET_BOTTOM_CONSUMED, value ? 1 : 0, true);
  }
  toString() {
    return `Inset: left=${this.left}, top=${this.top}, right=${this.right}, bottom=${this.bottom}, ` + `leftConsumed=${this.leftConsumed}, topConsumed=${this.topConsumed}, ` + `rightConsumed=${this.rightConsumed}, bottomConsumed=${this.bottomConsumed}`;
  }
  toJSON() {
    return {
      left: this.left,
      top: this.top,
      right: this.right,
      bottom: this.bottom,
      leftConsumed: this.leftConsumed,
      topConsumed: this.topConsumed,
      rightConsumed: this.rightConsumed,
      bottomConsumed: this.bottomConsumed
    };
  }
}

class View extends ViewCommon {
  _observe(type, callback, thisArg) {
    super._observe(type, callback, thisArg);
    if (this.isLoaded && !this.touchListenerIsSet) {
      this.setOnTouchListener();
    }
  }
  addEventListener(eventNames, callback, thisArg, once) {
    super.addEventListener(eventNames, callback, thisArg, once);
    const isLayoutEvent = typeof eventNames === "string" ? eventNames.indexOf(ViewCommon.layoutChangedEvent) !== -1 : false;
    if (this.isLoaded && !this.layoutChangeListenerIsSet && isLayoutEvent) {
      this.setOnLayoutChangeListener();
    }
    const isInsetEvent = typeof eventNames === "string" ? eventNames.indexOf(ViewCommon.androidOverflowInsetEvent) !== -1 : false;
    if (!this.insetListenerIsSet && isInsetEvent) {
      this.setInsetListener();
    }
  }
  removeEventListener(eventNames, callback, thisArg) {
    super.removeEventListener(eventNames, callback, thisArg);
    const isLayoutEvent = typeof eventNames === "string" ? eventNames.indexOf(ViewCommon.layoutChangedEvent) !== -1 : false;
    if (this.isLoaded && this.layoutChangeListenerIsSet && isLayoutEvent && !this.needsOnLayoutChangeListener()) {
      this.nativeViewProtected.removeOnLayoutChangeListener(this.layoutChangeListener);
      this.layoutChangeListenerIsSet = false;
    }
    const isInsetEvent = typeof eventNames === "string" ? eventNames.indexOf(ViewCommon.androidOverflowInsetEvent) !== -1 : false;
    if (this.insetListenerIsSet && isInsetEvent && this.nativeViewProtected && this.nativeViewProtected.setInsetListener) {
      this.nativeViewProtected.setInsetListener(null);
      this.insetListenerIsSet = false;
    }
  }
  setInsetListener() {
    if (this.nativeViewProtected) {
      if (this.nativeViewProtected.setInsetListener) {
        const ref2 = new WeakRef(this);
        this.nativeViewProtected.setInsetListener(new org.nativescript.widgets.LayoutBase.WindowInsetListener({
          onApplyWindowInsets(param0) {
            const owner = ref2.get();
            if (!owner) {
              return;
            }
            const inset = new Inset(param0);
            const args = {
              eventName: ViewCommon.androidOverflowInsetEvent,
              object: this,
              inset
            };
            owner.notify(args);
          }
        }));
        this.insetListenerIsSet = true;
      }
      this.needsInsetListener = false;
    } else {
      this.needsInsetListener = true;
    }
  }
  _getChildFragmentManager() {
    return null;
  }
  _getRootFragmentManager() {
    if (!this._rootManager && this._context) {
      this._rootManager = this._context.getSupportFragmentManager();
    }
    return this._rootManager;
  }
  _getFragmentManager() {
    let manager = this._manager;
    if (!manager) {
      let view = this;
      let frameOrTabViewItemFound = false;
      while (view) {
        const dialogFragment = view._dialogFragment;
        if (dialogFragment) {
          manager = dialogFragment.getChildFragmentManager();
          break;
        }
        if (view._hasFragments) {
          if (frameOrTabViewItemFound) {
            manager = view._getChildFragmentManager();
            break;
          }
          frameOrTabViewItemFound = true;
        }
        view = view.parent;
      }
      if (!manager) {
        manager = this._getRootFragmentManager();
      }
      this._manager = manager;
    }
    return manager;
  }
  [androidOverflowEdgeProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    if (typeof value !== "string" || nativeView === null || nativeView == undefined) {
      return;
    }
    if (!("setOverflowEdge" in nativeView)) {
      return;
    }
    switch (value) {
      case "none":
        nativeView.setOverflowEdge(OverflowEdgeNone);
        break;
      case "ignore":
        nativeView.setOverflowEdge(OverflowEdgeIgnore);
        break;
      default:
        {
          const edge = parseEdges(value);
          if (edge != null) {
            nativeView.setOverflowEdge(edge);
          }
        }
        break;
    }
  }
  onLoaded() {
    this._manager = null;
    this._rootManager = null;
    super.onLoaded();
    this.setOnTouchListener();
  }
  onUnloaded() {
    this._manager = null;
    this._rootManager = null;
    super.onUnloaded();
  }
  onBackPressed() {
    const topmostFrame = topmost();
    if (topmostFrame && topmostFrame._hasAncestorView(this)) {
      return topmostFrame.onBackPressed();
    }
    return false;
  }
  handleGestureTouch(event) {
    const allObservers = Object.values(this._gestureObservers);
    for (const observers of allObservers) {
      const length2 = observers.length;
      if (!length2) {
        continue;
      }
      if (length2 === 1) {
        const entry = observers[0];
        if (entry) {
          entry.androidOnTouchEvent(event);
        }
      } else {
        const observersCp = observers.slice();
        for (let i4 = 0;i4 < length2; i4++) {
          const entry = observersCp[i4];
          if (entry) {
            entry.androidOnTouchEvent(event);
          }
        }
      }
    }
    if (this.parent instanceof View) {
      this.parent.handleGestureTouch(event);
    }
  }
  hasGestureObservers() {
    return this._gestureObservers && Object.keys(this._gestureObservers).length > 0;
  }
  initNativeView() {
    super.initNativeView();
    if (this.needsOnLayoutChangeListener()) {
      this.setOnLayoutChangeListener();
    }
    if (!this.insetListenerIsSet && this.needsInsetListener) {
      this.setInsetListener();
    }
  }
  needsOnLayoutChangeListener() {
    return this.hasListeners(ViewCommon.layoutChangedEvent);
  }
  disposeNativeView() {
    if (this.touchListenerIsSet) {
      this.touchListenerIsSet = false;
      if (this.nativeViewProtected) {
        this.nativeViewProtected.setOnTouchListener(null);
      }
    }
    if (this.layoutChangeListenerIsSet) {
      this.layoutChangeListenerIsSet = false;
      if (this.nativeViewProtected) {
        this.nativeViewProtected.removeOnLayoutChangeListener(this.layoutChangeListener);
        this.layoutChangeListener = null;
      }
    }
    super.disposeNativeView();
  }
  setOnTouchListener() {
    if (this.touchListenerIsSet || !this.nativeViewProtected || !this.hasGestureObservers()) {
      return;
    }
    initializeTouchListener();
    this.touchListener = this.touchListener || new TouchListener(this);
    this.nativeViewProtected.setOnTouchListener(this.touchListener);
    this.touchListenerIsSet = true;
    if (this.nativeViewProtected.setClickable) {
      this.nativeViewProtected.setClickable(this.isUserInteractionEnabled);
    }
  }
  setOnLayoutChangeListener() {
    if (this.nativeViewProtected) {
      const owner = this;
      this.layoutChangeListenerIsSet = true;
      this.layoutChangeListener = this.layoutChangeListener || new android.view.View.OnLayoutChangeListener({
        onLayoutChange(v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom) {
          if (left !== oldLeft || top !== oldTop || right !== oldRight || bottom !== oldBottom) {
            owner._raiseLayoutChangedEvent();
          }
        }
      });
      this.nativeViewProtected.addOnLayoutChangeListener(this.layoutChangeListener);
    }
  }
  get isLayoutRequired() {
    return !this.isLayoutValid;
  }
  get isLayoutValid() {
    if (this.nativeViewProtected) {
      return !this.nativeViewProtected.isLayoutRequested();
    }
    return false;
  }
  get _hasFragments() {
    return false;
  }
  layoutNativeView(left, top, right, bottom) {
    if (this.nativeViewProtected) {
      this.nativeViewProtected.layout(left, top, right, bottom);
    }
  }
  requestLayout() {
    super.requestLayout();
    if (this.nativeViewProtected) {
      this.nativeViewProtected.requestLayout();
    }
  }
  measure(widthMeasureSpec, heightMeasureSpec) {
    super.measure(widthMeasureSpec, heightMeasureSpec);
    this.onMeasure(widthMeasureSpec, heightMeasureSpec);
  }
  layout(left, top, right, bottom) {
    super.layout(left, top, right, bottom);
    this.onLayout(left, top, right, bottom);
  }
  onMeasure(widthMeasureSpec, heightMeasureSpec) {
    const view = this.nativeViewProtected;
    if (view) {
      view.measure(widthMeasureSpec, heightMeasureSpec);
      this.setMeasuredDimension(view.getMeasuredWidth(), view.getMeasuredHeight());
    }
  }
  onLayout(left, top, right, bottom) {
    const view = this.nativeViewProtected;
    if (view) {
      this.layoutNativeView(left, top, right, bottom);
    }
  }
  _getCurrentLayoutBounds() {
    if (this.nativeViewProtected && !this.isCollapsed) {
      return {
        left: this.nativeViewProtected.getLeft(),
        top: this.nativeViewProtected.getTop(),
        right: this.nativeViewProtected.getRight(),
        bottom: this.nativeViewProtected.getBottom()
      };
    } else {
      return { left: 0, top: 0, right: 0, bottom: 0 };
    }
  }
  getMeasuredWidth() {
    if (this.nativeViewProtected) {
      return this.nativeViewProtected.getMeasuredWidth();
    }
    return super.getMeasuredWidth();
  }
  getMeasuredHeight() {
    if (this.nativeViewProtected) {
      return this.nativeViewProtected.getMeasuredHeight();
    }
    return super.getMeasuredHeight();
  }
  focus() {
    if (this.nativeViewProtected) {
      return this.nativeViewProtected.requestFocus();
    }
    return false;
  }
  getLocationInWindow() {
    if (!this.nativeViewProtected || !this.nativeViewProtected.getWindowToken()) {
      return;
    }
    const nativeArray = Array.create("int", 2);
    this.nativeViewProtected.getLocationInWindow(nativeArray);
    return {
      x: layout.toDeviceIndependentPixels(nativeArray[0]),
      y: layout.toDeviceIndependentPixels(nativeArray[1])
    };
  }
  getLocationOnScreen() {
    if (!this.nativeViewProtected || !this.nativeViewProtected.getWindowToken()) {
      return;
    }
    const nativeArray = Array.create("int", 2);
    this.nativeViewProtected.getLocationOnScreen(nativeArray);
    return {
      x: layout.toDeviceIndependentPixels(nativeArray[0]),
      y: layout.toDeviceIndependentPixels(nativeArray[1])
    };
  }
  getLocationRelativeTo(otherView) {
    if (!this.nativeViewProtected || !this.nativeViewProtected.getWindowToken() || !otherView || !otherView.nativeViewProtected || !otherView.nativeViewProtected.getWindowToken() || this.nativeViewProtected.getWindowToken() !== otherView.nativeViewProtected.getWindowToken()) {
      return;
    }
    const myArray = Array.create("int", 2);
    this.nativeViewProtected.getLocationOnScreen(myArray);
    const otherArray = Array.create("int", 2);
    otherView.nativeViewProtected.getLocationOnScreen(otherArray);
    return {
      x: layout.toDeviceIndependentPixels(myArray[0] - otherArray[0]),
      y: layout.toDeviceIndependentPixels(myArray[1] - otherArray[1])
    };
  }
  static resolveSizeAndState(size, specSize, specMode, childMeasuredState) {
    let result = size;
    switch (specMode) {
      case layout.UNSPECIFIED:
        result = size;
        break;
      case layout.AT_MOST:
        if (specSize < size) {
          result = specSize | layout.MEASURED_STATE_TOO_SMALL;
        }
        break;
      case layout.EXACTLY:
        result = specSize;
        break;
    }
    return result | childMeasuredState & layout.MEASURED_STATE_MASK;
  }
  _showNativeModalView(parent, options) {
    if (isAppInBackground() && !parent.isLoaded) {
      const onLoaded = () => {
        parent.off("loaded", onLoaded);
        this._showNativeModalView(parent, options);
      };
      parent.on("loaded", onLoaded);
      return;
    }
    super._showNativeModalView(parent, options);
    initializeDialogFragment();
    const df = new DialogFragment;
    const args = new android.os.Bundle;
    args.putInt(DOMID, this._domId);
    df.setArguments(args);
    let cancelable = true;
    let windowSoftInputMode;
    if (options.android) {
      if (options.android.cancelable !== undefined) {
        cancelable = !!options.android.cancelable;
        console.log("ShowModalOptions.android.cancelable is deprecated. Use ShowModalOptions.cancelable instead.");
      }
      windowSoftInputMode = options.android.windowSoftInputMode;
    }
    cancelable = options.cancelable !== undefined ? !!options.cancelable : cancelable;
    const dialogOptions = {
      owner: this,
      fullscreen: !!options.fullscreen,
      animated: !!options.animated,
      stretched: !!options.stretched,
      cancelable,
      windowSoftInputMode,
      shownCallback: () => this._raiseShownModallyEvent(),
      dismissCallback: () => this.closeModal()
    };
    saveModal(dialogOptions);
    this._dialogFragment = df;
    this._raiseShowingModallyEvent();
    this._dialogFragment.show(parent._getRootFragmentManager(), this._domId.toString());
  }
  _hideNativeModalView(parent, whenClosedCallback) {
    if (this._dialogFragment) {
      const manager = this._dialogFragment.getFragmentManager();
      if (manager) {
        this._dialogFragment.dismissAllowingStateLoss();
      }
    }
    this._dialogFragment = null;
    whenClosedCallback();
  }
  [isEnabledProperty.setNative](value) {
    this.nativeViewProtected.setEnabled(value);
  }
  [originXProperty.getDefault]() {
    return this.nativeViewProtected.getPivotX();
  }
  [originXProperty.setNative](value) {
    org.nativescript.widgets.OriginPoint.setX(this.nativeViewProtected, value);
  }
  [originYProperty.getDefault]() {
    return this.nativeViewProtected.getPivotY();
  }
  [originYProperty.setNative](value) {
    org.nativescript.widgets.OriginPoint.setY(this.nativeViewProtected, value);
  }
  [isUserInteractionEnabledProperty.setNative](value) {
    this.nativeViewProtected.setClickable(value);
    this.nativeViewProtected.setFocusable(value);
  }
  [hiddenProperty.getDefault]() {
    return this.nativeViewProtected.getVisibility() === android.view.View.GONE;
  }
  [hiddenProperty.setNative](value) {
    this.nativeViewProtected.setVisibility(value ? android.view.View.GONE : android.view.View.VISIBLE);
  }
  [visibilityProperty.getDefault]() {
    const nativeVisibility = this.nativeViewProtected.getVisibility();
    switch (nativeVisibility) {
      case android.view.View.VISIBLE:
        return "visible";
      case android.view.View.INVISIBLE:
        return "hidden";
      case android.view.View.GONE:
        return "collapse";
      default:
        throw new Error(`Unsupported android.view.View visibility: ${nativeVisibility}. Currently supported values are android.view.View.VISIBLE, android.view.View.INVISIBLE, android.view.View.GONE.`);
    }
  }
  [visibilityProperty.setNative](value) {
    switch (value) {
      case "visible":
        this.nativeViewProtected.setVisibility(android.view.View.VISIBLE);
        break;
      case "hidden":
        this.nativeViewProtected.setVisibility(android.view.View.INVISIBLE);
        break;
      case "collapse":
        this.nativeViewProtected.setVisibility(android.view.View.GONE);
        break;
      default:
        throw new Error(`Invalid visibility value: ${value}. Valid values are: visible, hidden, collapse.`);
    }
  }
  [opacityProperty.getDefault]() {
    return this.nativeViewProtected.getAlpha();
  }
  [opacityProperty.setNative](value) {
    this.nativeViewProtected.setAlpha(float(value));
  }
  [accessibilityRoleProperty.setNative](value) {
    this.accessibilityRole = value;
    updateA11yPropertiesCallback(this);
    if (SDK_VERSION >= 28) {
      this.nativeViewProtected?.setAccessibilityHeading(value === AccessibilityRole.Header);
    }
  }
  [accessibilityLiveRegionProperty.setNative](value) {
    switch (value) {
      case AccessibilityLiveRegion.Assertive: {
        this.nativeViewProtected.setAccessibilityLiveRegion(android.view.View.ACCESSIBILITY_LIVE_REGION_ASSERTIVE);
        break;
      }
      case AccessibilityLiveRegion.Polite: {
        this.nativeViewProtected.setAccessibilityLiveRegion(android.view.View.ACCESSIBILITY_LIVE_REGION_POLITE);
        break;
      }
      default: {
        this.nativeViewProtected.setAccessibilityLiveRegion(android.view.View.ACCESSIBILITY_LIVE_REGION_NONE);
        break;
      }
    }
  }
  [accessibilityStateProperty.setNative](value) {
    this.accessibilityState = value;
    updateA11yPropertiesCallback(this);
  }
  [horizontalAlignmentProperty.getDefault]() {
    return org.nativescript.widgets.ViewHelper.getHorizontalAlignment(this.nativeViewProtected);
  }
  [horizontalAlignmentProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    const lp = nativeView.getLayoutParams() || new org.nativescript.widgets.CommonLayoutParams;
    const gravity = lp.gravity;
    const weight = lp.weight;
    if (gravity != null) {
      switch (value) {
        case "start":
          lp.gravity = (this.direction === CoreTypes.LayoutDirection.rtl ? GRAVITY_RIGHT : GRAVITY_LEFT) | gravity & VERTICAL_GRAVITY_MASK;
          if (weight < 0) {
            lp.weight = -2;
          }
          break;
        case "left":
          lp.gravity = GRAVITY_LEFT | gravity & VERTICAL_GRAVITY_MASK;
          if (weight < 0) {
            lp.weight = -2;
          }
          break;
        case "center":
          lp.gravity = GRAVITY_CENTER_HORIZONTAL | gravity & VERTICAL_GRAVITY_MASK;
          if (weight < 0) {
            lp.weight = -2;
          }
          break;
        case "right":
          lp.gravity = GRAVITY_RIGHT | gravity & VERTICAL_GRAVITY_MASK;
          if (weight < 0) {
            lp.weight = -2;
          }
          break;
        case "end":
          lp.gravity = (this.direction === CoreTypes.LayoutDirection.rtl ? GRAVITY_LEFT : GRAVITY_RIGHT) | gravity & VERTICAL_GRAVITY_MASK;
          if (weight < 0) {
            lp.weight = -2;
          }
          break;
        case "stretch":
          lp.gravity = GRAVITY_FILL_HORIZONTAL | gravity & VERTICAL_GRAVITY_MASK;
          if (weight < 0) {
            lp.weight = -1;
          }
          break;
      }
      nativeView.setLayoutParams(lp);
    }
  }
  [verticalAlignmentProperty.getDefault]() {
    return org.nativescript.widgets.ViewHelper.getVerticalAlignment(this.nativeViewProtected);
  }
  [verticalAlignmentProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    const lp = nativeView.getLayoutParams() || new org.nativescript.widgets.CommonLayoutParams;
    const gravity = lp.gravity;
    const height = lp.height;
    if (gravity !== undefined) {
      switch (value) {
        case "top":
          lp.gravity = GRAVITY_TOP | gravity & HORIZONTAL_GRAVITY_MASK;
          if (height < 0) {
            lp.height = -2;
          }
          break;
        case "middle":
          lp.gravity = GRAVITY_CENTER_VERTICAL | gravity & HORIZONTAL_GRAVITY_MASK;
          if (height < 0) {
            lp.height = -2;
          }
          break;
        case "bottom":
          lp.gravity = GRAVITY_BOTTOM | gravity & HORIZONTAL_GRAVITY_MASK;
          if (height < 0) {
            lp.height = -2;
          }
          break;
        case "stretch":
          lp.gravity = GRAVITY_FILL_VERTICAL | gravity & HORIZONTAL_GRAVITY_MASK;
          if (height < 0) {
            lp.height = -1;
          }
          break;
      }
      nativeView.setLayoutParams(lp);
    }
  }
  [statusBarStyleProperty.getDefault]() {
    return this.style.statusBarStyle;
  }
  [statusBarStyleProperty.setNative](value) {
    this.updateStatusBarStyle(value);
  }
  updateStatusBarStyle(value) {
    if (SDK_VERSION < 21)
      return;
    const window2 = this.getClosestWindow();
    window2.clearFlags(android.view.WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    window2.addFlags(android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    const decorView = window2.getDecorView();
    const controller = window2.getInsetsController?.();
    if (controller && SDK_VERSION >= 30) {
      const APPEARANCE_LIGHT_STATUS_BARS = android.view.WindowInsetsController?.APPEARANCE_LIGHT_STATUS_BARS;
      if (typeof value === "string") {
        this.style.statusBarStyle = value;
        if (value === "light") {
          controller.setSystemBarsAppearance(0, APPEARANCE_LIGHT_STATUS_BARS);
        } else {
          controller.setSystemBarsAppearance(APPEARANCE_LIGHT_STATUS_BARS, APPEARANCE_LIGHT_STATUS_BARS);
        }
      } else {
        if (value.color != null)
          window2.setStatusBarColor(value.color);
      }
      return;
    }
    if (SDK_VERSION >= 23) {
      if (typeof value === "string") {
        this.style.statusBarStyle = value;
        let flags = decorView.getSystemUiVisibility();
        if (value === "light") {
          flags |= android.view.View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
          decorView.setSystemUiVisibility(flags);
        } else {
          flags &= ~android.view.View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
          decorView.setSystemUiVisibility(flags);
        }
      } else {
        if (value.color != null)
          window2.setStatusBarColor(value.color);
        if (value.systemUiVisibility != null) {
          const merged = decorView.getSystemUiVisibility() & ~android.view.View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR | value.systemUiVisibility & android.view.View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
          decorView.setSystemUiVisibility(merged);
        }
      }
      return;
    }
    if (typeof value === "object" && value.color != null) {
      window2.setStatusBarColor(value.color);
    }
  }
  getClosestWindow() {
    const view = this.parent ?? this;
    const dialogFragment = view._dialogFragment;
    if (dialogFragment) {
      const dialog = dialogFragment.getDialog();
      if (dialog) {
        return dialog.getWindow();
      }
    }
    return this._context.getWindow();
  }
  setAccessibilityIdentifier(view, value) {
    const id = android2.resources.getId(":id/nativescript_accessibility_id");
    if (id) {
      view.setTag(id, value);
      view.setTag(value);
    }
    if (this.testID && this.testID !== value)
      this.testID = value;
    if (this.accessibilityIdentifier !== value)
      this.accessibilityIdentifier = value;
  }
  [directionProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    switch (value) {
      case CoreTypes.LayoutDirection.ltr:
        nativeView.setLayoutDirection(android.view.View.LAYOUT_DIRECTION_LTR);
        break;
      case CoreTypes.LayoutDirection.rtl:
        nativeView.setLayoutDirection(android.view.View.LAYOUT_DIRECTION_RTL);
        break;
      default:
        nativeView.setLayoutDirection(android.view.View.LAYOUT_DIRECTION_LOCALE);
        break;
    }
  }
  [testIDProperty.setNative](value) {
    this.setAccessibilityIdentifier(this.nativeViewProtected, value);
  }
  [accessibilityEnabledProperty.setNative](value) {
    this.nativeViewProtected.setFocusable(!!value);
    updateA11yPropertiesCallback(this);
  }
  [accessibilityIdentifierProperty.setNative](value) {
    this.setAccessibilityIdentifier(this.nativeViewProtected, value);
  }
  [accessibilityValueProperty.setNative](value) {
    this._androidContentDescriptionUpdated = true;
    updateContentDescription(this);
  }
  [accessibilityLabelProperty.setNative](value) {
    this._androidContentDescriptionUpdated = true;
    updateContentDescription(this);
  }
  [accessibilityHintProperty.setNative](value) {
    this._androidContentDescriptionUpdated = true;
    updateContentDescription(this);
  }
  [accessibilityHiddenProperty.setNative](value) {
    if (value) {
      this.nativeViewProtected.setImportantForAccessibility(android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS);
    } else {
      this.nativeViewProtected.setImportantForAccessibility(android.view.View.IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
  }
  [accessibilityMediaSessionProperty.setNative](value) {
    updateA11yPropertiesCallback(this);
  }
  [androidElevationProperty.getDefault]() {
    return this.getDefaultElevation();
  }
  [androidElevationProperty.setNative](value) {
    if (SDK_VERSION < 21) {
      return;
    }
    this.refreshStateListAnimator();
  }
  [androidDynamicElevationOffsetProperty.getDefault]() {
    return this.getDefaultDynamicElevationOffset();
  }
  [androidDynamicElevationOffsetProperty.setNative](value) {
    if (SDK_VERSION < 21) {
      return;
    }
    this.refreshStateListAnimator();
  }
  getDefaultElevation() {
    if (SDK_VERSION < 21) {
      return 0;
    }
    return layout.toDeviceIndependentPixels(this.nativeViewProtected.getElevation());
  }
  getDefaultDynamicElevationOffset() {
    return 0;
  }
  refreshStateListAnimator() {
    const nativeView = this.nativeViewProtected;
    const ObjectAnimator = android.animation.ObjectAnimator;
    const AnimatorSet = android.animation.AnimatorSet;
    const duration = nativeView.getContext().getResources().getInteger(shortAnimTime) / 2;
    let elevation = this.androidElevation;
    if (typeof elevation === "undefined" || elevation === null) {
      elevation = this.getDefaultElevation();
    }
    elevation = layout.toDevicePixels(elevation);
    const z2 = layout.toDevicePixels(0);
    let pressedZ = this.androidDynamicElevationOffset;
    if (typeof pressedZ === "undefined" || pressedZ === null) {
      pressedZ = this.getDefaultDynamicElevationOffset();
    }
    pressedZ = layout.toDevicePixels(pressedZ);
    const pressedSet = new AnimatorSet;
    pressedSet.playTogether(java.util.Arrays.asList([ObjectAnimator.ofFloat(nativeView, "translationZ", [pressedZ]).setDuration(duration), ObjectAnimator.ofFloat(nativeView, "elevation", [elevation]).setDuration(0)]));
    const notPressedSet = new AnimatorSet;
    notPressedSet.playTogether(java.util.Arrays.asList([ObjectAnimator.ofFloat(nativeView, "translationZ", [z2]).setDuration(duration), ObjectAnimator.ofFloat(nativeView, "elevation", [elevation]).setDuration(0)]));
    const defaultSet = new AnimatorSet;
    defaultSet.playTogether(java.util.Arrays.asList([ObjectAnimator.ofFloat(nativeView, "translationZ", [0]).setDuration(0), ObjectAnimator.ofFloat(nativeView, "elevation", [0]).setDuration(0)]));
    const stateListAnimator = new android.animation.StateListAnimator;
    stateListAnimator.addState([statePressed, stateEnabled], pressedSet);
    stateListAnimator.addState([stateEnabled], notPressedSet);
    stateListAnimator.addState([], defaultSet);
    const currentAnimator = nativeView.getStateListAnimator();
    if (currentAnimator) {
      currentAnimator.jumpToCurrentState();
    }
    nativeView.setStateListAnimator(stateListAnimator);
  }
  [rotateProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setRotate(this.nativeViewProtected, float(value));
  }
  [rotateXProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setRotateX(this.nativeViewProtected, float(value));
  }
  [rotateYProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setRotateY(this.nativeViewProtected, float(value));
  }
  [perspectiveProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPerspective(this.nativeViewProtected, float(value * Screen.mainScreen.scale));
  }
  [scaleXProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setScaleX(this.nativeViewProtected, float(value));
  }
  [scaleYProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setScaleY(this.nativeViewProtected, float(value));
  }
  [translateXProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setTranslateX(this.nativeViewProtected, layout.toDevicePixels(value));
  }
  [translateYProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setTranslateY(this.nativeViewProtected, layout.toDevicePixels(value));
  }
  [zIndexProperty.getDefault]() {
    return 0;
  }
  [zIndexProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setZIndex(this.nativeViewProtected, value);
  }
  [backgroundInternalProperty.getDefault]() {
    const nativeView = this.nativeViewProtected;
    return AndroidHelper.getCopyOrDrawable(nativeView.getBackground(), nativeView.getResources());
  }
  [backgroundInternalProperty.setNative](value) {
    this._redrawNativeBackground(value);
  }
  [minWidthProperty.setNative](value) {
    if (this.parent instanceof CustomLayoutView && this.parent.nativeViewProtected) {
      this.parent._setChildMinWidthNative(this, value);
    } else {
      this._setMinWidthNative(value);
    }
  }
  [minHeightProperty.setNative](value) {
    if (this.parent instanceof CustomLayoutView && this.parent.nativeViewProtected) {
      this.parent._setChildMinHeightNative(this, value);
    } else {
      this._setMinHeightNative(value);
    }
  }
  _applyBackground(background, isBorderDrawable, onlyColor, backgroundDrawable) {
    const nativeView = this.nativeViewProtected;
    if (onlyColor) {
      const backgroundColor = background.color.android;
      if (isBorderDrawable) {
        backgroundDrawable = nativeView._cachedDrawable != null ? AndroidHelper.getCopyOrDrawable(nativeView._cachedDrawable, nativeView.getResources()) : null;
        nativeView.setBackground(backgroundDrawable);
      }
      if (this.needsNativeDrawableFill && backgroundDrawable) {
        backgroundDrawable.mutate();
        AndroidHelper.setDrawableColor(backgroundColor, backgroundDrawable);
        backgroundDrawable.invalidateSelf();
      } else {
        nativeView.setBackgroundColor(backgroundColor);
      }
    } else {
      if (background.clearFlags & 1) {
        if (backgroundDrawable) {
          backgroundDrawable.mutate();
          AndroidHelper.clearDrawableColor(backgroundDrawable);
          backgroundDrawable.invalidateSelf();
        } else {
          nativeView.setBackgroundColor(-1);
        }
      }
      if (background.isEmpty()) {
        const defaultDrawable = nativeView._cachedDrawable ?? null;
        if (backgroundDrawable !== defaultDrawable) {
          nativeView.setBackground(defaultDrawable);
        }
      } else {
        if (isBorderDrawable) {
          refreshBorderDrawable(this, backgroundDrawable);
        } else {
          const borderDrawable = new org.nativescript.widgets.BorderDrawable(layout.getDisplayDensity(), this.toString());
          refreshBorderDrawable(this, borderDrawable);
          nativeView.setBackground(borderDrawable);
        }
      }
    }
  }
  _drawBoxShadow(boxShadows) {
    const nativeView = this.nativeViewProtected;
    const valueCount = 6;
    const nativeArray = Array.create("int", boxShadows.length * valueCount);
    for (let i4 = 0, length2 = boxShadows.length;i4 < length2; i4++) {
      const boxShadow = boxShadows[i4];
      const nativeIndex = i4 * valueCount;
      nativeArray[nativeIndex + 0] = boxShadow.color.android;
      nativeArray[nativeIndex + 1] = boxShadow.spreadRadius;
      nativeArray[nativeIndex + 2] = boxShadow.blurRadius;
      nativeArray[nativeIndex + 3] = boxShadow.offsetX;
      nativeArray[nativeIndex + 4] = boxShadow.offsetY;
      nativeArray[nativeIndex + 5] = boxShadow.inset ? 1 : 0;
    }
    org.nativescript.widgets.Utils.drawBoxShadow(nativeView, nativeArray);
  }
  _redrawNativeBackground(value) {
    if (value instanceof Background) {
      this.onBackgroundOrBorderPropertyChanged();
    } else {
      const nativeView = this.nativeViewProtected;
      nativeView.setBackground(value);
      const style = this.style;
      const paddingTop = paddingTopProperty.isSet(style) ? this.effectivePaddingTop : this._defaultPaddingTop;
      const paddingRight = paddingRightProperty.isSet(style) ? this.effectivePaddingRight : this._defaultPaddingRight;
      const paddingBottom = paddingBottomProperty.isSet(style) ? this.effectivePaddingBottom : this._defaultPaddingBottom;
      const paddingLeft = paddingLeftProperty.isSet(style) ? this.effectivePaddingLeft : this._defaultPaddingLeft;
      if (this._isPaddingRelative) {
        nativeView.setPaddingRelative(paddingLeft, paddingTop, paddingRight, paddingBottom);
      } else {
        nativeView.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);
      }
    }
  }
  onBackgroundOrBorderPropertyChanged() {
    const nativeView = this.nativeViewProtected;
    if (!nativeView) {
      return;
    }
    const background = this.style.backgroundInternal;
    const drawable = nativeView.getBackground();
    const isBorderDrawable = drawable instanceof org.nativescript.widgets.BorderDrawable;
    if (nativeView._cachedDrawable === undefined) {
      nativeView._cachedDrawable = drawable;
    }
    if (background.clearFlags & 2) {
      if (drawable instanceof org.nativescript.widgets.BoxShadowDrawable) {
        nativeView.setBackground(nativeView._cachedDrawable ?? null);
      }
    }
    const onlyColor = !background.hasBorderWidth() && !background.hasBorderRadius() && !background.hasBoxShadows() && !background.clipPath && !background.image && !!background.color;
    this._applyBackground(background, isBorderDrawable, onlyColor, drawable);
    if (background.hasBoxShadows()) {
      this._drawBoxShadow(background.getBoxShadows());
    }
    const leftPadding = Math.ceil(this.effectiveBorderLeftWidth + this.effectivePaddingLeft);
    const topPadding = Math.ceil(this.effectiveBorderTopWidth + this.effectivePaddingTop);
    const rightPadding = Math.ceil(this.effectiveBorderRightWidth + this.effectivePaddingRight);
    const bottomPadding = Math.ceil(this.effectiveBorderBottomWidth + this.effectivePaddingBottom);
    if (this._isPaddingRelative) {
      nativeView.setPaddingRelative(leftPadding, topPadding, rightPadding, bottomPadding);
    } else {
      nativeView.setPadding(leftPadding, topPadding, rightPadding, bottomPadding);
    }
    background.clearFlags = 0;
  }
  accessibilityAnnouncement(message = this.accessibilityLabel) {
    this.sendAccessibilityEvent({
      androidAccessibilityEvent: AndroidAccessibilityEvent.ANNOUNCEMENT,
      message
    });
  }
  accessibilityScreenChanged() {
    this.sendAccessibilityEvent({
      androidAccessibilityEvent: AndroidAccessibilityEvent.WINDOW_STATE_CHANGED
    });
  }
}
View.androidBackPressedEvent = androidBackPressedEvent;
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], View.prototype, "onLoaded", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], View.prototype, "onUnloaded", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], View.prototype, "requestLayout", null);
var edgeMap = {
  none: OverflowEdgeNone,
  left: OverflowEdgeLeft,
  top: OverflowEdgeTop,
  right: OverflowEdgeRight,
  bottom: OverflowEdgeBottom,
  "dont-apply": OverflowEdgeDontApply,
  "left-dont-consume": OverflowEdgeLeftDontConsume,
  "top-dont-consume": OverflowEdgeTopDontConsume,
  "right-dont-consume": OverflowEdgeRightDontConsume,
  "bottom-dont-consume": OverflowEdgeBottomDontConsume,
  "all-but-left": OverflowEdgeAllButLeft,
  "all-but-top": OverflowEdgeAllButTop,
  "all-but-right": OverflowEdgeAllButRight,
  "all-but-bottom": OverflowEdgeAllButBottom
};
function parseEdges(edges) {
  let result = 0;
  const values = edges.split(",");
  for (const raw of values) {
    const value = edgeMap[raw.trim()];
    if (value === undefined)
      continue;
    if (value === OverflowEdgeDontApply)
      return value;
    result |= value;
  }
  return result === 0 ? null : result;
}

class ContainerView extends View {
  constructor() {
    super();
    this.androidOverflowEdge = "none";
  }
}

class CustomLayoutView extends ContainerView {
  createNativeView() {
    return new org.nativescript.widgets.ContentLayout(this._context);
  }
  _addViewToNativeVisualTree(child, atIndex = Number.MAX_SAFE_INTEGER) {
    super._addViewToNativeVisualTree(child);
    if (this.nativeViewProtected && child.nativeViewProtected) {
      if (Trace.isEnabled()) {
        Trace.write(`${this}.nativeView.addView(${child}.nativeView, ${atIndex})`, Trace.categories.VisualTreeEvents);
      }
      this.nativeViewProtected.addView(child.nativeViewProtected, atIndex);
      if (child instanceof View) {
        this._updateNativeLayoutParams(child);
      }
      return true;
    }
    return false;
  }
  _updateNativeLayoutParams(child) {}
  _setChildMinWidthNative(child, value) {
    child._setMinWidthNative(value);
  }
  _setChildMinHeightNative(child, value) {
    child._setMinHeightNative(value);
  }
  _removeViewFromNativeVisualTree(child) {
    super._removeViewFromNativeVisualTree(child);
    const nativeView = this.nativeViewProtected;
    const childView = child.nativeViewProtected;
    if (nativeView && childView) {
      nativeView.removeView(childView);
      if (Trace.isEnabled()) {
        Trace.write(`${nativeView}.removeView(${childView})`, Trace.categories.VisualTreeEvents);
        Trace.notifyEvent(child, "childInLayoutRemovedFromNativeVisualTree");
      }
    }
  }
}
var percentNotSupported = (view, value) => {
  throw new Error("PercentLength is not supported.");
};
function createNativePercentLengthProperty(options) {
  const { getter, setter, auto = 0 } = options;
  let setPixels, getPixels, setPercent;
  if (getter) {
    View.prototype[getter] = function() {
      if (options) {
        setPixels = options.setPixels;
        getPixels = options.getPixels;
        setPercent = options.setPercent || percentNotSupported;
        options = null;
      }
      const value = getPixels(this.nativeViewProtected);
      if (value == auto) {
        return "auto";
      } else {
        return { value, unit: "px" };
      }
    };
  }
  if (setter) {
    View.prototype[setter] = function(length2) {
      if (options) {
        setPixels = options.setPixels;
        getPixels = options.getPixels;
        setPercent = options.setPercent || percentNotSupported;
        options = null;
      }
      if (length2 == "auto" || length2 == null || isCssWideKeyword(length2)) {
        setPixels(this.nativeViewProtected, auto);
      } else if (typeof length2 === "number") {
        setPixels(this.nativeViewProtected, layout.round(layout.toDevicePixels(length2)));
      } else if (length2.unit == "dip") {
        setPixels(this.nativeViewProtected, layout.round(layout.toDevicePixels(length2.value)));
      } else if (length2.unit == "px") {
        setPixels(this.nativeViewProtected, layout.round(length2.value));
      } else if (length2.unit == "%") {
        setPercent(this.nativeViewProtected, length2.value);
      } else {
        throw new Error(`Unsupported PercentLength ${length2}`);
      }
    };
  }
}
createNativePercentLengthProperty({
  setter: marginTopProperty.setNative,
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setMarginTop;
  },
  get setPercent() {
    return org.nativescript.widgets.ViewHelper.setMarginTopPercent;
  }
});
createNativePercentLengthProperty({
  setter: marginRightProperty.setNative,
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setMarginRight;
  },
  get setPercent() {
    return org.nativescript.widgets.ViewHelper.setMarginRightPercent;
  }
});
createNativePercentLengthProperty({
  setter: marginBottomProperty.setNative,
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setMarginBottom;
  },
  get setPercent() {
    return org.nativescript.widgets.ViewHelper.setMarginBottomPercent;
  }
});
createNativePercentLengthProperty({
  setter: marginLeftProperty.setNative,
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setMarginLeft;
  },
  get setPercent() {
    return org.nativescript.widgets.ViewHelper.setMarginLeftPercent;
  }
});
createNativePercentLengthProperty({
  setter: widthProperty.setNative,
  auto: -1,
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setWidth;
  },
  get setPercent() {
    return org.nativescript.widgets.ViewHelper.setWidthPercent;
  }
});
createNativePercentLengthProperty({
  setter: heightProperty.setNative,
  auto: -1,
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setHeight;
  },
  get setPercent() {
    return org.nativescript.widgets.ViewHelper.setHeightPercent;
  }
});
createNativePercentLengthProperty({
  setter: "_setMinWidthNative",
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setMinWidth;
  }
});
createNativePercentLengthProperty({
  setter: "_setMinHeightNative",
  get setPixels() {
    return org.nativescript.widgets.ViewHelper.setMinHeight;
  }
});

// node_modules/@nativescript/core/ui/action-bar/action-bar-common.js
var ActionBarBase = class ActionBarBase2 extends View {
  disposeNativeView() {
    this._actionItems = null;
    super.disposeNativeView();
  }
  get navigationButton() {
    return this._navigationButton;
  }
  set navigationButton(value) {
    if (this._navigationButton !== value) {
      if (this._navigationButton) {
        this._removeView(this._navigationButton);
        this._navigationButton.actionBar = undefined;
      }
      this._navigationButton = value;
      if (this._navigationButton) {
        this._navigationButton.actionBar = this;
        this._addView(this._navigationButton);
      }
      this.update();
    }
  }
  get actionItems() {
    return this._actionItems;
  }
  set actionItems(value) {
    throw new Error("actionItems property is read-only");
  }
  get titleView() {
    return this._titleView;
  }
  set titleView(value) {
    if (this._titleView !== value) {
      if (this._titleView) {
        this._removeView(this._titleView);
        this._titleView.style[horizontalAlignmentProperty.cssName] = unsetValue;
        this._titleView.style[verticalAlignmentProperty.cssName] = unsetValue;
      }
      this._titleView = value;
      if (value) {
        this._addView(value);
        const style = value.style;
        if (!horizontalAlignmentProperty.isSet(style)) {
          style[horizontalAlignmentProperty.cssName] = "center";
        }
        if (!verticalAlignmentProperty.isSet(style)) {
          style[verticalAlignmentProperty.cssName] = "middle";
        }
      }
      this.update();
    }
  }
  get androidContentInset() {
    return this.style.androidContentInset;
  }
  set androidContentInset(value) {
    this.style.androidContentInset = value;
  }
  get androidContentInsetLeft() {
    return this.style.androidContentInsetLeft;
  }
  set androidContentInsetLeft(value) {
    this.style.androidContentInsetLeft = value;
  }
  get androidContentInsetRight() {
    return this.style.androidContentInsetRight;
  }
  set androidContentInsetRight(value) {
    this.style.androidContentInsetRight = value;
  }
  get ios() {
    return;
  }
  get android() {
    return;
  }
  get _childrenCount() {
    let actionViewsCount = 0;
    this._actionItems?.getItems().forEach((actionItem) => {
      if (actionItem.actionView) {
        actionViewsCount++;
      }
    });
    return actionViewsCount + (this.titleView ? 1 : 0);
  }
  constructor() {
    super();
    this.iosLargeTitle = false;
    this.iosShadow = true;
    this._actionItems = new ActionItems(this);
  }
  update() {}
  _onTitlePropertyChanged() {}
  _addArrayFromBuilder(name50, value) {
    if (name50 === "actionItems") {
      this.actionItems?.setItems(value);
    }
  }
  eachChildView(callback) {
    const titleView = this.titleView;
    if (titleView) {
      callback(titleView);
    }
  }
  eachChild(callback) {
    const titleView = this.titleView;
    if (titleView) {
      callback(titleView);
    }
    const navigationButton = this._navigationButton;
    if (navigationButton) {
      callback(navigationButton);
    }
    this.actionItems?.getItems().forEach((actionItem) => {
      callback(actionItem);
    });
  }
  _isEmpty() {
    if (this.title || this.titleView || this.android && this.android.icon || this.navigationButton || this.actionItems?.getItems().length > 0) {
      return false;
    }
    return true;
  }
};
ActionBarBase = __decorate([
  CSSType("ActionBar"),
  __metadata("design:paramtypes", [])
], ActionBarBase);
class ActionItems {
  constructor(actionBar) {
    this._items = new Array;
    this._actionBar = actionBar;
  }
  addItem(item) {
    if (!item) {
      throw new Error("Cannot add empty item");
    }
    this._items.push(item);
    item.actionBar = this._actionBar;
    this._actionBar._addView(item);
    this.invalidate();
  }
  removeItem(item) {
    if (!item) {
      throw new Error("Cannot remove empty item");
    }
    const itemIndex = this._items.indexOf(item);
    if (itemIndex < 0) {
      throw new Error("Cannot find item to remove");
    }
    this._items.splice(itemIndex, 1);
    this._actionBar._removeView(item);
    item.actionBar = undefined;
    this.invalidate();
  }
  getItems() {
    return this._items.slice();
  }
  getVisibleItems() {
    const visibleItems = [];
    this._items.forEach((item) => {
      if (isVisible(item)) {
        visibleItems.push(item);
      }
    });
    return visibleItems;
  }
  getItemAt(index) {
    if (index < 0 || index >= this._items.length) {
      return;
    }
    return this._items[index];
  }
  setItems(items) {
    while (this._items.length > 0) {
      this.removeItem(this._items[this._items.length - 1]);
    }
    for (let i4 = 0;i4 < items.length; i4++) {
      this.addItem(items[i4]);
    }
    this.invalidate();
  }
  invalidate() {
    if (this._actionBar) {
      this._actionBar.update();
    }
  }
}

class ActionItemBase extends ViewBase {
  get actionView() {
    return this._actionView;
  }
  set actionView(value) {
    if (this._actionView !== value) {
      if (this._actionView) {
        this._actionView.style[horizontalAlignmentProperty.cssName] = unsetValue;
        this._actionView.style[verticalAlignmentProperty.cssName] = unsetValue;
        this._removeView(this._actionView);
      }
      this._actionView = value;
      if (this._actionView) {
        this._addView(this._actionView);
      }
      if (this._actionBar) {
        this._actionBar.update();
      }
    }
  }
  get actionBar() {
    return this._actionBar;
  }
  set actionBar(value) {
    if (value !== this._actionBar) {
      this._actionBar = value;
    }
  }
  onLoaded() {
    if (this._actionView) {
      this._actionView.style[horizontalAlignmentProperty.cssName] = "center";
      this._actionView.style[verticalAlignmentProperty.cssName] = "middle";
    }
    super.onLoaded();
  }
  _raiseTap() {
    this._emit(ActionItemBase.tapEvent);
  }
  _addChildFromBuilder(name50, value) {
    this.actionView = value;
  }
  _onVisibilityChanged(visibility) {
    if (this.actionBar) {
      this.actionBar.update();
    }
  }
  eachChild(callback) {
    if (this._actionView) {
      callback(this._actionView);
    }
  }
}
ActionItemBase.tapEvent = "tap";
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], ActionItemBase.prototype, "onLoaded", null);
function isVisible(item) {
  return item.visibility === "visible";
}
function onTitlePropertyChanged(actionBar, oldValue, newValue) {
  actionBar._onTitlePropertyChanged();
}
var titleProperty = new Property({
  name: "title",
  valueChanged: onTitlePropertyChanged
});
titleProperty.register(ActionBarBase);
function onItemChanged(item, oldValue, newValue) {
  if (item.actionBar) {
    item.actionBar.update();
  }
}
function onVisibilityChanged(item, oldValue, newValue) {
  item._onVisibilityChanged(newValue);
}
function traceMissingIcon(icon) {
  Trace.write("Could not load action bar icon: " + icon, Trace.categories.Error, Trace.messageType.error);
}
function convertToContentInset(value) {
  if (typeof value === "string" && value !== "auto") {
    const insets = value.split(/[ ,]+/);
    return [
      [androidContentInsetLeftProperty, Length.parse(insets[0])],
      [androidContentInsetRightProperty, Length.parse(insets[1] || insets[0])]
    ];
  } else {
    return [
      [androidContentInsetLeftProperty, value],
      [androidContentInsetRightProperty, value]
    ];
  }
}
var iosIconRenderingModeProperty = new Property({ name: "iosIconRenderingMode", defaultValue: "alwaysOriginal" });
iosIconRenderingModeProperty.register(ActionBarBase);
var iosLargeTitleProperty = new Property({ name: "iosLargeTitle", defaultValue: false, valueConverter: booleanConverter });
iosLargeTitleProperty.register(ActionBarBase);
var iosShadowProperty = new Property({ name: "iosShadow", defaultValue: true, valueConverter: booleanConverter });
iosShadowProperty.register(ActionBarBase);
var textProperty = new Property({
  name: "text",
  defaultValue: "",
  valueChanged: onItemChanged
});
textProperty.register(ActionItemBase);
var iconProperty = new Property({
  name: "icon",
  valueChanged: onItemChanged
});
iconProperty.register(ActionItemBase);
var visibilityProperty2 = new Property({
  name: "visibility",
  defaultValue: "visible",
  valueChanged: onVisibilityChanged
});
visibilityProperty2.register(ActionItemBase);
var flatProperty = new Property({
  name: "flat",
  defaultValue: false,
  valueConverter: booleanConverter
});
flatProperty.register(ActionBarBase);
var androidContentInsetProperty = new ShorthandProperty({
  name: "androidContentInset",
  cssName: "android-content-inset",
  getter: function() {
    if (Length.equals(this.androidContentInsetLeft, this.androidContentInsetRight)) {
      return this.androidContentInsetLeft;
    }
    return `${Length.convertToString(this.androidContentInsetLeft)} ${Length.convertToString(this.androidContentInsetRight)}`;
  },
  converter: convertToContentInset
});
androidContentInsetProperty.register(Style);
var androidContentInsetLeftProperty = new CssProperty({
  name: "androidContentInsetLeft",
  cssName: "android-content-inset-left",
  defaultValue: "auto",
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectiveContentInsetLeft = Length.toDevicePixels(newValue);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
androidContentInsetLeftProperty.register(Style);
var androidContentInsetRightProperty = new CssProperty({
  name: "androidContentInsetRight",
  cssName: "android-content-inset-right",
  defaultValue: "auto",
  equalityComparer: Length.equals,
  valueChanged: (target, oldValue, newValue) => {
    const view = target.viewRef.get();
    if (view) {
      view.effectiveContentInsetRight = Length.toDevicePixels(newValue);
    } else {
      Trace.write(`${newValue} not set to view's property because ".viewRef" is cleared`, Trace.categories.Style, Trace.messageType.warn);
    }
  },
  valueConverter: Length.parse
});
androidContentInsetRightProperty.register(Style);

// node_modules/@nativescript/core/ui/action-bar/index.android.js
var R_ID_HOME = 16908332;
var ACTION_ITEM_ID_OFFSET = 1e4;
var DEFAULT_ELEVATION = 4;
var AppCompatTextView;
var actionItemIdGenerator = ACTION_ITEM_ID_OFFSET;
function generateItemId() {
  actionItemIdGenerator++;
  return actionItemIdGenerator;
}
function loadActionIconDrawableOrResourceId(item) {
  const itemIcon = item.icon;
  const itemStyle = item.style;
  let drawableOrId = null;
  if (isFontIconURI(itemIcon)) {
    const fontIconCode = itemIcon.split("//")[1];
    const font = itemStyle.fontInternal;
    const color2 = itemStyle.color;
    const is = ImageSource.fromFontIconCodeSync(fontIconCode, font, color2);
    if (is && is.android) {
      drawableOrId = new android.graphics.drawable.BitmapDrawable(appResources, is.android);
    }
  } else {
    drawableOrId = getDrawableOrResourceId(itemIcon, appResources);
  }
  if (!drawableOrId) {
    traceMissingIcon(itemIcon);
  }
  return drawableOrId;
}
var appResources;
var MenuItemClickListener;
function initializeMenuItemClickListener() {
  if (MenuItemClickListener) {
    return;
  }
  AppCompatTextView = androidx.appcompat.widget.AppCompatTextView;
  var MenuItemClickListenerImpl = function(_super) {
    __extends(MenuItemClickListenerImpl2, _super);
    function MenuItemClickListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    MenuItemClickListenerImpl2.prototype.onMenuItemClick = function(item) {
      var itemId = item.getItemId();
      return this.owner._onAndroidItemSelected(itemId);
    };
    MenuItemClickListenerImpl2 = __decorate([
      Interfaces([androidx.appcompat.widget.Toolbar.OnMenuItemClickListener])
    ], MenuItemClickListenerImpl2);
    return MenuItemClickListenerImpl2;
  }(java.lang.Object);
  MenuItemClickListener = MenuItemClickListenerImpl;
  appResources = getNativeApp().getApplicationContext().getResources();
}

class ActionItem extends ActionItemBase {
  constructor() {
    super();
    this._androidPosition = {
      position: "actionBar",
      systemIcon: undefined
    };
    this._itemId = generateItemId();
  }
  get android() {
    return this._androidPosition;
  }
  set android(value) {
    throw new Error("ActionItem.android is read-only");
  }
  _getItemId() {
    return this._itemId;
  }
}

class AndroidActionBarSettings {
  constructor(actionBar) {
    this._iconVisibility = "auto";
    this._actionBar = actionBar;
  }
  get icon() {
    return this._icon;
  }
  set icon(value) {
    if (value !== this._icon) {
      this._icon = value;
      this._actionBar._onIconPropertyChanged();
    }
  }
  get iconVisibility() {
    return this._iconVisibility;
  }
  set iconVisibility(value) {
    if (value !== this._iconVisibility) {
      this._iconVisibility = value;
      this._actionBar._onIconPropertyChanged();
    }
  }
}

class NavigationButton extends ActionItem {
}

class ActionBar extends ActionBarBase {
  constructor() {
    super();
    this._android = new AndroidActionBarSettings(this);
  }
  get android() {
    return this._android;
  }
  _addChildFromBuilder(name50, value) {
    if (value instanceof NavigationButton) {
      this.navigationButton = value;
    } else if (value instanceof ActionItem) {
      this.actionItems?.addItem(value);
    } else if (value instanceof View) {
      this.titleView = value;
    }
  }
  createNativeView() {
    return new androidx.appcompat.widget.Toolbar(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    initializeMenuItemClickListener();
    const menuItemClickListener = new MenuItemClickListener(this);
    nativeView.setOnMenuItemClickListener(menuItemClickListener);
    nativeView.menuItemClickListener = menuItemClickListener;
  }
  disposeNativeView() {
    if (this.nativeViewProtected?.menuItemClickListener) {
      this.nativeViewProtected.menuItemClickListener.owner = null;
    }
    super.disposeNativeView();
  }
  onLoaded() {
    super.onLoaded();
    this.update();
  }
  get needsNativeDrawableFill() {
    return true;
  }
  update() {
    if (!this.nativeViewProtected) {
      return;
    }
    const page = this.page;
    if (!page.frame || !page.frame._getNavBarVisible(page)) {
      this.nativeViewProtected.setVisibility(android.view.View.GONE);
      return;
    }
    this.nativeViewProtected.setVisibility(android.view.View.VISIBLE);
    this._addActionItems();
    this._updateTitleAndTitleView();
    this._updateIcon();
    this._updateNavigationButton();
  }
  _onAndroidItemSelected(itemId) {
    if (this.navigationButton && itemId === R_ID_HOME) {
      this.navigationButton._raiseTap();
      return true;
    }
    let menuItem = undefined;
    const items = this.actionItems?.getItems() ?? [];
    for (let i4 = 0;i4 < items.length; i4++) {
      if (items[i4]._getItemId() === itemId) {
        menuItem = items[i4];
        break;
      }
    }
    if (menuItem) {
      menuItem._raiseTap();
      return true;
    }
    return false;
  }
  _updateNavigationButton() {
    const navButton = this.navigationButton;
    if (navButton && isVisible(navButton)) {
      const systemIcon = navButton.android.systemIcon;
      if (systemIcon !== undefined) {
        const systemResourceId = getSystemResourceId(systemIcon);
        if (systemResourceId) {
          this.nativeViewProtected.setNavigationIcon(systemResourceId);
        }
      } else if (navButton.icon) {
        const drawableOrId = loadActionIconDrawableOrResourceId(navButton);
        if (drawableOrId) {
          this.nativeViewProtected.setNavigationIcon(drawableOrId);
        }
      }
      this.nativeViewProtected.setNavigationContentDescription(navButton.text || null);
      const navBtn = new WeakRef(navButton);
      this.nativeViewProtected.setNavigationOnClickListener(new android.view.View.OnClickListener({
        onClick: function(v) {
          const owner = navBtn?.get();
          if (owner) {
            owner._raiseTap();
          }
        }
      }));
    } else {
      this.nativeViewProtected.setNavigationIcon(null);
    }
  }
  _updateIcon() {
    const visibility = getIconVisibility(this.android.iconVisibility);
    if (visibility) {
      const icon = this.android.icon;
      if (icon !== undefined) {
        const drawableOrId = getDrawableOrResourceId(icon, appResources);
        if (drawableOrId) {
          this.nativeViewProtected.setLogo(drawableOrId);
        } else {
          traceMissingIcon(icon);
        }
      } else {
        const defaultIcon = getNativeApp().getApplicationInfo().icon;
        this.nativeViewProtected.setLogo(defaultIcon);
      }
    } else {
      this.nativeViewProtected.setLogo(null);
    }
  }
  _updateTitleAndTitleView() {
    if (!this.titleView) {
      const title = this.title;
      if (title !== undefined) {
        this.nativeViewProtected.setTitle(title);
      } else {
        const appContext = getNativeApp().getApplicationContext();
        const appInfo = appContext.getApplicationInfo();
        const appLabel = appContext.getPackageManager().getApplicationLabel(appInfo);
        if (appLabel) {
          this.nativeViewProtected.setTitle(appLabel);
        }
      }
    }
    updateContentDescription(this, true);
  }
  _addActionItems() {
    const menu = this.nativeViewProtected.getMenu();
    const items = this.actionItems?.getVisibleItems() ?? [];
    menu.clear();
    for (let i4 = 0;i4 < items.length; i4++) {
      const item = items[i4];
      const menuItem = menu.add(android.view.Menu.NONE, item._getItemId(), android.view.Menu.NONE, item.text + "");
      if (item.actionView && item.actionView.android) {
        item.android.position = "actionBar";
        menuItem.setActionView(item.actionView.android);
        ActionBar._setOnClickListener(item);
      } else if (item.android.systemIcon) {
        const systemResourceId = getSystemResourceId(item.android.systemIcon);
        if (systemResourceId) {
          menuItem.setIcon(systemResourceId);
        }
      } else if (item.icon) {
        const drawableOrId = loadActionIconDrawableOrResourceId(item);
        if (drawableOrId) {
          menuItem.setIcon(drawableOrId);
        }
      }
      const showAsAction = getShowAsAction(item);
      menuItem.setShowAsAction(showAsAction);
    }
  }
  static _setOnClickListener(item) {
    const weakRef = new WeakRef(item);
    item.actionView.android.setOnClickListener(new android.view.View.OnClickListener({
      onClick: function(v) {
        const owner = weakRef?.get();
        if (owner) {
          owner._raiseTap();
        }
      }
    }));
  }
  _onTitlePropertyChanged() {
    if (this.nativeViewProtected) {
      this._updateTitleAndTitleView();
    }
  }
  _onIconPropertyChanged() {
    if (this.nativeViewProtected) {
      this._updateIcon();
    }
  }
  _addViewToNativeVisualTree(child, atIndex = Number.MAX_VALUE) {
    super._addViewToNativeVisualTree(child);
    if (this.nativeViewProtected && child.nativeViewProtected) {
      if (atIndex >= this.nativeViewProtected.getChildCount()) {
        this.nativeViewProtected.addView(child.nativeViewProtected);
      } else {
        this.nativeViewProtected.addView(child.nativeViewProtected, atIndex);
      }
      return true;
    }
    return false;
  }
  _removeViewFromNativeVisualTree(child) {
    super._removeViewFromNativeVisualTree(child);
    if (this.nativeViewProtected && child.nativeViewProtected) {
      this.nativeViewProtected.removeView(child.nativeViewProtected);
    }
  }
  [colorProperty.getDefault]() {
    const nativeView = this.nativeViewProtected;
    if (!defaultTitleTextColor) {
      let tv = getAppCompatTextView(nativeView);
      if (!tv) {
        const title = nativeView.getTitle();
        nativeView.setTitle("");
        tv = getAppCompatTextView(nativeView);
        if (title) {
          nativeView.setTitle(title);
        }
      }
      defaultTitleTextColor = tv ? tv.getTextColors().getDefaultColor() : -570425344;
    }
    return defaultTitleTextColor;
  }
  [colorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    this.nativeViewProtected.setTitleTextColor(color2);
  }
  [flatProperty.setNative](value) {
    const compat = androidx.core.view.ViewCompat;
    if (compat.setElevation) {
      if (value) {
        compat.setElevation(this.nativeViewProtected, 0);
      } else {
        const val = DEFAULT_ELEVATION * layout.getDisplayDensity();
        compat.setElevation(this.nativeViewProtected, val);
      }
    }
  }
  [androidContentInsetLeftProperty.setNative]() {
    if (SDK_VERSION >= 21) {
      this.nativeViewProtected.setContentInsetsAbsolute(this.effectiveContentInsetLeft, this.effectiveContentInsetRight);
    }
  }
  [androidContentInsetRightProperty.setNative]() {
    if (SDK_VERSION >= 21) {
      this.nativeViewProtected.setContentInsetsAbsolute(this.effectiveContentInsetLeft, this.effectiveContentInsetRight);
    }
  }
  accessibilityScreenChanged() {
    if (!isAccessibilityServiceEnabled()) {
      return;
    }
    const nativeView = this.nativeViewProtected;
    if (!nativeView) {
      return;
    }
    const originalFocusableState = SDK_VERSION >= 26 && nativeView.getFocusable();
    const originalImportantForAccessibility = nativeView.getImportantForAccessibility();
    const originalIsAccessibilityHeading = SDK_VERSION >= 28 && nativeView.isAccessibilityHeading();
    try {
      nativeView.setFocusable(false);
      nativeView.setImportantForAccessibility(android.view.View.IMPORTANT_FOR_ACCESSIBILITY_NO);
      let announceView = null;
      const numChildren = nativeView.getChildCount();
      for (let i4 = 0;i4 < numChildren; i4 += 1) {
        const childView = nativeView.getChildAt(i4);
        if (!childView) {
          continue;
        }
        childView.setFocusable(true);
        if (childView instanceof androidx.appcompat.widget.AppCompatTextView) {
          announceView = childView;
          if (SDK_VERSION >= 28) {
            announceView.setAccessibilityHeading(true);
          }
        }
      }
      if (!announceView) {
        announceView = nativeView;
      }
      announceView.setFocusable(true);
      announceView.setImportantForAccessibility(android.view.View.IMPORTANT_FOR_ACCESSIBILITY_YES);
      announceView.sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent.TYPE_VIEW_FOCUSED);
      announceView.sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
    } catch {} finally {
      setTimeout(() => {
        const localNativeView = this.nativeViewProtected;
        if (!localNativeView) {
          return;
        }
        if (SDK_VERSION >= 28) {
          nativeView.setAccessibilityHeading(originalIsAccessibilityHeading);
        }
        if (SDK_VERSION >= 26) {
          localNativeView.setFocusable(originalFocusableState);
        }
        localNativeView.setImportantForAccessibility(originalImportantForAccessibility);
      });
    }
  }
}
function getAppCompatTextView(toolbar) {
  for (let i4 = 0, count = toolbar.getChildCount();i4 < count; i4++) {
    const child = toolbar.getChildAt(i4);
    if (child instanceof AppCompatTextView) {
      return child;
    }
  }
  return null;
}
ActionBar.prototype.recycleNativeView = "auto";
var defaultTitleTextColor;
function getDrawableOrResourceId(icon, resources3) {
  if (typeof icon !== "string") {
    return null;
  }
  let result = null;
  if (icon.indexOf(RESOURCE_PREFIX) === 0) {
    const resourceId = resources3.getIdentifier(icon.substring(RESOURCE_PREFIX.length), "drawable", getNativeApp().getApplicationContext().getPackageName());
    if (resourceId > 0) {
      result = resourceId;
    }
  } else {
    let drawable;
    const is = ImageSource.fromFileOrResourceSync(icon);
    if (is) {
      drawable = new android.graphics.drawable.BitmapDrawable(appResources, is.android);
    }
    result = drawable;
  }
  return result;
}
function getShowAsAction(menuItem) {
  switch (menuItem.android.position) {
    case "actionBarIfRoom":
      return android.view.MenuItem.SHOW_AS_ACTION_IF_ROOM;
    case "popup":
      return android.view.MenuItem.SHOW_AS_ACTION_NEVER;
    case "actionBar":
    default:
      return android.view.MenuItem.SHOW_AS_ACTION_ALWAYS;
  }
}
function getIconVisibility(iconVisibility) {
  switch (iconVisibility) {
    case "always":
      return true;
    case "auto":
    case "never":
    default:
      return false;
  }
}
function getSystemResourceId(systemIcon) {
  return android.content.res.Resources.getSystem().getIdentifier(systemIcon, "drawable", "android");
}
// node_modules/@nativescript/core/ui/activity-indicator/activity-indicator-common.js
var ActivityIndicatorBase = class ActivityIndicatorBase2 extends View {
};
ActivityIndicatorBase = __decorate([
  CSSType("ActivityIndicator")
], ActivityIndicatorBase);
ActivityIndicatorBase.prototype.recycleNativeView = "auto";
var busyProperty = new Property({
  name: "busy",
  defaultValue: false,
  valueConverter: booleanConverter
});
busyProperty.register(ActivityIndicatorBase);
var iosIndicatorViewStyleProperty = new Property({
  name: "iosIndicatorViewStyle",
  defaultValue: "medium"
});
iosIndicatorViewStyleProperty.register(ActivityIndicatorBase);

// node_modules/@nativescript/core/ui/activity-indicator/index.android.js
class ActivityIndicator extends ActivityIndicatorBase {
  createNativeView() {
    const progressBar = new android.widget.ProgressBar(this._context);
    progressBar.setVisibility(android.view.View.INVISIBLE);
    progressBar.setIndeterminate(true);
    return progressBar;
  }
  [busyProperty.getDefault]() {
    return false;
  }
  [busyProperty.setNative](value) {
    if (this.visibility === CoreTypes.Visibility.visible) {
      this.nativeViewProtected.setVisibility(value ? android.view.View.VISIBLE : android.view.View.INVISIBLE);
    }
  }
  [visibilityProperty.getDefault]() {
    return CoreTypes.Visibility.hidden;
  }
  [visibilityProperty.setNative](value) {
    switch (value) {
      case CoreTypes.Visibility.visible:
        this.nativeViewProtected.setVisibility(this.busy ? android.view.View.VISIBLE : android.view.View.INVISIBLE);
        break;
      case CoreTypes.Visibility.hidden:
        this.nativeViewProtected.setVisibility(android.view.View.INVISIBLE);
        break;
      case CoreTypes.Visibility.collapse:
        this.nativeViewProtected.setVisibility(android.view.View.GONE);
        break;
      default:
        throw new Error(`Invalid visibility value: ${value}. Valid values are: "${CoreTypes.Visibility.visible}", "${CoreTypes.Visibility.hidden}", "${CoreTypes.Visibility.collapse}".`);
    }
  }
  [colorProperty.getDefault]() {
    return -1;
  }
  [colorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    const drawable = this.nativeViewProtected.getIndeterminateDrawable().mutate();
    if (color2) {
      AndroidHelper.setDrawableColor(color2, drawable);
    } else {
      AndroidHelper.clearDrawableColor(drawable);
    }
  }
}
// node_modules/@nativescript/core/ui/text-base/span.js
class Span extends ViewBase {
  constructor() {
    super(...arguments);
    this._tappable = false;
  }
  get fontFamily() {
    return this.style.fontFamily;
  }
  set fontFamily(value) {
    this.style.fontFamily = value;
  }
  get fontSize() {
    return this.style.fontSize;
  }
  set fontSize(value) {
    this.style.fontSize = value;
  }
  get fontStyle() {
    return this.style.fontStyle;
  }
  set fontStyle(value) {
    this.style.fontStyle = value;
  }
  get fontWeight() {
    return this.style.fontWeight;
  }
  set fontWeight(value) {
    this.style.fontWeight = value;
  }
  get fontVariationSettings() {
    return this.style.fontVariationSettings;
  }
  set fontVariationSettings(value) {
    this.style.fontVariationSettings = value;
  }
  get textDecoration() {
    return this.style.textDecoration;
  }
  set textDecoration(value) {
    this.style.textDecoration = value;
  }
  get color() {
    return this.style.color;
  }
  set color(value) {
    this.style.color = value;
  }
  get backgroundColor() {
    return this.style.backgroundColor;
  }
  set backgroundColor(value) {
    this.style.backgroundColor = value;
  }
  get iosAccessibilityAdjustsFontSize() {
    return this.style.iosAccessibilityAdjustsFontSize;
  }
  set iosAccessibilityAdjustsFontSize(value) {
    this.style.iosAccessibilityAdjustsFontSize = value;
  }
  get iosAccessibilityMinFontScale() {
    return this.style.iosAccessibilityMinFontScale;
  }
  set iosAccessibilityMinFontScale(value) {
    this.style.iosAccessibilityMinFontScale = value;
  }
  get iosAccessibilityMaxFontScale() {
    return this.style.iosAccessibilityMaxFontScale;
  }
  set iosAccessibilityMaxFontScale(value) {
    this.style.iosAccessibilityMaxFontScale = value;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text !== value) {
      if (isNullOrUndefined(value)) {
        this._text = "";
      } else {
        this._text = isString(value) ? `${value}`.replace("\\n", `
`).replace("\\t", "\t") : `${value}`;
      }
      this.notifyPropertyChange("text", this._text);
    }
  }
  get tappable() {
    return this._tappable;
  }
  addEventListener(arg, callback, thisArg, once) {
    super.addEventListener(arg, callback, thisArg, once);
    this._setTappable(this.hasListeners(Span.linkTapEvent));
  }
  removeEventListener(arg, callback, thisArg) {
    super.removeEventListener(arg, callback, thisArg);
    this._setTappable(this.hasListeners(Span.linkTapEvent));
  }
  _setTextInternal(value) {
    this._text = value;
  }
  _setTappable(value) {
    if (this._tappable !== value) {
      this._tappable = value;
      this.notifyPropertyChange("tappable", value);
    }
  }
}
Span.linkTapEvent = "linkTap";

// node_modules/@nativescript/core/ui/text-base/formatted-string.js
class FormattedString extends ViewBase {
  constructor() {
    super();
    this._spans = new ObservableArray;
    this._spans.addEventListener(ObservableArray.changeEvent, this.onSpansCollectionChanged, this);
  }
  get fontFamily() {
    return this.style.fontFamily;
  }
  set fontFamily(value) {
    this.style.fontFamily = value;
  }
  get fontSize() {
    return this.style.fontSize;
  }
  set fontSize(value) {
    this.style.fontSize = value;
  }
  get fontStyle() {
    return this.style.fontStyle;
  }
  set fontStyle(value) {
    this.style.fontStyle = value;
  }
  get fontWeight() {
    return this.style.fontWeight;
  }
  set fontWeight(value) {
    this.style.fontWeight = value;
  }
  get fontVariationSettings() {
    return this.style.fontVariationSettings;
  }
  set fontVariationSettings(value) {
    this.style.fontVariationSettings = value;
  }
  get textDecoration() {
    return this.style.textDecoration;
  }
  set textDecoration(value) {
    this.style.textDecoration = value;
  }
  get color() {
    return this.style.color;
  }
  set color(value) {
    this.style.color = value;
  }
  get backgroundColor() {
    return this.style.backgroundColor;
  }
  set backgroundColor(value) {
    this.style.backgroundColor = value;
  }
  get iosAccessibilityAdjustsFontSize() {
    return this.style.iosAccessibilityAdjustsFontSize;
  }
  set iosAccessibilityAdjustsFontSize(value) {
    this.style.iosAccessibilityAdjustsFontSize = value;
  }
  get iosAccessibilityMinFontScale() {
    return this.style.iosAccessibilityMinFontScale;
  }
  set iosAccessibilityMinFontScale(value) {
    this.style.iosAccessibilityMinFontScale = value;
  }
  get iosAccessibilityMaxFontScale() {
    return this.style.iosAccessibilityMaxFontScale;
  }
  set iosAccessibilityMaxFontScale(value) {
    this.style.iosAccessibilityMaxFontScale = value;
  }
  get spans() {
    if (!this._spans) {
      this._spans = new ObservableArray;
    }
    return this._spans;
  }
  toString() {
    let result = "";
    for (let i4 = 0, length2 = this.spans.length;i4 < length2; i4++) {
      result += this.spans.getItem(i4).text;
    }
    return result;
  }
  _addArrayFromBuilder(name50, value) {
    if (name50 === "spans") {
      this.spans.push(...value);
    }
  }
  _addChildFromBuilder(name50, value) {
    if (value instanceof Span) {
      this.spans.push(value);
    }
  }
  onSpansCollectionChanged(eventData) {
    if (eventData.addedCount > 0) {
      for (let i4 = 0;i4 < eventData.addedCount; i4++) {
        const span = eventData.object.getItem(eventData.index + i4);
        this._addView(span);
        this.addPropertyChangeHandler(span);
      }
    }
    if (eventData.removed && eventData.removed.length > 0) {
      for (let p2 = 0;p2 < eventData.removed.length; p2++) {
        const span = eventData.removed[p2];
        this.removePropertyChangeHandler(span);
        this._removeView(span);
      }
    }
    this.notifyPropertyChange(".", this);
  }
  addPropertyChangeHandler(span) {
    const style = span.style;
    span.on(Observable.propertyChangeEvent, this.onPropertyChange, this);
    style.on("fontFamilyChange", this.onPropertyChange, this);
    style.on("fontSizeChange", this.onPropertyChange, this);
    style.on("fontStyleChange", this.onPropertyChange, this);
    style.on("fontWeightChange", this.onPropertyChange, this);
    style.on("fontVariationSettingsChange", this.onPropertyChange, this);
    style.on("textDecorationChange", this.onPropertyChange, this);
    style.on("colorChange", this.onPropertyChange, this);
    style.on("backgroundColorChange", this.onPropertyChange, this);
    style.on("iosAccessibilityAdjustsFontSizeChange", this.onPropertyChange, this);
    style.on("iosAccessibilityMinFontScaleChange", this.onPropertyChange, this);
    style.on("iosAccessibilityMaxFontScaleChange", this.onPropertyChange, this);
    style.on("fontScaleInternalChange", this.onPropertyChange, this);
  }
  removePropertyChangeHandler(span) {
    const style = span.style;
    span.off(Observable.propertyChangeEvent, this.onPropertyChange, this);
    style.off("fontFamilyChange", this.onPropertyChange, this);
    style.off("fontSizeChange", this.onPropertyChange, this);
    style.off("fontStyleChange", this.onPropertyChange, this);
    style.off("fontWeightChange", this.onPropertyChange, this);
    style.off("fontVariationSettingsChange", this.onPropertyChange, this);
    style.off("textDecorationChange", this.onPropertyChange, this);
    style.off("colorChange", this.onPropertyChange, this);
    style.off("backgroundColorChange", this.onPropertyChange, this);
    style.off("iosAccessibilityAdjustsFontSizeChange", this.onPropertyChange, this);
    style.off("iosAccessibilityMinFontScaleChange", this.onPropertyChange, this);
    style.off("iosAccessibilityMaxFontScaleChange", this.onPropertyChange, this);
    style.off("fontScaleInternalChange", this.onPropertyChange, this);
  }
  onPropertyChange(data2) {
    this.notifyPropertyChange(data2.propertyName, this);
  }
  eachChild(callback) {
    this.spans.forEach((v, i4, arr) => callback(v));
  }
}

// node_modules/@nativescript/core/ui/styling/css-stroke.js
function parseCSSStroke(value) {
  const data2 = parseCSSShorthand(value);
  if (!data2) {
    return null;
  }
  const [width] = data2.values;
  return {
    width,
    color: data2.color ? new Color(data2.color) : undefined
  };
}

// node_modules/@nativescript/core/ui/text-base/text-base-common.js
var CHILD_SPAN = "Span";
var CHILD_FORMATTED_TEXT = "formattedText";
var CHILD_FORMATTED_STRING = "FormattedString";

class TextBaseCommon extends View {
  get nativeTextViewProtected() {
    return this.nativeViewProtected;
  }
  get fontFamily() {
    return this.style.fontFamily;
  }
  set fontFamily(value) {
    this.style.fontFamily = value;
  }
  get fontSize() {
    return this.style.fontSize;
  }
  set fontSize(value) {
    this.style.fontSize = value;
  }
  get fontStyle() {
    return this.style.fontStyle;
  }
  set fontStyle(value) {
    this.style.fontStyle = value;
  }
  get fontWeight() {
    return this.style.fontWeight;
  }
  set fontWeight(value) {
    this.style.fontWeight = value;
  }
  get letterSpacing() {
    return this.style.letterSpacing;
  }
  set letterSpacing(value) {
    this.style.letterSpacing = value;
  }
  get lineHeight() {
    return this.style.lineHeight;
  }
  set lineHeight(value) {
    this.style.lineHeight = value;
  }
  get maxLines() {
    return this.style.maxLines;
  }
  set maxLines(value) {
    this.style.maxLines = value;
  }
  get textAlignment() {
    return this.style.textAlignment;
  }
  set textAlignment(value) {
    this.style.textAlignment = value;
  }
  get textDecoration() {
    return this.style.textDecoration;
  }
  set textDecoration(value) {
    this.style.textDecoration = value;
  }
  get textTransform() {
    return this.style.textTransform;
  }
  set textTransform(value) {
    this.style.textTransform = value;
  }
  get textShadow() {
    return this.style.textShadow;
  }
  set textShadow(value) {
    this.style.textShadow = value;
  }
  get textStroke() {
    return this.style.textStroke;
  }
  set textStroke(value) {
    this.style.textStroke = value;
  }
  get whiteSpace() {
    return this.style.whiteSpace;
  }
  set whiteSpace(value) {
    this.style.whiteSpace = value;
  }
  get textOverflow() {
    return this.style.textOverflow;
  }
  set textOverflow(value) {
    this.style.textOverflow = value;
  }
  get padding() {
    return this.style.padding;
  }
  set padding(value) {
    this.style.padding = value;
  }
  get paddingTop() {
    return this.style.paddingTop;
  }
  set paddingTop(value) {
    this.style.paddingTop = value;
  }
  get paddingRight() {
    return this.style.paddingRight;
  }
  set paddingRight(value) {
    this.style.paddingRight = value;
  }
  get paddingBottom() {
    return this.style.paddingBottom;
  }
  set paddingBottom(value) {
    this.style.paddingBottom = value;
  }
  get paddingLeft() {
    return this.style.paddingLeft;
  }
  set paddingLeft(value) {
    this.style.paddingLeft = value;
  }
  _onFormattedTextContentsChanged(data2) {
    if (this.nativeViewProtected) {
      this[formattedTextProperty.setNative](data2.value);
    }
  }
  _addChildFromBuilder(name50, value) {
    if (name50 === CHILD_SPAN) {
      if (!this.formattedText) {
        const formattedText = new FormattedString;
        formattedText.spans.push(value);
        this.formattedText = formattedText;
      } else {
        this.formattedText.spans.push(value);
      }
    } else if (name50 === CHILD_FORMATTED_TEXT || name50 === CHILD_FORMATTED_STRING) {
      this.formattedText = value;
    }
  }
  _requestLayoutOnTextChanged() {
    this.requestLayout();
  }
  eachChild(callback) {
    const text = this.formattedText;
    if (text) {
      callback(text);
    }
  }
  _setNativeText(reset2 = false) {}
}
TextBaseCommon.iosTextAnimationFallback = true;
TextBaseCommon.prototype._isSingleLine = false;
TextBaseCommon.prototype._isManualRtlTextStyleNeeded = false;
var textProperty2 = new Property({
  name: "text",
  defaultValue: "",
  affectsLayout: __ANDROID__
});
textProperty2.register(TextBaseCommon);
var formattedTextProperty = new Property({
  name: "formattedText",
  affectsLayout: true,
  valueChanged: onFormattedTextPropertyChanged
});
formattedTextProperty.register(TextBaseCommon);
var iosTextAnimationProperty = new Property({
  name: "iosTextAnimation",
  defaultValue: "inherit",
  affectsLayout: false,
  valueConverter(value) {
    try {
      return booleanConverter(value);
    } catch (e3) {
      return "inherit";
    }
  }
});
iosTextAnimationProperty.register(TextBaseCommon);
function onFormattedTextPropertyChanged(textBase, oldValue, newValue) {
  if (oldValue) {
    oldValue.off(Observable.propertyChangeEvent, textBase._onFormattedTextContentsChanged, textBase);
    textBase._removeView(oldValue);
  }
  if (newValue) {
    const oldParent = newValue.parent;
    if (oldParent) {
      oldParent._removeView(newValue);
    }
    textBase._addView(newValue);
    newValue.on(Observable.propertyChangeEvent, textBase._onFormattedTextContentsChanged, textBase);
  }
}
function getClosestPropertyValue(property2, span) {
  if (property2.isSet(span.style)) {
    return span.style[property2.name];
  } else if (property2.isSet(span.parent.style)) {
    return span.parent.style[property2.name];
  } else if (property2.isSet(span.parent.parent.style)) {
    return span.parent.parent.style[property2.name];
  }
}
var textAlignmentConverter = makeParser(makeValidator("left", "center", "right", "justify"));
var textAlignmentProperty = new InheritedCssProperty({
  name: "textAlignment",
  cssName: "text-align",
  defaultValue: "initial",
  valueConverter: textAlignmentConverter
});
textAlignmentProperty.register(Style);
var textTransformConverter = makeParser(makeValidator("none", "capitalize", "uppercase", "lowercase"));
var textTransformProperty = new InheritedCssProperty({
  name: "textTransform",
  cssName: "text-transform",
  defaultValue: "initial",
  valueConverter: textTransformConverter
});
textTransformProperty.register(Style);
var textShadowProperty = new InheritedCssProperty({
  name: "textShadow",
  cssName: "text-shadow",
  affectsLayout: __APPLE__,
  valueConverter: (value) => {
    return parseCSSShadow(value);
  }
});
textShadowProperty.register(Style);
var textStrokeProperty = new InheritedCssProperty({
  name: "textStroke",
  cssName: "text-stroke",
  affectsLayout: __APPLE__,
  valueConverter: (value) => {
    return parseCSSStroke(value);
  }
});
textStrokeProperty.register(Style);
var whiteSpaceConverter = makeParser(makeValidator("normal", "nowrap", "wrap"));
var whiteSpaceProperty = new InheritedCssProperty({
  name: "whiteSpace",
  cssName: "white-space",
  defaultValue: "initial",
  affectsLayout: __APPLE__,
  valueConverter: whiteSpaceConverter
});
whiteSpaceProperty.register(Style);
var textOverflowConverter = makeParser(makeValidator("clip", "ellipsis"));
var textOverflowProperty = new CssProperty({
  name: "textOverflow",
  cssName: "text-overflow",
  defaultValue: "initial",
  affectsLayout: __APPLE__,
  valueConverter: textOverflowConverter
});
textOverflowProperty.register(Style);
var textDecorationConverter = makeParser(makeValidator("none", "underline", "line-through", "underline line-through"));
var textDecorationProperty = new CssProperty({
  name: "textDecoration",
  cssName: "text-decoration",
  defaultValue: "none",
  valueConverter: textDecorationConverter
});
textDecorationProperty.register(Style);
var letterSpacingProperty = new InheritedCssProperty({
  name: "letterSpacing",
  cssName: "letter-spacing",
  defaultValue: 0,
  affectsLayout: __APPLE__,
  valueConverter: (v) => parseFloat(v)
});
letterSpacingProperty.register(Style);
var lineHeightProperty = new InheritedCssProperty({
  name: "lineHeight",
  cssName: "line-height",
  affectsLayout: __APPLE__,
  valueConverter: (v) => parseFloat(v)
});
lineHeightProperty.register(Style);
var maxLinesProperty = new CssProperty({
  name: "maxLines",
  cssName: "max-lines",
  valueConverter: (v) => v === "none" ? 0 : parseInt(v, 10)
});
maxLinesProperty.register(Style);
var resetSymbol = Symbol("textPropertyDefault");

// node_modules/@nativescript/core/ui/text-base/index.android.js
var TextTransformation;
function initializeTextTransformation() {
  if (TextTransformation) {
    return;
  }
  var TextTransformationImpl = function(_super) {
    __extends(TextTransformationImpl2, _super);
    function TextTransformationImpl2(textBase) {
      var _this = _super.call(this) || this;
      _this.textBase = textBase;
      return global.__native(_this);
    }
    TextTransformationImpl2.prototype.getTransformation = function(charSeq, view) {
      var formattedText = this.textBase.formattedText;
      if (formattedText) {
        return this.textBase.createFormattedTextNative(formattedText);
      } else {
        var text = this.textBase.text;
        var stringValue = isNullOrUndefined(text) ? "" : text.toString();
        return getTransformedText(stringValue, this.textBase.textTransform);
      }
    };
    TextTransformationImpl2.prototype.onFocusChanged = function(view, sourceText, focused, direction, previouslyFocusedRect) {};
    TextTransformationImpl2 = __decorate([
      Interfaces([android.text.method.TransformationMethod])
    ], TextTransformationImpl2);
    return TextTransformationImpl2;
  }(java.lang.Object);
  TextTransformation = TextTransformationImpl;
}
var ClickableSpan;
function initializeClickableSpan() {
  if (ClickableSpan) {
    return;
  }
  var ClickableSpanImpl = function(_super) {
    __extends(ClickableSpanImpl2, _super);
    function ClickableSpanImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = new WeakRef(owner);
      return global.__native(_this);
    }
    ClickableSpanImpl2.prototype.onClick = function(view) {
      var _a4;
      var owner = (_a4 = this.owner) === null || _a4 === undefined ? undefined : _a4.get();
      if (owner) {
        owner._emit(Span.linkTapEvent);
      }
      view.clearFocus();
      view.invalidate();
    };
    ClickableSpanImpl2.prototype.updateDrawState = function(tp) {};
    return ClickableSpanImpl2;
  }(android.text.style.ClickableSpan);
  ClickableSpan = ClickableSpanImpl;
}
var BaselineAdjustedSpan;
function initializeBaselineAdjustedSpan() {
  if (BaselineAdjustedSpan) {
    return;
  }
  var BaselineAdjustedSpanImpl = function(_super) {
    __extends(BaselineAdjustedSpanImpl2, _super);
    function BaselineAdjustedSpanImpl2(fontSize, align) {
      var _this = _super.call(this) || this;
      _this.align = "baseline";
      _this.align = align;
      _this.fontSize = fontSize;
      return _this;
    }
    BaselineAdjustedSpanImpl2.prototype.updateDrawState = function(paint) {
      this.updateState(paint);
    };
    BaselineAdjustedSpanImpl2.prototype.updateMeasureState = function(paint) {
      this.updateState(paint);
    };
    BaselineAdjustedSpanImpl2.prototype.updateState = function(paint) {
      var metrics = paint.getFontMetrics();
      if (!this.align || ["baseline", "stretch"].includes(this.align)) {
        return;
      }
      if (this.align === "top") {
        return paint.baselineShift = -this.fontSize - metrics.bottom - metrics.top;
      }
      if (this.align === "bottom") {
        return paint.baselineShift = metrics.bottom;
      }
      if (this.align === "text-top") {
        return paint.baselineShift = -this.fontSize - metrics.descent - metrics.ascent;
      }
      if (this.align === "text-bottom") {
        return paint.baselineShift = metrics.bottom - metrics.descent;
      }
      if (this.align === "middle") {
        return paint.baselineShift = (metrics.descent - metrics.ascent) / 2 - metrics.descent;
      }
      if (this.align === "sup") {
        return paint.baselineShift = -this.fontSize * 0.4;
      }
      if (this.align === "sub") {
        return paint.baselineShift = (metrics.descent - metrics.ascent) * 0.4;
      }
    };
    return BaselineAdjustedSpanImpl2;
  }(android.text.style.MetricAffectingSpan);
  BaselineAdjustedSpan = BaselineAdjustedSpanImpl;
}

class TextBase extends TextBaseCommon {
  constructor() {
    super(...arguments);
    this._tappable = false;
  }
  get nativeTextViewProtected() {
    return super.nativeTextViewProtected;
  }
  initNativeView() {
    super.initNativeView();
    initializeTextTransformation();
    const nativeView = this.nativeTextViewProtected;
    nativeView.setIncludeFontPadding(false);
    this._defaultTransformationMethod = nativeView.getTransformationMethod();
    this._defaultMovementMethod = nativeView.getMovementMethod();
    this._minHeight = nativeView.getMinHeight();
    this._maxHeight = nativeView.getMaxHeight();
    this._minLines = nativeView.getMinLines();
    this._maxLines = nativeView.getMaxLines();
    if (layout.hasRtlSupport() && this._isManualRtlTextStyleNeeded) {
      nativeView.setTextAlignment(android.view.View.TEXT_ALIGNMENT_VIEW_START);
    }
  }
  disposeNativeView() {
    super.disposeNativeView();
    this._tappable = false;
    this._defaultTransformationMethod = null;
    this._defaultMovementMethod = null;
    this._paintFlags = 0;
    this._minHeight = 0;
    this._maxHeight = 0;
    this._minLines = 0;
    this._maxLines = 0;
  }
  resetNativeView() {
    super.resetNativeView();
    const nativeView = this.nativeTextViewProtected;
    nativeView.setSingleLine(this._isSingleLine);
    nativeView.setTransformationMethod(this._defaultTransformationMethod);
    this._defaultTransformationMethod = null;
    if (this._paintFlags !== undefined) {
      nativeView.setPaintFlags(this._paintFlags);
      this._paintFlags = undefined;
    }
    if (this._minLines !== -1) {
      nativeView.setMinLines(this._minLines);
    } else {
      nativeView.setMinHeight(this._minHeight);
    }
    this._minHeight = this._minLines = undefined;
    if (this._maxLines !== -1) {
      nativeView.setMaxLines(this._maxLines);
    } else {
      nativeView.setMaxHeight(this._maxHeight);
    }
    this._maxHeight = this._maxLines = undefined;
  }
  [textProperty2.getDefault]() {
    return resetSymbol;
  }
  [textProperty2.setNative](value) {
    const reset2 = value === resetSymbol;
    if (!reset2 && this.formattedText) {
      return;
    }
    this._setTappableState(false);
    this._setNativeText(reset2);
  }
  [textStrokeProperty.setNative](value) {
    this._setNativeText();
  }
  createFormattedTextNative(value) {
    return createSpannableStringBuilder(value, this.style.fontSize);
  }
  [formattedTextProperty.setNative](value) {
    const nativeView = this.nativeTextViewProtected;
    if (!value) {
      if (nativeView instanceof android.widget.Button && nativeView.getTransformationMethod() instanceof TextTransformation) {
        nativeView.setTransformationMethod(this._defaultTransformationMethod);
      }
    }
    if (this.secure) {
      return;
    }
    const spannableStringBuilder = this.createFormattedTextNative(value);
    nativeView.setText(spannableStringBuilder);
    this._setTappableState(isStringTappable(value));
    textProperty2.nativeValueChange(this, value === null || value === undefined ? "" : value.toString());
    if (spannableStringBuilder && nativeView instanceof android.widget.Button && !(nativeView.getTransformationMethod() instanceof TextTransformation)) {
      nativeView.setTransformationMethod(new TextTransformation(this));
    }
  }
  [textTransformProperty.setNative](value) {
    if (value === "initial") {
      this.nativeTextViewProtected.setTransformationMethod(this._defaultTransformationMethod);
      return;
    }
    if (this.secure) {
      return;
    }
    this.nativeTextViewProtected.setTransformationMethod(new TextTransformation(this));
  }
  [textAlignmentProperty.getDefault]() {
    return "initial";
  }
  [textAlignmentProperty.setNative](value) {
    const supportsRtlTextAlign = layout.hasRtlSupport() && this._isManualRtlTextStyleNeeded;
    const verticalGravity = this.nativeTextViewProtected.getGravity() & android.view.Gravity.VERTICAL_GRAVITY_MASK;
    switch (value) {
      case "left":
      case "justify":
        if (supportsRtlTextAlign) {
          this.nativeTextViewProtected.setTextAlignment(android.view.View.TEXT_ALIGNMENT_GRAVITY);
        }
        this.nativeTextViewProtected.setGravity(android.view.Gravity.LEFT | verticalGravity);
        break;
      case "center":
        if (supportsRtlTextAlign) {
          this.nativeTextViewProtected.setTextAlignment(android.view.View.TEXT_ALIGNMENT_CENTER);
        }
        this.nativeTextViewProtected.setGravity(android.view.Gravity.CENTER_HORIZONTAL | verticalGravity);
        break;
      case "right":
        if (supportsRtlTextAlign) {
          this.nativeTextViewProtected.setTextAlignment(android.view.View.TEXT_ALIGNMENT_GRAVITY);
        }
        this.nativeTextViewProtected.setGravity(android.view.Gravity.RIGHT | verticalGravity);
        break;
      default:
        if (supportsRtlTextAlign) {
          this.nativeTextViewProtected.setTextAlignment(android.view.View.TEXT_ALIGNMENT_VIEW_START);
        }
        this.nativeTextViewProtected.setGravity(android.view.Gravity.START | verticalGravity);
        break;
    }
    if (SDK_VERSION >= 26) {
      if (value === "justify") {
        this.nativeTextViewProtected.setJustificationMode(android.text.Layout.JUSTIFICATION_MODE_INTER_WORD);
      } else {
        this.nativeTextViewProtected.setJustificationMode(android.text.Layout.JUSTIFICATION_MODE_NONE);
      }
    }
  }
  [whiteSpaceProperty.setNative](value) {
    this.adjustLineBreak();
  }
  [textOverflowProperty.setNative](value) {
    this.adjustLineBreak();
  }
  [directionProperty.setNative](value) {
    if (this.whiteSpace === "nowrap" || this.maxLines > 0) {
      this.nativeTextViewProtected.setEllipsize(value === CoreTypes.LayoutDirection.rtl ? android.text.TextUtils.TruncateAt.START : android.text.TextUtils.TruncateAt.END);
    }
    super[directionProperty.setNative](value);
  }
  adjustLineBreak() {
    const whiteSpace = this.whiteSpace;
    const textOverflow = this.textOverflow;
    const nativeView = this.nativeTextViewProtected;
    switch (whiteSpace) {
      case "initial":
      case "normal":
      case "wrap":
        nativeView.setSingleLine(false);
        nativeView.setEllipsize(null);
        break;
      case "nowrap": {
        const isRtl = this.direction === CoreTypes.LayoutDirection.rtl;
        switch (textOverflow) {
          case "initial":
          case "ellipsis":
            nativeView.setSingleLine(true);
            break;
          default:
            nativeView.setSingleLine(false);
            break;
        }
        nativeView.setEllipsize(isRtl ? android.text.TextUtils.TruncateAt.START : android.text.TextUtils.TruncateAt.END);
        break;
      }
    }
  }
  [colorProperty.getDefault]() {
    return this.nativeTextViewProtected.getTextColors();
  }
  [colorProperty.setNative](value) {
    if (!this.formattedText || !(value instanceof Color)) {
      if (value instanceof Color) {
        this.nativeTextViewProtected.setTextColor(value.android);
      } else {
        this.nativeTextViewProtected.setTextColor(value);
      }
    }
  }
  [fontSizeProperty.getDefault]() {
    return { nativeSize: this.nativeTextViewProtected.getTextSize() };
  }
  [fontSizeProperty.setNative](value) {
    if (!this.formattedText || typeof value !== "number") {
      if (typeof value === "number") {
        this.nativeTextViewProtected.setTextSize(value);
      } else {
        this.nativeTextViewProtected.setTextSize(android.util.TypedValue.COMPLEX_UNIT_PX, value.nativeSize);
      }
    }
  }
  [fontInternalProperty.getDefault]() {
    return this.nativeTextViewProtected.getTypeface();
  }
  [fontInternalProperty.setNative](value) {
    if (!this.formattedText || !(value instanceof Font2)) {
      this.nativeTextViewProtected.setTypeface(value instanceof Font2 ? value.getAndroidTypeface() : value);
    }
  }
  [textDecorationProperty.getDefault]() {
    return this._paintFlags = this.nativeTextViewProtected.getPaintFlags();
  }
  [textDecorationProperty.setNative](value) {
    switch (value) {
      case "underline":
        this.nativeTextViewProtected.setPaintFlags(android.graphics.Paint.UNDERLINE_TEXT_FLAG);
        break;
      case "line-through":
        this.nativeTextViewProtected.setPaintFlags(android.graphics.Paint.STRIKE_THRU_TEXT_FLAG);
        break;
      case "underline line-through":
        this.nativeTextViewProtected.setPaintFlags(android.graphics.Paint.UNDERLINE_TEXT_FLAG | android.graphics.Paint.STRIKE_THRU_TEXT_FLAG);
        break;
      default:
        if (value === "none" || isCssWideKeyword(value)) {
          this.nativeTextViewProtected.setPaintFlags(0);
        } else {
          this.nativeTextViewProtected.setPaintFlags(value);
        }
        break;
    }
  }
  [textShadowProperty.getDefault]() {
    return {
      radius: this.nativeTextViewProtected.getShadowRadius(),
      offsetX: this.nativeTextViewProtected.getShadowDx(),
      offsetY: this.nativeTextViewProtected.getShadowDy(),
      color: this.nativeTextViewProtected.getShadowColor()
    };
  }
  [textShadowProperty.setNative](value) {
    this.nativeTextViewProtected.setShadowLayer(Length.toDevicePixels(value.blurRadius, java.lang.Float.MIN_VALUE), Length.toDevicePixels(value.offsetX, 0), Length.toDevicePixels(value.offsetY, 0), value.color.android);
  }
  [paddingTopProperty.getDefault]() {
    return { value: this._defaultPaddingTop, unit: "px" };
  }
  [paddingTopProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingTop(this.nativeTextViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderTopWidth, 0));
  }
  [paddingRightProperty.getDefault]() {
    return { value: this._defaultPaddingRight, unit: "px" };
  }
  [paddingRightProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingRight(this.nativeTextViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderRightWidth, 0));
  }
  [paddingBottomProperty.getDefault]() {
    return { value: this._defaultPaddingBottom, unit: "px" };
  }
  [paddingBottomProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingBottom(this.nativeTextViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderBottomWidth, 0));
  }
  [paddingLeftProperty.getDefault]() {
    return { value: this._defaultPaddingLeft, unit: "px" };
  }
  [paddingLeftProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingLeft(this.nativeTextViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderLeftWidth, 0));
  }
  [lineHeightProperty.getDefault]() {
    return this.nativeTextViewProtected.getLineSpacingExtra() / layout.getDisplayDensity();
  }
  [lineHeightProperty.setNative](value) {
    this.nativeTextViewProtected.setLineSpacing(value * layout.getDisplayDensity(), 1);
  }
  [letterSpacingProperty.getDefault]() {
    return org.nativescript.widgets.ViewHelper.getLetterspacing(this.nativeTextViewProtected);
  }
  [letterSpacingProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setLetterspacing(this.nativeTextViewProtected, value);
  }
  [testIDProperty.setNative](value) {
    this.setAccessibilityIdentifier(this.nativeTextViewProtected, value);
  }
  [accessibilityIdentifierProperty.setNative](value) {
    this.setAccessibilityIdentifier(this.nativeTextViewProtected, value);
  }
  [maxLinesProperty.setNative](value) {
    const nativeTextViewProtected = this.nativeTextViewProtected;
    if (value <= 0) {
      nativeTextViewProtected.setMaxLines(Number.MAX_SAFE_INTEGER);
    } else {
      const isRtl = this.direction === CoreTypes.LayoutDirection.rtl;
      nativeTextViewProtected.setMaxLines(typeof value === "string" ? parseInt(value, 10) : value);
      nativeTextViewProtected.setEllipsize(isRtl ? android.text.TextUtils.TruncateAt.START : android.text.TextUtils.TruncateAt.END);
    }
  }
  _setNativeText(reset2 = false) {
    if (reset2) {
      this.nativeTextViewProtected.setText(null);
      return;
    }
    let transformedText;
    if (this.formattedText) {
      transformedText = this.createFormattedTextNative(this.formattedText);
    } else {
      const text = this.text;
      const stringValue = text === null || text === undefined ? "" : text.toString();
      transformedText = getTransformedText(stringValue, this.textTransform);
    }
    if (this.style?.textStroke) {
      this.nativeTextViewProtected.setTextStroke(Length.toDevicePixels(this.style.textStroke.width), this.style.textStroke.color.android, this.style.color.android);
    } else if (this.nativeTextViewProtected.setTextStroke) {
      this.nativeTextViewProtected.setTextStroke(0, 0, 0);
    }
    this.nativeTextViewProtected.setText(transformedText);
  }
  _setTappableState(tappable) {
    if (this._tappable !== tappable) {
      this._tappable = tappable;
      if (this._tappable) {
        this.nativeTextViewProtected.setSingleLine(false);
        this.nativeTextViewProtected.setMovementMethod(android.text.method.LinkMovementMethod.getInstance());
        this.nativeTextViewProtected.setHighlightColor(null);
      } else {
        this.nativeTextViewProtected.setMovementMethod(this._defaultMovementMethod);
      }
    }
  }
}
function getCapitalizedString(str) {
  let newString = str.toLowerCase();
  newString = newString.replace(/(?:^|\s'*|[-"([{])+\S/g, (c3) => c3.toUpperCase());
  return newString;
}
function getTransformedText(text, textTransform) {
  if (!text || !isString(text)) {
    return "";
  }
  switch (textTransform) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return getCapitalizedString(text);
    case "none":
    default:
      return text;
  }
}
function isStringTappable(formattedString) {
  if (!formattedString) {
    return false;
  }
  for (let i4 = 0, length2 = formattedString.spans.length;i4 < length2; i4++) {
    const span = formattedString.spans.getItem(i4);
    if (span.tappable) {
      return true;
    }
  }
  return false;
}
function createSpannableStringBuilder(formattedString, defaultFontSize) {
  if (!formattedString || !formattedString.parent) {
    return null;
  }
  const ssb = new android.text.SpannableStringBuilder;
  for (let i4 = 0, spanStart = 0, spanLength = 0, length2 = formattedString.spans.length;i4 < length2; i4++) {
    const span = formattedString.spans.getItem(i4);
    const text = span.text;
    const textTransform = formattedString.parent.textTransform;
    let spanText = text === null || text === undefined ? "" : text.toString();
    if (textTransform && textTransform !== "none") {
      spanText = getTransformedText(spanText, textTransform);
    }
    spanLength = spanText.length;
    if (spanLength > 0) {
      ssb.insert(spanStart, spanText);
      setSpanModifiers(ssb, span, spanStart, spanStart + spanLength, defaultFontSize);
      spanStart += spanLength;
    }
  }
  return ssb;
}
function setSpanModifiers(ssb, span, start2, end, defaultFontSize) {
  const spanStyle = span.style;
  const align = spanStyle.verticalAlignment;
  const font = new Font2(spanStyle.fontFamily, spanStyle.fontSize, spanStyle.fontStyle, spanStyle.fontWeight, spanStyle.fontScaleInternal, spanStyle.fontVariationSettings);
  const typefaceSpan = new org.nativescript.widgets.CustomTypefaceSpan(font.getAndroidTypeface());
  ssb.setSpan(typefaceSpan, start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  if (spanStyle.fontSize) {
    ssb.setSpan(new android.text.style.AbsoluteSizeSpan(layout.toDevicePixels(spanStyle.fontSize)), start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
  const color2 = spanStyle.color;
  if (color2) {
    ssb.setSpan(new android.text.style.ForegroundColorSpan(color2.android), start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
  const backgroundColor = spanStyle.backgroundColor || span.parent.backgroundColor;
  if (backgroundColor) {
    ssb.setSpan(new android.text.style.BackgroundColorSpan(backgroundColor.android), start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
  const textDecoration = getClosestPropertyValue(textDecorationProperty, span);
  if (textDecoration) {
    const underline = textDecoration.indexOf("underline") !== -1;
    if (underline) {
      ssb.setSpan(new android.text.style.UnderlineSpan, start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    const strikethrough = textDecoration.indexOf("line-through") !== -1;
    if (strikethrough) {
      ssb.setSpan(new android.text.style.StrikethroughSpan, start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
  }
  if (align) {
    initializeBaselineAdjustedSpan();
    ssb.setSpan(new BaselineAdjustedSpan(layout.toDevicePixels(defaultFontSize), align), start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
  const tappable = span.tappable;
  if (tappable) {
    initializeClickableSpan();
    ssb.setSpan(new ClickableSpan(span), start2, end, android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
}

// node_modules/@nativescript/core/ui/button/button-common.js
var ButtonBase = class ButtonBase2 extends TextBase {
  constructor() {
    super(...arguments);
    this.accessibilityRole = AccessibilityRole.Button;
  }
  get textWrap() {
    return this.style.whiteSpace === "normal";
  }
  set textWrap(value) {
    if (typeof value === "string") {
      value = booleanConverter(value);
    }
    this.style.whiteSpace = value ? "normal" : "nowrap";
  }
};
ButtonBase.tapEvent = "tap";
ButtonBase = __decorate([
  CSSType("Button")
], ButtonBase);
ButtonBase.prototype.recycleNativeView = "auto";

// node_modules/@nativescript/core/ui/button/index.android.js
var ClickListener;
var AndroidButton;
function initializeClickListener() {
  if (ClickListener) {
    return;
  }
  var ClickListenerImpl = function(_super) {
    __extends(ClickListenerImpl2, _super);
    function ClickListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    ClickListenerImpl2.prototype.onClick = function(v) {
      var owner = this.owner;
      if (owner) {
        owner._emit(ButtonBase.tapEvent);
      }
    };
    ClickListenerImpl2 = __decorate([
      Interfaces([android.view.View.OnClickListener])
    ], ClickListenerImpl2);
    return ClickListenerImpl2;
  }(java.lang.Object);
  ClickListener = ClickListenerImpl;
}
function onButtonStateChange(args) {
  const button = args.object;
  switch (args.action) {
    case TouchAction.up:
    case TouchAction.cancel:
      button._removeVisualState("highlighted");
      break;
    case TouchAction.down:
      button._addVisualState("highlighted");
      break;
  }
}

class Button extends ButtonBase {
  createNativeView() {
    if (!AndroidButton) {
      AndroidButton = android.widget.Button;
    }
    return new AndroidButton(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    nativeView.setAllCaps(false);
    initializeClickListener();
    const clickListener = new ClickListener(this);
    nativeView.setOnClickListener(clickListener);
    nativeView.clickListener = clickListener;
  }
  disposeNativeView() {
    if (this.nativeViewProtected?.clickListener) {
      this.nativeViewProtected.clickListener.owner = null;
    }
    super.disposeNativeView();
  }
  resetNativeView() {
    super.resetNativeView();
    if (this._stateListAnimator && SDK_VERSION >= 21) {
      this.nativeViewProtected.setStateListAnimator(this._stateListAnimator);
      this._stateListAnimator = undefined;
    }
  }
  _updateButtonStateChangeHandler(subscribe) {
    if (subscribe) {
      this.on(GestureTypes[GestureTypes.touch], onButtonStateChange);
    } else {
      this.off(GestureTypes[GestureTypes.touch], onButtonStateChange);
      this._removeVisualState("highlighted");
    }
  }
  get needsNativeDrawableFill() {
    return true;
  }
  [minWidthProperty.getDefault]() {
    const dips = org.nativescript.widgets.ViewHelper.getMinWidth(this.nativeViewProtected);
    return { value: dips, unit: "px" };
  }
  [minHeightProperty.getDefault]() {
    const dips = org.nativescript.widgets.ViewHelper.getMinHeight(this.nativeViewProtected);
    return { value: dips, unit: "px" };
  }
  [paddingTopProperty.getDefault]() {
    return { value: this._defaultPaddingTop, unit: "px" };
  }
  [paddingTopProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingTop(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderTopWidth, 0));
  }
  [paddingRightProperty.getDefault]() {
    return { value: this._defaultPaddingRight, unit: "px" };
  }
  [paddingRightProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingRight(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderRightWidth, 0));
  }
  [paddingBottomProperty.getDefault]() {
    return { value: this._defaultPaddingBottom, unit: "px" };
  }
  [paddingBottomProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingBottom(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderBottomWidth, 0));
  }
  [paddingLeftProperty.getDefault]() {
    return { value: this._defaultPaddingLeft, unit: "px" };
  }
  [paddingLeftProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingLeft(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderLeftWidth, 0));
  }
  [zIndexProperty.setNative](value) {
    if (SDK_VERSION >= 21) {
      const nativeView = this.nativeViewProtected;
      if (!this._stateListAnimator) {
        this._stateListAnimator = nativeView.getStateListAnimator();
      }
      nativeView.setStateListAnimator(null);
    }
    org.nativescript.widgets.ViewHelper.setZIndex(this.nativeViewProtected, value);
  }
  [textAlignmentProperty.setNative](value) {
    const newValue = value === "initial" ? "center" : value;
    super[textAlignmentProperty.setNative](newValue);
  }
  getDefaultElevation() {
    if (SDK_VERSION < 21) {
      return 0;
    }
    return 2;
  }
  getDefaultDynamicElevationOffset() {
    if (SDK_VERSION < 21) {
      return 0;
    }
    return 4;
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], Button.prototype, "createNativeView", null);
__decorate([
  PseudoClassHandler("normal", "highlighted", "pressed", "active"),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", undefined)
], Button.prototype, "_updateButtonStateChangeHandler", null);
Button.prototype._ignoreFlexMinWidthHeightReset = true;
// node_modules/@nativescript/core/ui/content-view/index.js
class ContentView extends CustomLayoutView {
  get content() {
    return this._content;
  }
  set content(value) {
    const oldView = this._content;
    if (this._content) {
      this._removeView(this._content);
    }
    this._content = value;
    if (this._content) {
      this._addView(this._content);
    }
    this._onContentChanged(oldView, value);
    if (__APPLE__ && oldView !== value) {
      this.requestLayout();
    }
  }
  get layoutView() {
    let result;
    if (this._content) {
      let first = true;
      this._content._eachLayoutView((child) => {
        if (first) {
          first = false;
          result = child;
        } else {
          throw new Error("More than one layout child inside a ContentView");
        }
      });
    }
    return result;
  }
  get _childrenCount() {
    return this._content ? 1 : 0;
  }
  _onContentChanged(oldView, newView) {}
  _addChildFromBuilder(name50, value) {
    if (value instanceof View) {
      this.content = value;
    }
  }
  eachChildView(callback) {
    const content = this._content;
    if (content) {
      callback(content);
    }
  }
  onMeasure(widthMeasureSpec, heightMeasureSpec) {
    const result = View.measureChild(this, this.layoutView, widthMeasureSpec, heightMeasureSpec);
    const width = layout.getMeasureSpecSize(widthMeasureSpec);
    const widthMode = layout.getMeasureSpecMode(widthMeasureSpec);
    const height = layout.getMeasureSpecSize(heightMeasureSpec);
    const heightMode = layout.getMeasureSpecMode(heightMeasureSpec);
    const measureWidth = Math.max(result.measuredWidth, this.effectiveMinWidth);
    const measureHeight = Math.max(result.measuredHeight, this.effectiveMinHeight);
    const widthAndState = View.resolveSizeAndState(measureWidth, width, widthMode, 0);
    const heightAndState = View.resolveSizeAndState(measureHeight, height, heightMode, 0);
    this.setMeasuredDimension(widthAndState, heightAndState);
  }
  onLayout(left, top, right, bottom) {
    View.layoutChild(this, this.layoutView, 0, 0, right - left, bottom - top);
  }
}
ContentView.prototype.recycleNativeView = "auto";
// node_modules/@nativescript/core/ui/date-picker/date-picker-common.js
var defaultDate = new Date;
var dateComparer = (x2, y2) => x2 <= y2 && x2 >= y2;
var DatePickerBase = class DatePickerBase2 extends View {
};
DatePickerBase.dateChangeEvent = "dateChange";
DatePickerBase = __decorate([
  CSSType("DatePicker")
], DatePickerBase);
DatePickerBase.prototype.recycleNativeView = "auto";
var yearProperty = new Property({
  name: "year",
  defaultValue: defaultDate.getFullYear(),
  valueConverter: (v) => parseInt(v)
});
yearProperty.register(DatePickerBase);
var monthProperty = new Property({
  name: "month",
  defaultValue: defaultDate.getMonth() + 1,
  valueConverter: (v) => parseInt(v)
});
monthProperty.register(DatePickerBase);
var dayProperty = new Property({
  name: "day",
  defaultValue: defaultDate.getDate(),
  valueConverter: (v) => parseInt(v)
});
dayProperty.register(DatePickerBase);
var hourProperty = new Property({
  name: "hour",
  defaultValue: defaultDate.getHours(),
  valueConverter: (v) => parseInt(v)
});
hourProperty.register(DatePickerBase);
var minuteProperty = new Property({
  name: "minute",
  defaultValue: defaultDate.getMinutes(),
  valueConverter: (v) => parseInt(v)
});
minuteProperty.register(DatePickerBase);
var secondProperty = new Property({
  name: "second",
  defaultValue: defaultDate.getSeconds(),
  valueConverter: (v) => parseInt(v)
});
secondProperty.register(DatePickerBase);
var maxDateProperty = new Property({
  name: "maxDate",
  equalityComparer: dateComparer,
  valueConverter: (v) => new Date(v)
});
maxDateProperty.register(DatePickerBase);
var minDateProperty = new Property({
  name: "minDate",
  equalityComparer: dateComparer,
  valueConverter: (v) => new Date(v)
});
minDateProperty.register(DatePickerBase);
var dateProperty = new Property({
  name: "date",
  defaultValue: defaultDate,
  equalityComparer: dateComparer,
  valueConverter: (v) => new Date(v)
});
dateProperty.register(DatePickerBase);
var showTimeProperty = new Property({
  name: "showTime",
  defaultValue: false,
  valueConverter: (v) => booleanConverter(v)
});
showTimeProperty.register(DatePickerBase);
var iosPreferredDatePickerStyleProperty = new Property({
  name: "iosPreferredDatePickerStyle",
  defaultValue: 0,
  valueConverter: (v) => parseInt(v)
});
iosPreferredDatePickerStyleProperty.register(DatePickerBase);

// node_modules/@nativescript/core/ui/time-picker/time-picker-common.js
var dateComparer2 = (x2, y2) => x2 <= y2 && x2 >= y2;
function getValidTime(picker, hour, minute) {
  if (picker.minuteInterval > 1) {
    const minuteFloor = minute - minute % picker.minuteInterval;
    minute = minuteFloor + (minute === minuteFloor + 1 ? picker.minuteInterval : 0);
    if (minute === 60) {
      hour++;
      minute = 0;
    }
  }
  let time3 = { hour, minute };
  if (!isLessThanMaxTime(picker, hour, minute)) {
    time3 = { hour: picker.maxHour, minute: picker.maxMinute };
  }
  if (!isGreaterThanMinTime(picker, hour, minute)) {
    time3 = { hour: picker.minHour, minute: picker.minMinute };
  }
  return time3;
}
function isValidTime(picker) {
  return isGreaterThanMinTime(picker) && isLessThanMaxTime(picker);
}
function isHourValid(value) {
  return typeof value === "number" && value >= 0 && value <= 23;
}
function isMinuteValid(value) {
  return typeof value === "number" && value >= 0 && value <= 59;
}
function isMinuteIntervalValid(value) {
  return typeof value === "number" && value >= 1 && value <= 30 && 60 % value === 0;
}
function getMinutes(hour) {
  return hour * 60;
}
function isDefined2(value) {
  return value !== undefined;
}
function isGreaterThanMinTime(picker, hour, minute) {
  if (picker.minHour === undefined || picker.minMinute === undefined) {
    return true;
  }
  return getMinutes(hour !== undefined ? hour : picker.hour) + (minute !== undefined ? minute : picker.minute) >= getMinutes(picker.minHour) + picker.minMinute;
}
function isLessThanMaxTime(picker, hour, minute) {
  if (!isDefined2(picker.maxHour) || !isDefined2(picker.maxMinute)) {
    return true;
  }
  return getMinutes(isDefined2(hour) ? hour : picker.hour) + (isDefined2(minute) ? minute : picker.minute) <= getMinutes(picker.maxHour) + picker.maxMinute;
}
function toString3(value) {
  if (value instanceof Date) {
    return value + "";
  }
  return value < 10 ? `0${value}` : `${value}`;
}
function getMinMaxTimeErrorMessage(picker) {
  return `Min time: (${toString3(picker.minHour)}:${toString3(picker.minMinute)}), max time: (${toString3(picker.maxHour)}:${toString3(picker.maxMinute)})`;
}
function getErrorMessage(picker, propertyName, newValue) {
  return `${propertyName} property value (${toString3(newValue)}:${toString3(picker.minute)}) is not valid. ${getMinMaxTimeErrorMessage(picker)}.`;
}
var TimePickerBase = class TimePickerBase2 extends View {
};
TimePickerBase.timeChangeEvent = "timeChange";
TimePickerBase = __decorate([
  CSSType("TimePicker")
], TimePickerBase);
TimePickerBase.prototype.recycleNativeView = "auto";
var minHourProperty = new Property({
  name: "minHour",
  defaultValue: 0,
  valueChanged: (picker, oldValue, newValue) => {
    if (!isHourValid(newValue) || !isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "minHour", newValue));
    }
  },
  valueConverter: (v) => parseInt(v)
});
minHourProperty.register(TimePickerBase);
var maxHourProperty = new Property({
  name: "maxHour",
  defaultValue: 23,
  valueChanged: (picker, oldValue, newValue) => {
    if (!isHourValid(newValue) || !isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "maxHour", newValue));
    }
  },
  valueConverter: (v) => parseInt(v)
});
maxHourProperty.register(TimePickerBase);
var minMinuteProperty = new Property({
  name: "minMinute",
  defaultValue: 0,
  valueChanged: (picker, oldValue, newValue) => {
    if (!isMinuteValid(newValue) || !isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "minMinute", newValue));
    }
  },
  valueConverter: (v) => parseInt(v)
});
minMinuteProperty.register(TimePickerBase);
var maxMinuteProperty = new Property({
  name: "maxMinute",
  defaultValue: 59,
  valueChanged: (picker, oldValue, newValue) => {
    if (!isMinuteValid(newValue) || !isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "maxMinute", newValue));
    }
  },
  valueConverter: (v) => parseInt(v)
});
maxMinuteProperty.register(TimePickerBase);
var minuteIntervalProperty = new Property({
  name: "minuteInterval",
  defaultValue: 1,
  valueChanged: (picker, oldValue, newValue) => {
    if (!isMinuteIntervalValid(newValue)) {
      throw new Error(getErrorMessage(picker, "minuteInterval", newValue));
    }
  },
  valueConverter: (v) => parseInt(v)
});
minuteIntervalProperty.register(TimePickerBase);
var minuteProperty2 = new Property({
  name: "minute",
  defaultValue: null,
  valueChanged: (picker, oldValue, newValue) => {
    newValue = newValue || 0;
    if (!isMinuteValid(newValue) || !isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "minute", newValue));
    }
    picker.time = new Date(0, 0, 0, picker.hour, picker.minute);
  },
  valueConverter: (v) => parseInt(v)
});
minuteProperty2.register(TimePickerBase);
var hourProperty2 = new Property({
  name: "hour",
  defaultValue: null,
  valueChanged: (picker, oldValue, newValue) => {
    newValue = newValue || 0;
    if (!isHourValid(newValue) || !isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "Hour", newValue));
    }
    picker.time = new Date(0, 0, 0, picker.hour, picker.minute);
  },
  valueConverter: (v) => parseInt(v)
});
hourProperty2.register(TimePickerBase);
var timeProperty = new Property({
  name: "time",
  defaultValue: new Date,
  equalityComparer: dateComparer2,
  valueChanged: (picker, oldValue, newValue) => {
    if (!isValidTime(picker)) {
      throw new Error(getErrorMessage(picker, "time", newValue));
    }
    picker.hour = newValue.getHours();
    picker.minute = newValue.getMinutes();
  }
});
timeProperty.register(TimePickerBase);
var iosPreferredDatePickerStyleProperty2 = new Property({
  name: "iosPreferredDatePickerStyle",
  defaultValue: 0,
  valueConverter: (v) => parseInt(v)
});
iosPreferredDatePickerStyleProperty2.register(TimePickerBase);

// node_modules/@nativescript/core/ui/time-picker/index.android.js
var TimeChangedListener;
function initializeTimeChangedListener() {
  if (TimeChangedListener) {
    return;
  }
  var TimeChangedListenerImpl = function(_super) {
    __extends(TimeChangedListenerImpl2, _super);
    function TimeChangedListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    TimeChangedListenerImpl2.prototype.onTimeChanged = function(picker, hour, minute) {
      var timePicker = this.owner;
      if (timePicker.updatingNativeValue) {
        return;
      }
      var validTime = getValidTime(timePicker, hour, minute);
      timeProperty.nativeValueChange(timePicker, new Date(0, 0, 0, validTime.hour, validTime.minute));
    };
    TimeChangedListenerImpl2 = __decorate([
      Interfaces([android.widget.TimePicker.OnTimeChangedListener])
    ], TimeChangedListenerImpl2);
    return TimeChangedListenerImpl2;
  }(java.lang.Object);
  TimeChangedListener = TimeChangedListenerImpl;
}

class TimePicker extends TimePickerBase {
  createNativeView() {
    return new android.widget.TimePicker(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    initializeTimeChangedListener();
    const listener = new TimeChangedListener(this);
    nativeView.setOnTimeChangedListener(listener);
    nativeView.listener = listener;
    const calendar = nativeView.calendar = java.util.Calendar.getInstance();
    const hour = hourProperty2.isSet(this) ? this.hour : calendar.get(java.util.Calendar.HOUR_OF_DAY);
    const minute = minuteProperty2.isSet(this) ? this.minute : calendar.get(java.util.Calendar.MINUTE);
    const validTime = getValidTime(this, hour, minute);
    if (!timeProperty.isSet(this)) {
      this.time = new Date(0, 0, 0, validTime.hour, validTime.minute);
    }
  }
  [minuteProperty2.setNative](value) {
    this.updatingNativeValue = true;
    try {
      if (SDK_VERSION >= 23) {
        this.nativeViewProtected.setMinute(value);
      } else {
        this.nativeViewProtected.setCurrentMinute(new java.lang.Integer(value));
      }
    } finally {
      this.updatingNativeValue = false;
    }
  }
  [hourProperty2.setNative](value) {
    this.updatingNativeValue = true;
    try {
      if (SDK_VERSION >= 23) {
        this.nativeViewProtected.setHour(value);
      } else {
        this.nativeViewProtected.setCurrentHour(new java.lang.Integer(value));
      }
    } finally {
      this.updatingNativeValue = false;
    }
  }
}

// node_modules/@nativescript/core/ui/date-picker/index.android.js
var DateChangedListener;
function initializeDateChangedListener() {
  if (DateChangedListener) {
    return;
  }
  var DateChangedListenerImpl = function(_super) {
    __extends(DateChangedListenerImpl2, _super);
    function DateChangedListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    DateChangedListenerImpl2.prototype.onDateChanged = function(picker, year, month, day) {
      var owner = this.owner;
      var dateChanged = false;
      if (year !== owner.year) {
        yearProperty.nativeValueChange(owner, year);
        dateChanged = true;
      }
      if (month !== owner.month - 1) {
        monthProperty.nativeValueChange(owner, month + 1);
        dateChanged = true;
      }
      if (day !== owner.day) {
        dayProperty.nativeValueChange(owner, day);
        dateChanged = true;
      }
      if (dateChanged || owner.showTime && owner.timePicker) {
        var newDate = undefined;
        if (owner.showTime && owner.timePicker) {
          var dateTime = owner.timePicker.time;
          newDate = new Date(year, month, day, dateTime.getHours(), dateTime.getMinutes(), dateTime.getSeconds(), dateTime.getMilliseconds());
        } else {
          newDate = new Date(year, month, day);
        }
        dateProperty.nativeValueChange(owner, newDate);
      }
    };
    DateChangedListenerImpl2 = __decorate([
      Interfaces([android.widget.DatePicker.OnDateChangedListener])
    ], DateChangedListenerImpl2);
    return DateChangedListenerImpl2;
  }(java.lang.Object);
  DateChangedListener = DateChangedListenerImpl;
}

class DatePicker extends DatePickerBase {
  createNativeView() {
    const picker = new android.widget.DatePicker(this._context);
    picker.setCalendarViewShown(false);
    return picker;
  }
  initNativeView() {
    super.initNativeView();
    initializeDateChangedListener();
    const nativeView = this.nativeViewProtected;
    const listener = new DateChangedListener(this);
    nativeView.init(this.year, this.month - 1, this.day, listener);
    nativeView.listener = listener;
    if (this.showTime) {
      this.timePicker = new TimePicker;
      this.timePicker.width = this.width;
      this.timePicker.height = this.height;
      this.timePicker.on("timeChange", (args) => {
        this.updateNativeDate();
      });
      this.parent.addChild(this.timePicker);
    }
  }
  disposeNativeView() {
    if (this.timePicker) {
      this.timePicker.disposeNativeView();
    }
    if (this.nativeViewProtected?.listener) {
      this.nativeViewProtected.listener.owner = null;
    }
    super.disposeNativeView();
  }
  updateNativeDate() {
    const nativeView = this.nativeViewProtected;
    const year = typeof this.year === "number" ? this.year : nativeView.getYear();
    const month = typeof this.month === "number" ? this.month - 1 : nativeView.getMonth();
    const day = typeof this.day === "number" ? this.day : nativeView.getDayOfMonth();
    if (this.showTime && this.timePicker) {
      const time3 = this.timePicker.time || new Date;
      this.date = new Date(year, month, day, time3.getHours(), time3.getMinutes(), time3.getSeconds(), time3.getMilliseconds());
    } else {
      this.date = new Date(year, month, day);
    }
  }
  [yearProperty.setNative](value) {
    if (this.nativeViewProtected.getYear() !== value) {
      this.updateNativeDate();
    }
  }
  [monthProperty.setNative](value) {
    if (this.nativeViewProtected.getMonth() !== value - 1) {
      this.updateNativeDate();
    }
  }
  [dayProperty.setNative](value) {
    if (this.nativeViewProtected.getDayOfMonth() !== value) {
      this.updateNativeDate();
    }
  }
  [dateProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    if (value && (nativeView.getDayOfMonth() !== value.getDate() || nativeView.getMonth() !== value.getMonth() || nativeView.getYear() !== value.getFullYear())) {
      nativeView.updateDate(value.getFullYear(), value.getMonth(), value.getDate());
    }
  }
  [maxDateProperty.getDefault]() {
    return this.nativeViewProtected.getMaxDate();
  }
  [maxDateProperty.setNative](value) {
    const newValue = value instanceof Date ? value.getTime() : value;
    this.nativeViewProtected.setMaxDate(newValue);
  }
  [minDateProperty.getDefault]() {
    return this.nativeViewProtected.getMinDate();
  }
  [minDateProperty.setNative](value) {
    const newValue = value instanceof Date ? value.getTime() : value;
    this.nativeViewProtected.setMinDate(newValue);
  }
}
// node_modules/@nativescript/core/ui/frame/frame-interfaces.js
var NavigationType;
(function(NavigationType2) {
  NavigationType2[NavigationType2["back"] = 0] = "back";
  NavigationType2[NavigationType2["forward"] = 1] = "forward";
  NavigationType2[NavigationType2["replace"] = 2] = "replace";
})(NavigationType || (NavigationType = {}));

// node_modules/@nativescript/core/ui/frame/frame-helpers.js
var FRAME_SYMBOL = Symbol("FRAME_SYMBOL");
function isFrame(object) {
  return object && object[FRAME_SYMBOL] === true;
}

// node_modules/@nativescript/core/ui/frame/frame-common.js
var FrameBase_1;
function buildEntryFromArgs(arg) {
  let entry;
  if (typeof arg === "string") {
    entry = {
      moduleName: arg
    };
  } else if (typeof arg === "function") {
    entry = {
      create: arg
    };
  } else {
    entry = arg;
  }
  return entry;
}
var FrameBase = FrameBase_1 = class FrameBase2 extends CustomLayoutView {
  constructor() {
    super(...arguments);
    this._backStack = new Array;
    this._navigationQueue = new Array;
    this._animationInProgress = false;
    this._isInFrameStack = false;
  }
  static getFrameById(id) {
    return frameStack.find((frame) => frame.id && frame.id === id);
  }
  static topmost() {
    return topmost();
  }
  static goBack() {
    const top = FrameBase_1.topmost();
    if (top && top.canGoBack()) {
      top.goBack();
      return true;
    } else if (top) {
      let parentFrameCanGoBack = false;
      let parentFrame = getAncestor(top, "Frame");
      while (parentFrame && !parentFrameCanGoBack) {
        if (parentFrame && parentFrame.canGoBack()) {
          parentFrameCanGoBack = true;
        } else {
          parentFrame = getAncestor(parentFrame, "Frame");
        }
      }
      if (parentFrame && parentFrameCanGoBack) {
        parentFrame.goBack();
        return true;
      }
    }
    if (frameStack.length > 1) {
      top._popFromFrameStack();
    }
    return false;
  }
  static reloadPage() {}
  static _stack() {
    return frameStack;
  }
  _addChildFromBuilder(name50, value) {
    throw new Error(`Frame should not have a view. Use 'defaultPage' property instead.`);
  }
  onLoaded() {
    super.onLoaded();
    this._processNextNavigationEntry();
  }
  canGoBack() {
    let backstack = this._backStack.length;
    let previousForwardNotInBackstack = false;
    this._navigationQueue.forEach((item) => {
      const entry = item.entry;
      const isBackNavigation = item.navigationType === NavigationType.back;
      if (isBackNavigation) {
        previousForwardNotInBackstack = false;
        if (!entry) {
          backstack--;
        } else {
          const backstackIndex = this._backStack.indexOf(entry);
          if (backstackIndex !== -1) {
            backstack = backstackIndex;
          } else {
            backstack--;
          }
        }
      } else if (entry.entry.clearHistory) {
        previousForwardNotInBackstack = false;
        backstack = 0;
      } else {
        backstack++;
        if (previousForwardNotInBackstack) {
          backstack--;
        }
        previousForwardNotInBackstack = entry.entry.backstackVisible === false;
      }
    });
    if (this._navigationQueue.length > 0 && !this._currentEntry) {
      backstack--;
    }
    return backstack > 0;
  }
  goBack(backstackEntry) {
    if (Trace.isEnabled()) {
      Trace.write(`GO BACK`, Trace.categories.Navigation);
    }
    if (!this.canGoBack()) {
      return;
    }
    if (backstackEntry) {
      const index = this._backStack.indexOf(backstackEntry);
      if (index < 0) {
        return;
      }
    }
    const navigationContext = {
      entry: backstackEntry,
      isBackNavigation: true,
      navigationType: NavigationType.back
    };
    this._navigationQueue.push(navigationContext);
    this._processNextNavigationEntry();
  }
  _removeEntry(removed) {
    const page = removed.resolvedPage;
    if (page) {
      const frame = page.frame;
      if (frame) {
        frame._removeView(page);
      } else {
        page._tearDownUI(true);
      }
    } else {
      if (Trace.isEnabled()) {
        Trace.write(`_removeEntry: backstack entry missing page`, Trace.categories.Navigation);
      }
    }
    removed.resolvedPage = null;
  }
  _disposeBackstackEntry(entry) {
    const page = entry.resolvedPage;
    if (page) {
      page._tearDownUI(true);
    }
  }
  navigate(param) {
    if (Trace.isEnabled()) {
      Trace.write(`NAVIGATE`, Trace.categories.Navigation);
    }
    this._pushInFrameStack();
    const entry = buildEntryFromArgs(param);
    const page = Builder.createViewFromEntry(entry);
    const backstackEntry = {
      entry,
      resolvedPage: page,
      navDepth: undefined,
      fragmentTag: undefined
    };
    const navigationContext = {
      entry: backstackEntry,
      isBackNavigation: false,
      navigationType: NavigationType.forward
    };
    this._navigationQueue.push(navigationContext);
    this._processNextNavigationEntry();
  }
  isCurrent(entry) {
    return this._currentEntry === entry;
  }
  setCurrent(entry, navigationType) {
    const fromEntry = this._currentEntry;
    const newPage = entry.resolvedPage;
    if (!newPage.frame) {
      this._resolvedPage = newPage;
      this._addView(newPage);
    }
    this._currentEntry = entry;
    const isBack = navigationType === NavigationType.back;
    if (isBack) {
      this._pushInFrameStack();
    }
    newPage.onNavigatedTo(isBack);
    this.notify({
      eventName: FrameBase_1.navigatedToEvent,
      object: this,
      isBack,
      entry,
      fromEntry
    });
    this._executingContext = null;
  }
  _updateBackstack(entry, navigationType) {
    const isBack = navigationType === NavigationType.back;
    const isReplace = navigationType === NavigationType.replace;
    this.raiseCurrentPageNavigatedEvents(isBack);
    const current2 = this._currentEntry;
    if (isBack) {
      const index = this._backStack.indexOf(entry);
      this._backStack.splice(index + 1).forEach((e3) => this._removeEntry(e3));
      this._backStack.pop();
    } else if (!isReplace) {
      if (entry.entry.clearHistory) {
        this._backStack.forEach((e3) => {
          if (e3 !== entry) {
            this._removeEntry(e3);
          } else {
            Trace.write(`Failed to dispose backstack entry ${entry}. This entry is the one frame is navigating to.`, Trace.categories.Navigation, Trace.messageType.warn);
          }
        });
        this._backStack.length = 0;
      } else if (FrameBase_1._isEntryBackstackVisible(current2)) {
        this._backStack.push(current2);
      }
    }
    if (current2 && this._backStack.indexOf(current2) < 0) {
      this._removeEntry(current2);
    }
  }
  isNestedWithin(parentFrameCandidate) {
    let frameAncestor = this;
    while (frameAncestor) {
      frameAncestor = getAncestor(frameAncestor, FrameBase_1);
      if (frameAncestor === parentFrameCandidate) {
        return true;
      }
    }
    return false;
  }
  raiseCurrentPageNavigatedEvents(isBack) {
    const page = this.currentPage;
    if (page) {
      if (page.isLoaded) {
        page.callUnloaded();
      }
      page.onNavigatedFrom(isBack);
    }
  }
  _processNavigationQueue(page) {
    if (this._navigationQueue.length === 0) {
      return;
    }
    const entry = this._navigationQueue[0].entry;
    const currentNavigationPage = entry.resolvedPage;
    if (page !== currentNavigationPage) {
      return;
    }
    this._navigationQueue.shift();
    this._processNextNavigationEntry();
    this._updateActionBar();
  }
  _findEntryForTag(fragmentTag) {
    let entry;
    if (this._currentEntry && this._currentEntry.fragmentTag === fragmentTag) {
      entry = this._currentEntry;
    } else {
      entry = this._backStack.find((value) => value.fragmentTag === fragmentTag);
      if (!entry) {
        const navigationItem = this._navigationQueue.find((value) => value.entry.fragmentTag === fragmentTag);
        entry = navigationItem ? navigationItem.entry : undefined;
      }
    }
    return entry;
  }
  getNavigationQueueContextByEntry(entry) {
    for (const context of this._navigationQueue) {
      if (context.entry === entry) {
        return context;
      }
    }
    return null;
  }
  navigationQueueIsEmpty() {
    return this._navigationQueue.length === 0;
  }
  static _isEntryBackstackVisible(entry) {
    if (!entry) {
      return false;
    }
    const backstackVisibleValue = entry.entry.backstackVisible;
    const backstackHidden = backstackVisibleValue !== undefined && !backstackVisibleValue;
    return !backstackHidden;
  }
  _updateActionBar(page, disableNavBarAnimation) {}
  _processNextNavigationEntry() {
    if (!this.isLoaded || this._executingContext) {
      return;
    }
    if (this._navigationQueue.length > 0) {
      const navigationContext = this._navigationQueue[0];
      const isBackNavigation = navigationContext.navigationType === NavigationType.back;
      if (isBackNavigation) {
        this.performGoBack(navigationContext);
      } else {
        this.performNavigation(navigationContext);
      }
    }
  }
  performNavigation(navigationContext) {
    this._executingContext = navigationContext;
    const backstackEntry = navigationContext.entry;
    const isBackNavigation = navigationContext.navigationType === NavigationType.back;
    this._onNavigatingTo(backstackEntry, isBackNavigation);
    const navigationTransition = this._getNavigationTransition(backstackEntry.entry);
    if (navigationTransition?.instance) {
      const state = SharedTransition.getState(navigationTransition?.instance.id);
      SharedTransition.updateState(navigationTransition?.instance.id, {
        page: state?.page || this.currentPage,
        toPage: this
      });
    }
    this._navigateCore(backstackEntry);
  }
  performGoBack(navigationContext) {
    const backstack = this._backStack;
    const backstackEntry = navigationContext.entry || backstack[backstack.length - 1];
    if (backstackEntry) {
      navigationContext.entry = backstackEntry;
      this._executingContext = navigationContext;
      this._onNavigatingTo(backstackEntry, true);
      this._goBackCore(backstackEntry);
    } else {
      Trace.write("Frame.performGoBack: No backstack entry found to navigate back to", Trace.categories.Navigation, Trace.messageType.warn);
    }
  }
  _goBackCore(backstackEntry) {
    if (Trace.isEnabled()) {
      Trace.write(`GO BACK CORE(${this._backstackEntryTrace(backstackEntry)}); currentPage: ${this.currentPage}`, Trace.categories.Navigation);
    }
  }
  _navigateCore(backstackEntry) {
    if (Trace.isEnabled()) {
      Trace.write(`NAVIGATE CORE(${this._backstackEntryTrace(backstackEntry)}); currentPage: ${this.currentPage}`, Trace.categories.Navigation);
    }
  }
  _onNavigatingTo(backstackEntry, isBack) {
    if (this.currentPage) {
      this.currentPage.onNavigatingFrom(isBack);
    }
    backstackEntry.resolvedPage.onNavigatingTo(backstackEntry.entry.context, isBack, backstackEntry.entry.bindingContext);
    this.notify({
      eventName: FrameBase_1.navigatingToEvent,
      object: this,
      isBack,
      entry: backstackEntry,
      fromEntry: this._currentEntry
    });
  }
  get animated() {
    return this._animated;
  }
  set animated(value) {
    this._animated = value;
  }
  get transition() {
    return this._transition;
  }
  set transition(value) {
    this._transition = value;
  }
  get backStack() {
    return this._backStack.slice();
  }
  get currentPage() {
    if (this._currentEntry) {
      return this._currentEntry.resolvedPage;
    }
    return null;
  }
  get currentEntry() {
    if (this._currentEntry) {
      return this._currentEntry.entry;
    }
    return null;
  }
  _pushInFrameStackRecursive() {
    this._pushInFrameStack();
    const framesToPush = [];
    for (const frame of frameStack) {
      if (frame.isNestedWithin(this)) {
        framesToPush.push(frame);
      }
    }
    for (const frame of framesToPush) {
      frame._pushInFrameStack();
    }
  }
  _isFrameStackEmpty() {
    return _isFrameStackEmpty();
  }
  _pushInFrameStack() {
    _pushInFrameStack(this);
  }
  _popFromFrameStack() {
    _popFromFrameStack(this);
  }
  _removeFromFrameStack() {
    _removeFromFrameStack(this);
  }
  _dialogClosed() {
    this._removeFromFrameStack();
  }
  _onRootViewReset() {
    super._onRootViewReset();
    this._removeFromFrameStack();
  }
  get _childrenCount() {
    if (this._resolvedPage) {
      return 1;
    }
    return 0;
  }
  eachChildView(callback) {
    const page = this._resolvedPage;
    if (page) {
      callback(page);
    }
  }
  _getIsAnimatedNavigation(entry) {
    if (entry && entry.animated !== undefined) {
      return entry.animated;
    }
    if (this.animated !== undefined) {
      return this.animated;
    }
    return FrameBase_1.defaultAnimatedNavigation;
  }
  _getNavigationTransition(entry) {
    if (entry) {
      if (__APPLE__ && entry.transitioniOS !== undefined) {
        return entry.transitioniOS;
      }
      if (__ANDROID__ && entry.transitionAndroid !== undefined) {
        return entry.transitionAndroid;
      }
      if (entry.transition !== undefined) {
        return entry.transition;
      }
    }
    if (this.transition !== undefined) {
      return this.transition;
    }
    return FrameBase_1.defaultTransition;
  }
  get navigationBarHeight() {
    return 0;
  }
  _getNavBarVisible(page) {
    throw new Error;
  }
  _addViewToNativeVisualTree(child) {
    return true;
  }
  _removeViewFromNativeVisualTree(child) {
    child._isAddedToNativeVisualTree = false;
  }
  _printFrameBackStack() {
    const length2 = this.backStack.length;
    let i4 = length2 - 1;
    console.log(`Frame Back Stack: `);
    while (i4 >= 0) {
      const backstackEntry = this.backStack[i4--];
      console.log(`	${backstackEntry.resolvedPage}`);
    }
  }
  _backstackEntryTrace(b2) {
    let result = `${b2.resolvedPage}`;
    const backstackVisible = FrameBase_1._isEntryBackstackVisible(b2);
    if (!backstackVisible) {
      result += ` | INVISIBLE`;
    }
    if (b2.entry.clearHistory) {
      result += ` | CLEAR HISTORY`;
    }
    const animated = this._getIsAnimatedNavigation(b2.entry);
    if (!animated) {
      result += ` | NOT ANIMATED`;
    }
    const t3 = this._getNavigationTransition(b2.entry);
    if (t3) {
      result += ` | Transition[${JSON.stringify(t3)}]`;
    }
    return result;
  }
  _onLivesync(context) {
    if (super._onLivesync(context)) {
      return true;
    }
    if (!context) {
      return this._onLivesyncWithoutContext();
    }
    return false;
  }
  _handleLivesync(context) {
    if (super._handleLivesync(context)) {
      return true;
    }
    if (this.currentPage && viewMatchesModuleContext(this.currentPage, context, ["markup", "script"])) {
      Trace.write(`Change Handled: Replacing page ${context.path}`, Trace.categories.Livesync);
      this.replacePage({
        moduleName: context.path,
        transition: {
          name: "fade",
          duration: 100
        }
      });
      return true;
    }
    return false;
  }
  _onLivesyncWithoutContext() {
    if (Trace.isEnabled()) {
      Trace.write(`${this}._onLivesyncWithoutContext()`, Trace.categories.Livesync);
    }
    if (!this._currentEntry || !this._currentEntry.entry) {
      return false;
    }
    const currentEntry = this._currentEntry.entry;
    if (currentEntry.create) {
      const page = currentEntry.create();
      if (page === this.currentPage) {
        return false;
      }
    }
    this.replacePage({
      moduleName: currentEntry.moduleName,
      create: currentEntry.create,
      transition: {
        name: "fade",
        duration: 100
      }
    });
    return true;
  }
  replacePage(entry) {
    const currentBackstackEntry = this._currentEntry;
    if (typeof entry === "string") {
      const contextModuleName = sanitizeModuleName(entry);
      entry = { moduleName: contextModuleName };
    }
    const newPage = Builder.createViewFromEntry(entry);
    const newBackstackEntry = {
      entry: Object.assign({}, currentBackstackEntry.entry, entry),
      resolvedPage: newPage,
      navDepth: currentBackstackEntry.navDepth,
      fragmentTag: currentBackstackEntry.fragmentTag,
      frameId: currentBackstackEntry.frameId
    };
    const navigationContext = {
      entry: newBackstackEntry,
      isBackNavigation: false,
      navigationType: NavigationType.replace
    };
    this._navigationQueue.push(navigationContext);
    this._processNextNavigationEntry();
  }
};
FrameBase.navigatingToEvent = "navigatingTo";
FrameBase.navigatedToEvent = "navigatedTo";
FrameBase.defaultAnimatedNavigation = true;
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], FrameBase.prototype, "onLoaded", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", undefined)
], FrameBase.prototype, "performNavigation", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", undefined)
], FrameBase.prototype, "performGoBack", null);
FrameBase = FrameBase_1 = __decorate([
  CSSType("Frame")
], FrameBase);
FrameBase.prototype[FRAME_SYMBOL] = true;
function _stack() {
  console.log("_stack() is deprecated. Use Frame._stack() instead.");
  return FrameBase._stack();
}
var defaultPageProperty = new Property({
  name: "defaultPage",
  valueChanged: (frame, oldValue, newValue) => {
    frame.navigate({ moduleName: newValue });
  }
});
defaultPageProperty.register(FrameBase);
var actionBarVisibilityProperty = new Property({ name: "actionBarVisibility", defaultValue: "auto", affectsLayout: __APPLE__ });
actionBarVisibilityProperty.register(FrameBase);

// node_modules/@nativescript/core/ui/transition/index.android.js
var _defaultInterpolator = lazy(() => new android.view.animation.AccelerateDecelerateInterpolator);
var transitionId = 0;

class Transition {
  constructor(duration = 350, curve) {
    this._duration = duration;
    this._interpolator = curve ? _resolveAnimationCurve(curve) : _defaultInterpolator();
    transitionId++;
    this.id = transitionId;
  }
  getDuration() {
    return this._duration;
  }
  setDuration(value) {
    this._duration = value;
  }
  getCurve() {
    return this._interpolator;
  }
  animateIOSTransition(transitionContext, fromViewCtrl, toViewCtrl, operation) {
    throw new Error("Abstract method call");
  }
  createAndroidAnimator(transitionType) {
    throw new Error("Abstract method call");
  }
  toString() {
    return `Transition@${this.id}`;
  }
}
Transition.AndroidTransitionType = {
  enter: "enter",
  exit: "exit",
  popEnter: "popEnter",
  popExit: "popExit"
};

// node_modules/@nativescript/core/ui/transition/flip-transition.android.js
class FlipTransition extends Transition {
  constructor(direction, duration, curve) {
    super(duration, curve);
    this._direction = direction;
  }
  createAndroidAnimator(transitionType) {
    let objectAnimators;
    let values;
    let animator;
    const animatorSet = new android.animation.AnimatorSet;
    const fullDuration = this.getDuration() || 300;
    const interpolator = this.getCurve();
    const rotationY = this._direction === "right" ? 180 : -180;
    switch (transitionType) {
      case Transition.AndroidTransitionType.enter:
        objectAnimators = Array.create(android.animation.Animator, 2);
        values = Array.create("float", 2);
        values[0] = rotationY;
        values[1] = 0;
        animator = android.animation.ObjectAnimator.ofFloat(null, "rotationY", values);
        animator.setInterpolator(interpolator);
        animator.setDuration(fullDuration);
        objectAnimators[0] = animator;
        values = Array.create("float", 3);
        values[0] = 0;
        values[1] = 0;
        values[2] = 255;
        animator = android.animation.ObjectAnimator.ofFloat(null, "alpha", values);
        animator.setDuration(fullDuration / 2);
        objectAnimators[1] = animator;
        break;
      case Transition.AndroidTransitionType.exit:
        objectAnimators = Array.create(android.animation.Animator, 2);
        values = Array.create("float", 2);
        values[0] = 0;
        values[1] = -rotationY;
        animator = android.animation.ObjectAnimator.ofFloat(null, "rotationY", values);
        animator.setInterpolator(interpolator);
        animator.setDuration(fullDuration);
        objectAnimators[0] = animator;
        values = Array.create("float", 3);
        values[0] = 255;
        values[1] = 0;
        values[2] = 0;
        animator = android.animation.ObjectAnimator.ofFloat(null, "alpha", values);
        animator.setDuration(fullDuration / 2);
        objectAnimators[1] = animator;
        break;
      case Transition.AndroidTransitionType.popEnter:
        objectAnimators = Array.create(android.animation.Animator, 2);
        values = Array.create("float", 2);
        values[0] = -rotationY;
        values[1] = 0;
        animator = android.animation.ObjectAnimator.ofFloat(null, "rotationY", values);
        animator.setInterpolator(interpolator);
        animator.setDuration(fullDuration);
        objectAnimators[0] = animator;
        values = Array.create("float", 3);
        values[0] = 0;
        values[1] = 0;
        values[2] = 255;
        animator = android.animation.ObjectAnimator.ofFloat(null, "alpha", values);
        animator.setDuration(fullDuration / 2);
        objectAnimators[1] = animator;
        break;
      case Transition.AndroidTransitionType.popExit:
        objectAnimators = Array.create(android.animation.Animator, 2);
        values = Array.create("float", 2);
        values[0] = 0;
        values[1] = rotationY;
        animator = android.animation.ObjectAnimator.ofFloat(null, "rotationY", values);
        animator.setInterpolator(interpolator);
        animator.setDuration(fullDuration);
        objectAnimators[0] = animator;
        values = Array.create("float", 3);
        values[0] = 255;
        values[1] = 0;
        values[2] = 0;
        animator = android.animation.ObjectAnimator.ofFloat(null, "alpha", values);
        animator.setDuration(fullDuration / 2);
        objectAnimators[1] = animator;
        break;
    }
    animatorSet.playTogether(objectAnimators);
    return animatorSet;
  }
}
// node_modules/@nativescript/core/ui/frame/fragment.transitions.android.js
var defaultInterpolator = lazy(() => new android.view.animation.AccelerateDecelerateInterpolator);
var animFadeIn = 17432576;
var animFadeOut = 17432577;
var waitingQueue = new Map;
var completedEntries = new Map;
var TransitionListener;
var AnimationListener;
function _setAndroidFragmentTransitions(animated, navigationTransition, currentEntry, newEntry, frameId, fragmentTransaction, layoutDirection2, isNestedDefaultTransition) {
  const currentFragment = currentEntry ? currentEntry.fragment : null;
  const newFragment = newEntry.fragment;
  const entries = waitingQueue.get(frameId);
  if (entries && entries.size > 0) {
    throw new Error("Calling navigation before previous navigation finish.");
  }
  newEntry.isAnimationRunning = false;
  allowTransitionOverlap(currentFragment);
  allowTransitionOverlap(newFragment);
  let name50 = "";
  let transition;
  if (navigationTransition) {
    transition = navigationTransition.instance;
    name50 = navigationTransition.name ? navigationTransition.name.toLowerCase() : "";
  }
  if (!animated) {
    name50 = "none";
  } else if (transition) {
    name50 = "custom";
  } else if (name50.indexOf("slide") !== 0 && name50 !== "fade" && name50.indexOf("flip") !== 0 && name50.indexOf("explode") !== 0) {
    name50 = "default";
  }
  let currentFragmentNeedsDifferentAnimation = false;
  if (currentEntry) {
    _updateTransitions(currentEntry);
    if (currentEntry.transitionName !== name50 || currentEntry.transition !== transition || isNestedDefaultTransition) {
      clearExitAndReenterTransitions(currentEntry, true);
      currentFragmentNeedsDifferentAnimation = true;
    }
  }
  if (name50 === "none") {
    const noTransition = new NoTransition(0, null);
    if (isNestedDefaultTransition) {
      fragmentTransaction.setCustomAnimations(animFadeIn, animFadeOut);
      setupAllAnimation(newEntry, noTransition);
      setupNewFragmentCustomTransition({ duration: 0, curve: null }, newEntry, noTransition);
    } else {
      setupNewFragmentCustomTransition({ duration: 0, curve: null }, newEntry, noTransition);
    }
    newEntry.isNestedDefaultTransition = isNestedDefaultTransition;
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentCustomTransition({ duration: 0, curve: null }, currentEntry, noTransition);
    }
  } else if (name50 === "custom") {
    setupNewFragmentCustomTransition({
      duration: transition.getDuration(),
      curve: transition.getCurve()
    }, newEntry, transition);
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentCustomTransition({
        duration: transition.getDuration(),
        curve: transition.getCurve()
      }, currentEntry, transition);
    }
  } else if (name50 === "default") {
    setupNewFragmentFadeTransition({ duration: 150, curve: null }, newEntry);
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentFadeTransition({ duration: 150, curve: null }, currentEntry);
    }
  } else if (name50.indexOf("slide") === 0) {
    const defaultDirection = layoutDirection2 === CoreTypes.LayoutDirection.rtl ? "right" : "left";
    const direction = name50.substring("slide".length) || defaultDirection;
    setupNewFragmentSlideTransition(navigationTransition, newEntry, direction);
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentSlideTransition(navigationTransition, currentEntry, direction);
    }
  } else if (name50 === "fade") {
    setupNewFragmentFadeTransition(navigationTransition, newEntry);
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentFadeTransition(navigationTransition, currentEntry);
    }
  } else if (name50 === "explode") {
    setupNewFragmentExplodeTransition(navigationTransition, newEntry);
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentExplodeTransition(navigationTransition, currentEntry);
    }
  } else if (name50.indexOf("flip") === 0) {
    const defaultDirection = layoutDirection2 === CoreTypes.LayoutDirection.rtl ? "left" : "right";
    const direction = name50.substring("flip".length) || defaultDirection;
    const flipTransition = new FlipTransition(direction, navigationTransition.duration, navigationTransition.curve);
    setupNewFragmentCustomTransition(navigationTransition, newEntry, flipTransition);
    if (currentFragmentNeedsDifferentAnimation) {
      setupCurrentFragmentCustomTransition(navigationTransition, currentEntry, flipTransition);
    }
  }
  newEntry.transitionName = name50;
  if (currentEntry) {
    currentEntry.transitionName = name50;
    if (name50 === "custom") {
      currentEntry.transition = transition;
    }
  }
  printTransitions(currentEntry);
  printTransitions(newEntry);
}
function setupAllAnimation(entry, transition) {
  setupExitAndPopEnterAnimation(entry, transition);
  const listener = getAnimationListener();
  const enterAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.enter);
  enterAnimator.transitionType = Transition.AndroidTransitionType.enter;
  enterAnimator.entry = entry;
  enterAnimator.addListener(listener);
  entry.enterAnimator = enterAnimator;
  const popExitAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.popExit);
  popExitAnimator.transitionType = Transition.AndroidTransitionType.popExit;
  popExitAnimator.entry = entry;
  popExitAnimator.addListener(listener);
  entry.popExitAnimator = popExitAnimator;
}
function setupExitAndPopEnterAnimation(entry, transition) {
  const listener = getAnimationListener();
  clearAnimationListener(entry.exitAnimator, listener);
  clearAnimationListener(entry.popEnterAnimator, listener);
  const exitAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.exit);
  exitAnimator.transitionType = Transition.AndroidTransitionType.exit;
  exitAnimator.entry = entry;
  exitAnimator.addListener(listener);
  entry.exitAnimator = exitAnimator;
  const popEnterAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.popEnter);
  popEnterAnimator.transitionType = Transition.AndroidTransitionType.popEnter;
  popEnterAnimator.entry = entry;
  popEnterAnimator.addListener(listener);
  entry.popEnterAnimator = popEnterAnimator;
}
function getAnimationListener() {
  if (!AnimationListener) {
    var AnimationListenerImpl = function(_super) {
      __extends(AnimationListenerImpl2, _super);
      function AnimationListenerImpl2() {
        var _this = _super.call(this) || this;
        return global.__native(_this);
      }
      AnimationListenerImpl2.prototype.onAnimationStart = function(animator) {
        var entry = animator.entry;
        addToWaitingQueue(entry);
        if (Trace.isEnabled()) {
          Trace.write("START ".concat(animator.transitionType, " for ").concat(entry.fragmentTag), Trace.categories.Transition);
        }
        entry.isAnimationRunning = true;
      };
      AnimationListenerImpl2.prototype.onAnimationRepeat = function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("REPEAT ".concat(animator.transitionType, " for ").concat(animator.entry.fragmentTag), Trace.categories.Transition);
        }
      };
      AnimationListenerImpl2.prototype.onAnimationEnd = function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("END ".concat(animator.transitionType, " for ").concat(animator.entry.fragmentTag), Trace.categories.Transition);
        }
        animator.entry.isAnimationRunning = false;
        transitionOrAnimationCompleted(animator.entry, animator.backEntry);
      };
      AnimationListenerImpl2.prototype.onAnimationCancel = function(animator) {
        if (Trace.isEnabled()) {
          Trace.write("CANCEL ".concat(animator.transitionType, " for ").concat(animator.entry.fragmentTag), Trace.categories.Transition);
        }
        animator.entry.isAnimationRunning = false;
      };
      AnimationListenerImpl2 = __decorate([
        Interfaces([android.animation.Animator.AnimatorListener])
      ], AnimationListenerImpl2);
      return AnimationListenerImpl2;
    }(java.lang.Object);
    AnimationListener = new AnimationListenerImpl;
  }
  return AnimationListener;
}
function clearAnimationListener(animator, listener) {
  if (!animator) {
    return;
  }
  animator.removeListener(listener);
  if (animator.entry && Trace.isEnabled()) {
    const entry = animator.entry;
    Trace.write(`Clear ${animator.transitionType} - ${entry.transition} for ${entry.fragmentTag}`, Trace.categories.Transition);
  }
  animator.entry = null;
}
function _getAnimatedEntries(frameId) {
  return waitingQueue.get(frameId);
}
function _updateTransitions(entry) {
  const fragment = entry.fragment;
  if (!fragment) {
    return;
  }
  const enterTransitionListener = entry.enterTransitionListener;
  if (enterTransitionListener) {
    fragment.setEnterTransition(enterTransitionListener.transition);
  }
  const exitTransitionListener = entry.exitTransitionListener;
  if (exitTransitionListener) {
    fragment.setExitTransition(exitTransitionListener.transition);
  }
  const reenterTransitionListener = entry.reenterTransitionListener;
  if (reenterTransitionListener) {
    fragment.setReenterTransition(reenterTransitionListener.transition);
  }
  const returnTransitionListener = entry.returnTransitionListener;
  if (returnTransitionListener) {
    fragment.setReturnTransition(returnTransitionListener.transition);
  }
}
function _reverseTransitions(previousEntry, currentEntry) {
  const previousFragment = previousEntry.fragment;
  const currentFragment = currentEntry.fragment;
  let transitionUsed = false;
  const returnTransitionListener = currentEntry.returnTransitionListener;
  if (returnTransitionListener) {
    transitionUsed = true;
    currentFragment.setExitTransition(returnTransitionListener.transition);
  } else {
    currentFragment.setExitTransition(null);
  }
  const reenterTransitionListener = previousEntry.reenterTransitionListener;
  if (reenterTransitionListener) {
    transitionUsed = true;
    previousFragment.setEnterTransition(reenterTransitionListener.transition);
  } else {
    previousFragment.setEnterTransition(null);
  }
  return transitionUsed;
}
function notifySharedTransition(id, eventName) {
  const state = SharedTransition.getState(id);
  if (!state) {
    return;
  }
  SharedTransition.notifyEvent(eventName, {
    id,
    type: "page",
    action: state.activeType === SharedTransitionAnimationType.present ? "present" : "dismiss"
  });
  if (eventName === SharedTransition.finishedEvent) {
    if (state.activeType === SharedTransitionAnimationType.present) {
      SharedTransition.updateState(id, {
        activeType: SharedTransitionAnimationType.dismiss
      });
    } else {
      SharedTransition.finishState(id);
    }
  }
}
function getTransitionListener(entry, transition) {
  if (!TransitionListener) {
    var TransitionListenerImpl = function(_super) {
      __extends(TransitionListenerImpl2, _super);
      function TransitionListenerImpl2(entry2, transition2) {
        var _this = _super.call(this) || this;
        _this.entry = entry2;
        _this.transition = transition2;
        return global.__native(_this);
      }
      TransitionListenerImpl2.prototype.onTransitionStart = function(transition2) {
        var _a4;
        var entry2 = this.entry;
        entry2.isAnimationRunning = true;
        addToWaitingQueue(entry2);
        if (Trace.isEnabled()) {
          Trace.write("START ".concat(toShortString(transition2), " transition for ").concat(entry2.fragmentTag), Trace.categories.Transition);
        }
        if (entry2 === null || entry2 === undefined ? undefined : entry2.transition) {
          notifySharedTransition((_a4 = entry2.transition) === null || _a4 === undefined ? undefined : _a4.id, SharedTransition.startedEvent);
        }
      };
      TransitionListenerImpl2.prototype.onTransitionEnd = function(transition2) {
        var _a4;
        var entry2 = this.entry;
        if (Trace.isEnabled()) {
          Trace.write("END ".concat(toShortString(transition2), " transition for ").concat(entry2.fragmentTag), Trace.categories.Transition);
        }
        entry2.isAnimationRunning = false;
        transitionOrAnimationCompleted(entry2, this.backEntry);
        if (entry2 === null || entry2 === undefined ? undefined : entry2.transition) {
          notifySharedTransition((_a4 = entry2.transition) === null || _a4 === undefined ? undefined : _a4.id, SharedTransition.finishedEvent);
        }
      };
      TransitionListenerImpl2.prototype.onTransitionResume = function(transition2) {
        if (Trace.isEnabled()) {
          var fragment = this.entry.fragmentTag;
          Trace.write("RESUME ".concat(toShortString(transition2), " transition for ").concat(fragment), Trace.categories.Transition);
        }
      };
      TransitionListenerImpl2.prototype.onTransitionPause = function(transition2) {
        if (Trace.isEnabled()) {
          Trace.write("PAUSE ".concat(toShortString(transition2), " transition for ").concat(this.entry.fragmentTag), Trace.categories.Transition);
        }
      };
      TransitionListenerImpl2.prototype.onTransitionCancel = function(transition2) {
        var entry2 = this.entry;
        entry2.isAnimationRunning = false;
        if (Trace.isEnabled()) {
          Trace.write("CANCEL ".concat(toShortString(transition2), " transition for ").concat(this.entry.fragmentTag), Trace.categories.Transition);
        }
      };
      TransitionListenerImpl2 = __decorate([
        Interfaces([androidx.transition.Transition.TransitionListener])
      ], TransitionListenerImpl2);
      return TransitionListenerImpl2;
    }(java.lang.Object);
    TransitionListener = TransitionListenerImpl;
  }
  return new TransitionListener(entry, transition);
}
function addToWaitingQueue(entry) {
  const frameId = entry.frameId;
  let entries = waitingQueue.get(frameId);
  if (!entries) {
    entries = new Set;
    waitingQueue.set(frameId, entries);
  }
  entries.add(entry);
}
function cloneExpandedTransitionListener(expandedTransitionListener) {
  if (!expandedTransitionListener) {
    return null;
  }
  const cloneTransition = expandedTransitionListener.transition.clone();
  return addNativeTransitionListener(expandedTransitionListener.entry, cloneTransition);
}
function clearExitAndReenterTransitions(entry, removeListener) {
  const fragment = entry.fragment;
  const exitListener = entry.exitTransitionListener;
  if (exitListener) {
    const exitTransition = fragment.getExitTransition();
    if (exitTransition) {
      if (removeListener) {
        exitTransition.removeListener(exitListener);
      }
      fragment.setExitTransition(null);
      if (Trace.isEnabled()) {
        Trace.write(`Cleared Exit ${exitTransition.getClass().getSimpleName()} transition for ${fragment}`, Trace.categories.Transition);
      }
    }
    if (removeListener) {
      entry.exitTransitionListener = null;
    }
  }
  const reenterListener = entry.reenterTransitionListener;
  if (reenterListener) {
    const reenterTransition = fragment.getReenterTransition();
    if (reenterTransition) {
      if (removeListener) {
        reenterTransition.removeListener(reenterListener);
      }
      fragment.setReenterTransition(null);
      if (Trace.isEnabled()) {
        Trace.write(`Cleared Reenter ${reenterTransition.getClass().getSimpleName()} transition for ${fragment}`, Trace.categories.Transition);
      }
    }
    if (removeListener) {
      entry.reenterTransitionListener = null;
    }
  }
}
function _getTransitionState(entry) {
  let transitionState;
  if (entry.enterTransitionListener && entry.exitTransitionListener) {
    transitionState = {
      enterTransitionListener: cloneExpandedTransitionListener(entry.enterTransitionListener),
      exitTransitionListener: cloneExpandedTransitionListener(entry.exitTransitionListener),
      reenterTransitionListener: cloneExpandedTransitionListener(entry.reenterTransitionListener),
      returnTransitionListener: cloneExpandedTransitionListener(entry.returnTransitionListener),
      transitionName: entry.transitionName,
      entry
    };
  } else {
    transitionState = null;
  }
  return transitionState;
}
function _restoreTransitionState(snapshot) {
  const entry = snapshot.entry;
  if (snapshot.enterTransitionListener) {
    entry.enterTransitionListener = snapshot.enterTransitionListener;
  }
  if (snapshot.exitTransitionListener) {
    entry.exitTransitionListener = snapshot.exitTransitionListener;
  }
  if (snapshot.reenterTransitionListener) {
    entry.reenterTransitionListener = snapshot.reenterTransitionListener;
  }
  if (snapshot.returnTransitionListener) {
    entry.returnTransitionListener = snapshot.returnTransitionListener;
  }
  entry.transitionName = snapshot.transitionName;
}
function _clearFragment(entry) {
  clearTransitions(entry, false);
}
function _clearEntry(entry) {
  clearTransitions(entry, true);
}
function clearTransitions(entry, removeListener) {
  clearExitAndReenterTransitions(entry, removeListener);
  const fragment = entry.fragment;
  const enterListener = entry.enterTransitionListener;
  if (enterListener) {
    const enterTransition = fragment.getEnterTransition();
    if (enterTransition) {
      if (removeListener) {
        enterTransition.removeListener(enterListener);
      }
      fragment.setEnterTransition(null);
      if (Trace.isEnabled()) {
        Trace.write(`Cleared Enter ${enterTransition.getClass().getSimpleName()} transition for ${fragment}`, Trace.categories.Transition);
      }
    }
    if (removeListener) {
      entry.enterTransitionListener = null;
    }
  }
  const returnListener = entry.returnTransitionListener;
  if (returnListener) {
    const returnTransition = fragment.getReturnTransition();
    if (returnTransition) {
      if (removeListener) {
        returnTransition.removeListener(returnListener);
      }
      fragment.setReturnTransition(null);
      if (Trace.isEnabled()) {
        Trace.write(`Cleared Return ${returnTransition.getClass().getSimpleName()} transition for ${fragment}`, Trace.categories.Transition);
      }
    }
    if (removeListener) {
      entry.returnTransitionListener = null;
    }
  }
}
function allowTransitionOverlap(fragment) {
  if (fragment) {
    fragment.setAllowEnterTransitionOverlap(true);
    fragment.setAllowReturnTransitionOverlap(true);
  }
}
function setEnterTransition(navigationTransition, entry, transition) {
  setUpNativeTransition(navigationTransition, transition);
  const listener = addNativeTransitionListener(entry, transition);
  entry.enterTransitionListener = listener;
  const fragment = entry.fragment;
  fragment.setEnterTransition(transition);
}
function setExitTransition(navigationTransition, entry, transition) {
  setUpNativeTransition(navigationTransition, transition);
  const listener = addNativeTransitionListener(entry, transition);
  entry.exitTransitionListener = listener;
  const fragment = entry.fragment;
  fragment.setExitTransition(transition);
}
function setReenterTransition(navigationTransition, entry, transition) {
  setUpNativeTransition(navigationTransition, transition);
  const listener = addNativeTransitionListener(entry, transition);
  entry.reenterTransitionListener = listener;
  const fragment = entry.fragment;
  fragment.setReenterTransition(transition);
}
function setReturnTransition(navigationTransition, entry, transition) {
  setUpNativeTransition(navigationTransition, transition);
  const listener = addNativeTransitionListener(entry, transition);
  entry.returnTransitionListener = listener;
  const fragment = entry.fragment;
  fragment.setReturnTransition(transition);
}
function setupNewFragmentSlideTransition(navTransition, entry, direction) {
  setupCurrentFragmentSlideTransition(navTransition, entry, direction);
  switch (direction) {
    case "left":
      setEnterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.RIGHT));
      setReturnTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.RIGHT));
      break;
    case "right":
      setEnterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.LEFT));
      setReturnTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.LEFT));
      break;
    case "top":
      setEnterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.BOTTOM));
      setReturnTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.BOTTOM));
      break;
    case "bottom":
      setEnterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.TOP));
      setReturnTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.TOP));
      break;
  }
}
function setupCurrentFragmentSlideTransition(navTransition, entry, direction) {
  switch (direction) {
    case "left":
      setExitTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.LEFT));
      setReenterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.LEFT));
      break;
    case "right":
      setExitTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.RIGHT));
      setReenterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.RIGHT));
      break;
    case "top":
      setExitTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.TOP));
      setReenterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.TOP));
      break;
    case "bottom":
      setExitTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.BOTTOM));
      setReenterTransition(navTransition, entry, new androidx.transition.Slide(android.view.Gravity.BOTTOM));
      break;
  }
}
function setupCurrentFragmentCustomTransition(navTransition, entry, transition) {
  const exitAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.exit);
  const exitTransition = new org.nativescript.widgets.CustomTransition(exitAnimator, transition.constructor.name + Transition.AndroidTransitionType.exit.toString());
  setExitTransition(navTransition, entry, exitTransition);
  const reenterAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.popEnter);
  const reenterTransition = new org.nativescript.widgets.CustomTransition(reenterAnimator, transition.constructor.name + Transition.AndroidTransitionType.popEnter.toString());
  setReenterTransition(navTransition, entry, reenterTransition);
}
function setupNewFragmentCustomTransition(navTransition, entry, transition) {
  setupCurrentFragmentCustomTransition(navTransition, entry, transition);
  const enterAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.enter);
  const enterTransition = new org.nativescript.widgets.CustomTransition(enterAnimator, transition.constructor.name + Transition.AndroidTransitionType.enter.toString());
  setEnterTransition(navTransition, entry, enterTransition);
  const returnAnimator = transition.createAndroidAnimator(Transition.AndroidTransitionType.popExit);
  const returnTransition = new org.nativescript.widgets.CustomTransition(returnAnimator, transition.constructor.name + Transition.AndroidTransitionType.popExit.toString());
  setReturnTransition(navTransition, entry, returnTransition);
}
function setupNewFragmentFadeTransition(navTransition, entry) {
  setupCurrentFragmentFadeTransition(navTransition, entry);
  const fadeInEnter = new androidx.transition.Fade(androidx.transition.Fade.IN);
  setEnterTransition(navTransition, entry, fadeInEnter);
  const fadeOutReturn = new androidx.transition.Fade(androidx.transition.Fade.OUT);
  setReturnTransition(navTransition, entry, fadeOutReturn);
}
function setupCurrentFragmentFadeTransition(navTransition, entry) {
  const fadeOutExit = new androidx.transition.Fade(androidx.transition.Fade.OUT);
  setExitTransition(navTransition, entry, fadeOutExit);
  const fadeInReenter = new androidx.transition.Fade(androidx.transition.Fade.IN);
  setReenterTransition(navTransition, entry, fadeInReenter);
}
function setupCurrentFragmentExplodeTransition(navTransition, entry) {
  setExitTransition(navTransition, entry, new androidx.transition.Explode);
  setReenterTransition(navTransition, entry, new androidx.transition.Explode);
}
function setupNewFragmentExplodeTransition(navTransition, entry) {
  setupCurrentFragmentExplodeTransition(navTransition, entry);
  setEnterTransition(navTransition, entry, new androidx.transition.Explode);
  setReturnTransition(navTransition, entry, new androidx.transition.Explode);
}
function setUpNativeTransition(navigationTransition, nativeTransition) {
  if (navigationTransition.duration) {
    nativeTransition.setDuration(navigationTransition.duration);
  }
  const interpolator = navigationTransition.curve ? _resolveAnimationCurve(navigationTransition.curve) : defaultInterpolator();
  nativeTransition.setInterpolator(interpolator);
}
function addNativeTransitionListener(entry, nativeTransition) {
  const listener = getTransitionListener(entry, nativeTransition);
  nativeTransition.addListener(listener);
  return listener;
}
function transitionOrAnimationCompleted(entry, backEntry) {
  const frameId = entry.frameId;
  const entries = waitingQueue.get(frameId);
  if (!entries) {
    return;
  }
  entries.delete(entry);
  if (entries.size === 0) {
    const previousCompletedEntry = completedEntries.get(frameId);
    completedEntries.delete(frameId);
    waitingQueue.delete(frameId);
    if (!entry.resolvedPage) {
      if (Trace.isEnabled()) {
        Trace.write(`Transition completed - Entry ${entry} with unexpected null value for the resolvedPage property.`, Trace.categories.Transition, Trace.messageType.error);
      }
      return;
    }
    const frame = entry.resolvedPage.frame;
    const navigationContext = frame._executingContext || {
      navigationType: NavigationType.back
    };
    const current2 = frame.isCurrent(entry) && previousCompletedEntry ? previousCompletedEntry : entry;
    if (current2) {
      setTimeout(() => frame.setCurrent(backEntry || current2, navigationContext.navigationType));
    }
  } else {
    completedEntries.set(frameId, entry);
  }
}
function toShortString(nativeTransition) {
  return `${nativeTransition.getClass().getSimpleName()}@${nativeTransition.hashCode().toString(16)}`;
}
function printTransitions(entry) {
  if (entry && Trace.isEnabled()) {
    let result = `${entry.fragmentTag} Transitions:`;
    if (entry.transitionName) {
      result += `transitionName=${entry.transitionName}, `;
    }
    const fragment = entry.fragment;
    result += `${fragment.getEnterTransition() ? " enter=" + toShortString(fragment.getEnterTransition()) : ""}`;
    result += `${fragment.getExitTransition() ? " exit=" + toShortString(fragment.getExitTransition()) : ""}`;
    result += `${fragment.getReenterTransition() ? " popEnter=" + toShortString(fragment.getReenterTransition()) : ""}`;
    result += `${fragment.getReturnTransition() ? " popExit=" + toShortString(fragment.getReturnTransition()) : ""}`;
    Trace.write(result, Trace.categories.Transition);
  }
}
function createDummyZeroDurationAnimator(duration) {
  const animatorSet = new android.animation.AnimatorSet;
  const objectAnimators = Array.create(android.animation.Animator, 1);
  const values = Array.create("float", 2);
  values[0] = 0;
  values[1] = 1;
  const animator = android.animation.ObjectAnimator.ofFloat(null, "alpha", values);
  animator.setDuration(duration);
  objectAnimators[0] = animator;
  animatorSet.playTogether(objectAnimators);
  return animatorSet;
}

class NoTransition extends Transition {
  createAndroidAnimator(transitionType) {
    return createDummyZeroDurationAnimator(this.getDuration());
  }
}

// node_modules/@nativescript/core/ui/embedding/index.android.js
function isEmbedded2() {
  return org.nativescript?.Bootstrap?.isEmbeddedNativeScript;
}
var embeddedView;
function setEmbeddedView(view) {
  embeddedView = view;
}
function getEmbeddedView() {
  if (!embeddedView) {
    throw new Error("{N} Core: Fragment content view not set or set to 'undefined'");
  }
  return embeddedView;
}

// node_modules/@nativescript/core/ui/frame/frame-helper-for-android.js
var FRAMEID = "_frameId";
var CALLBACKS = "_callbacks";
var framesCache = new Array;
function findPageForFragment(fragment, frame) {
  const fragmentTag = fragment.getTag();
  if (Trace.isEnabled()) {
    Trace.write(`Finding page for ${fragmentTag}.`, Trace.categories.NativeLifecycle);
  }
  let entry;
  const current2 = frame._currentEntry;
  const executingContext = frame._executingContext;
  if (current2 && current2.fragmentTag === fragmentTag) {
    entry = current2;
  } else if (executingContext && executingContext.entry && executingContext.entry.fragmentTag === fragmentTag) {
    entry = executingContext.entry;
  }
  let page;
  if (entry) {
    entry.recreated = true;
    page = entry.resolvedPage;
  }
  if (page) {
    const callbacks = fragment[CALLBACKS];
    callbacks.frame = frame;
    callbacks.entry = entry;
    entry.fragment = fragment;
    _updateTransitions(entry);
  } else {
    throw new Error(`Could not find a page for ${fragmentTag}.`);
  }
}

class FragmentCallbacksImplementation {
  constructor() {
    this.backgroundBitmap = null;
  }
  onHiddenChanged(fragment, hidden, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write(`${fragment}.onHiddenChanged(${hidden})`, Trace.categories.NativeLifecycle);
    }
    superFunc.call(fragment, hidden);
  }
  onCreateAnimator(fragment, transit, enter, nextAnim, superFunc) {
    let animator = null;
    const entry = this.entry;
    if (enter && entry.isNestedDefaultTransition) {
      animator = entry.enterAnimator;
      entry.isNestedDefaultTransition = false;
    }
    return animator || superFunc.call(fragment, transit, enter, nextAnim);
  }
  onCreate(fragment, savedInstanceState, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write(`${fragment}.onCreate(${savedInstanceState})`, Trace.categories.NativeLifecycle);
    }
    superFunc.call(fragment, savedInstanceState);
    if (!this.entry) {
      const args = fragment.getArguments();
      const frameId = args.getInt(FRAMEID);
      const frame = getFrameByNumberId(frameId);
      if (!frame) {
        throw new Error(`Cannot find Frame for ${fragment}`);
      }
      findPageForFragment(fragment, frame);
    }
  }
  onCreateView(fragment, inflater, container, savedInstanceState, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write(`${fragment}.onCreateView(inflater, container, ${savedInstanceState})`, Trace.categories.NativeLifecycle);
    }
    const entry = this.entry;
    if (!entry) {
      Trace.error(`${fragment}.onCreateView: entry is null or undefined`);
      return null;
    }
    const page = entry.resolvedPage;
    if (!page) {
      Trace.error(`${fragment}.onCreateView: entry has no resolvedPage`);
      return null;
    }
    const frame = this.frame;
    if (!frame) {
      Trace.error(`${fragment}.onCreateView: this.frame is null or undefined`);
      return null;
    }
    frame._resolvedPage = page;
    if (page.parent === frame) {
      frame._inheritStyles(page);
      if (!page._context) {
        const context = container && container.getContext() || inflater && inflater.getContext();
        page._setupUI(context);
      }
      if (frame.isLoaded && !page.isLoaded) {
        page.callLoaded();
      }
    } else {
      if (!page.parent) {
        if (!frame._styleScope) {
          page._updateStyleScope();
        }
        frame._addView(page);
      } else {
        throw new Error("Page is already shown on another frame.");
      }
    }
    const savedState = entry.viewSavedState;
    if (savedState) {
      page.nativeViewProtected.restoreHierarchyState(savedState);
      entry.viewSavedState = null;
    }
    const nativeView = page.nativeViewProtected;
    if (nativeView != null) {
      const parentView = nativeView.getParent();
      if (parentView instanceof android.view.ViewGroup) {
        if (parentView.getChildCount() === 0) {
          parentView.addViewInLayout(nativeView, -1, new org.nativescript.widgets.CommonLayoutParams);
        }
        parentView.removeAllViews();
      }
    }
    return page.nativeViewProtected;
  }
  onSaveInstanceState(fragment, outState, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write(`${fragment}.onSaveInstanceState(${outState})`, Trace.categories.NativeLifecycle);
    }
    superFunc.call(fragment, outState);
  }
  onDestroyView(fragment, superFunc) {
    try {
      if (Trace.isEnabled()) {
        Trace.write(`${fragment}.onDestroyView()`, Trace.categories.NativeLifecycle);
      }
      const hasRemovingParent = fragment.getRemovingParentFragment();
      if (hasRemovingParent) {
        const nativeFrameView = this.frame.nativeViewProtected;
        if (nativeFrameView) {
          const bitmapDrawable = new android.graphics.drawable.BitmapDrawable(getNativeApp().getApplicationContext().getResources(), this.backgroundBitmap);
          this.frame._originalBackground = this.frame.backgroundColor || new Color("White");
          nativeFrameView.setBackgroundDrawable(bitmapDrawable);
          this.backgroundBitmap = null;
        }
      }
    } finally {
      superFunc.call(fragment);
    }
  }
  onDestroy(fragment, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write(`${fragment}.onDestroy()`, Trace.categories.NativeLifecycle);
    }
    superFunc.call(fragment);
    const entry = this.entry;
    if (!entry) {
      Trace.error(`${fragment}.onDestroy: entry is null or undefined`);
      return null;
    }
    entry.fragment = null;
    const page = entry.resolvedPage;
    if (!page) {
      console.log(`${fragment}.onDestroy: entry has no resolvedPage`);
      return null;
    }
  }
  onPause(fragment, superFunc) {
    try {
      const hasRemovingParent = fragment.getRemovingParentFragment();
      if (hasRemovingParent) {
        this.backgroundBitmap = this.loadBitmapFromView(this.frame.nativeViewProtected);
      }
    } finally {
      superFunc.call(fragment);
    }
  }
  onResume(fragment, superFunc) {
    const frame = this.entry.resolvedPage.frame;
    const weakRef = new WeakRef(this);
    setTimeout(() => {
      const owner = weakRef.get();
      if (!owner) {
        return;
      }
      if (frame._executingContext && !owner.entry.isAnimationRunning) {
        frame.setCurrent(owner.entry, frame._executingContext.navigationType);
      }
    }, 0);
    superFunc.call(fragment);
  }
  onStop(fragment, superFunc) {
    superFunc.call(fragment);
  }
  toStringOverride(fragment, superFunc) {
    const entry = this.entry;
    if (entry) {
      return `${entry.fragmentTag}<${entry.resolvedPage}>`;
    } else {
      return "NO ENTRY, " + superFunc.call(fragment);
    }
  }
  loadBitmapFromView(view) {
    if (!(view && view.getWidth() > 0 && view.getHeight() > 0)) {
      return;
    }
    return org.nativescript.widgets.Utils.getBitmapFromView(view);
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, Boolean, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onHiddenChanged", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, Number, Boolean, Number, Function]),
  __metadata("design:returntype", android.animation.Animator)
], FragmentCallbacksImplementation.prototype, "onCreateAnimator", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, android.os.Bundle, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onCreate", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle, Function]),
  __metadata("design:returntype", android.view.View)
], FragmentCallbacksImplementation.prototype, "onCreateView", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, android.os.Bundle, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onSaveInstanceState", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [org.nativescript.widgets.FragmentBase, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onDestroyView", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onDestroy", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [org.nativescript.widgets.FragmentBase, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onPause", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [org.nativescript.widgets.FragmentBase, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onResume", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, Function]),
  __metadata("design:returntype", undefined)
], FragmentCallbacksImplementation.prototype, "onStop", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.fragment.app.Fragment, Function]),
  __metadata("design:returntype", String)
], FragmentCallbacksImplementation.prototype, "toStringOverride", null);
function getFrameByNumberId(frameId) {
  for (let i4 = 0;i4 < framesCache.length; i4++) {
    const aliveFrame = framesCache[i4].get();
    if (aliveFrame && aliveFrame.frameId === frameId) {
      return aliveFrame.owner;
    }
  }
  return null;
}
function setFragmentCallbacks(fragment) {
  fragment[CALLBACKS] = new FragmentCallbacksImplementation;
}

// node_modules/@nativescript/core/ui/frame/fragment.android.js
var superProto = org.nativescript.widgets.FragmentBase.prototype;
var FragmentClass = org.nativescript.widgets.FragmentBase.extend("com.tns.FragmentClass", {
  init() {},
  onHiddenChanged(hidden) {
    this._callbacks.onHiddenChanged(this, hidden, superProto.onHiddenChanged);
  },
  onCreateAnimator(transit, enter, nextAnim) {
    return this._callbacks.onCreateAnimator(this, transit, enter, nextAnim, superProto.onCreateAnimator);
  },
  onStop() {
    this._callbacks.onStop(this, superProto.onStop);
  },
  onPause() {
    this._callbacks.onPause(this, superProto.onPause);
  },
  onResume() {
    this._callbacks.onResume(this, superProto.onResume);
  },
  onCreate(savedInstanceState) {
    if (!this._callbacks) {
      setFragmentCallbacks(this);
    }
    this.setHasOptionsMenu(true);
    this._callbacks.onCreate(this, savedInstanceState, superProto.onCreate);
  },
  onCreateView(inflater, container, savedInstanceState) {
    return this._callbacks.onCreateView(this, inflater, container, savedInstanceState, superProto.onCreateView);
  },
  onSaveInstanceState(outState) {
    this._callbacks.onSaveInstanceState(this, outState, superProto.onSaveInstanceState);
  },
  onDestroyView() {
    this._callbacks.onDestroyView(this, superProto.onDestroyView);
  },
  onDestroy() {
    this._callbacks.onDestroy(this, superProto.onDestroy);
    this._callbacks = null;
  },
  toString() {
    const callbacks = this._callbacks;
    if (callbacks) {
      return callbacks.toStringOverride(this, superProto.toString);
    } else {
      superProto.toString();
    }
  }
});
var fragmentClass;
function ensureFragmentClass() {
  if (fragmentClass) {
    return;
  }
  if (!fragmentClass) {
    throw new Error("Failed to initialize the extended androidx.fragment.app.Fragment class");
  }
}
function setFragmentClass(clazz) {
  if (fragmentClass) {
    throw new Error("Fragment class already initialized");
  }
  if (isEmbedded2()) {
    attachEmbeddableFragmentCallbacks();
  }
  fragmentClass = clazz;
}
function attachEmbeddableFragmentCallbacks() {
  const Callbacks = com.tns.embedding.EmbeddableFragmentCallbacks.extend({
    init() {},
    onCreateView() {
      return getEmbeddedView().nativeViewProtected;
    },
    onResume() {
      getEmbeddedView().callLoaded();
    },
    onPause() {
      getEmbeddedView().callUnloaded();
    }
  });
  com.tns.embedding.CallbacksStore.setFragmentCallbacks(new Callbacks);
}
setFragmentClass(FragmentClass);

// node_modules/@nativescript/core/ui/frame/index.android.js
var INTENT_EXTRA = "com.tns.activity";
var ownerSymbol = Symbol("_owner");
var isPendingDetachSymbol = Symbol("_isPendingDetach");
var navDepth = -1;
var fragmentId = -1;
var attachStateChangeListener;
function getAttachListener() {
  if (!attachStateChangeListener) {
    const AttachListener = java.lang.Object.extend({
      interfaces: [android.view.View.OnAttachStateChangeListener],
      init() {},
      onViewAttachedToWindow(view) {
        const owner = view[ownerSymbol];
        if (owner) {
          owner._onAttachedToWindow();
        }
      },
      onViewDetachedFromWindow(view) {
        const owner = view[ownerSymbol];
        if (owner) {
          owner._onDetachedFromWindow();
        }
        if (view[isPendingDetachSymbol]) {
          delete view[isPendingDetachSymbol];
          view.removeOnAttachStateChangeListener(this);
          view[ownerSymbol] = null;
        }
      }
    });
    attachStateChangeListener = new AttachListener;
  }
  return attachStateChangeListener;
}

class Frame extends FrameBase {
  constructor() {
    super();
    this._containerViewId = -1;
    this._tearDownPending = false;
    this._attachedToWindow = false;
    this._isReset = false;
    this._android = new AndroidFrame(this);
    this.androidOverflowEdge = "ignore";
  }
  static reloadPage(context) {
    const activity = android2.getCurrentActivity();
    const callbacks = activity[CALLBACKS];
    if (callbacks) {
      const rootView2 = callbacks.getRootView();
      const isAppRootModuleChanged = context && context.path && context.path.includes(getAppMainEntry().moduleName) && context.type !== "style";
      if (isAppRootModuleChanged || !rootView2 || !rootView2._onLivesync(context)) {
        callbacks.resetActivityContent(activity);
      }
    } else {
      Trace.error(`${activity}[CALLBACKS] is null or undefined`);
    }
  }
  static get defaultAnimatedNavigation() {
    return FrameBase.defaultAnimatedNavigation;
  }
  static set defaultAnimatedNavigation(value) {
    FrameBase.defaultAnimatedNavigation = value;
  }
  static get defaultTransition() {
    return FrameBase.defaultTransition;
  }
  static set defaultTransition(value) {
    FrameBase.defaultTransition = value;
  }
  get containerViewId() {
    return this._containerViewId;
  }
  get android() {
    return this._android;
  }
  get _hasFragments() {
    return true;
  }
  _onAttachedToWindow() {
    super._onAttachedToWindow();
    const activity = android2.getCurrentActivity();
    const lifecycleState = activity?.getLifecycle?.()?.getCurrentState() || androidx.lifecycle.Lifecycle.State.CREATED;
    if (this._manager && this._manager.isDestroyed() || !lifecycleState.isAtLeast(androidx.lifecycle.Lifecycle.State.CREATED)) {
      return;
    }
    this._attachedToWindow = true;
    this._isReset = false;
    this._processNextNavigationEntry();
    this._ensureEntryFragment();
  }
  _onDetachedFromWindow() {
    super._onDetachedFromWindow();
    this._attachedToWindow = false;
  }
  _processNextNavigationEntry() {
    if (!this.isLoaded || this._executingContext) {
      return;
    }
    if (this._isReset && !this._attachedToWindow) {
      return;
    }
    const animatedEntries = _getAnimatedEntries(this._android.frameId);
    if (animatedEntries) {
      if (animatedEntries.size > 0) {
        return;
      }
    }
    const manager = this._getFragmentManager();
    const entry = this._currentEntry;
    const isNewEntry = !this._cachedTransitionState || entry !== this._cachedTransitionState.entry;
    if (isNewEntry && entry && manager && !manager.findFragmentByTag(entry.fragmentTag)) {
      const cachedTransitionState = _getTransitionState(this._currentEntry);
      if (cachedTransitionState) {
        this._cachedTransitionState = cachedTransitionState;
        this._currentEntry = null;
        this._navigateCore(entry);
        this._currentEntry = entry;
      } else {
        super._processNextNavigationEntry();
      }
    } else {
      super._processNextNavigationEntry();
    }
  }
  _getChildFragmentManager() {
    let backstackEntry;
    if (this._executingContext && this._executingContext.entry) {
      backstackEntry = this._executingContext.entry;
    } else {
      backstackEntry = this._currentEntry;
    }
    if (backstackEntry && backstackEntry.fragment && backstackEntry.fragment.isAdded()) {
      return backstackEntry.fragment.getChildFragmentManager();
    }
    return null;
  }
  _onRootViewReset() {
    super._onRootViewReset();
    this._isReset = true;
    this.disposeCurrentFragment();
  }
  onLoaded() {
    if (this._originalBackground) {
      this.backgroundColor = null;
      this.backgroundColor = this._originalBackground;
      this._originalBackground = null;
    }
    this._ensureEntryFragment();
    super.onLoaded();
  }
  onUnloaded() {
    super.onUnloaded();
    if (typeof this._frameCreateTimeout === "number") {
      clearTimeout(this._frameCreateTimeout);
      this._frameCreateTimeout = null;
    }
  }
  _ensureEntryFragment() {
    if (this._isReset && !this._attachedToWindow) {
      return;
    }
    this._frameCreateTimeout = setTimeout(() => {
      const currentEntry = this._currentEntry || this._executingContext?.entry;
      if (currentEntry) {
        if (!currentEntry.fragment) {
          const manager = this._getFragmentManager();
          const transaction = manager.beginTransaction();
          currentEntry.fragment = this.createFragment(currentEntry, currentEntry.fragmentTag);
          _updateTransitions(currentEntry);
          transaction.replace(this.containerViewId, currentEntry.fragment, currentEntry.fragmentTag);
          transaction.commitAllowingStateLoss();
        }
      }
      this._frameCreateTimeout = null;
    }, 0);
  }
  disposeCurrentFragment() {
    if (!this._currentEntry || !this._currentEntry.fragment || !this._currentEntry.fragment.isAdded()) {
      return;
    }
    const fragment = this._currentEntry.fragment;
    const fragmentManager = fragment.getFragmentManager();
    const transaction = fragmentManager.beginTransaction();
    const fragmentExitTransition = fragment.getExitTransition();
    if (fragmentExitTransition && fragmentExitTransition instanceof org.nativescript.widgets.CustomTransition) {
      fragmentExitTransition.setResetOnTransitionEnd(true);
    }
    transaction.remove(fragment);
    transaction.commitNowAllowingStateLoss();
  }
  createFragment(backstackEntry, fragmentTag) {
    ensureFragmentClass();
    const newFragment = new fragmentClass;
    const args = new android.os.Bundle;
    args.putInt(FRAMEID, this._android.frameId);
    newFragment.setArguments(args);
    setFragmentCallbacks(newFragment);
    const callbacks = newFragment[CALLBACKS];
    callbacks.frame = this;
    callbacks.entry = backstackEntry;
    backstackEntry.fragment = newFragment;
    backstackEntry.fragmentTag = fragmentTag;
    backstackEntry.navDepth = navDepth;
    return newFragment;
  }
  setCurrent(entry, navigationType) {
    const current2 = this._currentEntry;
    const currentEntryChanged = current2 !== entry;
    if (currentEntryChanged) {
      this._updateBackstack(entry, navigationType);
      if (this._tearDownPending) {
        this._tearDownPending = false;
        if (!entry.recreated) {
          this._disposeBackstackEntry(entry);
        }
        if (current2 && !current2.recreated) {
          this._disposeBackstackEntry(current2);
        }
        const context = this._context;
        if (context && !entry.recreated) {
          entry.fragment = this.createFragment(entry, entry.fragmentTag);
          entry.resolvedPage._setupUI(context);
        }
        entry.recreated = false;
        if (current2) {
          current2.recreated = false;
        }
      }
      super.setCurrent(entry, navigationType);
      this._processNavigationQueue(entry.resolvedPage);
    } else {
      this._processNextNavigationEntry();
    }
    if (this._cachedTransitionState) {
      _restoreTransitionState(this._cachedTransitionState);
      this._cachedTransitionState = null;
    }
    if (navigationType === NavigationType.replace) {
      _clearEntry(entry);
      const animated = this._getIsAnimatedNavigation(entry.entry);
      const navigationTransition = this._getNavigationTransition(entry.entry);
      const currentEntry = null;
      const newEntry = entry;
      const transaction = null;
      _setAndroidFragmentTransitions(animated, navigationTransition, currentEntry, newEntry, this._android.frameId, transaction, this.direction);
    }
  }
  onBackPressed() {
    if (this.canGoBack()) {
      this.goBack();
      return true;
    }
    if (!this.navigationQueueIsEmpty()) {
      const manager = this._getFragmentManager();
      if (manager) {
        manager.executePendingTransactions();
        return true;
      }
    }
    return false;
  }
  _navigateCore(newEntry) {
    super._navigateCore(newEntry);
    newEntry.frameId = this._android.frameId;
    const activity = this._android.activity;
    if (!activity) {
      const currentActivity = this._android.currentActivity;
      if (currentActivity) {
        startActivity(currentActivity, this._android.frameId);
      }
      return;
    }
    const manager = this._getFragmentManager();
    const clearHistory = newEntry.entry.clearHistory;
    const currentEntry = this._currentEntry;
    if (clearHistory) {
      navDepth = -1;
    }
    const isReplace = this._executingContext && this._executingContext.navigationType === NavigationType.replace;
    if (!isReplace) {
      navDepth++;
    }
    fragmentId++;
    const newFragmentTag = `fragment${fragmentId}[${navDepth}]`;
    const newFragment = this.createFragment(newEntry, newFragmentTag);
    const transaction = manager.beginTransaction();
    const animated = currentEntry ? this._getIsAnimatedNavigation(newEntry.entry) : false;
    let navigationTransition;
    if (this._currentEntry) {
      navigationTransition = this._getNavigationTransition(newEntry.entry);
    } else {
      navigationTransition = null;
    }
    const isNestedDefaultTransition = !currentEntry;
    _setAndroidFragmentTransitions(animated, navigationTransition, currentEntry, newEntry, this._android.frameId, transaction, this.direction, isNestedDefaultTransition);
    if (currentEntry && animated && !navigationTransition) {}
    transaction.replace(this.containerViewId, newFragment, newFragmentTag);
    navigationTransition?.instance?.androidFragmentTransactionCallback?.(transaction, currentEntry, newEntry);
    transaction.commitAllowingStateLoss();
  }
  _goBackCore(backstackEntry) {
    super._goBackCore(backstackEntry);
    navDepth = backstackEntry.navDepth;
    const manager = this._getFragmentManager();
    const transaction = manager.beginTransaction();
    if (!backstackEntry.fragment) {
      backstackEntry.fragment = this.createFragment(backstackEntry, backstackEntry.fragmentTag);
      _updateTransitions(backstackEntry);
    }
    _reverseTransitions(backstackEntry, this._currentEntry);
    transaction.replace(this.containerViewId, backstackEntry.fragment, backstackEntry.fragmentTag);
    backstackEntry.transition?.androidFragmentTransactionCallback?.(transaction, this._currentEntry, backstackEntry);
    transaction.commitAllowingStateLoss();
  }
  _removeEntry(removed) {
    super._removeEntry(removed);
    if (removed.fragment) {
      _clearEntry(removed);
      removed.fragment = null;
    }
    removed.viewSavedState = null;
  }
  _disposeBackstackEntry(entry) {
    if (entry.fragment) {
      _clearFragment(entry);
      entry.fragment = null;
    }
    entry.recreated = false;
    super._disposeBackstackEntry(entry);
  }
  createNativeView() {
    if (this._currentEntry) {
      this._pushInFrameStack();
    }
    return new org.nativescript.widgets.ContentLayout(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const listener = getAttachListener();
    const nativeView = this.nativeViewProtected;
    nativeView.addOnAttachStateChangeListener(listener);
    nativeView[ownerSymbol] = this;
    this._android.rootViewGroup = nativeView;
    if (this._containerViewId < 0) {
      this._containerViewId = android.view.View.generateViewId();
    }
    this._android.rootViewGroup.setId(this._containerViewId);
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    const listener = getAttachListener();
    if (nativeView.isAttachedToWindow()) {
      nativeView[isPendingDetachSymbol] = true;
    } else {
      nativeView.removeOnAttachStateChangeListener(listener);
      nativeView[ownerSymbol] = null;
    }
    this._tearDownPending = !!this._executingContext;
    const current2 = this._currentEntry;
    const executingEntry = this._executingContext ? this._executingContext.entry : null;
    this.backStack.forEach((entry) => {
      if (entry !== executingEntry) {
        this._disposeBackstackEntry(entry);
      }
    });
    if (current2 && !executingEntry) {
      this._disposeBackstackEntry(current2);
    }
    this._cachedTransitionState = null;
    this._isReset = true;
    this._android.rootViewGroup = null;
    this._removeFromFrameStack();
    super.disposeNativeView();
  }
  _popFromFrameStack() {
    if (!this._isInFrameStack) {
      return;
    }
    super._popFromFrameStack();
  }
  _getNavBarVisible(page) {
    switch (this.actionBarVisibility) {
      case "never":
        return false;
      case "always":
        return true;
      default:
        if (page.actionBarHidden !== undefined) {
          return !page.actionBarHidden;
        }
        if (this._android && this._android.showActionBar !== undefined) {
          return this._android.showActionBar;
        }
        return true;
    }
  }
  _saveFragmentsState() {
    this.backStack.forEach((entry) => {
      const view = entry.resolvedPage.nativeViewProtected;
      if (!entry.viewSavedState && view) {
        const viewState = new android.util.SparseArray;
        view.saveHierarchyState(viewState);
        entry.viewSavedState = viewState;
      }
    });
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", undefined)
], Frame.prototype, "_navigateCore", null);
global.__onLiveSyncCore = Frame.reloadPage;
var framesCounter = 0;

class AndroidFrame extends Observable {
  constructor(owner) {
    super();
    this._showActionBar = true;
    this._owner = owner;
    this.frameId = framesCounter++;
    framesCache.push(new WeakRef(this));
  }
  get showActionBar() {
    return this._showActionBar;
  }
  set showActionBar(value) {
    if (this._showActionBar !== value) {
      this._showActionBar = value;
      if (this.owner.currentPage) {
        this.owner.currentPage.actionBar.update();
      }
    }
  }
  get activity() {
    const activity = this.owner._context;
    if (activity) {
      return activity;
    }
    let currView = this._owner.parent;
    while (currView) {
      if (currView instanceof Frame) {
        return currView.android.activity;
      }
      currView = currView.parent;
    }
    return;
  }
  get actionBar() {
    const activity = this.currentActivity;
    if (!activity) {
      return;
    }
    const bar = activity.getActionBar();
    if (!bar) {
      return;
    }
    return bar;
  }
  get currentActivity() {
    let activity = this.activity;
    if (activity) {
      return activity;
    }
    const frames = _stack();
    for (let length2 = frames.length, i4 = length2 - 1;i4 >= 0; i4--) {
      activity = frames[i4].android.activity;
      if (activity) {
        return activity;
      }
    }
    return;
  }
  get owner() {
    return this._owner;
  }
  canGoBack() {
    if (!this.activity) {
      return false;
    }
    return this.activity.getIntent().getAction() !== android.content.Intent.ACTION_MAIN;
  }
  fragmentForPage(entry) {
    const tag = entry && entry.fragmentTag;
    if (tag) {
      return this.owner._getFragmentManager().findFragmentByTag(tag);
    }
    return;
  }
}
function startActivity(activity, frameId) {
  const intent = new android.content.Intent(activity, activity.getClass());
  intent.setAction(android.content.Intent.ACTION_DEFAULT);
  intent.putExtra(INTENT_EXTRA, frameId);
  activity.startActivity(intent);
}
var OnBackPressedCallback2;
if (SDK_VERSION >= 33) {
  OnBackPressedCallback2 = androidx.activity.OnBackPressedCallback.extend("com.tns.OnBackPressedCallback", {
    handleOnBackPressed() {
      if (Trace.isEnabled()) {
        Trace.write("NativeScriptActivity.onBackPressed;", Trace.categories.NativeLifecycle);
      }
      const activity = this["_activity"]?.get();
      if (!activity) {
        if (Trace.isEnabled()) {
          Trace.write("NativeScriptActivity.onBackPressed; Activity is null, calling super", Trace.categories.NativeLifecycle);
        }
        this.setEnabled(false);
        return;
      }
      const args = {
        eventName: "activityBackPressed",
        object: Application,
        android: Application.android,
        activity,
        cancel: false
      };
      Application.android.notify(args);
      if (args.cancel) {
        return;
      }
      const callbacks = activity[CALLBACKS];
      let callSuper = false;
      if (callbacks) {
        const view = callbacks.getRootView();
        if (view) {
          const viewArgs = {
            eventName: "activityBackPressed",
            object: view,
            activity,
            cancel: false
          };
          view.notify(viewArgs);
          if (!viewArgs.cancel && (view.onBackPressed === Frame.prototype.onBackPressed || !view.onBackPressed())) {
            callSuper = view instanceof Frame ? !Frame.goBack() : true;
          }
        }
      }
      if (callSuper) {
        this.setEnabled(false);
        activity.getOnBackPressedDispatcher().onBackPressed();
        this.setEnabled(true);
      }
    }
  });
}
var activityRootViewsMap = new Map;
var ROOT_VIEW_ID_EXTRA = "com.tns.activity.rootViewId";
var moduleLoaded;

class ActivityCallbacksImplementation {
  getRootView() {
    return this._rootView;
  }
  onCreate(activity, savedInstanceState, intentOrSuperFunc, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write(`Activity.onCreate(${savedInstanceState})`, Trace.categories.NativeLifecycle);
    }
    const intent = superFunc ? intentOrSuperFunc : undefined;
    if (!superFunc) {
      console.log("AndroidActivityCallbacks.onCreate(activity: any, savedInstanceState: any, superFunc: Function) " + "is deprecated. Use AndroidActivityCallbacks.onCreate(activity: any, savedInstanceState: any, intent: any, superFunc: Function) instead.");
      superFunc = intentOrSuperFunc;
    }
    const isRestart = !!savedInstanceState && moduleLoaded;
    superFunc.call(activity, isRestart ? savedInstanceState : null);
    if (savedInstanceState) {
      const rootViewId = savedInstanceState.getInt(ROOT_VIEW_ID_EXTRA, -1);
      if (rootViewId !== -1 && activityRootViewsMap.has(rootViewId)) {
        this._rootView = activityRootViewsMap.get(rootViewId)?.get();
      }
    }
    if (intent && intent.getAction()) {
      Application.android.notify({
        eventName: Application.AndroidApplication.activityNewIntentEvent,
        object: Application.android,
        activity,
        intent
      });
    }
    this.setActivityContent(activity, savedInstanceState, true);
    moduleLoaded = true;
  }
  onSaveInstanceState(activity, outState, superFunc) {
    superFunc.call(activity, outState);
    const rootView2 = this._rootView;
    if (rootView2 instanceof Frame) {
      outState.putInt(INTENT_EXTRA, rootView2.android.frameId);
      rootView2._saveFragmentsState();
    }
    if (rootView2) {
      outState.putInt(ROOT_VIEW_ID_EXTRA, rootView2._domId);
    }
  }
  onNewIntent(activity, intent, superSetIntentFunc, superFunc) {
    superFunc.call(activity, intent);
    superSetIntentFunc.call(activity, intent);
    Application.android.notify({
      eventName: Application.AndroidApplication.activityNewIntentEvent,
      object: Application.android,
      activity,
      intent
    });
  }
  onStart(activity, superFunc) {
    superFunc.call(activity);
    if (Trace.isEnabled()) {
      Trace.write("NativeScriptActivity.onStart();", Trace.categories.NativeLifecycle);
    }
    const rootView2 = this._rootView;
    if (rootView2 && !rootView2.isLoaded && !isEmbedded2()) {
      rootView2.callLoaded();
    }
  }
  onStop(activity, superFunc) {
    superFunc.call(activity);
    if (Trace.isEnabled()) {
      Trace.write("NativeScriptActivity.onStop();", Trace.categories.NativeLifecycle);
    }
    const rootView2 = this._rootView;
    if (rootView2 && rootView2.isLoaded && !isEmbedded2()) {
      rootView2.callUnloaded();
    }
  }
  onPostResume(activity, superFunc) {
    superFunc.call(activity);
    if (Trace.isEnabled()) {
      Trace.write("NativeScriptActivity.onPostResume();", Trace.categories.NativeLifecycle);
    }
    if (activity.isNativeScriptActivity) {
      Application.setSuspended(false, {
        android: activity,
        activity
      });
    }
  }
  onDestroy(activity, superFunc) {
    try {
      if (Trace.isEnabled()) {
        Trace.write("NativeScriptActivity.onDestroy();", Trace.categories.NativeLifecycle);
      }
      const rootView2 = this._rootView;
      if (rootView2) {
        rootView2._tearDownUI(true);
      }
      if (activity.isFinishing()) {
        const exitArgs = {
          eventName: Application.exitEvent,
          object: Application.android,
          android: activity
        };
        Application.notify(exitArgs);
      }
    } finally {
      superFunc.call(activity);
    }
  }
  onBackPressed(activity, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write("NativeScriptActivity.onBackPressed;", Trace.categories.NativeLifecycle);
    }
    const args = {
      eventName: "activityBackPressed",
      object: Application,
      android: Application.android,
      activity,
      cancel: false
    };
    Application.android.notify(args);
    if (args.cancel) {
      return;
    }
    const view = this._rootView;
    let callSuper = false;
    const viewArgs = {
      eventName: "activityBackPressed",
      object: view,
      activity,
      cancel: false
    };
    view.notify(viewArgs);
    if (!viewArgs.cancel && (view.onBackPressed === Frame.prototype.onBackPressed || !view.onBackPressed())) {
      callSuper = view instanceof Frame ? !Frame.goBack() : true;
    }
    if (callSuper) {
      superFunc.call(activity);
    }
  }
  onRequestPermissionsResult(activity, requestCode, permissions, grantResults, superFunc) {
    if (Trace.isEnabled()) {
      Trace.write("NativeScriptActivity.onRequestPermissionsResult;", Trace.categories.NativeLifecycle);
    }
    Application.android.notify({
      eventName: "activityRequestPermissions",
      object: Application,
      android: Application.android,
      activity,
      requestCode,
      permissions,
      grantResults
    });
  }
  onActivityResult(activity, requestCode, resultCode, data2, superFunc) {
    superFunc.call(activity, requestCode, resultCode, data2);
    if (Trace.isEnabled()) {
      Trace.write(`NativeScriptActivity.onActivityResult(${requestCode}, ${resultCode}, ${data2})`, Trace.categories.NativeLifecycle);
    }
    Application.android.notify({
      eventName: "activityResult",
      object: Application,
      android: Application.android,
      activity,
      requestCode,
      resultCode,
      intent: data2
    });
  }
  resetActivityContent(activity) {
    if (this._rootView) {
      const manager = this._rootView._getFragmentManager();
      manager.executePendingTransactions();
      this._rootView._onRootViewReset();
    }
    this._rootView = null;
    this.setActivityContent(activity, null, false);
    this._rootView.callLoaded();
  }
  setActivityContent(activity, savedInstanceState, fireLaunchEvent) {
    let rootView2 = this._rootView;
    if (Trace.isEnabled()) {
      Trace.write(`Frame.setActivityContent rootView: ${rootView2} shouldCreateRootFrame: false fireLaunchEvent: ${fireLaunchEvent}`, Trace.categories.NativeLifecycle);
    }
    const intent = activity.getIntent();
    rootView2 = Application.createRootView(rootView2, fireLaunchEvent, {
      android: intent,
      intent,
      savedInstanceState
    });
    if (!rootView2) {
      return;
    }
    activityRootViewsMap.set(rootView2._domId, new WeakRef(rootView2));
    rootView2._setupAsRootView(activity);
    if (isEmbedded2()) {
      setEmbeddedView(rootView2);
    } else {
      activity.setContentView(rootView2.nativeViewProtected, new org.nativescript.widgets.CommonLayoutParams);
    }
    this._rootView = rootView2;
    Application.initRootView(rootView2);
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.appcompat.app.AppCompatActivity, android.os.Bundle, Object, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onCreate", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.appcompat.app.AppCompatActivity, android.os.Bundle, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onSaveInstanceState", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [androidx.appcompat.app.AppCompatActivity, android.content.Intent, Function, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onNewIntent", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onStart", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onStop", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onPostResume", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onDestroy", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onBackPressed", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Number, Array, Array, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onRequestPermissionsResult", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Number, Number, android.content.Intent, Function]),
  __metadata("design:returntype", undefined)
], ActivityCallbacksImplementation.prototype, "onActivityResult", null);

// node_modules/@nativescript/core/ui/label/index.android.js
var Label = class Label2 extends TextBase {
  get textWrap() {
    return this.style.whiteSpace === "normal";
  }
  set textWrap(value) {
    if (typeof value === "string") {
      value = booleanConverter(value);
    }
    this.style.whiteSpace = value ? "normal" : "nowrap";
  }
  createNativeView() {
    return new org.nativescript.widgets.StyleableTextView(this._context);
  }
  initNativeView() {
    const isRtl = this.direction === CoreTypes.LayoutDirection.rtl;
    super.initNativeView();
    const textView = this.nativeTextViewProtected;
    textView.setSingleLine(true);
    textView.setEllipsize(isRtl ? android.text.TextUtils.TruncateAt.START : android.text.TextUtils.TruncateAt.END);
    textView.setGravity(android.view.Gravity.CENTER_VERTICAL);
  }
  [whiteSpaceProperty.setNative](value) {
    const newValue = value === "initial" ? "nowrap" : value;
    super[whiteSpaceProperty.setNative](newValue);
  }
};
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], Label.prototype, "createNativeView", null);
Label = __decorate([
  CSSType("Label")
], Label);
Label.prototype._isSingleLine = true;
Label.prototype._isManualRtlTextStyleNeeded = true;
Label.prototype.recycleNativeView = "auto";

// node_modules/@nativescript/core/ui/editable-text-base/editable-text-base-common.js
function focusChangeHandler(args) {
  const view = args.object;
  if (args.eventName === "focus") {
    view._addVisualState("focus");
    view._removeVisualState("blur");
  } else {
    view._addVisualState("blur");
    view._removeVisualState("focus");
  }
}

class EditableTextBase extends TextBase {
  _updateTextBaseFocusStateHandler(subscribe) {
    if (subscribe) {
      this.on("focus", focusChangeHandler);
      this.on("blur", focusChangeHandler);
    } else {
      this.off("focus", focusChangeHandler);
      this.off("blur", focusChangeHandler);
      this._removeVisualState("focus");
      this._removeVisualState("blur");
    }
  }
}
EditableTextBase.blurEvent = "blur";
EditableTextBase.focusEvent = "focus";
EditableTextBase.textChangeEvent = "textChange";
__decorate([
  PseudoClassHandler("focus", "blur"),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", undefined)
], EditableTextBase.prototype, "_updateTextBaseFocusStateHandler", null);
var placeholderColorProperty = new CssProperty({
  name: "placeholderColor",
  cssName: "placeholder-color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
placeholderColorProperty.register(Style);
var keyboardTypeConverter = makeParser(makeValidator(CoreTypes.KeyboardType.datetime, CoreTypes.KeyboardType.phone, CoreTypes.KeyboardType.number, CoreTypes.KeyboardType.decimal, CoreTypes.KeyboardType.url, CoreTypes.KeyboardType.email, CoreTypes.KeyboardType.integer), true);
var autofillTypeProperty = new Property({ name: "autofillType" });
autofillTypeProperty.register(EditableTextBase);
var keyboardTypeProperty = new Property({ name: "keyboardType", valueConverter: keyboardTypeConverter });
keyboardTypeProperty.register(EditableTextBase);
var returnKeyTypeConverter = makeParser(makeValidator(CoreTypes.ReturnKeyType.done, CoreTypes.ReturnKeyType.next, CoreTypes.ReturnKeyType.go, CoreTypes.ReturnKeyType.search, CoreTypes.ReturnKeyType.send), true);
var returnKeyTypeProperty = new Property({ name: "returnKeyType", valueConverter: returnKeyTypeConverter });
returnKeyTypeProperty.register(EditableTextBase);
var editableProperty = new Property({
  name: "editable",
  defaultValue: true,
  valueConverter: booleanConverter
});
editableProperty.register(EditableTextBase);
var updateTextTriggerProperty = new Property({ name: "updateTextTrigger", defaultValue: CoreTypes.UpdateTextTrigger.textChanged });
updateTextTriggerProperty.register(EditableTextBase);
var autocapitalizationTypeConverter = makeParser(makeValidator(CoreTypes.AutocapitalizationType.none, CoreTypes.AutocapitalizationType.words, CoreTypes.AutocapitalizationType.sentences, CoreTypes.AutocapitalizationType.allCharacters), true);
var autocapitalizationTypeProperty = new Property({
  name: "autocapitalizationType",
  defaultValue: CoreTypes.AutocapitalizationType.sentences,
  valueConverter: autocapitalizationTypeConverter
});
autocapitalizationTypeProperty.register(EditableTextBase);
var autocorrectProperty = new Property({
  name: "autocorrect",
  valueConverter: booleanConverter
});
autocorrectProperty.register(EditableTextBase);
var hintProperty = new Property({
  name: "hint",
  defaultValue: ""
});
hintProperty.register(EditableTextBase);
var maxLengthProperty = new Property({
  name: "maxLength",
  defaultValue: Number.POSITIVE_INFINITY,
  valueConverter: parseInt
});
maxLengthProperty.register(EditableTextBase);

// node_modules/@nativescript/core/ui/editable-text-base/index.android.js
var dismissKeyboardTimeoutId;
var EditTextListeners;
function clearDismissTimer() {
  if (dismissKeyboardTimeoutId) {
    clearTimeout(dismissKeyboardTimeoutId);
    dismissKeyboardTimeoutId = null;
  }
}
function dismissSoftInput3(view) {
  clearDismissTimer();
  if (!dismissKeyboardTimeoutId) {
    dismissKeyboardTimeoutId = setTimeout2(() => {
      const activity = view._context;
      dismissKeyboardTimeoutId = null;
      const focused = activity && activity.getCurrentFocus();
      if (focused && !(focused instanceof android.widget.EditText)) {
        ad.dismissSoftInput(focused);
      }
    }, 10);
  }
}
function initializeEditTextListeners() {
  if (EditTextListeners) {
    return;
  }
  var EditTextListenersImpl = function(_super) {
    __extends(EditTextListenersImpl2, _super);
    function EditTextListenersImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    EditTextListenersImpl2.prototype.beforeTextChanged = function(text, start2, count, after) {
      var _a4, _b4;
      (_b4 = (_a4 = this.owner) === null || _a4 === undefined ? undefined : _a4.get()) === null || _b4 === undefined || _b4.beforeTextChanged(text, start2, count, after);
    };
    EditTextListenersImpl2.prototype.onTextChanged = function(text, start2, before, count) {
      var _a4, _b4;
      (_b4 = (_a4 = this.owner) === null || _a4 === undefined ? undefined : _a4.get()) === null || _b4 === undefined || _b4.onTextChanged(text, start2, before, count);
    };
    EditTextListenersImpl2.prototype.afterTextChanged = function(editable) {
      var _a4, _b4;
      (_b4 = (_a4 = this.owner) === null || _a4 === undefined ? undefined : _a4.get()) === null || _b4 === undefined || _b4.afterTextChanged(editable);
    };
    EditTextListenersImpl2.prototype.onFocusChange = function(view, hasFocus) {
      var _a4, _b4;
      (_b4 = (_a4 = this.owner) === null || _a4 === undefined ? undefined : _a4.get()) === null || _b4 === undefined || _b4.onFocusChange(view, hasFocus);
    };
    EditTextListenersImpl2.prototype.onEditorAction = function(textView, actionId, event) {
      var _a4, _b4;
      return ((_b4 = (_a4 = this.owner) === null || _a4 === undefined ? undefined : _a4.get()) === null || _b4 === undefined ? undefined : _b4.onEditorAction(textView, actionId, event)) || false;
    };
    EditTextListenersImpl2 = __decorate([
      Interfaces([android.text.TextWatcher, android.view.View.OnFocusChangeListener, android.widget.TextView.OnEditorActionListener])
    ], EditTextListenersImpl2);
    return EditTextListenersImpl2;
  }(java.lang.Object);
  EditTextListeners = EditTextListenersImpl;
}

class EditableTextBase2 extends EditableTextBase {
  _onReturnPress() {}
  createNativeView() {
    return new android.widget.EditText(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const editText = this.nativeTextViewProtected;
    this._configureEditText(editText);
    initializeEditTextListeners();
    const listeners = new EditTextListeners(new WeakRef(this));
    editText.addTextChangedListener(listeners);
    editText.setOnFocusChangeListener(listeners);
    editText.setOnEditorActionListener(listeners);
    editText.listener = listeners;
    this._inputType = editText.getInputType();
  }
  disposeNativeView() {
    const editText = this.nativeTextViewProtected;
    editText.removeTextChangedListener(editText.listener);
    editText.setOnFocusChangeListener(null);
    editText.setOnEditorActionListener(null);
    editText.listener.owner = null;
    editText.listener = null;
    this._keyListenerCache = null;
    this._dirtyTextAccumulator = undefined;
    this._inputType = 0;
    super.disposeNativeView();
  }
  resetNativeView() {
    super.resetNativeView();
    this.nativeTextViewProtected.setInputType(this._inputType);
  }
  onUnloaded() {
    this.dismissSoftInput();
    super.onUnloaded();
  }
  dismissSoftInput() {
    const nativeView = this.nativeTextViewProtected;
    if (!nativeView) {
      return;
    }
    ad.dismissSoftInput(nativeView);
  }
  focus() {
    const nativeView = this.nativeTextViewProtected;
    if (!nativeView) {
      return;
    }
    const result = super.focus();
    if (result) {
      ad.showSoftInput(this.nativeTextViewProtected);
    }
    return result;
  }
  _setInputType(inputType) {
    const nativeView = this.nativeTextViewProtected;
    try {
      this._changeFromCode = true;
      nativeView.setInputType(parseInt(inputType, 10));
    } finally {
      this._changeFromCode = false;
    }
    const listener = nativeView.getKeyListener();
    if (listener) {
      this._keyListenerCache = listener;
    }
    if (!this.editable) {
      nativeView.setFocusable(false);
      nativeView.setFocusableInTouchMode(false);
      nativeView.setLongClickable(false);
      nativeView.setClickable(false);
    }
  }
  [textProperty2.getDefault]() {
    return resetSymbol;
  }
  [textProperty2.setNative](value) {
    try {
      this._changeFromCode = true;
      this._setNativeText(value === resetSymbol);
    } finally {
      this._changeFromCode = false;
    }
  }
  [keyboardTypeProperty.getDefault]() {
    return this.nativeTextViewProtected.getInputType();
  }
  [keyboardTypeProperty.setNative](value) {
    let newInputType;
    switch (value) {
      case "datetime":
        newInputType = android.text.InputType.TYPE_CLASS_DATETIME | android.text.InputType.TYPE_DATETIME_VARIATION_NORMAL;
        break;
      case "phone":
        newInputType = android.text.InputType.TYPE_CLASS_PHONE;
        break;
      case "number":
        newInputType = android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_VARIATION_NORMAL | android.text.InputType.TYPE_NUMBER_FLAG_SIGNED | android.text.InputType.TYPE_NUMBER_FLAG_DECIMAL;
        break;
      case "decimal":
        newInputType = android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_FLAG_DECIMAL | android.text.InputType.TYPE_NUMBER_FLAG_SIGNED;
        break;
      case "url":
        newInputType = android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_URI;
        break;
      case "email":
        newInputType = android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS;
        break;
      case "integer":
        newInputType = android.text.InputType.TYPE_CLASS_NUMBER;
        break;
      default: {
        const inputType = +value;
        if (!isNaN(inputType)) {
          newInputType = inputType;
        } else {
          newInputType = android.text.InputType.TYPE_CLASS_TEXT;
        }
        break;
      }
    }
    this._setInputType(newInputType);
  }
  [autofillTypeProperty.setNative](value) {
    if (SDK_VERSION < 26) {
      return;
    }
    let newOptions;
    switch (value) {
      case "phone":
        newOptions = "phone";
        break;
      case "postalCode":
        newOptions = "postalCode";
        break;
      case "creditCardNumber":
        newOptions = "creditCardNumber";
        break;
      case "email":
        newOptions = "emailAddress";
        break;
      case "name":
        newOptions = "name";
        break;
      case "username":
        newOptions = "username";
        break;
      case "password":
        newOptions = "password";
        break;
      case "newPassword":
        newOptions = "newPassword";
        break;
      case "newUsername":
        newOptions = "newUsername";
        break;
      case "oneTimeCode":
        newOptions = "2faAppOTPCode";
        break;
      case "none":
        newOptions = null;
        break;
      default: {
        newOptions = value;
        break;
      }
    }
    if (newOptions) {
      const array = Array.create(java.lang.String, 1);
      array[0] = newOptions;
      this.nativeTextViewProtected.setAutofillHints(array);
    } else {
      this.nativeTextViewProtected.setAutofillHints(null);
    }
  }
  [returnKeyTypeProperty.getDefault]() {
    const ime = this.nativeTextViewProtected.getImeOptions();
    switch (ime) {
      case android.view.inputmethod.EditorInfo.IME_ACTION_DONE:
        return "done";
      case android.view.inputmethod.EditorInfo.IME_ACTION_GO:
        return "go";
      case android.view.inputmethod.EditorInfo.IME_ACTION_NEXT:
        return "next";
      case android.view.inputmethod.EditorInfo.IME_ACTION_SEARCH:
        return "search";
      case android.view.inputmethod.EditorInfo.IME_ACTION_SEND:
        return "send";
      default:
        return ime.toString();
    }
  }
  [returnKeyTypeProperty.setNative](value) {
    let newImeOptions;
    switch (value) {
      case "done":
        newImeOptions = android.view.inputmethod.EditorInfo.IME_ACTION_DONE;
        break;
      case "go":
        newImeOptions = android.view.inputmethod.EditorInfo.IME_ACTION_GO;
        break;
      case "next":
        newImeOptions = android.view.inputmethod.EditorInfo.IME_ACTION_NEXT;
        break;
      case "search":
        newImeOptions = android.view.inputmethod.EditorInfo.IME_ACTION_SEARCH;
        break;
      case "send":
        newImeOptions = android.view.inputmethod.EditorInfo.IME_ACTION_SEND;
        break;
      default: {
        const ime = +value;
        if (!isNaN(ime)) {
          newImeOptions = ime;
        } else {
          newImeOptions = android.view.inputmethod.EditorInfo.IME_ACTION_UNSPECIFIED;
        }
        break;
      }
    }
    this.nativeTextViewProtected.setImeOptions(newImeOptions);
  }
  [editableProperty.setNative](value) {
    const nativeView = this.nativeTextViewProtected;
    if (value) {
      nativeView.setKeyListener(this._keyListenerCache);
    } else {
      if (!this._keyListenerCache) {
        this._keyListenerCache = nativeView.getKeyListener();
      }
      nativeView.setKeyListener(null);
    }
  }
  [autocapitalizationTypeProperty.getDefault]() {
    const inputType = this.nativeTextViewProtected.getInputType();
    if ((inputType & android.text.InputType.TYPE_TEXT_FLAG_CAP_WORDS) === android.text.InputType.TYPE_TEXT_FLAG_CAP_WORDS) {
      return "words";
    } else if ((inputType & android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) === android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) {
      return "sentences";
    } else if ((inputType & android.text.InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) === android.text.InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) {
      return "allcharacters";
    } else {
      return inputType.toString();
    }
  }
  [autocapitalizationTypeProperty.setNative](value) {
    let inputType = this.nativeTextViewProtected.getInputType();
    inputType = inputType & ~28672;
    switch (value) {
      case "none":
        break;
      case "words":
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_WORDS;
        break;
      case "sentences":
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
        break;
      case "allcharacters":
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS;
        break;
      default: {
        const number2 = +value;
        if (!isNaN(number2)) {
          inputType = number2;
        } else {
          inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
        }
        break;
      }
    }
    this._setInputType(inputType);
  }
  [autocorrectProperty.getDefault]() {
    const autocorrect = this.nativeTextViewProtected.getInputType();
    if ((autocorrect & android.text.InputType.TYPE_TEXT_FLAG_AUTO_CORRECT) === android.text.InputType.TYPE_TEXT_FLAG_AUTO_CORRECT) {
      return true;
    }
    return false;
  }
  [autocorrectProperty.setNative](value) {
    let inputType = this.nativeTextViewProtected.getInputType();
    switch (value) {
      case true:
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;
        inputType = inputType & ~android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        break;
      case false:
        inputType = inputType & ~android.text.InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        inputType = inputType & ~android.text.InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        break;
      default:
        break;
    }
    this._setInputType(inputType);
  }
  [hintProperty.getDefault]() {
    return this.nativeTextViewProtected.getHint();
  }
  [hintProperty.setNative](value) {
    const text = value === null || value === undefined ? null : value.toString();
    this.nativeTextViewProtected.setHint(text);
  }
  [placeholderColorProperty.getDefault]() {
    return this.nativeTextViewProtected.getHintTextColors();
  }
  [placeholderColorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    this.nativeTextViewProtected.setHintTextColor(color2);
  }
  [textTransformProperty.setNative](value) {}
  [maxLengthProperty.setNative](value) {
    if (value === Number.POSITIVE_INFINITY) {
      this.nativeTextViewProtected.setFilters([]);
    } else {
      const lengthFilter = new android.text.InputFilter.LengthFilter(value);
      const filters = this.nativeTextViewProtected.getFilters();
      const newFilters = [];
      for (let i4 = 0;i4 < filters.length; i4++) {
        const filter = filters[i4];
        if (!(filter instanceof android.text.InputFilter.LengthFilter)) {
          newFilters.push(filter);
        }
      }
      newFilters.push(lengthFilter);
      this.nativeTextViewProtected.setFilters(newFilters);
    }
  }
  setSelection(start2, stop2) {
    const view = this.nativeTextViewProtected;
    if (view) {
      if (stop2 !== undefined) {
        view.setSelection(start2, stop2);
      } else {
        view.setSelection(start2);
      }
    }
  }
  beforeTextChanged(text, start2, count, after) {}
  onTextChanged(text, start2, before, count) {
    if (this.valueFormatter) {
      this.text = this.valueFormatter(text.toString());
      this.android.setSelection((this.text || "").length);
    }
  }
  afterTextChanged(editable) {
    if (this._changeFromCode) {
      return;
    }
    switch (this.updateTextTrigger) {
      case "focusLost":
        this._dirtyTextAccumulator = editable.toString();
        break;
      case "textChanged":
        textProperty2.nativeValueChange(this, editable.toString());
        break;
      default:
        throw new Error("Invalid updateTextTrigger: " + this.updateTextTrigger);
    }
  }
  onFocusChange(view, hasFocus) {
    if (hasFocus) {
      clearDismissTimer();
      this.notify({ eventName: EditableTextBase2.focusEvent });
    } else {
      if (this._dirtyTextAccumulator || this._dirtyTextAccumulator === "") {
        textProperty2.nativeValueChange(this, this._dirtyTextAccumulator);
        this._dirtyTextAccumulator = undefined;
      }
      this.notify({ eventName: EditableTextBase2.blurEvent });
      dismissSoftInput3(this);
    }
  }
  onEditorAction(textView, actionId, event) {
    if (actionId === android.view.inputmethod.EditorInfo.IME_ACTION_DONE || actionId === android.view.inputmethod.EditorInfo.IME_ACTION_UNSPECIFIED || event && event.getKeyCode() === android.view.KeyEvent.KEYCODE_ENTER) {
      if (textView.getMaxLines() === 1) {
        this.dismissSoftInput();
      }
      this._onReturnPress();
    } else if (actionId === android.view.inputmethod.EditorInfo.IME_ACTION_NEXT || actionId === android.view.inputmethod.EditorInfo.IME_ACTION_PREVIOUS) {
      this._onReturnPress();
    }
    return false;
  }
}

// node_modules/@nativescript/core/ui/text-field/text-field-common.js
var TextFieldBase = class TextFieldBase2 extends EditableTextBase2 {
};
TextFieldBase.returnPressEvent = "returnPress";
TextFieldBase = __decorate([
  CSSType("TextField")
], TextFieldBase);
TextFieldBase.prototype.recycleNativeView = "auto";
var secureProperty = new Property({
  name: "secure",
  defaultValue: false,
  valueConverter: booleanConverter
});
secureProperty.register(TextFieldBase);
var closeOnReturnProperty = new Property({
  name: "closeOnReturn",
  defaultValue: true,
  valueConverter: booleanConverter
});
closeOnReturnProperty.register(TextFieldBase);

// node_modules/@nativescript/core/ui/text-field/index.android.js
class TextField extends TextFieldBase {
  _configureEditText(editText) {
    editText.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_NORMAL | android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES | android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    editText.setLines(1);
    editText.setMaxLines(1);
    editText.setHorizontallyScrolling(true);
  }
  _onReturnPress() {
    this.notify({ eventName: TextField.returnPressEvent, object: this });
  }
  [secureProperty.setNative]() {
    this.setSecureAndKeyboardType();
  }
  [keyboardTypeProperty.setNative]() {
    this.setSecureAndKeyboardType();
  }
  setSecureAndKeyboardType() {
    let inputType;
    const value = +this.keyboardType;
    if (typeof this.keyboardType !== "boolean" && !isNaN(value)) {
      this._setInputType(value);
      return;
    }
    if (this.secure) {
      if (this.keyboardType === "number") {
        inputType = android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_VARIATION_PASSWORD;
      } else {
        inputType = android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD;
      }
    } else {
      inputType = android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_NORMAL;
      if (this.autocorrect) {
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;
        inputType = inputType & ~android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
      }
      switch (this.autocapitalizationType) {
        case "words":
          inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_WORDS;
          break;
        case "sentences":
          inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
          break;
        case "allcharacters":
          inputType = inputType | android.text.InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS;
          break;
        default:
          break;
      }
      switch (this.keyboardType) {
        case "datetime":
          inputType = android.text.InputType.TYPE_CLASS_DATETIME | android.text.InputType.TYPE_DATETIME_VARIATION_NORMAL;
          break;
        case "phone":
          inputType = android.text.InputType.TYPE_CLASS_PHONE;
          break;
        case "number":
          inputType = android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_VARIATION_NORMAL | android.text.InputType.TYPE_NUMBER_FLAG_SIGNED | android.text.InputType.TYPE_NUMBER_FLAG_DECIMAL;
          break;
        case "decimal":
          inputType = android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_FLAG_DECIMAL | android.text.InputType.TYPE_NUMBER_FLAG_SIGNED;
          break;
        case "url":
          inputType = android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_URI;
          break;
        case "email":
          inputType = android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS;
          break;
        case "integer":
          inputType = android.text.InputType.TYPE_CLASS_NUMBER;
          break;
        default:
          break;
      }
    }
    this._setInputType(inputType);
  }
}
TextField.prototype._isSingleLine = true;

// node_modules/@nativescript/core/ui/dialogs/dialogs-common.js
var CSS_CLASS = `${CSSUtils.CLASS_PREFIX}dialog-item`;
var DialogStrings;
(function(DialogStrings2) {
  DialogStrings2.STRING = "string";
  DialogStrings2.PROMPT = "Prompt";
  DialogStrings2.CONFIRM = "Confirm";
  DialogStrings2.ALERT = "Alert";
  DialogStrings2.LOGIN = "Login";
  DialogStrings2.OK = "OK";
  DialogStrings2.CANCEL = "Cancel";
})(DialogStrings || (DialogStrings = {}));
var inputType;
(function(inputType2) {
  inputType2.text = "text";
  inputType2.password = "password";
  inputType2.email = "email";
  inputType2.number = "number";
  inputType2.decimal = "decimal";
  inputType2.phone = "phone";
})(inputType || (inputType = {}));
var capitalizationType;
(function(capitalizationType2) {
  capitalizationType2.none = "none";
  capitalizationType2.all = "all";
  capitalizationType2.sentences = "sentences";
  capitalizationType2.words = "words";
})(capitalizationType || (capitalizationType = {}));
function getCurrentPage() {
  const topmostFrame = Frame.topmost();
  if (topmostFrame) {
    return topmostFrame.currentPage;
  }
  return;
}
function applySelectors(view, callback) {
  const currentPage = getCurrentPage();
  if (currentPage) {
    const styleScope = currentPage._styleScope;
    if (styleScope) {
      view.parent = currentPage;
      view._inheritStyleScope(styleScope);
      view.onLoaded();
      callback(view);
      view.onUnloaded();
    }
  }
}
var button;
var label;
function getButtonColors() {
  if (!button) {
    button = new Button;
    button.className = CSS_CLASS;
    if (__APPLE__) {
      button._setupUI({});
    }
  }
  let buttonColor;
  let buttonBackgroundColor;
  applySelectors(button, (btn) => {
    buttonColor = btn.color;
    buttonBackgroundColor = btn.backgroundColor;
  });
  return { color: buttonColor, backgroundColor: buttonBackgroundColor };
}
function getLabelColor() {
  if (!label) {
    label = new Label;
    label.className = CSS_CLASS;
    if (__APPLE__) {
      label._setupUI({});
    }
  }
  let labelColor;
  applySelectors(label, (lbl) => {
    labelColor = lbl.color;
  });
  return labelColor;
}
function isDialogOptions(arg) {
  return arg && (arg.message || arg.title);
}
function parseLoginOptions(args) {
  if (args.length === 1 && isObject(args[0])) {
    return args[0];
  }
  const options = {
    title: DialogStrings.LOGIN,
    okButtonText: DialogStrings.OK,
    cancelButtonText: DialogStrings.CANCEL
  };
  if (isString(args[0])) {
    options.message = args[0];
  }
  if (isString(args[1])) {
    options.userNameHint = args[1];
  }
  if (isString(args[2])) {
    options.passwordHint = args[2];
  }
  if (isString(args[3])) {
    options.userName = args[3];
  }
  if (isString(args[4])) {
    options.password = args[4];
  }
  return options;
}

// node_modules/@nativescript/core/ui/dialogs/index.android.js
function isString2(value) {
  return typeof value === "string";
}
function createAlertDialog(options) {
  const alert2 = new android.app.AlertDialog.Builder(android2.getCurrentActivity(), options.theme ? options.theme : -1);
  alert2.setTitle(options && isString2(options.title) ? options.title : "");
  alert2.setMessage(options && isString2(options.message) ? options.message : "");
  if (options && options.cancelable === false) {
    alert2.setCancelable(false);
  }
  return alert2;
}
function showDialog(builder) {
  const dlg = builder.show();
  const labelColor = getLabelColor();
  if (labelColor) {
    const textViewId = dlg.getContext().getResources().getIdentifier("android:id/alertTitle", null, null);
    if (textViewId) {
      const tv = dlg.findViewById(textViewId);
      if (tv) {
        tv.setTextColor(labelColor.android);
      }
    }
    const messageTextViewId = dlg.getContext().getResources().getIdentifier("android:id/message", null, null);
    if (messageTextViewId) {
      const messageTextView = dlg.findViewById(messageTextViewId);
      if (messageTextView) {
        messageTextView.setTextColor(labelColor.android);
      }
    }
  }
  const { color: color2, backgroundColor } = getButtonColors();
  if (color2) {
    const buttons = [];
    for (let i4 = 0;i4 < 4; i4++) {
      const id = dlg.getContext().getResources().getIdentifier("android:id/button" + i4, null, null);
      buttons[i4] = dlg.findViewById(id);
    }
    buttons.forEach((button2) => {
      if (button2) {
        if (color2) {
          button2.setTextColor(color2.android);
        }
        if (backgroundColor) {
          button2.setBackgroundColor(backgroundColor.android);
        }
      }
    });
  }
}
function addButtonsToAlertDialog(alert2, options, callback) {
  if (!options) {
    return;
  }
  if (options.okButtonText) {
    alert2.setPositiveButton(options.okButtonText, new android.content.DialogInterface.OnClickListener({
      onClick: function(dialog, id) {
        dialog.cancel();
        callback(true);
      }
    }));
  }
  if (options.cancelButtonText) {
    alert2.setNegativeButton(options.cancelButtonText, new android.content.DialogInterface.OnClickListener({
      onClick: function(dialog, id) {
        dialog.cancel();
        callback(false);
      }
    }));
  }
  if (options.neutralButtonText) {
    alert2.setNeutralButton(options.neutralButtonText, new android.content.DialogInterface.OnClickListener({
      onClick: function(dialog, id) {
        dialog.cancel();
        callback(undefined);
      }
    }));
  }
  alert2.setOnDismissListener(new android.content.DialogInterface.OnDismissListener({
    onDismiss: function() {
      callback(false);
    }
  }));
}
function alert2(arg) {
  return new Promise((resolve, reject) => {
    try {
      const options = !isDialogOptions(arg) ? { title: DialogStrings.ALERT, okButtonText: DialogStrings.OK, message: arg + "" } : arg;
      const alert3 = createAlertDialog(options);
      alert3.setPositiveButton(options.okButtonText, new android.content.DialogInterface.OnClickListener({
        onClick: function(dialog, id) {
          dialog.cancel();
          resolve();
        }
      }));
      alert3.setOnDismissListener(new android.content.DialogInterface.OnDismissListener({
        onDismiss: function() {
          resolve();
        }
      }));
      showDialog(alert3);
    } catch (ex) {
      reject(ex);
    }
  });
}
function confirm(arg) {
  return new Promise((resolve, reject) => {
    try {
      const options = !isDialogOptions(arg) ? {
        title: DialogStrings.CONFIRM,
        okButtonText: DialogStrings.OK,
        cancelButtonText: DialogStrings.CANCEL,
        message: arg + ""
      } : arg;
      const alert3 = createAlertDialog(options);
      addButtonsToAlertDialog(alert3, options, function(result) {
        resolve(result);
      });
      showDialog(alert3);
    } catch (ex) {
      reject(ex);
    }
  });
}
function prompt(...args) {
  let options;
  const defaultOptions2 = {
    title: DialogStrings.PROMPT,
    okButtonText: DialogStrings.OK,
    cancelButtonText: DialogStrings.CANCEL,
    inputType: inputType.text
  };
  const arg = args[0];
  if (args.length === 1) {
    if (isString2(arg)) {
      options = defaultOptions2;
      options.message = arg;
    } else {
      options = arg;
    }
  } else if (args.length === 2) {
    if (isString2(arg) && isString2(args[1])) {
      options = defaultOptions2;
      options.message = arg;
      options.defaultText = args[1];
    }
  }
  return new Promise((resolve, reject) => {
    try {
      const alert3 = createAlertDialog(options);
      const input = new android.widget.EditText(android2.getCurrentActivity());
      if (options) {
        if (options.inputType === inputType.password) {
          input.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
        } else if (options.inputType === inputType.email) {
          input.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
        } else if (options.inputType === inputType.number) {
          input.setInputType(android.text.InputType.TYPE_CLASS_NUMBER);
        } else if (options.inputType === inputType.decimal) {
          input.setInputType(android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_FLAG_DECIMAL);
        } else if (options.inputType === inputType.phone) {
          input.setInputType(android.text.InputType.TYPE_CLASS_PHONE);
        }
        switch (options.capitalizationType) {
          case capitalizationType.all: {
            input.setInputType(input.getInputType() | android.text.InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS);
            break;
          }
          case capitalizationType.sentences: {
            input.setInputType(input.getInputType() | android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES);
            break;
          }
          case capitalizationType.words: {
            input.setInputType(input.getInputType() | android.text.InputType.TYPE_TEXT_FLAG_CAP_WORDS);
            break;
          }
        }
      }
      input.setText(options && options.defaultText || "");
      alert3.setView(input);
      const getText = function() {
        return input.getText().toString();
      };
      addButtonsToAlertDialog(alert3, options, function(r3) {
        resolve({ result: r3, text: getText() });
      });
      showDialog(alert3);
    } catch (ex) {
      reject(ex);
    }
  });
}
function login(...args) {
  const options = parseLoginOptions(args);
  return new Promise((resolve, reject) => {
    try {
      const alert3 = createAlertDialog(options);
      const userNameInput = new android.widget.EditText(getNativeApp().getApplicationContext());
      userNameInput.setHint(options.userNameHint ? options.userNameHint : "");
      userNameInput.setText(options.userName ? options.userName : "");
      const passwordInput = new android.widget.EditText(getNativeApp().getApplicationContext());
      passwordInput.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
      passwordInput.setTypeface(android.graphics.Typeface.DEFAULT);
      passwordInput.setHint(options.passwordHint ? options.passwordHint : "");
      passwordInput.setText(options.password ? options.password : "");
      const layout2 = new android.widget.LinearLayout(getNativeApp().getApplicationContext());
      layout2.setOrientation(1);
      layout2.addView(userNameInput);
      layout2.addView(passwordInput);
      alert3.setView(layout2);
      addButtonsToAlertDialog(alert3, options, function(r3) {
        resolve({
          result: r3,
          userName: userNameInput.getText().toString(),
          password: passwordInput.getText().toString()
        });
      });
      showDialog(alert3);
    } catch (ex) {
      reject(ex);
    }
  });
}
function action(...args) {
  let options;
  const defaultOptions2 = { title: null, cancelButtonText: DialogStrings.CANCEL };
  if (args.length === 1) {
    if (isString2(args[0])) {
      options = defaultOptions2;
      options.message = args[0];
    } else {
      options = args[0];
    }
  } else if (args.length === 2) {
    if (isString2(args[0]) && isString2(args[1])) {
      options = defaultOptions2;
      options.message = args[0];
      options.cancelButtonText = args[1];
    }
  } else if (args.length === 3) {
    if (isString2(args[0]) && isString2(args[1]) && typeof args[2] !== "undefined") {
      options = defaultOptions2;
      options.message = args[0];
      options.cancelButtonText = args[1];
      options.actions = args[2];
    }
  }
  return new Promise((resolve, reject) => {
    try {
      const alert3 = new android.app.AlertDialog.Builder(android2.getCurrentActivity(), options.theme ? options.theme : -1);
      const message = options && isString2(options.message) ? options.message : "";
      const title = options && isString2(options.title) ? options.title : "";
      if (options && options.cancelable === false) {
        alert3.setCancelable(false);
      }
      if (title) {
        alert3.setTitle(title);
        if (!options.actions) {
          alert3.setMessage(message);
        }
      } else {
        alert3.setTitle(message);
      }
      if (options.actions) {
        alert3.setItems(options.actions, new android.content.DialogInterface.OnClickListener({
          onClick: function(dialog, which) {
            resolve(options.actions[which]);
          }
        }));
      }
      if (isString2(options.cancelButtonText)) {
        alert3.setNegativeButton(options.cancelButtonText, new android.content.DialogInterface.OnClickListener({
          onClick: function(dialog, id) {
            dialog.cancel();
            resolve(options.cancelButtonText);
          }
        }));
      }
      alert3.setOnDismissListener(new android.content.DialogInterface.OnDismissListener({
        onDismiss: function() {
          if (isString2(options.cancelButtonText)) {
            resolve(options.cancelButtonText);
          } else {
            resolve("");
          }
        }
      }));
      showDialog(alert3);
    } catch (ex) {
      reject(ex);
    }
  });
}
// node_modules/@nativescript/core/ui/html-view/html-view-common.js
var HtmlViewBase = class HtmlViewBase2 extends View {
};
HtmlViewBase = __decorate([
  CSSType("HtmlView")
], HtmlViewBase);
HtmlViewBase.prototype.recycleNativeView = "auto";
var htmlProperty = new Property({
  name: "html",
  defaultValue: "",
  affectsLayout: true
});
htmlProperty.register(HtmlViewBase);
var selectableProperty = new Property({
  name: "selectable",
  defaultValue: true,
  valueConverter: booleanConverter
});
selectableProperty.register(HtmlViewBase);
var linkColorProperty = new Property({
  name: "linkColor",
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
linkColorProperty.register(HtmlViewBase);

// node_modules/@nativescript/core/ui/html-view/index.android.js
class HtmlView extends HtmlViewBase {
  createNativeView() {
    return new android.widget.TextView(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    nativeView.setTextIsSelectable(true);
    nativeView.setLinksClickable(true);
    nativeView.setMovementMethod(android.text.method.LinkMovementMethod.getInstance());
  }
  resetNativeView() {
    super.resetNativeView();
    this.nativeViewProtected.setAutoLinkMask(0);
  }
  [htmlProperty.getDefault]() {
    return "";
  }
  [htmlProperty.setNative](value) {
    let mask = 15;
    if (value.search(/<a\s/i) >= 0) {
      mask = 0;
    }
    this.nativeViewProtected.setAutoLinkMask(mask);
    if (SDK_VERSION >= 24) {
      this.nativeViewProtected.setText(android.text.Html.fromHtml(value, android.text.Html.FROM_HTML_MODE_LEGACY));
    } else {
      this.nativeViewProtected.setText(android.text.Html.fromHtml(value));
    }
  }
  [selectableProperty.getDefault]() {
    return true;
  }
  [selectableProperty.setNative](value) {
    this.nativeViewProtected.setTextIsSelectable(value);
  }
  [colorProperty.getDefault]() {
    return this.nativeViewProtected.getTextColors();
  }
  [colorProperty.setNative](value) {
    if (value instanceof Color) {
      this.nativeViewProtected.setTextColor(value.android);
    } else {
      this.nativeViewProtected.setTextColor(value);
    }
  }
  [linkColorProperty.getDefault]() {
    return this.nativeViewProtected.getLinkTextColors();
  }
  [linkColorProperty.setNative](value) {
    if (value instanceof Color) {
      this.nativeViewProtected.setLinkTextColor(value.android);
    } else {
      this.nativeViewProtected.setLinkTextColor(value);
    }
  }
  [fontInternalProperty.getDefault]() {
    return this.nativeViewProtected.getTypeface();
  }
  [fontInternalProperty.setNative](value) {
    const font = value instanceof Font2 ? value.getAndroidTypeface() : value;
    this.nativeViewProtected.setTypeface(font);
  }
  [fontSizeProperty.getDefault]() {
    return { nativeSize: this.nativeViewProtected.getTextSize() };
  }
  [fontSizeProperty.setNative](value) {
    if (typeof value === "number") {
      this.nativeViewProtected.setTextSize(value);
    } else {
      this.nativeViewProtected.setTextSize(android.util.TypedValue.COMPLEX_UNIT_PX, value.nativeSize);
    }
  }
}
// node_modules/@nativescript/core/ui/image/symbol-effects-common.js
var ImageSymbolEffects;
(function(ImageSymbolEffects2) {
  ImageSymbolEffects2["Appear"] = "appear";
  ImageSymbolEffects2["AppearUp"] = "appearUp";
  ImageSymbolEffects2["AppearDown"] = "appearDown";
  ImageSymbolEffects2["Bounce"] = "bounce";
  ImageSymbolEffects2["BounceUp"] = "bounceUp";
  ImageSymbolEffects2["BounceDown"] = "bounceDown";
  ImageSymbolEffects2["Disappear"] = "disappear";
  ImageSymbolEffects2["DisappearDown"] = "disappearDown";
  ImageSymbolEffects2["DisappearUp"] = "disappearUp";
  ImageSymbolEffects2["Pulse"] = "pulse";
  ImageSymbolEffects2["Scale"] = "scale";
  ImageSymbolEffects2["ScaleDown"] = "scaleDown";
  ImageSymbolEffects2["ScaleUp"] = "scaleUp";
  ImageSymbolEffects2["VariableColor"] = "variableColor";
  ImageSymbolEffects2["Breathe"] = "breathe";
  ImageSymbolEffects2["BreathePlain"] = "breathePlain";
  ImageSymbolEffects2["BreathePulse"] = "breathePulse";
  ImageSymbolEffects2["Rotate"] = "rotate";
  ImageSymbolEffects2["RotateClockwise"] = "rotateClockwise";
  ImageSymbolEffects2["RotateCounterClockwise"] = "rotateCounterClockwise";
  ImageSymbolEffects2["Wiggle"] = "wiggle";
  ImageSymbolEffects2["WiggleBackward"] = "wiggleBackward";
  ImageSymbolEffects2["WiggleClockwise"] = "wiggleClockwise";
  ImageSymbolEffects2["WiggleCounterClockwise"] = "wiggleCounterClockwise";
  ImageSymbolEffects2["WiggleDown"] = "wiggleDown";
  ImageSymbolEffects2["WiggleForward"] = "wiggleForward";
  ImageSymbolEffects2["WiggleUp"] = "wiggleUp";
  ImageSymbolEffects2["WiggleLeft"] = "wiggleLeft";
  ImageSymbolEffects2["WiggleRight"] = "wiggleRight";
})(ImageSymbolEffects || (ImageSymbolEffects = {}));
// node_modules/@nativescript/core/ui/image/image-common.js
var ImageBase = class ImageBase2 extends View {
  get tintColor() {
    return this.style.tintColor;
  }
  set tintColor(value) {
    this.style.tintColor = value;
  }
  disposeImageSource() {}
  _createImageSourceFromSrc(value) {
    this.disposeImageSource();
    const originalValue = value;
    const sync = this.loadMode === "sync";
    if (typeof value === "string" || value instanceof String) {
      value = value.trim();
      this.imageSource = null;
      this["_url"] = value;
      this.isLoading = true;
      const imageLoaded = (source) => {
        const currentValue = this.src;
        if (currentValue !== originalValue) {
          return;
        }
        this.imageSource = source;
        this.isLoading = false;
      };
      if (isFontIconURI(value)) {
        const fontIconCode = value.split("//")[1];
        if (fontIconCode !== undefined) {
          const font = this.style.fontInternal;
          const color2 = this.style.color;
          imageLoaded(ImageSource.fromFontIconCodeSync(fontIconCode, font, color2));
        }
      } else if (isDataURI(value)) {
        const base64Data = value.split(",")[1];
        if (base64Data !== undefined) {
          if (sync) {
            imageLoaded(ImageSource.fromBase64Sync(base64Data));
          } else {
            ImageSource.fromBase64(base64Data).then(imageLoaded);
          }
        }
      } else if (isFileOrResourcePath(value)) {
        if (value.indexOf(RESOURCE_PREFIX) === 0) {
          const resPath = value.slice(RESOURCE_PREFIX.length);
          if (sync) {
            imageLoaded(ImageSource.fromResourceSync(resPath));
          } else {
            this.imageSource = null;
            ImageSource.fromResource(resPath).then(imageLoaded);
          }
        } else if (value.indexOf(SYSTEM_PREFIX) === 0) {
          const sysPath = value.slice(SYSTEM_PREFIX.length);
          if (sync) {
            imageLoaded(ImageSource.fromSystemImageSync(sysPath, this));
          } else {
            this.imageSource = null;
            ImageSource.fromSystemImage(sysPath, this).then(imageLoaded);
          }
        } else {
          if (sync) {
            imageLoaded(ImageSource.fromFileSync(value));
          } else {
            this.imageSource = null;
            ImageSource.fromFile(value).then(imageLoaded);
          }
        }
      } else {
        this.imageSource = null;
        ImageSource.fromUrl(value).then((r3) => {
          if (this["_url"] === value) {
            this.imageSource = r3;
            this.isLoading = false;
          }
        }, (err) => {
          this.isLoading = false;
          if (Trace.isEnabled()) {
            if (typeof err === "object" && err.message) {
              err = err.message;
            }
            Trace.write(err, Trace.categories.Debug);
          }
        });
      }
    } else if (value instanceof ImageSource) {
      this.imageSource = new ImageSource(value.getNativeSource());
      this.isLoading = false;
    } else if (value instanceof ImageAsset) {
      ImageSource.fromAsset(value).then((result) => {
        this.imageSource = result;
        this.isLoading = false;
      });
    } else {
      this.imageSource = new ImageSource(value);
      this.isLoading = false;
    }
  }
};
ImageBase.isLoadingChangeEvent = "isLoadingChange";
ImageBase = __decorate([
  CSSType("Image")
], ImageBase);
ImageBase.prototype.recycleNativeView = "auto";
var imageSourceProperty = new Property({
  name: "imageSource"
});
imageSourceProperty.register(ImageBase);
var srcProperty = new Property({ name: "src" });
srcProperty.register(ImageBase);
var loadModeProperty = new Property({
  name: "loadMode",
  defaultValue: "sync"
});
loadModeProperty.register(ImageBase);
var isLoadingProperty = new Property({
  name: "isLoading",
  defaultValue: false,
  valueConverter: booleanConverter
});
isLoadingProperty.register(ImageBase);
var stretchProperty = new Property({
  name: "stretch",
  defaultValue: "aspectFit",
  affectsLayout: __APPLE__
});
stretchProperty.register(ImageBase);
var tintColorProperty = new InheritedCssProperty({
  name: "tintColor",
  cssName: "tint-color",
  equalityComparer: Color.equals,
  valueConverter: (value) => new Color(value)
});
tintColorProperty.register(Style);
var decodeHeightProperty = new Property({
  name: "decodeHeight",
  defaultValue: { value: 0, unit: "dip" },
  equalityComparer: Length.equals,
  valueConverter: Length.parse
});
decodeHeightProperty.register(ImageBase);
var decodeWidthProperty = new Property({
  name: "decodeWidth",
  defaultValue: { value: 0, unit: "dip" },
  equalityComparer: Length.equals,
  valueConverter: Length.parse
});
decodeWidthProperty.register(ImageBase);
var iosSymbolEffectProperty = new Property({
  name: "iosSymbolEffect"
});
iosSymbolEffectProperty.register(ImageBase);
var iosSymbolScaleProperty = new Property({
  name: "iosSymbolScale"
});
iosSymbolScaleProperty.register(ImageBase);

// node_modules/@nativescript/core/ui/image/index.android.js
var FILE_PREFIX2 = "file:///";
var ASYNC = "async";
var AndroidImageView;
var ImageLoadedListener;
function initializeImageLoadedListener() {
  if (ImageLoadedListener) {
    return;
  }
  var ImageLoadedListenerImpl = function(_super) {
    __extends(ImageLoadedListenerImpl2, _super);
    function ImageLoadedListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    ImageLoadedListenerImpl2.prototype.onImageLoaded = function(success) {
      var owner = this.owner;
      if (owner) {
        owner.isLoading = false;
      }
    };
    ImageLoadedListenerImpl2 = __decorate([
      Interfaces([org.nativescript.widgets.image.Worker.OnImageLoadedListener])
    ], ImageLoadedListenerImpl2);
    return ImageLoadedListenerImpl2;
  }(java.lang.Object);
  ImageLoadedListener = ImageLoadedListenerImpl;
}

class Image extends ImageBase {
  constructor() {
    super(...arguments);
    this.useCache = true;
  }
  createNativeView() {
    if (!AndroidImageView) {
      AndroidImageView = org.nativescript.widgets.ImageView;
    }
    return new AndroidImageView(this._context);
  }
  initNativeView() {
    super.initNativeView();
    initializeImageLoadedListener();
    const nativeView = this.nativeViewProtected;
    const listener = new ImageLoadedListener(this);
    nativeView.setImageLoadedListener(listener);
    nativeView.listener = listener;
  }
  disposeNativeView() {
    if (this.nativeViewProtected?.listener) {
      this.nativeViewProtected.listener.owner = null;
    }
    super.disposeNativeView();
  }
  resetNativeView() {
    super.resetNativeView();
    this.nativeViewProtected.setImageMatrix(new android.graphics.Matrix);
  }
  _createImageSourceFromSrc(value) {
    const imageView = this.nativeViewProtected;
    if (!imageView) {
      return;
    }
    if (!value) {
      imageView.setUri(null, 0, 0, false, false, true);
      return;
    }
    let decodeWidth = Math.min(Length.toDevicePixels(this.decodeWidth, 0), Screen.mainScreen.widthPixels);
    let decodeHeight = Math.min(Length.toDevicePixels(this.decodeHeight, 0), Screen.mainScreen.heightPixels);
    let keepAspectRatio = this._calculateKeepAspectRatio();
    if (value instanceof ImageAsset) {
      if (value.options) {
        decodeWidth = value.options.width || decodeWidth;
        decodeHeight = value.options.height || decodeHeight;
        keepAspectRatio = !!value.options.keepAspectRatio;
      }
      value = value.android;
    }
    const async = this.loadMode === ASYNC;
    if (typeof value === "string" || value instanceof String) {
      value = value.trim();
      this.isLoading = true;
      if (isFontIconURI(value) || isDataURI(value)) {
        super._createImageSourceFromSrc(value);
      } else if (isFileOrResourcePath(value)) {
        if (value.indexOf(RESOURCE_PREFIX) === 0) {
          imageView.setUri(value, decodeWidth, decodeHeight, keepAspectRatio, this.useCache, async);
        } else {
          let fileName = value;
          if (fileName.indexOf("~/") === 0) {
            fileName = knownFolders.currentApp().path + "/" + fileName.replace("~/", "");
          }
          imageView.setUri(FILE_PREFIX2 + fileName, decodeWidth, decodeHeight, keepAspectRatio, this.useCache, async);
        }
      } else {
        imageView.setUri(value, decodeWidth, decodeHeight, keepAspectRatio, this.useCache, true);
      }
    } else {
      super._createImageSourceFromSrc(value);
    }
  }
  _calculateKeepAspectRatio() {
    return this.stretch === "fill" ? false : true;
  }
  [stretchProperty.getDefault]() {
    return "aspectFit";
  }
  [stretchProperty.setNative](value) {
    switch (value) {
      case "aspectFit":
        this.nativeViewProtected.setScaleType(android.widget.ImageView.ScaleType.FIT_CENTER);
        break;
      case "aspectFill":
        this.nativeViewProtected.setScaleType(android.widget.ImageView.ScaleType.CENTER_CROP);
        break;
      case "fill":
        this.nativeViewProtected.setScaleType(android.widget.ImageView.ScaleType.FIT_XY);
        break;
      case "none":
      default:
        this.nativeViewProtected.setScaleType(android.widget.ImageView.ScaleType.MATRIX);
        break;
    }
  }
  [tintColorProperty.getDefault]() {
    return;
  }
  [tintColorProperty.setNative](value) {
    if (value) {
      this.nativeViewProtected.setColorFilter(value.android);
    } else {
      this.nativeViewProtected.clearColorFilter();
    }
  }
  [imageSourceProperty.getDefault]() {
    return;
  }
  [imageSourceProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    if (value && value.android) {
      const rotation = value.rotationAngle ? value.rotationAngle : 0;
      nativeView.setRotationAngle(rotation);
      nativeView.setImageBitmap(value.android);
    } else {
      nativeView.setRotationAngle(0);
      nativeView.setImageBitmap(null);
    }
  }
  [srcProperty.getDefault]() {
    return;
  }
  [srcProperty.setNative](value) {
    this._createImageSourceFromSrc(value);
  }
}
// node_modules/@nativescript/core/ui/image-cache/image-cache-common.js
class Cache extends Observable {
  constructor() {
    super(...arguments);
    this.maxRequests = 5;
    this._enabled = true;
    this._pendingDownloads = {};
    this._queue = [];
    this._currentDownloads = 0;
  }
  enableDownload() {
    if (this._enabled) {
      return;
    }
    this._enabled = true;
    let request2;
    while (this._queue.length > 0 && this._currentDownloads < this.maxRequests) {
      request2 = this._queue.pop();
      if (!(request2.key in this._pendingDownloads)) {
        this._download(request2);
      }
    }
  }
  disableDownload() {
    if (!this._enabled) {
      return;
    }
    this._enabled = false;
  }
  push(request2) {
    this._addRequest(request2, true);
  }
  enqueue(request2) {
    this._addRequest(request2, false);
  }
  _addRequest(request2, onTop) {
    if (request2.key in this._pendingDownloads) {
      const existingRequest = this._pendingDownloads[request2.key];
      this._mergeRequests(existingRequest, request2);
    } else {
      let queueRequest;
      for (let i4 = 0;i4 < this._queue.length; i4++) {
        if (this._queue[i4].key === request2.key) {
          queueRequest = this._queue[i4];
          break;
        }
      }
      if (queueRequest) {
        this._mergeRequests(queueRequest, request2);
      } else {
        if (this._shouldDownload(request2, onTop)) {
          this._download(request2);
        }
      }
    }
  }
  _mergeRequests(existingRequest, newRequest) {
    if (existingRequest.completed) {
      if (newRequest.completed) {
        const existingCompleted = existingRequest.completed;
        const stackCompleted = function(result, key) {
          existingCompleted(result, key);
          newRequest.completed(result, key);
        };
        existingRequest.completed = stackCompleted;
      }
    } else {
      existingRequest.completed = newRequest.completed;
    }
    if (existingRequest.error) {
      if (newRequest.error) {
        const existingError = existingRequest.error;
        const stackError = function(key) {
          existingError(key);
          newRequest.error(key);
        };
        existingRequest.error = stackError;
      }
    } else {
      existingRequest.error = newRequest.error;
    }
  }
  get(key) {
    throw new Error("Abstract");
  }
  set(key, image) {
    throw new Error("Abstract");
  }
  remove(key) {
    throw new Error("Abstract");
  }
  clear() {
    throw new Error("Abstract");
  }
  _downloadCore(request2) {
    throw new Error("Abstract");
  }
  _onDownloadCompleted(key, image) {
    const request2 = this._pendingDownloads[key];
    this.set(request2.key, image);
    this._currentDownloads--;
    if (request2.completed) {
      request2.completed(image, request2.key);
    }
    if (this.hasListeners(Cache.downloadedEvent)) {
      this.notify({
        eventName: Cache.downloadedEvent,
        object: this,
        key,
        image
      });
    }
    delete this._pendingDownloads[request2.key];
    this._updateQueue();
  }
  _onDownloadError(key, err) {
    const request2 = this._pendingDownloads[key];
    this._currentDownloads--;
    if (request2.error) {
      request2.error(request2.key);
    }
    if (this.hasListeners(Cache.downloadErrorEvent)) {
      this.notify({
        eventName: Cache.downloadErrorEvent,
        object: this,
        key,
        error: err
      });
    }
    delete this._pendingDownloads[request2.key];
    this._updateQueue();
  }
  _shouldDownload(request2, onTop) {
    if (this.get(request2.key) || request2.key in this._pendingDownloads) {
      return false;
    }
    if (this._currentDownloads >= this.maxRequests || !this._enabled) {
      if (onTop) {
        this._queue.push(request2);
      } else {
        this._queue.unshift(request2);
      }
      return false;
    }
    return true;
  }
  _download(request2) {
    this._currentDownloads++;
    this._pendingDownloads[request2.key] = request2;
    this._downloadCore(request2);
  }
  _updateQueue() {
    if (!this._enabled || this._queue.length === 0 || this._currentDownloads === this.maxRequests) {
      return;
    }
    const request2 = this._queue.pop();
    this._download(request2);
  }
}
Cache.downloadedEvent = "downloaded";
Cache.downloadErrorEvent = "downloadError";
// node_modules/@nativescript/core/ui/layouts/layout-base-common.js
class LayoutBaseCommon extends CustomLayoutView {
  constructor() {
    super(...arguments);
    this._subViews = new Array;
  }
  _addChildFromBuilder(name50, value) {
    if (value instanceof View) {
      this.addChild(value);
    }
  }
  getChildrenCount() {
    return this._subViews.length;
  }
  get _childrenCount() {
    return this._subViews.length;
  }
  getChildAt(index) {
    return this._subViews[index];
  }
  getChildIndex(child) {
    return this._subViews.indexOf(child);
  }
  getChildById(id) {
    return getViewById(this, id);
  }
  _registerLayoutChild(child) {}
  _unregisterLayoutChild(child) {}
  addChild(child) {
    this._subViews.push(child);
    this._addView(child);
    this._registerLayoutChild(child);
  }
  insertChild(child, atIndex) {
    if (atIndex > -1) {
      this._subViews.splice(atIndex, 0, child);
      this._addView(child, atIndex);
      this._registerLayoutChild(child);
      return true;
    }
    return false;
  }
  removeChild(child) {
    this._removeView(child);
    const index = this._subViews.indexOf(child);
    if (index > -1) {
      this._subViews.splice(index, 1);
      this._unregisterLayoutChild(child);
    }
  }
  removeChildren() {
    while (this.getChildrenCount() !== 0) {
      this.removeChild(this._subViews[this.getChildrenCount() - 1]);
    }
  }
  get padding() {
    return this.style.padding;
  }
  set padding(value) {
    this.style.padding = value;
  }
  get paddingTop() {
    return this.style.paddingTop;
  }
  set paddingTop(value) {
    this.style.paddingTop = value;
  }
  get paddingRight() {
    return this.style.paddingRight;
  }
  set paddingRight(value) {
    this.style.paddingRight = value;
  }
  get paddingBottom() {
    return this.style.paddingBottom;
  }
  set paddingBottom(value) {
    this.style.paddingBottom = value;
  }
  get paddingLeft() {
    return this.style.paddingLeft;
  }
  set paddingLeft(value) {
    this.style.paddingLeft = value;
  }
  _childIndexToNativeChildIndex(index) {
    if (index === undefined) {
      return;
    }
    let result = 0;
    for (let i4 = 0;i4 < index && i4 < this._subViews.length; i4++) {
      result += this._subViews[i4]._getNativeViewsCount();
    }
    return result;
  }
  eachChildView(callback) {
    for (let i4 = 0, length2 = this._subViews.length;i4 < length2; i4++) {
      const retVal = callback(this._subViews[i4]);
      if (retVal === false) {
        break;
      }
    }
  }
  eachLayoutChild(callback) {
    let lastChild = null;
    this.eachChildView((cv) => {
      cv._eachLayoutView((lv) => {
        if (lastChild && !lastChild.isCollapsed) {
          callback(lastChild, false);
        }
        lastChild = lv;
      });
      return true;
    });
    if (lastChild && !lastChild.isCollapsed) {
      callback(lastChild, true);
    }
  }
}
var clipToBoundsProperty = new Property({
  name: "clipToBounds",
  defaultValue: true,
  valueConverter: booleanConverter
});
clipToBoundsProperty.register(LayoutBaseCommon);
var isPassThroughParentEnabledProperty = new Property({
  name: "isPassThroughParentEnabled",
  defaultValue: false,
  valueConverter: booleanConverter
});
isPassThroughParentEnabledProperty.register(LayoutBaseCommon);

// node_modules/@nativescript/core/ui/layouts/layout-base.android.js
class LayoutBase extends LayoutBaseCommon {
  [clipToBoundsProperty.getDefault]() {
    return true;
  }
  [clipToBoundsProperty.setNative](value) {
    console.warn(`clipToBounds with value false is not supported on Android. You can use this.android.getParent().setClipChildren(false) as an alternative`);
  }
  [isPassThroughParentEnabledProperty.setNative](value) {
    this.nativeViewProtected.setPassThroughParent(value);
  }
  [paddingTopProperty.getDefault]() {
    return { value: this._defaultPaddingTop, unit: "px" };
  }
  [paddingTopProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingTop(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderTopWidth, 0));
  }
  [paddingRightProperty.getDefault]() {
    return { value: this._defaultPaddingRight, unit: "px" };
  }
  [paddingRightProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingRight(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderRightWidth, 0));
  }
  [paddingBottomProperty.getDefault]() {
    return { value: this._defaultPaddingBottom, unit: "px" };
  }
  [paddingBottomProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingBottom(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderBottomWidth, 0));
  }
  [paddingLeftProperty.getDefault]() {
    return { value: this._defaultPaddingLeft, unit: "px" };
  }
  [paddingLeftProperty.setNative](value) {
    org.nativescript.widgets.ViewHelper.setPaddingLeft(this.nativeViewProtected, Length.toDevicePixels(value, 0) + Length.toDevicePixels(this.style.borderLeftWidth, 0));
  }
}

// node_modules/@nativescript/core/ui/layouts/absolute-layout/absolute-layout-common.js
View.prototype.effectiveLeft = 0;
View.prototype.effectiveTop = 0;
function validateArgs2(element) {
  if (!element) {
    throw new Error("element cannot be null or undefinied.");
  }
  return element;
}
var AbsoluteLayoutBase = class AbsoluteLayoutBase2 extends LayoutBase {
  static getLeft(element) {
    return validateArgs2(element).left;
  }
  static setLeft(element, value) {
    validateArgs2(element).left = value;
  }
  static getTop(element) {
    return validateArgs2(element).top;
  }
  static setTop(element, value) {
    validateArgs2(element).top = value;
  }
  onLeftChanged(view, oldValue, newValue) {}
  onTopChanged(view, oldValue, newValue) {}
};
AbsoluteLayoutBase = __decorate([
  CSSType("AbsoluteLayout")
], AbsoluteLayoutBase);
AbsoluteLayoutBase.prototype.recycleNativeView = "auto";
var leftProperty = new Property({
  name: "left",
  defaultValue: CoreTypes.zeroLength,
  valueChanged: (target, oldValue, newValue) => {
    target.effectiveLeft = Length.toDevicePixels(newValue, 0);
    const layout2 = target.parent;
    if (layout2 instanceof AbsoluteLayoutBase) {
      layout2.onLeftChanged(target, oldValue, newValue);
    }
  },
  equalityComparer: Length.equals,
  valueConverter: Length.parse
});
leftProperty.register(View);
var topProperty = new Property({
  name: "top",
  defaultValue: CoreTypes.zeroLength,
  valueChanged: (target, oldValue, newValue) => {
    target.effectiveTop = Length.toDevicePixels(newValue, 0);
    const layout2 = target.parent;
    if (layout2 instanceof AbsoluteLayoutBase) {
      layout2.onTopChanged(target, oldValue, newValue);
    }
  },
  equalityComparer: Length.equals,
  valueConverter: Length.parse
});
topProperty.register(View);

// node_modules/@nativescript/core/ui/layouts/absolute-layout/index.android.js
function makeNativeSetter(setter) {
  return function(value) {
    const nativeView = this.nativeViewProtected;
    const lp = nativeView.getLayoutParams() || new org.nativescript.widgets.CommonLayoutParams;
    if (lp instanceof org.nativescript.widgets.CommonLayoutParams) {
      setter.call(this, lp, value);
      nativeView.setLayoutParams(lp);
    }
  };
}
View.prototype[topProperty.setNative] = makeNativeSetter(function(lp, value) {
  lp.top = Length.toDevicePixels(value, 0);
});
View.prototype[leftProperty.setNative] = makeNativeSetter(function(lp, value) {
  lp.left = Length.toDevicePixels(value, 0);
});
// node_modules/@nativescript/core/ui/layouts/dock-layout/dock-layout-common.js
function validateArgs3(element) {
  if (!element) {
    throw new Error("element cannot be null or undefinied.");
  }
  return element;
}
var DockLayoutBase = class DockLayoutBase2 extends LayoutBase {
  static getDock(element) {
    return validateArgs3(element).dock;
  }
  static setDock(element, value) {
    validateArgs3(element).dock = value;
  }
  onDockChanged(view, oldValue, newValue) {}
};
DockLayoutBase = __decorate([
  CSSType("DockLayout")
], DockLayoutBase);
DockLayoutBase.prototype.recycleNativeView = "auto";
var dockConverter = makeParser(makeValidator(CoreTypes.Dock.left, CoreTypes.Dock.top, CoreTypes.Dock.right, CoreTypes.Dock.bottom));
var dockProperty = new Property({
  name: "dock",
  defaultValue: "left",
  valueChanged: (target, oldValue, newValue) => {
    if (target instanceof View) {
      const layout2 = target.parent;
      if (layout2 instanceof DockLayoutBase) {
        layout2.onDockChanged(target, oldValue, newValue);
      }
    }
  },
  valueConverter: dockConverter
});
dockProperty.register(View);
var stretchLastChildProperty = new Property({
  name: "stretchLastChild",
  defaultValue: true,
  affectsLayout: __APPLE__,
  valueConverter: booleanConverter
});
stretchLastChildProperty.register(DockLayoutBase);

// node_modules/@nativescript/core/ui/layouts/dock-layout/index.android.js
View.prototype[dockProperty.setNative] = function(value) {
  const nativeView = this.nativeViewProtected;
  const lp = nativeView.getLayoutParams() || new org.nativescript.widgets.CommonLayoutParams;
  if (lp instanceof org.nativescript.widgets.CommonLayoutParams) {
    switch (value) {
      case "left":
        lp.dock = org.nativescript.widgets.Dock.left;
        break;
      case "top":
        lp.dock = org.nativescript.widgets.Dock.top;
        break;
      case "right":
        lp.dock = org.nativescript.widgets.Dock.right;
        break;
      case "bottom":
        lp.dock = org.nativescript.widgets.Dock.bottom;
        break;
      default:
        throw new Error(`Invalid value for dock property: ${value}`);
    }
    nativeView.setLayoutParams(lp);
  }
};

class DockLayout extends DockLayoutBase {
  createNativeView() {
    return new org.nativescript.widgets.DockLayout(this._context);
  }
  [stretchLastChildProperty.getDefault]() {
    return true;
  }
  [stretchLastChildProperty.setNative](value) {
    this.nativeViewProtected.setStretchLastChild(value);
  }
}
// node_modules/@nativescript/core/ui/layouts/flexbox-layout/flexbox-layout-common.js
var ORDER_DEFAULT = 1;
var FLEX_GROW_DEFAULT = 0;
var FLEX_SHRINK_DEFAULT = 1;
var FlexDirection;
(function(FlexDirection2) {
  FlexDirection2.ROW = "row";
  FlexDirection2.ROW_REVERSE = "row-reverse";
  FlexDirection2.COLUMN = "column";
  FlexDirection2.COLUMN_REVERSE = "column-reverse";
  FlexDirection2.isValid = makeValidator(FlexDirection2.ROW, FlexDirection2.ROW_REVERSE, FlexDirection2.COLUMN, FlexDirection2.COLUMN_REVERSE);
  FlexDirection2.parse = makeParser(FlexDirection2.isValid);
})(FlexDirection || (FlexDirection = {}));
var FlexWrap;
(function(FlexWrap2) {
  FlexWrap2.NOWRAP = "nowrap";
  FlexWrap2.WRAP = "wrap";
  FlexWrap2.WRAP_REVERSE = "wrap-reverse";
  FlexWrap2.isValid = makeValidator(FlexWrap2.NOWRAP, FlexWrap2.WRAP, FlexWrap2.WRAP_REVERSE);
  FlexWrap2.parse = makeParser(FlexWrap2.isValid);
})(FlexWrap || (FlexWrap = {}));
var JustifyContent;
(function(JustifyContent2) {
  JustifyContent2.FLEX_START = "flex-start";
  JustifyContent2.FLEX_END = "flex-end";
  JustifyContent2.CENTER = "center";
  JustifyContent2.SPACE_BETWEEN = "space-between";
  JustifyContent2.SPACE_AROUND = "space-around";
  JustifyContent2.isValid = makeValidator(JustifyContent2.FLEX_START, JustifyContent2.FLEX_END, JustifyContent2.CENTER, JustifyContent2.SPACE_BETWEEN, JustifyContent2.SPACE_AROUND);
  JustifyContent2.parse = makeParser(JustifyContent2.isValid);
})(JustifyContent || (JustifyContent = {}));
var FlexBasisPercent;
(function(FlexBasisPercent2) {
  FlexBasisPercent2.DEFAULT = -1;
})(FlexBasisPercent || (FlexBasisPercent = {}));
var AlignItems;
(function(AlignItems2) {
  AlignItems2.FLEX_START = "flex-start";
  AlignItems2.FLEX_END = "flex-end";
  AlignItems2.CENTER = "center";
  AlignItems2.BASELINE = "baseline";
  AlignItems2.STRETCH = "stretch";
  AlignItems2.isValid = makeValidator(AlignItems2.FLEX_START, AlignItems2.FLEX_END, AlignItems2.CENTER, AlignItems2.BASELINE, AlignItems2.STRETCH);
  AlignItems2.parse = makeParser(AlignItems2.isValid);
})(AlignItems || (AlignItems = {}));
var AlignContent;
(function(AlignContent2) {
  AlignContent2.FLEX_START = "flex-start";
  AlignContent2.FLEX_END = "flex-end";
  AlignContent2.CENTER = "center";
  AlignContent2.SPACE_BETWEEN = "space-between";
  AlignContent2.SPACE_AROUND = "space-around";
  AlignContent2.STRETCH = "stretch";
  AlignContent2.isValid = makeValidator(AlignContent2.FLEX_START, AlignContent2.FLEX_END, AlignContent2.CENTER, AlignContent2.SPACE_BETWEEN, AlignContent2.SPACE_AROUND, AlignContent2.STRETCH);
  AlignContent2.parse = makeParser(AlignContent2.isValid);
})(AlignContent || (AlignContent = {}));
var Order;
(function(Order2) {
  function isValid(value) {
    return isFinite(parseInt(value));
  }
  Order2.isValid = isValid;
  Order2.parse = parseInt;
})(Order || (Order = {}));
var FlexGrow;
(function(FlexGrow2) {
  function isValid(value) {
    const parsed = parseInt(value);
    return isFinite(parsed) && value >= 0;
  }
  FlexGrow2.isValid = isValid;
  FlexGrow2.parse = parseFloat;
})(FlexGrow || (FlexGrow = {}));
var FlexShrink;
(function(FlexShrink2) {
  function isValid(value) {
    const parsed = parseInt(value);
    return isFinite(parsed) && value >= 0;
  }
  FlexShrink2.isValid = isValid;
  FlexShrink2.parse = parseFloat;
})(FlexShrink || (FlexShrink = {}));
var FlexWrapBefore;
(function(FlexWrapBefore2) {
  function isValid(value) {
    if (typeof value === "boolean") {
      return true;
    }
    if (typeof value === "string") {
      const str = value.trim().toLowerCase();
      return str === "true" || str === "false";
    }
    return false;
  }
  FlexWrapBefore2.isValid = isValid;
  function parse59(value) {
    return value && value.toString().trim().toLowerCase() === "true";
  }
  FlexWrapBefore2.parse = parse59;
})(FlexWrapBefore || (FlexWrapBefore = {}));
var AlignSelf;
(function(AlignSelf2) {
  AlignSelf2.AUTO = "auto";
  AlignSelf2.FLEX_START = "flex-start";
  AlignSelf2.FLEX_END = "flex-end";
  AlignSelf2.CENTER = "center";
  AlignSelf2.BASELINE = "baseline";
  AlignSelf2.STRETCH = "stretch";
  AlignSelf2.isValid = makeValidator(AlignSelf2.AUTO, AlignSelf2.FLEX_START, AlignSelf2.FLEX_END, AlignSelf2.CENTER, AlignSelf2.BASELINE, AlignSelf2.STRETCH);
  AlignSelf2.parse = makeParser(AlignSelf2.isValid);
})(AlignSelf || (AlignSelf = {}));
function validateArgs4(element) {
  if (!element) {
    throw new Error("element cannot be null or undefinied.");
  }
  return element;
}
var FlexboxLayoutBase = class FlexboxLayoutBase2 extends LayoutBase {
  get flexDirection() {
    return this.style.flexDirection;
  }
  set flexDirection(value) {
    this.style.flexDirection = value;
  }
  get flexWrap() {
    return this.style.flexWrap;
  }
  set flexWrap(value) {
    this.style.flexWrap = value;
  }
  get justifyContent() {
    return this.style.justifyContent;
  }
  set justifyContent(value) {
    this.style.justifyContent = value;
  }
  get alignItems() {
    return this.style.alignItems;
  }
  set alignItems(value) {
    this.style.alignItems = value;
  }
  get alignContent() {
    return this.style.alignContent;
  }
  set alignContent(value) {
    this.style.alignContent = value;
  }
  static setOrder(view, order) {
    validateArgs4(view).style.order = order;
  }
  static getOrder(view) {
    return validateArgs4(view).style.order;
  }
  static setFlexGrow(view, grow) {
    validateArgs4(view).style.flexGrow = grow;
  }
  static getFlexGrow(view) {
    return validateArgs4(view).style.flexGrow;
  }
  static setFlexShrink(view, shrink) {
    validateArgs4(view).style.flexShrink = shrink;
  }
  static getFlexShrink(view) {
    return validateArgs4(view).style.flexShrink;
  }
  static setAlignSelf(view, align) {
    validateArgs4(view).style.alignSelf = align;
  }
  static getAlignSelf(view) {
    return validateArgs4(view).style.alignSelf;
  }
  static setFlexWrapBefore(view, wrap2) {
    validateArgs4(view).style.flexWrapBefore = wrap2;
  }
  static getFlexWrapBefore(view) {
    return validateArgs4(view).style.flexWrapBefore;
  }
};
FlexboxLayoutBase = __decorate([
  CSSType("FlexboxLayout")
], FlexboxLayoutBase);
FlexboxLayoutBase.prototype.recycleNativeView = "auto";
var flexDirectionProperty = new CssProperty({
  name: "flexDirection",
  cssName: "flex-direction",
  defaultValue: FlexDirection.ROW,
  affectsLayout: __APPLE__,
  valueConverter: FlexDirection.parse
});
flexDirectionProperty.register(Style);
var flexWrapProperty = new CssProperty({
  name: "flexWrap",
  cssName: "flex-wrap",
  defaultValue: "nowrap",
  affectsLayout: __APPLE__,
  valueConverter: FlexWrap.parse
});
flexWrapProperty.register(Style);
var justifyContentProperty = new CssProperty({
  name: "justifyContent",
  cssName: "justify-content",
  defaultValue: JustifyContent.FLEX_START,
  affectsLayout: __APPLE__,
  valueConverter: JustifyContent.parse
});
justifyContentProperty.register(Style);
var alignItemsProperty = new CssProperty({
  name: "alignItems",
  cssName: "align-items",
  defaultValue: AlignItems.STRETCH,
  affectsLayout: __APPLE__,
  valueConverter: AlignItems.parse
});
alignItemsProperty.register(Style);
var alignContentProperty = new CssProperty({
  name: "alignContent",
  cssName: "align-content",
  defaultValue: AlignContent.STRETCH,
  affectsLayout: __APPLE__,
  valueConverter: AlignContent.parse
});
alignContentProperty.register(Style);
var orderProperty = new CssProperty({
  name: "order",
  cssName: "order",
  defaultValue: ORDER_DEFAULT,
  valueConverter: Order.parse
});
orderProperty.register(Style);
Object.defineProperty(View.prototype, "order", {
  get() {
    return this.style.order;
  },
  set(value) {
    this.style.order = value;
  },
  enumerable: true,
  configurable: true
});
var flexGrowProperty = new CssProperty({
  name: "flexGrow",
  cssName: "flex-grow",
  defaultValue: FLEX_GROW_DEFAULT,
  valueConverter: FlexGrow.parse
});
flexGrowProperty.register(Style);
Object.defineProperty(View.prototype, "flexGrow", {
  get() {
    return this.style.flexGrow;
  },
  set(value) {
    this.style.flexGrow = value;
  },
  enumerable: true,
  configurable: true
});
var flexShrinkProperty = new CssProperty({
  name: "flexShrink",
  cssName: "flex-shrink",
  defaultValue: FLEX_SHRINK_DEFAULT,
  valueConverter: FlexShrink.parse
});
flexShrinkProperty.register(Style);
Object.defineProperty(View.prototype, "flexShrink", {
  get() {
    return this.style.flexShrink;
  },
  set(value) {
    this.style.flexShrink = value;
  },
  enumerable: true,
  configurable: true
});
var flexWrapBeforeProperty = new CssProperty({
  name: "flexWrapBefore",
  cssName: "flex-wrap-before",
  defaultValue: false,
  valueConverter: FlexWrapBefore.parse
});
flexWrapBeforeProperty.register(Style);
Object.defineProperty(View.prototype, "flexWrapBefore", {
  get() {
    return this.style.flexWrapBefore;
  },
  set(value) {
    this.style.flexWrapBefore = value;
  },
  enumerable: true,
  configurable: true
});
var alignSelfProperty = new CssProperty({
  name: "alignSelf",
  cssName: "align-self",
  defaultValue: AlignSelf.AUTO,
  valueConverter: AlignSelf.parse
});
alignSelfProperty.register(Style);
Object.defineProperty(View.prototype, "alignSelf", {
  get() {
    return this.style.alignSelf;
  },
  set(value) {
    this.style.alignSelf = value;
  },
  enumerable: true,
  configurable: true
});
var flexFlowProperty = new ShorthandProperty({
  name: "flexFlow",
  cssName: "flex-flow",
  getter: function() {
    return `${this.flexDirection} ${this.flexWrap}`;
  },
  converter: function(value) {
    const properties3 = [];
    if (value === unsetValue) {
      properties3.push([flexDirectionProperty, value]);
      properties3.push([flexWrapProperty, value]);
    } else {
      const trimmed = value && value.trim();
      if (trimmed) {
        const values = trimmed.split(/\s+/);
        if (values.length >= 1 && FlexDirection.isValid(values[0])) {
          properties3.push([flexDirectionProperty, FlexDirection.parse(values[0])]);
        }
        if (value.length >= 2 && FlexWrap.isValid(values[1])) {
          properties3.push([flexWrapProperty, FlexWrap.parse(values[1])]);
        }
      }
    }
    return properties3;
  }
});
flexFlowProperty.register(Style);
var flexProperty = new ShorthandProperty({
  name: "flex",
  cssName: "flex",
  getter: function() {
    return `${this.flexGrow} ${this.flexShrink}`;
  },
  converter: function(value) {
    const properties3 = [];
    if (value === unsetValue) {
      properties3.push([flexGrowProperty, value]);
      properties3.push([flexShrinkProperty, value]);
    } else {
      const trimmed = value && value.trim();
      if (trimmed) {
        const values = trimmed.split(/\s+/);
        if (values.length === 1) {
          switch (values[0]) {
            case "inital":
              properties3.push([flexGrowProperty, 0]);
              properties3.push([flexShrinkProperty, 1]);
              break;
            case "auto":
              properties3.push([flexGrowProperty, 1]);
              properties3.push([flexShrinkProperty, 1]);
              break;
            case "none":
              properties3.push([flexGrowProperty, 0]);
              properties3.push([flexShrinkProperty, 0]);
              break;
            default:
              if (FlexGrow.isValid(values[0])) {
                properties3.push([flexGrowProperty, FlexGrow.parse(values[0])]);
                properties3.push([flexShrinkProperty, 1]);
              }
          }
        }
        if (values.length >= 2) {
          if (FlexGrow.isValid(values[0]) && FlexShrink.isValid(values[1])) {
            properties3.push([flexGrowProperty, FlexGrow.parse(values[0])]);
            properties3.push([flexShrinkProperty, FlexShrink.parse(values[1])]);
          }
        }
      }
    }
    return properties3;
  }
});
flexProperty.register(Style);

// node_modules/@nativescript/core/ui/layouts/flexbox-layout/index.android.js
var widgetFlexboxLayout;
var widgetLayoutParams;
function ensureNativeTypes() {
  if (!widgetFlexboxLayout) {
    widgetFlexboxLayout = org.nativescript.widgets.FlexboxLayout;
    widgetLayoutParams = widgetFlexboxLayout.LayoutParams;
  }
}
function makeNativeSetter2(setter) {
  return function(value) {
    ensureNativeTypes();
    const nativeView = this.nativeViewProtected;
    const lp = nativeView.getLayoutParams() || new widgetLayoutParams;
    if (lp instanceof widgetLayoutParams) {
      setter(lp, value);
      nativeView.setLayoutParams(lp);
    }
  };
}
View.prototype[orderProperty.setNative] = makeNativeSetter2((lp, value) => lp.order = value);
View.prototype[flexGrowProperty.setNative] = makeNativeSetter2((lp, value) => lp.flexGrow = value);
View.prototype[flexShrinkProperty.setNative] = makeNativeSetter2((lp, value) => lp.flexShrink = value);
View.prototype[flexWrapBeforeProperty.setNative] = makeNativeSetter2((lp, value) => lp.wrapBefore = value);
View.prototype[alignSelfProperty.setNative] = makeNativeSetter2((lp, value) => lp.alignSelf = alignSelfMap[value]);
var flexDirectionMap = {
  [FlexDirection.ROW]: 0,
  [FlexDirection.ROW_REVERSE]: 1,
  [FlexDirection.COLUMN]: 2,
  [FlexDirection.COLUMN_REVERSE]: 3
};
var flexWrapMap = {
  [FlexWrap.NOWRAP]: 0,
  [FlexWrap.WRAP]: 1,
  [FlexWrap.WRAP_REVERSE]: 2
};
var justifyContentMap = {
  [JustifyContent.FLEX_START]: 0,
  [JustifyContent.FLEX_END]: 1,
  [JustifyContent.CENTER]: 2,
  [JustifyContent.SPACE_BETWEEN]: 3,
  [JustifyContent.SPACE_AROUND]: 4
};
var alignItemsMap = {
  [AlignItems.FLEX_START]: 0,
  [AlignItems.FLEX_END]: 1,
  [AlignItems.CENTER]: 2,
  [AlignItems.BASELINE]: 3,
  [AlignItems.STRETCH]: 4
};
var alignContentMap = {
  [AlignContent.FLEX_START]: 0,
  [AlignContent.FLEX_END]: 1,
  [AlignContent.CENTER]: 2,
  [AlignContent.SPACE_BETWEEN]: 3,
  [AlignContent.SPACE_AROUND]: 4,
  [AlignContent.STRETCH]: 5
};
var alignSelfMap = {
  [AlignSelf.AUTO]: -1,
  [AlignSelf.FLEX_START]: 0,
  [AlignSelf.FLEX_END]: 1,
  [AlignSelf.CENTER]: 2,
  [AlignSelf.BASELINE]: 3,
  [AlignSelf.STRETCH]: 4
};

class FlexboxLayout extends FlexboxLayoutBase {
  constructor() {
    super();
    ensureNativeTypes();
  }
  createNativeView() {
    return new widgetFlexboxLayout(this._context);
  }
  resetNativeView() {
    super.resetNativeView();
    this.nativeViewProtected.invalidateOrdersCache();
  }
  [flexDirectionProperty.getDefault]() {
    return flexDirectionProperty.defaultValue;
  }
  [flexDirectionProperty.setNative](flexDirection) {
    this.nativeViewProtected.setFlexDirection(flexDirectionMap[flexDirection]);
  }
  [flexWrapProperty.getDefault]() {
    return flexWrapProperty.defaultValue;
  }
  [flexWrapProperty.setNative](flexWrap) {
    this.nativeViewProtected.setFlexWrap(flexWrapMap[flexWrap]);
  }
  [justifyContentProperty.getDefault]() {
    return justifyContentProperty.defaultValue;
  }
  [justifyContentProperty.setNative](justifyContent) {
    this.nativeViewProtected.setJustifyContent(justifyContentMap[justifyContent]);
  }
  [alignItemsProperty.getDefault]() {
    return alignItemsProperty.defaultValue;
  }
  [alignItemsProperty.setNative](alignItems) {
    this.nativeViewProtected.setAlignItems(alignItemsMap[alignItems]);
  }
  [alignContentProperty.getDefault]() {
    return alignContentProperty.defaultValue;
  }
  [alignContentProperty.setNative](alignContent) {
    this.nativeViewProtected.setAlignContent(alignContentMap[alignContent]);
  }
  _updateNativeLayoutParams(child) {
    super._updateNativeLayoutParams(child);
    this._setChildMinWidthNative(child, child.minWidth);
    this._setChildMinHeightNative(child, child.minHeight);
    const lp = child.nativeViewProtected.getLayoutParams();
    const style = child.style;
    lp.order = style.order;
    lp.flexGrow = style.flexGrow;
    lp.flexShrink = style.flexShrink;
    lp.wrapBefore = style.flexWrapBefore;
    lp.alignSelf = alignSelfMap[style.alignSelf];
    child.nativeViewProtected.setLayoutParams(lp);
  }
  _setChildMinWidthNative(child, value) {
    if (!child._ignoreFlexMinWidthHeightReset) {
      child._setMinWidthNative(0);
    }
    const nativeView = child.nativeViewProtected;
    const lp = nativeView.getLayoutParams();
    if (lp instanceof widgetLayoutParams) {
      lp.minWidth = Length.toDevicePixels(value, 0);
      nativeView.setLayoutParams(lp);
    }
  }
  _setChildMinHeightNative(child, value) {
    if (!child._ignoreFlexMinWidthHeightReset) {
      child._setMinHeightNative(0);
    }
    const nativeView = child.nativeViewProtected;
    const lp = nativeView.getLayoutParams();
    if (lp instanceof widgetLayoutParams) {
      lp.minHeight = Length.toDevicePixels(value, 0);
      nativeView.setLayoutParams(lp);
    }
  }
}
// node_modules/@nativescript/core/ui/layouts/grid-layout/grid-layout-common.js
var GridLayoutBase_1;
function validateArgs5(element) {
  if (!element) {
    throw new Error("element cannot be null or undefined.");
  }
  return element;
}
View.prototype.row = 0;
View.prototype.col = 0;
View.prototype.rowSpan = 1;
View.prototype.colSpan = 1;
Object.defineProperty(View.prototype, "column", {
  get() {
    return this.col;
  },
  set(value) {
    this.col = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(View.prototype, "columnSpan", {
  get() {
    return this.colSpan;
  },
  set(value) {
    this.colSpan = value;
  },
  enumerable: true,
  configurable: true
});
function validateItemSpec(itemSpec) {
  if (!itemSpec) {
    throw new Error("Value cannot be undefined.");
  }
  if (itemSpec.owner) {
    throw new Error("itemSpec is already added to GridLayout.");
  }
}
function convertGridLength(value) {
  if (value === GridUnitType.AUTO) {
    return ItemSpec.create(1, GridUnitType.AUTO);
  } else if (value.indexOf("*") !== -1) {
    const starCount = parseInt(value.replace("*", "") || "1");
    return ItemSpec.create(starCount, GridUnitType.STAR);
  } else if (!isNaN(parseInt(value))) {
    return ItemSpec.create(parseInt(value), GridUnitType.PIXEL);
  } else {
    throw new Error(`Cannot parse item spec from string: ${value}`);
  }
}
function parseAndAddItemSpecs(value) {
  const specs = [];
  const arr = `${value}`.split(/[\s,]+/);
  for (let i4 = 0, length2 = arr.length;i4 < length2; i4++) {
    const str = arr[i4].trim();
    if (str.length > 0) {
      specs.push(convertGridLength(arr[i4].trim()));
    }
  }
  return specs;
}

class ItemSpec extends Observable {
  constructor(...args) {
    super();
    this._actualLength = 0;
    if (args.length === 0) {
      this._value = 1;
      this._unitType = GridUnitType.STAR;
    } else if (arguments.length === 2) {
      const value = args[0];
      const type = args[1];
      if (typeof value === "number" && typeof type === "string") {
        if (value < 0 || isNaN(value) || !isFinite(value)) {
          throw new Error(`Value should not be negative, NaN or Infinity: ${value}`);
        }
        this._value = value;
        this._unitType = GridUnitType.parse(type);
      } else {
        throw new Error("First argument should be number, second argument should be string.");
      }
    } else {
      throw new Error("ItemSpec expects 0 or 2 arguments");
    }
    this.index = -1;
  }
  static create(value, type) {
    const spec2 = new ItemSpec;
    spec2._value = value;
    spec2._unitType = type;
    return spec2;
  }
  get actualLength() {
    return this._actualLength;
  }
  static equals(value1, value2) {
    return value1.gridUnitType === value2.gridUnitType && value1.value === value2.value && value1.owner === value2.owner && value1.index === value2.index;
  }
  get gridUnitType() {
    return this._unitType;
  }
  get isAbsolute() {
    return this._unitType === GridUnitType.PIXEL;
  }
  get isAuto() {
    return this._unitType === GridUnitType.AUTO;
  }
  get isStar() {
    return this._unitType === GridUnitType.STAR;
  }
  get value() {
    return this._value;
  }
}
var GridLayoutBase = GridLayoutBase_1 = class GridLayoutBase2 extends LayoutBase {
  constructor() {
    super(...arguments);
    this._rows = new Array;
    this._cols = new Array;
  }
  static getColumn(element) {
    return validateArgs5(element).col;
  }
  static setColumn(element, value) {
    validateArgs5(element).col = value;
  }
  static getColumnSpan(element) {
    return validateArgs5(element).colSpan;
  }
  static setColumnSpan(element, value) {
    validateArgs5(element).colSpan = value;
  }
  static getRow(element) {
    return validateArgs5(element).row;
  }
  static setRow(element, value) {
    validateArgs5(element).row = value;
  }
  static getRowSpan(element) {
    return validateArgs5(element).rowSpan;
  }
  static setRowSpan(element, value) {
    validateArgs5(element).rowSpan = value;
  }
  _addRow(itemSpec) {
    validateItemSpec(itemSpec);
    itemSpec.owner = this;
    this._rows.push(itemSpec);
  }
  addRow(itemSpec) {
    this._addRow(itemSpec);
    this._onRowAdded(itemSpec);
    this.invalidate();
  }
  addRows(itemSpecs) {
    for (let index = 0;index < itemSpecs.length; index++) {
      const itemSpec = itemSpecs[index];
      this._addRow(itemSpec);
      this._onRowAdded(itemSpec);
    }
    this.invalidate();
  }
  _addColumn(itemSpec) {
    validateItemSpec(itemSpec);
    itemSpec.owner = this;
    this._cols.push(itemSpec);
  }
  addColumn(itemSpec) {
    this._addColumn(itemSpec);
    this._onColumnAdded(itemSpec);
    this.invalidate();
  }
  addColumns(itemSpecs) {
    for (let index = 0;index < itemSpecs.length; index++) {
      const itemSpec = itemSpecs[index];
      this._addColumn(itemSpec);
      this._onColumnAdded(itemSpec);
    }
    this.invalidate();
  }
  addChildAtCell(view, row, column, rowSpan, columnSpan) {
    this.addChild(view);
    GridLayoutBase_1.setRow(view, row);
    GridLayoutBase_1.setColumn(view, column);
    if (rowSpan) {
      GridLayoutBase_1.setRowSpan(view, rowSpan);
    }
    if (columnSpan) {
      GridLayoutBase_1.setColumnSpan(view, columnSpan);
    }
  }
  removeRow(itemSpec) {
    if (!itemSpec) {
      throw new Error("Value is null.");
    }
    const index = this._rows.indexOf(itemSpec);
    if (itemSpec.owner !== this || index < 0) {
      throw new Error("Row is not child of this GridLayout");
    }
    itemSpec.index = -1;
    this._rows.splice(index, 1);
    this._onRowRemoved(itemSpec, index);
    this.invalidate();
  }
  removeColumn(itemSpec) {
    if (!itemSpec) {
      throw new Error("Value is null.");
    }
    const index = this._cols.indexOf(itemSpec);
    if (itemSpec.owner !== this || index < 0) {
      throw new Error("Column is not child of this GridLayout");
    }
    itemSpec.index = -1;
    this._cols.splice(index, 1);
    this._onColumnRemoved(itemSpec, index);
    this.invalidate();
  }
  removeColumns() {
    for (let i4 = this._cols.length - 1;i4 >= 0; i4--) {
      const colSpec = this._cols[i4];
      this._onColumnRemoved(colSpec, i4);
      colSpec.index = -1;
    }
    this._cols.length = 0;
    this.invalidate();
  }
  removeRows() {
    for (let i4 = this._rows.length - 1;i4 >= 0; i4--) {
      const rowSpec = this._rows[i4];
      this._onRowRemoved(rowSpec, i4);
      rowSpec.index = -1;
    }
    this._rows.length = 0;
    this.invalidate();
  }
  onRowChanged(element, oldValue, newValue) {
    this.invalidate();
  }
  onRowSpanChanged(element, oldValue, newValue) {
    this.invalidate();
  }
  onColumnChanged(element, oldValue, newValue) {
    this.invalidate();
  }
  onColumnSpanChanged(element, oldValue, newValue) {
    this.invalidate();
  }
  _onRowAdded(itemSpec) {}
  _onColumnAdded(itemSpec) {}
  _onRowRemoved(itemSpec, index) {}
  _onColumnRemoved(itemSpec, index) {}
  getColumns() {
    return this._cols.slice();
  }
  getRows() {
    return this._rows.slice();
  }
  get columnsInternal() {
    return this._cols;
  }
  get rowsInternal() {
    return this._rows;
  }
  invalidate() {}
  set rows(value) {
    this.removeRows();
    const specs = parseAndAddItemSpecs(value);
    this.addRows(specs);
  }
  set columns(value) {
    this.removeColumns();
    const specs = parseAndAddItemSpecs(value);
    this.addColumns(specs);
  }
};
GridLayoutBase = GridLayoutBase_1 = __decorate([
  CSSType("GridLayout")
], GridLayoutBase);
GridLayoutBase.prototype.recycleNativeView = "auto";
var columnProperty = new Property({
  name: "col",
  defaultValue: 0,
  valueChanged: (target, oldValue, newValue) => {
    const grid = target.parent;
    if (grid instanceof GridLayoutBase) {
      grid.onColumnChanged(target, oldValue, newValue);
    }
  },
  valueConverter: (v) => Math.max(0, parseInt(v))
});
columnProperty.register(View);
var columnSpanProperty = new Property({
  name: "colSpan",
  defaultValue: 1,
  valueChanged: (target, oldValue, newValue) => {
    const grid = target.parent;
    if (grid instanceof GridLayoutBase) {
      grid.onColumnSpanChanged(target, oldValue, newValue);
    }
  },
  valueConverter: (v) => Math.max(1, parseInt(v))
});
columnSpanProperty.register(View);
var rowProperty = new Property({
  name: "row",
  defaultValue: 0,
  valueChanged: (target, oldValue, newValue) => {
    const grid = target.parent;
    if (grid instanceof GridLayoutBase) {
      grid.onRowChanged(target, oldValue, newValue);
    }
  },
  valueConverter: (v) => Math.max(0, parseInt(v))
});
rowProperty.register(View);
var rowSpanProperty = new Property({
  name: "rowSpan",
  defaultValue: 1,
  valueChanged: (target, oldValue, newValue) => {
    const grid = target.parent;
    if (grid instanceof GridLayoutBase) {
      grid.onRowSpanChanged(target, oldValue, newValue);
    }
  },
  valueConverter: (v) => Math.max(1, parseInt(v))
});
rowSpanProperty.register(View);
var GridUnitType;
(function(GridUnitType2) {
  GridUnitType2.PIXEL = "pixel";
  GridUnitType2.STAR = "star";
  GridUnitType2.AUTO = "auto";
  GridUnitType2.isValid = makeValidator(GridUnitType2.PIXEL, GridUnitType2.STAR, GridUnitType2.AUTO);
  GridUnitType2.parse = makeParser(GridUnitType2.isValid);
})(GridUnitType || (GridUnitType = {}));

// node_modules/@nativescript/core/ui/layouts/grid-layout/index.android.js
function makeNativeSetter3(setter) {
  return function(value) {
    const nativeView = this.nativeViewProtected;
    const lp = nativeView.getLayoutParams() || new org.nativescript.widgets.CommonLayoutParams;
    if (lp instanceof org.nativescript.widgets.CommonLayoutParams) {
      setter(lp, value);
      nativeView.setLayoutParams(lp);
    }
  };
}
View.prototype[rowProperty.setNative] = makeNativeSetter3((lp, value) => lp.row = value);
View.prototype[columnProperty.setNative] = makeNativeSetter3((lp, value) => lp.column = value);
View.prototype[rowSpanProperty.setNative] = makeNativeSetter3((lp, value) => lp.rowSpan = value);
View.prototype[columnSpanProperty.setNative] = makeNativeSetter3((lp, value) => lp.columnSpan = value);
ItemSpec.prototype.toJSON = function() {
  let result;
  switch (this.gridUnitType) {
    case GridUnitType.AUTO:
      result = { type: 0, value: this.value };
      break;
    case GridUnitType.PIXEL:
      result = { type: 1, value: this.value * layout.getDisplayDensity() };
      break;
    case GridUnitType.STAR:
      result = { type: 2, value: this.value };
      break;
    default:
      return null;
  }
  return result;
};

class GridLayout extends GridLayoutBase {
  createNativeView() {
    return new org.nativescript.widgets.GridLayout(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const jsonRows = JSON.stringify(this.rowsInternal.map((itemSpec) => itemSpec.toJSON()).filter((j2) => !!j2));
    const jsonColumns = JSON.stringify(this.columnsInternal.map((itemSpec) => itemSpec.toJSON()).filter((j2) => !!j2));
    this.nativeViewProtected.addRowsAndColumnsFromJSON(jsonRows, jsonColumns);
  }
  resetNativeView() {
    this.nativeViewProtected.reset();
    super.resetNativeView();
  }
  _onRowAdded(itemSpec) {
    if (this.nativeViewProtected) {
      this.nativeViewProtected.addRowsFromJSON(JSON.stringify([itemSpec.toJSON()]));
    }
  }
  addRows(itemSpecs) {
    const jsonArray = [];
    const nativeView = this.nativeViewProtected;
    const initialized = !!nativeView;
    for (let index = 0;index < itemSpecs.length; index++) {
      const itemSpec = itemSpecs[index];
      this._addRow(itemSpec);
      if (initialized) {
        jsonArray.push(itemSpec.toJSON());
      }
    }
    if (initialized) {
      nativeView.addRowsFromJSON(JSON.stringify(jsonArray.filter((s3) => !!s3)));
    }
  }
  addColumns(itemSpecs) {
    const jsonArray = [];
    const nativeView = this.nativeViewProtected;
    const initialized = !!nativeView;
    for (let index = 0;index < itemSpecs.length; index++) {
      const itemSpec = itemSpecs[index];
      this._addColumn(itemSpec);
      if (initialized) {
        jsonArray.push(itemSpec.toJSON());
      }
    }
    if (initialized) {
      nativeView.addColumnsFromJSON(JSON.stringify(jsonArray.filter((s3) => !!s3)));
    }
  }
  _onColumnAdded(itemSpec) {
    if (this.nativeViewProtected) {
      this.nativeViewProtected.addColumnsFromJSON(JSON.stringify([itemSpec.toJSON()]));
    }
  }
  removeColumns() {
    if (this._cols.length) {
      if (this.nativeViewProtected) {
        this.nativeViewProtected.clearColumns();
      }
      this._cols.length = 0;
    }
  }
  removeRows() {
    if (this._rows.length) {
      if (this.nativeViewProtected) {
        this.nativeViewProtected.clearRows();
      }
      this._rows.length = 0;
    }
  }
  _onRowRemoved(itemSpec, index) {
    if (this.nativeViewProtected) {
      this.nativeViewProtected.removeRowAt(index);
    }
  }
  _onColumnRemoved(itemSpec, index) {
    if (this.nativeViewProtected) {
      this.nativeViewProtected.removeColumnAt(index);
    }
  }
  invalidate() {}
}
// node_modules/@nativescript/core/ui/layouts/root-layout/root-layout-stack.js
var rootLayoutStack = [];
function _pushIntoRootLayoutStack(rootLayout) {
  if (!rootLayoutStack.includes(rootLayout)) {
    rootLayoutStack.push(rootLayout);
  }
}
function _removeFromRootLayoutStack(rootLayout) {
  const index = rootLayoutStack.indexOf(rootLayout);
  if (index > -1) {
    rootLayoutStack.splice(index, 1);
  }
}

// node_modules/@nativescript/core/ui/layouts/root-layout/root-layout-common.js
var RootLayoutBase = class RootLayoutBase2 extends GridLayout {
  constructor() {
    super(...arguments);
    this._popupViews = [];
  }
  initNativeView() {
    super.initNativeView();
    _pushIntoRootLayoutStack(this);
  }
  disposeNativeView() {
    super.disposeNativeView();
    _removeFromRootLayoutStack(this);
  }
  _onLivesync(context) {
    let handled = false;
    if (this._popupViews.length > 0) {
      this.closeAll();
      handled = true;
    }
    if (super._onLivesync(context)) {
      handled = true;
    }
    return handled;
  }
  open(view, options = {}) {
    return new Promise((resolve, reject) => {
      if (!(view instanceof View)) {
        return reject(new Error(`Invalid open view: ${view}`));
      }
      if (this.hasChild(view)) {
        return reject(new Error(`View ${view} has already been added to the root layout`));
      }
      const toOpen = [];
      const enterAnimationDefinition = options.animation ? options.animation.enterFrom : null;
      this._popupViews.push({ view, options });
      view.opacity = 0;
      this.insertChild(view, this.getChildrenCount());
      if (options.shadeCover) {
        if (this._shadeCover) {
          toOpen.push(this.updateShadeCover(this._shadeCover, options.shadeCover));
        } else {
          toOpen.push(this.openShadeCover(options.shadeCover));
        }
      }
      toOpen.push(new Promise((res, rej) => {
        setTimeout(() => {
          this.applyInitialState(view, enterAnimationDefinition);
          this.getEnterAnimation(view, enterAnimationDefinition).play().then(() => {
            this.applyDefaultState(view);
            view.notify({ eventName: "opened", object: view });
            res();
          }, (err) => {
            rej(new Error(`Error playing enter animation: ${err}`));
          });
        });
      }));
      Promise.all(toOpen).then(() => {
        resolve();
      }, (err) => {
        reject(err);
      });
    });
  }
  close(view, exitTo) {
    return new Promise((resolve, reject) => {
      if (!(view instanceof View)) {
        return reject(new Error(`Invalid close view: ${view}`));
      }
      if (!this.hasChild(view)) {
        return reject(new Error(`Unable to close popup. View ${view} not found`));
      }
      const toClose = [];
      const popupIndex = this.getPopupIndex(view);
      const poppedView = this._popupViews[popupIndex];
      const cleanupAndFinish = () => {
        view.notify({ eventName: "closed", object: view });
        this.removeChild(view);
        resolve();
      };
      const exitAnimationDefinition = exitTo || poppedView?.options?.animation?.exitTo;
      if (popupIndex > -1) {
        this._popupViews.splice(popupIndex, 1);
      }
      toClose.push(new Promise((res, rej) => {
        if (exitAnimationDefinition) {
          this.getExitAnimation(view, exitAnimationDefinition).play().then(res, (err) => {
            rej(new Error(`Error playing exit animation: ${err}`));
          });
        } else {
          res();
        }
      }));
      if (this._shadeCover) {
        let nextShadeCoverOpts;
        if (this._popupViews.length && !poppedView?.options?.shadeCover?.ignoreShadeRestore) {
          nextShadeCoverOpts = this._popupViews[this._popupViews.length - 1].options?.shadeCover;
        } else {
          nextShadeCoverOpts = null;
        }
        if (nextShadeCoverOpts) {
          toClose.push(this.updateShadeCover(this._shadeCover, nextShadeCoverOpts));
        } else {
          toClose.push(this.closeShadeCover(poppedView?.options?.shadeCover));
        }
      }
      Promise.all(toClose).then(() => {
        cleanupAndFinish();
      }, (err) => {
        reject(err);
      });
    });
  }
  closeAll() {
    const toClose = [];
    const views = this._popupViews.map((popupView) => popupView.view);
    for (const view of views) {
      toClose.push(this.close(view));
    }
    return Promise.all(toClose);
  }
  getShadeCover() {
    return this._shadeCover;
  }
  openShadeCover(options = {}) {
    return new Promise((resolve) => {
      const childrenCount = this.getChildrenCount();
      let indexToAdd;
      if (this._popupViews.length) {
        const { view } = this._popupViews[0];
        const index = this.getChildIndex(view);
        indexToAdd = index > -1 ? index : childrenCount;
      } else {
        indexToAdd = childrenCount;
      }
      if (this._shadeCover) {
        if (Trace.isEnabled()) {
          Trace.write(`RootLayout shadeCover already open.`, Trace.categories.Layout, Trace.messageType.warn);
        }
        resolve();
      } else {
        const shadeCover = this.createShadeCover();
        shadeCover.on("loaded", () => {
          this._initShadeCover(shadeCover, options);
          this.updateShadeCover(shadeCover, options).then(() => {
            resolve();
          });
        });
        this._shadeCover = shadeCover;
        this.insertChild(this._shadeCover, indexToAdd);
      }
    });
  }
  closeShadeCover(shadeCoverOptions = {}) {
    return new Promise((resolve) => {
      if (this._shadeCover) {
        return this._closeShadeCover(this._shadeCover, shadeCoverOptions).then(() => {
          if (this._shadeCover) {
            this._shadeCover.off("loaded");
            if (this._shadeCover.parent) {
              this.removeChild(this._shadeCover);
            }
          }
          this._shadeCover = null;
          this._cleanupPlatformShadeCover();
          resolve();
        });
      }
      resolve();
    });
  }
  topmost() {
    return this._popupViews.length ? this._popupViews[this._popupViews.length - 1].view : null;
  }
  bringToFront(view, animated = false) {
    return new Promise((resolve, reject) => {
      if (!(view instanceof View)) {
        return reject(new Error(`Invalid bringToFront view: ${view}`));
      }
      if (!this.hasChild(view)) {
        return reject(new Error(`View ${view} is not a child of the root layout`));
      }
      const popupIndex = this.getPopupIndex(view);
      if (popupIndex < 0) {
        return reject(new Error(`View ${view} is not a child of the root layout`));
      }
      if (popupIndex == this._popupViews.length - 1) {
        return reject(new Error(`View ${view} is already the topmost view in the rootlayout`));
      }
      const currentView = this._popupViews[popupIndex];
      this._popupViews.splice(popupIndex, 1);
      this._popupViews.push(currentView);
      const exitAnimation = this.getViewExitState(view);
      if (animated && exitAnimation) {
        this.getExitAnimation(view, exitAnimation).play().then(() => {
          this._bringToFront(view);
          const initialState = this.getViewInitialState(currentView.view);
          if (initialState) {
            this.applyInitialState(view, initialState);
            this.getEnterAnimation(view, initialState).play().then(() => {
              this.applyDefaultState(view);
            }).catch((ex) => {
              reject(new Error(`Error playing enter animation: ${ex}`));
            });
          } else {
            this.applyDefaultState(view);
          }
        }).catch((ex) => {
          this._bringToFront(view);
          reject(new Error(`Error playing exit animation: ${ex}`));
        });
      } else {
        this._bringToFront(view);
      }
      const shadeCoverOptions = currentView?.options?.shadeCover;
      if (shadeCoverOptions) {
        this.updateShadeCover(this._shadeCover, shadeCoverOptions);
      }
      resolve();
    });
  }
  getPopupIndex(view) {
    return this._popupViews.findIndex((popupView) => popupView.view === view);
  }
  getViewInitialState(view) {
    const popupIndex = this.getPopupIndex(view);
    if (popupIndex === -1) {
      return;
    }
    const initialState = this._popupViews[popupIndex]?.options?.animation?.enterFrom;
    if (!initialState) {
      return;
    }
    return initialState;
  }
  getViewExitState(view) {
    const popupIndex = this.getPopupIndex(view);
    if (popupIndex === -1) {
      return;
    }
    const exitAnimation = this._popupViews[popupIndex]?.options?.animation?.exitTo;
    if (!exitAnimation) {
      return;
    }
    return exitAnimation;
  }
  applyInitialState(targetView, enterFrom) {
    const animationOptions = {
      ...defaultTransitionAnimation,
      ...enterFrom || {}
    };
    targetView.translateX = animationOptions.translateX;
    targetView.translateY = animationOptions.translateY;
    targetView.scaleX = animationOptions.scaleX;
    targetView.scaleY = animationOptions.scaleY;
    targetView.rotate = animationOptions.rotate;
    targetView.opacity = animationOptions.opacity;
  }
  applyDefaultState(targetView) {
    targetView.translateX = 0;
    targetView.translateY = 0;
    targetView.scaleX = 1;
    targetView.scaleY = 1;
    targetView.rotate = 0;
    targetView.opacity = 1;
  }
  getEnterAnimation(targetView, enterFrom) {
    const animationOptions = {
      ...defaultTransitionAnimation,
      ...enterFrom || {}
    };
    return new Animation([
      {
        target: targetView,
        translate: { x: 0, y: 0 },
        scale: { x: 1, y: 1 },
        rotate: 0,
        opacity: 1,
        duration: animationOptions.duration,
        curve: animationOptions.curve
      }
    ]);
  }
  getExitAnimation(targetView, exitTo) {
    return new Animation([this.getExitAnimationDefinition(targetView, exitTo)]);
  }
  getExitAnimationDefinition(targetView, exitTo) {
    return {
      target: targetView,
      ...defaultTransitionAnimation,
      ...exitTo || {},
      translate: { x: isNumber(exitTo.translateX) ? exitTo.translateX : defaultTransitionAnimation.translateX, y: isNumber(exitTo.translateY) ? exitTo.translateY : defaultTransitionAnimation.translateY },
      scale: { x: isNumber(exitTo.scaleX) ? exitTo.scaleX : defaultTransitionAnimation.scaleX, y: isNumber(exitTo.scaleY) ? exitTo.scaleY : defaultTransitionAnimation.scaleY }
    };
  }
  createShadeCover() {
    const shadeCover = new GridLayout;
    shadeCover.verticalAlignment = "bottom";
    return shadeCover;
  }
  updateShadeCover(shade, shadeOptions = {}) {
    if (shadeOptions.tapToClose !== undefined && shadeOptions.tapToClose !== null) {
      shade.off("tap");
      if (shadeOptions.tapToClose) {
        shade.on("tap", () => {
          this.closeAll();
        });
      }
    }
    return this._updateShadeCover(shade, shadeOptions);
  }
  hasChild(view) {
    return this.getChildIndex(view) >= 0;
  }
  _bringToFront(view) {}
  _initShadeCover(view, shadeOption) {}
  _updateShadeCover(view, shadeOption) {
    return new Promise(() => {});
  }
  _closeShadeCover(view, shadeOptions) {
    return new Promise(() => {});
  }
  _cleanupPlatformShadeCover() {}
};
RootLayoutBase = __decorate([
  CSSType("RootLayout")
], RootLayoutBase);
var defaultTransitionAnimation = {
  translateX: 0,
  translateY: 0,
  scaleX: 1,
  scaleY: 1,
  rotate: 0,
  opacity: 1,
  duration: 300,
  curve: CoreTypes.AnimationCurve.easeIn
};
var defaultShadeCoverTransitionAnimation = {
  ...defaultTransitionAnimation,
  opacity: 0
};
// node_modules/@nativescript/core/ui/layouts/stack-layout/stack-layout-common.js
var StackLayoutBase = class StackLayoutBase2 extends LayoutBase {
};
StackLayoutBase = __decorate([
  CSSType("StackLayout")
], StackLayoutBase);
StackLayoutBase.prototype.recycleNativeView = "auto";
var converter = makeParser(makeValidator("horizontal", "vertical"));
var orientationProperty = new Property({
  name: "orientation",
  defaultValue: "vertical",
  affectsLayout: __APPLE__,
  valueConverter: converter
});
orientationProperty.register(StackLayoutBase);

// node_modules/@nativescript/core/ui/layouts/stack-layout/index.android.js
class StackLayout extends StackLayoutBase {
  createNativeView() {
    return new org.nativescript.widgets.StackLayout(this._context);
  }
  [orientationProperty.setNative](value) {
    this.nativeViewProtected.setOrientation(value === "vertical" ? org.nativescript.widgets.Orientation.vertical : org.nativescript.widgets.Orientation.horizontal);
  }
}
// node_modules/@nativescript/core/ui/layouts/wrap-layout/wrap-layout-common.js
var WrapLayoutBase = class WrapLayoutBase2 extends LayoutBase {
};
WrapLayoutBase = __decorate([
  CSSType("WrapLayout")
], WrapLayoutBase);
WrapLayoutBase.prototype.recycleNativeView = "auto";
var itemWidthProperty = new Property({
  name: "itemWidth",
  defaultValue: "auto",
  affectsLayout: __APPLE__,
  equalityComparer: Length.equals,
  valueConverter: Length.parse,
  valueChanged: (target, oldValue, newValue) => target.effectiveItemWidth = Length.toDevicePixels(newValue, -1)
});
itemWidthProperty.register(WrapLayoutBase);
var itemHeightProperty = new Property({
  name: "itemHeight",
  defaultValue: "auto",
  affectsLayout: __APPLE__,
  equalityComparer: Length.equals,
  valueConverter: Length.parse,
  valueChanged: (target, oldValue, newValue) => target.effectiveItemHeight = Length.toDevicePixels(newValue, -1)
});
itemHeightProperty.register(WrapLayoutBase);
var converter2 = makeParser(makeValidator(CoreTypes.Orientation.horizontal, CoreTypes.Orientation.vertical));
var orientationProperty2 = new Property({
  name: "orientation",
  defaultValue: CoreTypes.Orientation.horizontal,
  affectsLayout: __APPLE__,
  valueConverter: converter2
});
orientationProperty2.register(WrapLayoutBase);

// node_modules/@nativescript/core/ui/layouts/wrap-layout/index.android.js
class WrapLayout extends WrapLayoutBase {
  createNativeView() {
    return new org.nativescript.widgets.WrapLayout(this._context);
  }
  [orientationProperty2.setNative](value) {
    this.nativeViewProtected.setOrientation(value === "vertical" ? org.nativescript.widgets.Orientation.vertical : org.nativescript.widgets.Orientation.horizontal);
  }
  [itemWidthProperty.setNative](value) {
    this.nativeViewProtected.setItemWidth(Length.toDevicePixels(value, -1));
  }
  [itemHeightProperty.setNative](value) {
    this.nativeViewProtected.setItemHeight(Length.toDevicePixels(value, -1));
  }
}
// node_modules/@nativescript/core/ui/list-picker/list-picker-common.js
var ListPickerBase = class ListPickerBase2 extends View {
  _getItemAsString(index) {
    const items = this.items;
    if (!items) {
      return " ";
    }
    const item = this.isItemsSource ? this.items.getItem(index) : this.items[index];
    return item === undefined || item === null ? index + "" : this.parseItem(item);
  }
  parseItem(item) {
    return this.textField ? item[this.textField] + "" : item + "";
  }
  updateSelectedValue(index) {
    let newVal = null;
    if (index >= 0) {
      const item = this.items[index];
      newVal = this.valueField ? item[this.valueField] : item;
    }
    if (this.selectedValue !== newVal) {
      this.set("selectedValue", newVal);
    }
  }
};
ListPickerBase.selectedIndexChangeEvent = "selectedIndexChange";
ListPickerBase = __decorate([
  CSSType("ListPicker")
], ListPickerBase);
ListPickerBase.prototype.recycleNativeView = "auto";
var selectedIndexProperty = new CoercibleProperty({
  name: "selectedIndex",
  defaultValue: -1,
  valueConverter: (v) => parseInt(v),
  coerceValue: (target, value) => {
    const items = target.items;
    if (items) {
      const max2 = items.length - 1;
      if (value < 0) {
        value = 0;
      }
      if (value > max2) {
        value = max2;
      }
    } else {
      value = -1;
    }
    target.updateSelectedValue(value);
    return value;
  }
});
selectedIndexProperty.register(ListPickerBase);
var itemsProperty = new Property({
  name: "items",
  valueChanged: (target, oldValue, newValue) => {
    const getItem = newValue && newValue.getItem;
    target.isItemsSource = typeof getItem === "function";
  }
});
itemsProperty.register(ListPickerBase);
var textFieldProperty = new Property({
  name: "textField",
  defaultValue: ""
});
textFieldProperty.register(ListPickerBase);
var valueFieldProperty = new Property({
  name: "valueField",
  defaultValue: ""
});
valueFieldProperty.register(ListPickerBase);
var selectedValueProperty = new Property({
  name: "selectedValue",
  defaultValue: null
});
selectedValueProperty.register(ListPickerBase);

// node_modules/@nativescript/core/ui/list-picker/index.android.js
var Formatter;
var ValueChangeListener;
function initializeNativeClasses() {
  if (Formatter) {
    return;
  }
  var FormatterImpl = function(_super) {
    __extends(FormatterImpl2, _super);
    function FormatterImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    FormatterImpl2.prototype.format = function(index) {
      return this.owner._getItemAsString(index);
    };
    FormatterImpl2 = __decorate([
      Interfaces([android.widget.NumberPicker.Formatter])
    ], FormatterImpl2);
    return FormatterImpl2;
  }(java.lang.Object);
  var ValueChangeListenerImpl = function(_super) {
    __extends(ValueChangeListenerImpl2, _super);
    function ValueChangeListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    ValueChangeListenerImpl2.prototype.onValueChange = function(picker, oldValue, newValue) {
      selectedIndexProperty.nativeValueChange(this.owner, newValue);
      this.owner.updateSelectedValue(newValue);
    };
    ValueChangeListenerImpl2 = __decorate([
      Interfaces([android.widget.NumberPicker.OnValueChangeListener])
    ], ValueChangeListenerImpl2);
    return ValueChangeListenerImpl2;
  }(java.lang.Object);
  Formatter = FormatterImpl;
  ValueChangeListener = ValueChangeListenerImpl;
}
function getEditText(picker) {
  for (let i4 = 0, count = picker.getChildCount();i4 < count; i4++) {
    const child = picker.getChildAt(i4);
    if (child instanceof android.widget.EditText) {
      return child;
    }
  }
  return null;
}
var selectorWheelPaintField;
function getSelectorWheelPaint(picker) {
  try {
    selectorWheelPaintField = picker.getClass().getDeclaredField("mSelectorWheelPaint");
    if (selectorWheelPaintField) {
      selectorWheelPaintField.setAccessible(true);
    }
  } catch (err) {}
  if (selectorWheelPaintField) {
    return selectorWheelPaintField.get(picker);
  }
  return null;
}

class ListPicker extends ListPickerBase {
  createNativeView() {
    const picker = new android.widget.NumberPicker(this._context);
    picker.setDescendantFocusability(android.widget.NumberPicker.FOCUS_BLOCK_DESCENDANTS);
    picker.setMinValue(0);
    picker.setMaxValue(0);
    picker.setValue(0);
    picker.setWrapSelectorWheel(false);
    return picker;
  }
  initNativeView() {
    super.initNativeView();
    initializeNativeClasses();
    const nativeView = this.nativeViewProtected;
    this._selectorWheelPaint = getSelectorWheelPaint(nativeView);
    const formatter = new Formatter(this);
    nativeView.setFormatter(formatter);
    nativeView.formatter = formatter;
    const valueChangedListener = new ValueChangeListener(this);
    nativeView.setOnValueChangedListener(valueChangedListener);
    nativeView.valueChangedListener = valueChangedListener;
    const editText = getEditText(nativeView);
    if (editText) {
      nativeView.editText = editText;
      editText.setFilters([]);
      editText.setText(" ", android.widget.TextView.BufferType.NORMAL);
    }
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    if (nativeView?.formatter) {
      nativeView.formatter.owner = null;
    }
    if (nativeView?.valueChangedListener) {
      nativeView.valueChangedListener.owner = null;
    }
    super.disposeNativeView();
  }
  _fixNumberPickerRendering() {
    const nativeView = this.nativeViewProtected;
    nativeView.setFormatter(null);
    nativeView.setFormatter(nativeView.formatter);
    const editText = nativeView.editText;
    if (editText) {
      editText.setFilters([]);
      editText.invalidate();
    }
    nativeView.invalidate();
  }
  [selectedIndexProperty.getDefault]() {
    return -1;
  }
  [selectedIndexProperty.setNative](value) {
    if (value >= 0) {
      this.nativeViewProtected.setValue(value);
    }
  }
  [itemsProperty.getDefault]() {
    return null;
  }
  [itemsProperty.setNative](value) {
    const maxValue = value && value.length > 0 ? value.length - 1 : 0;
    this.nativeViewProtected.setMaxValue(maxValue);
    this._fixNumberPickerRendering();
    selectedIndexProperty.coerce(this);
  }
  [colorProperty.getDefault]() {
    if (this._selectorWheelPaint) {
      return this._selectorWheelPaint.getColor();
    }
    if (this.nativeView && this.nativeView.getTextColor) {
      return this.nativeView.getTextColor();
    } else {
      return 0;
    }
  }
  [colorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    if (this._selectorWheelPaint) {
      this._selectorWheelPaint.setColor(color2);
      const editText = this.nativeViewProtected.editText;
      if (editText) {
        editText.setTextColor(color2);
      }
    } else if (this.nativeView && this.nativeView.setTextColor) {
      this.nativeView.setTextColor(color2);
    }
  }
}
// node_modules/@nativescript/core/ui/list-view/list-view-common.js
var autoEffectiveRowHeight = -1;
var ListViewBase = class ListViewBase2 extends ContainerView {
  constructor() {
    super(...arguments);
    this._itemIdGenerator = (_item, index) => index;
    this._itemTemplateSelectorBindable = new Label;
    this._defaultTemplate = {
      key: "default",
      createView: () => {
        if (__UI_USE_EXTERNAL_RENDERER__) {
          if (isFunction(this.itemTemplate)) {
            return this.itemTemplate();
          }
        } else {
          if (this.itemTemplate) {
            return Builder.parse(this.itemTemplate, this);
          }
        }
        return;
      }
    };
    this._itemTemplatesInternal = new Array(this._defaultTemplate);
    this._effectiveRowHeight = autoEffectiveRowHeight;
  }
  get separatorColor() {
    return this.style.separatorColor;
  }
  set separatorColor(value) {
    this.style.separatorColor = value;
  }
  get itemTemplateSelector() {
    return this._itemTemplateSelector;
  }
  set itemTemplateSelector(value) {
    if (typeof value === "string") {
      this._itemTemplateSelectorBindable.bind({
        sourceProperty: null,
        targetProperty: "templateKey",
        expression: value
      });
      this._itemTemplateSelector = (item, index, items) => {
        item["$index"] = index;
        if (this._itemTemplateSelectorBindable.bindingContext === item) {
          this._itemTemplateSelectorBindable.bindingContext = null;
        }
        this._itemTemplateSelectorBindable.bindingContext = item;
        return this._itemTemplateSelectorBindable.get("templateKey");
      };
    } else if (typeof value === "function") {
      this._itemTemplateSelector = value;
    }
  }
  get itemIdGenerator() {
    return this._itemIdGenerator;
  }
  set itemIdGenerator(generatorFn) {
    this._itemIdGenerator = generatorFn;
  }
  refresh() {}
  scrollToIndex(index) {}
  scrollToIndexAnimated(index) {}
  _getItemTemplate(index) {
    let templateKey = "default";
    if (this.itemTemplateSelector) {
      const dataItem = this._getDataItem(index);
      templateKey = this._itemTemplateSelector(dataItem, index, this.items);
    }
    for (let i4 = 0, length2 = this._itemTemplatesInternal.length;i4 < length2; i4++) {
      if (this._itemTemplatesInternal[i4].key === templateKey) {
        return this._itemTemplatesInternal[i4];
      }
    }
    return this._itemTemplatesInternal[0];
  }
  _prepareItem(item, index) {
    if (item) {
      item.bindingContext = this._getDataItem(index);
    }
  }
  _prepareItemInSection(item, section, index) {
    if (item) {
      item.bindingContext = this._getDataItemInSection(section, index);
    }
  }
  _getDataItem(index) {
    const thisItems = this.items;
    return thisItems.getItem ? thisItems.getItem(index) : thisItems[index];
  }
  _getSectionCount() {
    if (!this.sectioned || !this.items) {
      return 1;
    }
    return this.items.length;
  }
  _getItemsInSection(section) {
    if (!this.sectioned || !this.items) {
      return this.items;
    }
    const sectionData = this.items[section];
    return sectionData?.items || [];
  }
  _getSectionData(section) {
    if (!this.sectioned || !this.items || !Array.isArray(this.items)) {
      return null;
    }
    if (section < 0 || section >= this.items.length) {
      if (Trace.isEnabled()) {
        Trace.write(`ListView: Section ${section} out of bounds (total sections: ${this.items.length})`, Trace.categories.Debug);
      }
      return null;
    }
    const sectionData = this.items[section];
    if (Trace.isEnabled() && !sectionData) {
      Trace.write(`ListView: Section ${section} data is null/undefined`, Trace.categories.Debug);
    }
    return sectionData;
  }
  _getDataItemInSection(section, index) {
    const sectionItems = this._getItemsInSection(section);
    return sectionItems.getItem ? sectionItems.getItem(index) : sectionItems[index];
  }
  _getDefaultItemContent(index) {
    const lbl = new Label;
    lbl.bind({
      targetProperty: "text",
      sourceProperty: "$value"
    });
    return lbl;
  }
  _onItemsChanged(args) {
    this.refresh();
  }
  _onRowHeightPropertyChanged(oldValue, newValue) {
    this.refresh();
  }
  isItemAtIndexVisible(index) {
    return false;
  }
  updateEffectiveRowHeight() {
    rowHeightProperty.coerce(this);
  }
};
ListViewBase.itemLoadingEvent = "itemLoading";
ListViewBase.itemTapEvent = "itemTap";
ListViewBase.loadMoreItemsEvent = "loadMoreItems";
ListViewBase.searchChangeEvent = "searchChange";
ListViewBase.knownFunctions = ["itemTemplateSelector", "itemIdGenerator"];
ListViewBase = __decorate([
  CSSType("ListView")
], ListViewBase);
ListViewBase.prototype.recycleNativeView = "auto";
var itemsProperty2 = new Property({
  name: "items",
  valueChanged: (target, oldValue, newValue) => {
    if (oldValue instanceof Observable) {
      removeWeakEventListener(oldValue, ObservableArray.changeEvent, target._onItemsChanged, target);
    }
    if (newValue instanceof Observable) {
      addWeakEventListener(newValue, ObservableArray.changeEvent, target._onItemsChanged, target);
    }
    target.refresh();
  }
});
itemsProperty2.register(ListViewBase);
var itemTemplateProperty = new Property({
  name: "itemTemplate",
  valueChanged: (target) => {
    target.refresh();
  }
});
itemTemplateProperty.register(ListViewBase);
var itemTemplatesProperty = new Property({
  name: "itemTemplates",
  valueConverter: (value) => {
    if (typeof value === "string") {
      if (__UI_USE_XML_PARSER__) {
        return Builder.parseMultipleTemplates(value, null);
      } else {
        return null;
      }
    }
    return value;
  }
});
itemTemplatesProperty.register(ListViewBase);
var defaultRowHeight = "auto";
var rowHeightProperty = new CoercibleProperty({
  name: "rowHeight",
  defaultValue: defaultRowHeight,
  equalityComparer: Length.equals,
  coerceValue: (target, value) => {
    return target.nativeViewProtected ? value : defaultRowHeight;
  },
  valueChanged: (target, oldValue, newValue) => {
    target._effectiveRowHeight = Length.toDevicePixels(newValue, autoEffectiveRowHeight);
    target._onRowHeightPropertyChanged(oldValue, newValue);
  },
  valueConverter: Length.parse
});
rowHeightProperty.register(ListViewBase);
var iosEstimatedRowHeightProperty = new Property({
  name: "iosEstimatedRowHeight",
  equalityComparer: Length.equals,
  valueConverter: Length.parse
});
iosEstimatedRowHeightProperty.register(ListViewBase);
var separatorColorProperty = new CssProperty({
  name: "separatorColor",
  cssName: "separator-color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
separatorColorProperty.register(Style);
var stickyHeaderProperty = new Property({
  name: "stickyHeader",
  defaultValue: false,
  valueConverter: booleanConverter
});
stickyHeaderProperty.register(ListViewBase);
var stickyHeaderTemplateProperty = new Property({
  name: "stickyHeaderTemplate",
  valueChanged: (target) => {
    target.refresh();
  }
});
stickyHeaderTemplateProperty.register(ListViewBase);
var stickyHeaderHeightProperty = new Property({
  name: "stickyHeaderHeight",
  defaultValue: "auto",
  equalityComparer: Length.equals,
  valueConverter: Length.parse
});
stickyHeaderHeightProperty.register(ListViewBase);
var stickyHeaderTopPaddingProperty = new Property({
  name: "stickyHeaderTopPadding",
  defaultValue: false,
  valueConverter: booleanConverter
});
stickyHeaderTopPaddingProperty.register(ListViewBase);
var sectionedProperty = new Property({
  name: "sectioned",
  defaultValue: false,
  valueConverter: (v) => !!v
});
sectionedProperty.register(ListViewBase);
var showSearchProperty = new Property({
  name: "showSearch",
  defaultValue: false,
  valueConverter: booleanConverter
});
showSearchProperty.register(ListViewBase);
var searchAutoHideProperty = new Property({
  name: "searchAutoHide",
  defaultValue: false,
  valueConverter: booleanConverter
});
searchAutoHideProperty.register(ListViewBase);

// node_modules/@nativescript/core/ui/proxy-view-container/index.js
var ProxyViewContainer = class ProxyViewContainer2 extends LayoutBase {
  constructor() {
    super();
    this.proxiedLayoutProperties = new Set;
    this.nativeViewProtected = undefined;
  }
  get ios() {
    return null;
  }
  get android() {
    return null;
  }
  get isLayoutRequested() {
    return false;
  }
  createNativeView() {
    return;
  }
  _getNativeViewsCount() {
    let result = 0;
    this.eachChildView((cv) => {
      result += cv._getNativeViewsCount();
      return true;
    });
    return result;
  }
  _eachLayoutView(callback) {
    this.eachChildView((cv) => {
      if (!cv.isCollapsed) {
        cv._eachLayoutView(callback);
      }
      return true;
    });
  }
  _setupUI(context, atIndex, parentIsLoaded) {
    let processChildren2 = false;
    if (this.reusable && this._context === context) {
      processChildren2 = true;
    }
    super._setupUI(context, atIndex, parentIsLoaded);
    if (this.reusable && processChildren2) {
      this.eachChild((child) => {
        const oldReusable = child.reusable;
        child.reusable = true;
        child._setupUI(context);
        child.reusable = oldReusable;
        return true;
      });
    }
  }
  _tearDownUI(force) {
    super._tearDownUI(force);
    if (this.reusable && !force) {
      this.eachChild((child) => {
        const oldReusable = child.reusable;
        child.reusable = true;
        child._tearDownUI();
        child.reusable = oldReusable;
        return true;
      });
    }
  }
  _addViewToNativeVisualTree(child, atIndex) {
    if (Trace.isEnabled()) {
      Trace.write("ProxyViewContainer._addViewToNativeVisualTree for a child " + child + " ViewContainer.parent: " + this.parent, Trace.categories.ViewHierarchy);
    }
    super._addViewToNativeVisualTree(child);
    layoutProperties.forEach((propName) => {
      const proxyPropName = makeProxyPropName(propName);
      child[proxyPropName] = child[propName];
      if (this.proxiedLayoutProperties.has(propName)) {
        this._applyLayoutPropertyToChild(child, propName, this[propName]);
      }
    });
    const parent = this.parent;
    if (parent instanceof View) {
      let baseIndex = 0;
      let insideIndex = 0;
      if (parent instanceof LayoutBase) {
        baseIndex = parent._childIndexToNativeChildIndex(parent.getChildIndex(this));
      }
      if (atIndex !== undefined) {
        insideIndex = this._childIndexToNativeChildIndex(atIndex);
      } else {
        insideIndex = this._getNativeViewsCount();
      }
      if (Trace.isEnabled()) {
        Trace.write("ProxyViewContainer._addViewToNativeVisualTree at: " + atIndex + " base: " + baseIndex + " additional: " + insideIndex, Trace.categories.ViewHierarchy);
      }
      return parent._addViewToNativeVisualTree(child, baseIndex + insideIndex);
    }
    return false;
  }
  _removeViewFromNativeVisualTree(child) {
    if (Trace.isEnabled()) {
      Trace.write("ProxyViewContainer._removeViewFromNativeVisualTree for a child " + child + " ViewContainer.parent: " + this.parent, Trace.categories.ViewHierarchy);
    }
    super._removeViewFromNativeVisualTree(child);
    const parent = this.parent;
    if (parent instanceof View) {
      return parent._removeViewFromNativeVisualTree(child);
    }
  }
  _registerLayoutChild(child) {
    const parent = this.parent;
    if (parent instanceof LayoutBase) {
      parent._registerLayoutChild(child);
    }
  }
  _unregisterLayoutChild(child) {
    const parent = this.parent;
    if (parent instanceof LayoutBase) {
      parent._unregisterLayoutChild(child);
    }
  }
  _parentChanged(oldParent) {
    super._parentChanged(oldParent);
    const addingToParent = this.parent && !oldParent;
    const newLayout = this.parent;
    const oldLayout = oldParent;
    if (addingToParent && newLayout instanceof LayoutBase) {
      this.eachLayoutChild((child) => {
        newLayout._registerLayoutChild(child);
        return true;
      });
    } else if (oldLayout instanceof LayoutBase) {
      this.eachLayoutChild((child) => {
        oldLayout._unregisterLayoutChild(child);
        return true;
      });
    }
  }
  _changedLayoutProperty(propName, value) {
    const numChildren = this._getNativeViewsCount();
    if (numChildren > 1) {
      Trace.write("ProxyViewContainer._changeLayoutProperty - you're setting '" + propName + "' for " + this + " with more than one child. Probably this is not what you want, consider wrapping it in a StackLayout ", Trace.categories.ViewHierarchy, Trace.messageType.error);
    }
    this.eachLayoutChild((child) => {
      this._applyLayoutPropertyToChild(child, propName, value);
      return true;
    });
    this.proxiedLayoutProperties.add(propName);
  }
  _applyLayoutPropertyToChild(child, propName, value) {
    const proxyPropName = makeProxyPropName(propName);
    if (proxyPropName in child) {
      if (child[propName] !== child[proxyPropName]) {
        if (Trace.isEnabled()) {
          Trace.write("ProxyViewContainer._applyLayoutPropertyToChild child " + child + " has its own value [" + child[propName] + "] for [" + propName + "]", Trace.categories.ViewHierarchy);
        }
        return;
      }
    }
    child[propName] = value;
    child[proxyPropName] = value;
  }
};
ProxyViewContainer = __decorate([
  CSSType("ProxyViewContainer"),
  __metadata("design:paramtypes", [])
], ProxyViewContainer);
var layoutProperties = [
  "left",
  "top",
  "dock",
  "flexDirection",
  "flexWrap",
  "justifyContent",
  "alignItems",
  "alignContent",
  "order",
  "flexGrow",
  "flexShrink",
  "flexWrapBefore",
  "alignSelf",
  "flexFlow",
  "flex",
  "column",
  "columnSpan",
  "col",
  "colSpan",
  "row",
  "rowSpan"
];
for (const name50 of layoutProperties) {
  const proxyProperty = new Property({
    name: name50,
    valueChanged(target, oldValue, value) {
      target._changedLayoutProperty(name50, value);
    }
  });
  proxyProperty.register(ProxyViewContainer);
}
function makeProxyPropName(propName) {
  return `_proxy:${propName}`;
}

// node_modules/@nativescript/core/ui/list-view/index.android.js
var ITEMLOADING = ListViewBase.itemLoadingEvent;
var LOADMOREITEMS = ListViewBase.loadMoreItemsEvent;
var ITEMTAP = ListViewBase.itemTapEvent;
var SEARCHCHANGE = ListViewBase.searchChangeEvent;
var STICKY_HEADER_Z_INDEX = 1000;
var SEARCH_VIEW_Z_INDEX = 2000;
var ItemClickListener;
function initializeItemClickListener() {
  if (ItemClickListener) {
    return;
  }
  var ItemClickListenerImpl = function(_super) {
    __extends(ItemClickListenerImpl2, _super);
    function ItemClickListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    ItemClickListenerImpl2.prototype.onItemClick = function(parent, convertView, index, id) {
      var owner = this.owner;
      var view = owner._realizedItems.get(convertView).view;
      owner.notify({
        eventName: ITEMTAP,
        object: owner,
        index,
        view
      });
    };
    ItemClickListenerImpl2 = __decorate([
      Interfaces([android.widget.AdapterView.OnItemClickListener])
    ], ItemClickListenerImpl2);
    return ItemClickListenerImpl2;
  }(java.lang.Object);
  ItemClickListener = ItemClickListenerImpl;
}

class ListView extends ListViewBase {
  constructor() {
    super(...arguments);
    this._androidViewId = -1;
    this._realizedItems = new Map;
    this._availableViews = new Map;
    this._realizedTemplates = new Map;
    this._stickyHeaderHeight = 0;
    this._hiddenHeaderPositions = new Set;
  }
  get hasSearchView() {
    return !!this._searchView;
  }
  _ensureAvailableViews(templateKey) {
    if (!this._availableViews.has(templateKey)) {
      this._availableViews.set(templateKey, new Set);
    }
  }
  _registerViewToTemplate(templateKey, nativeView, view) {
    this._realizedItems.set(nativeView, {
      view,
      templateKey
    });
    if (!this._realizedTemplates.has(templateKey)) {
      this._realizedTemplates.set(templateKey, new Map);
    }
    this._realizedTemplates.get(templateKey).set(nativeView, view);
    this._ensureAvailableViews(templateKey);
    const availableViews = this._availableViews.get(templateKey);
    availableViews.add(nativeView);
  }
  _markViewUsed(nativeView) {
    const viewData = this._realizedItems.get(nativeView);
    if (!viewData) {
      throw new Error("View not registered");
    }
    this._ensureAvailableViews(viewData.templateKey);
    this._availableViews.get(viewData.templateKey).delete(nativeView);
  }
  _markViewUnused(nativeView) {
    const viewData = this._realizedItems.get(nativeView);
    if (!viewData) {
      throw new Error("View not registered");
    }
    this._ensureAvailableViews(viewData.templateKey);
    this._availableViews.get(viewData.templateKey).add(nativeView);
  }
  _getKeyFromView(nativeView) {
    return this._realizedItems.get(nativeView).templateKey;
  }
  _hasAvailableView(templateKey) {
    this._ensureAvailableViews(templateKey);
    return this._availableViews.get(templateKey).size > 0;
  }
  _getAvailableView(templateKey) {
    this._ensureAvailableViews(templateKey);
    if (!this._hasAvailableView(templateKey)) {
      return null;
    }
    const view = this._availableViews.get(templateKey).values().next().value;
    this._markViewUsed(view);
    return view;
  }
  createNativeView() {
    const listView = new android.widget.ListView(this._context);
    listView.setDescendantFocusability(android.view.ViewGroup.FOCUS_AFTER_DESCENDANTS);
    listView.setCacheColorHint(android.graphics.Color.TRANSPARENT);
    return listView;
  }
  initNativeView() {
    super.initNativeView();
    this.updateEffectiveRowHeight();
    const nativeView = this.nativeViewProtected;
    initializeItemClickListener();
    ensureListViewAdapterClass();
    const adapter = new ListViewAdapterClass(this);
    nativeView.setAdapter(adapter);
    nativeView.adapter = adapter;
    const itemClickListener = new ItemClickListener(this);
    nativeView.setOnItemClickListener(itemClickListener);
    nativeView.itemClickListener = itemClickListener;
    if (this._androidViewId < 0) {
      this._androidViewId = android.view.View.generateViewId();
    }
    nativeView.setId(this._androidViewId);
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    nativeView.setAdapter(null);
    if (nativeView.itemClickListener) {
      nativeView.itemClickListener.owner = null;
    }
    if (nativeView.adapter) {
      nativeView.adapter.owner = null;
    }
    this._cleanupSearchView();
    this._cleanupStickyHeader();
    this.clearRealizedCells();
    super.disposeNativeView();
  }
  _cleanupStickyHeader() {
    if (this._scrollListener) {
      this.nativeViewProtected.setOnScrollListener(null);
      this._scrollListener = null;
    }
    if (this._stickyHeaderView && this._stickyHeaderView.parent) {
      this._stickyHeaderView.parent._removeView(this._stickyHeaderView);
    }
    this._stickyHeaderView = null;
    this._stickyHeaderHeight = 0;
    this._hiddenHeaderPositions.clear();
  }
  onLoaded() {
    super.onLoaded();
    this.requestLayout();
    if (this.stickyHeader && this.sectioned && this.stickyHeaderTemplate) {
      this._setupStickyHeader();
    }
    if (this.showSearch && !this._searchView && this.nativeViewProtected && this.nativeViewProtected.getAdapter()) {
      this._setupSearchView();
    }
  }
  refresh() {
    const nativeView = this.nativeViewProtected;
    if (!nativeView || !nativeView.getAdapter()) {
      return;
    }
    this._realizedItems.forEach(({ view }, nativeView2) => {
      if (!(view.bindingContext instanceof Observable)) {
        view.bindingContext = null;
      }
    });
    const adapter = nativeView.getAdapter();
    if (adapter instanceof android.widget.BaseAdapter) {
      try {
        adapter.notifyDataSetChanged();
      } catch (error) {
        if (Trace.isEnabled()) {
          Trace.error("Error refreshing adapter, recreating: " + error);
        }
        nativeView.setAdapter(new ListViewAdapterClass(this));
      }
    }
  }
  scrollToIndex(index) {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      nativeView.setSelection(index);
    }
  }
  scrollToIndexAnimated(index) {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      nativeView.smoothScrollToPosition(index);
    }
  }
  get _childrenCount() {
    return this._realizedItems.size;
  }
  eachChildView(callback) {
    this._realizedItems.forEach(({ view }, nativeView) => {
      if (view.parent instanceof ListView) {
        callback(view);
      } else {
        if (view.parent) {
          callback(view.parent);
        }
      }
    });
  }
  _dumpRealizedTemplates() {
    console.log(`Realized Templates:`);
    this._realizedTemplates.forEach((value, index) => {
      console.log(`	${index}:`);
      value.forEach((value2, index2) => {
        console.log(`		${index2.hashCode()}: ${value2}`);
      });
    });
    console.log(`Realized Items Size: ${this._realizedItems.size}`);
  }
  clearRealizedCells() {
    this._realizedItems.forEach(({ view }, nativeView) => {
      if (view.parent) {
        if (!(view.parent instanceof ListView)) {
          this._removeView(view.parent);
        }
        view.parent._removeView(view);
      }
    });
    this._realizedItems.clear();
    this._availableViews.clear();
    this._realizedTemplates.clear();
  }
  isItemAtIndexVisible(index) {
    const nativeView = this.nativeViewProtected;
    const start2 = nativeView.getFirstVisiblePosition();
    const end = nativeView.getLastVisiblePosition();
    return index >= start2 && index <= end;
  }
  _setupStickyHeader() {
    if (!this.stickyHeader || !this.sectioned || !this.stickyHeaderTemplate) {
      return;
    }
    this._createStickyHeaderView();
    this._addStickyHeaderToParent();
    this._addListViewPadding();
    this._setupScrollListener();
  }
  _createStickyHeaderView() {
    if (this._stickyHeaderView) {
      return;
    }
    if (typeof this.stickyHeaderTemplate === "string") {
      try {
        this._stickyHeaderView = Builder.parse(this.stickyHeaderTemplate, this);
      } catch (error) {
        this._stickyHeaderView = new Label;
        this._stickyHeaderView.text = "Header Error";
      }
    }
    if (!this._stickyHeaderView) {
      this._stickyHeaderView = new Label;
      this._stickyHeaderView.text = "Section 0";
    }
    this._updateStickyHeader(0);
  }
  _addStickyHeaderToParent() {
    if (!this._stickyHeaderView || !this.parent) {
      return;
    }
    if (this._stickyHeaderView.parent) {
      this._stickyHeaderView.parent._removeView(this._stickyHeaderView);
    }
    this._stickyHeaderView.width = { unit: "%", value: 100 };
    this._stickyHeaderView.height = "auto";
    this._stickyHeaderView.verticalAlignment = "top";
    this._stickyHeaderView.horizontalAlignment = "stretch";
    const parentLayout = this.parent;
    const hasSearchView = this.showSearch && this._searchView && this._searchView._wrapper;
    if (parentLayout instanceof StackLayout) {
      const insertIndex = hasSearchView ? 1 : 0;
      parentLayout.insertChild(this._stickyHeaderView, insertIndex);
    } else {
      parentLayout._addView(this._stickyHeaderView);
    }
    if (this.showSearch && this._searchView) {
      this._stickyHeaderView.marginTop = 0;
      if (this._stickyHeaderView.nativeViewProtected) {
        this._stickyHeaderView.nativeViewProtected.setZ(STICKY_HEADER_Z_INDEX);
        setTimeout(() => {
          if (this._searchView && this._searchView._wrapper) {
            const searchWrapper = this._searchView._wrapper;
            if (searchWrapper.nativeViewProtected) {
              const searchHeight = searchWrapper.nativeViewProtected.getMeasuredHeight() || 50;
              if (this._stickyHeaderView.nativeViewProtected) {
                this._stickyHeaderView.nativeViewProtected.setTranslationY(searchHeight);
              }
            }
          }
        }, 100);
      }
    } else {
      if (this._stickyHeaderView.nativeViewProtected) {
        this._stickyHeaderView.nativeViewProtected.setZ(STICKY_HEADER_Z_INDEX);
        this._stickyHeaderView.nativeViewProtected.setTranslationY(0);
      }
    }
  }
  _addListViewPadding() {
    if (!this._stickyHeaderView) {
      return;
    }
    let searchViewHeight = 0;
    if (this.showSearch && this._searchView && this._searchView._wrapper) {
      const searchWrapper = this._searchView._wrapper;
      if (searchWrapper.nativeViewProtected && searchWrapper.nativeViewProtected.getMeasuredHeight() > 0) {
        searchViewHeight = searchWrapper.nativeViewProtected.getMeasuredHeight();
      } else {
        searchViewHeight = 50;
      }
    }
    const defaultHeaderHeight = 50;
    const totalPadding = searchViewHeight + defaultHeaderHeight;
    this.nativeViewProtected.setPadding(0, totalPadding, 0, 0);
    this._stickyHeaderHeight = defaultHeaderHeight;
    this._stickyHeaderView.requestLayout();
    const stickyHeaderNativeView = this._stickyHeaderView && this._stickyHeaderView.nativeViewProtected;
    if (stickyHeaderNativeView) {
      const layoutListener = new android.view.View.OnLayoutChangeListener({
        onLayoutChange: (v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom) => {
          if (v.getMeasuredHeight() > 0) {
            const measuredHeaderHeight = v.getMeasuredHeight();
            let finalSearchHeight = searchViewHeight;
            if (this.showSearch && this._searchView && this._searchView._wrapper) {
              const searchWrapper = this._searchView._wrapper;
              if (searchWrapper.nativeViewProtected && searchWrapper.nativeViewProtected.getMeasuredHeight() > 0) {
                finalSearchHeight = searchWrapper.nativeViewProtected.getMeasuredHeight();
              }
            }
            const totalPaddingHeight = finalSearchHeight + measuredHeaderHeight + 4;
            this._stickyHeaderHeight = measuredHeaderHeight;
            this.nativeViewProtected.setPadding(0, totalPaddingHeight, 0, 0);
            this.scrollToIndex(0);
            v.removeOnLayoutChangeListener(layoutListener);
          }
        }
      });
      stickyHeaderNativeView.addOnLayoutChangeListener(layoutListener);
    }
  }
  _setupScrollListener() {
    if (this._scrollListener) {
      return;
    }
    const owner = this;
    this._scrollListener = new android.widget.AbsListView.OnScrollListener({
      onScrollStateChanged(view, scrollState) {},
      onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount) {
        if (owner.sectioned && owner._stickyHeaderView) {
          const currentSection = owner._getCurrentSection(firstVisibleItem);
          owner._updateStickyHeader(currentSection);
          owner._updateHiddenHeaders(firstVisibleItem);
        }
      }
    });
    this.nativeViewProtected.setOnScrollListener(this._scrollListener);
  }
  _getCurrentSection(firstVisibleItem) {
    if (!this.sectioned) {
      return 0;
    }
    let currentPosition = 0;
    const sectionCount = this._getSectionCount();
    for (let section = 0;section < sectionCount; section++) {
      const sectionItems = this._getItemsInSection(section) || [];
      const itemsInSection = sectionItems.length || 0;
      const sectionEndPosition = currentPosition + 1 + itemsInSection;
      if (firstVisibleItem < sectionEndPosition) {
        return section;
      }
      currentPosition = sectionEndPosition;
    }
    return Math.max(0, sectionCount - 1);
  }
  _updateStickyHeader(section) {
    if (!this._stickyHeaderView) {
      return;
    }
    const sectionData = this._getSectionData(section);
    if (sectionData) {
      this._stickyHeaderView.bindingContext = sectionData;
    } else {
      this._stickyHeaderView.bindingContext = { title: `Section ${section}`, section };
    }
  }
  _updateHiddenHeaders(firstVisibleItem) {
    const previousHiddenHeaders = new Set(this._hiddenHeaderPositions);
    this._hiddenHeaderPositions.clear();
    if (firstVisibleItem === 0) {
      this._hiddenHeaderPositions.add(0);
    }
    const hiddenHeadersChanged = previousHiddenHeaders.size !== this._hiddenHeaderPositions.size || [...previousHiddenHeaders].some((pos) => !this._hiddenHeaderPositions.has(pos));
    if (hiddenHeadersChanged) {
      const adapter = this.nativeViewProtected.getAdapter();
      if (adapter instanceof android.widget.BaseAdapter) {
        adapter.notifyDataSetChanged();
      }
    }
  }
  [separatorColorProperty.getDefault]() {
    const nativeView = this.nativeViewProtected;
    return {
      dividerHeight: nativeView.getDividerHeight(),
      divider: nativeView.getDivider()
    };
  }
  [separatorColorProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    if (value instanceof Color) {
      nativeView.setDivider(new android.graphics.drawable.ColorDrawable(value.android));
      nativeView.setDividerHeight(1);
    } else {
      nativeView.setDivider(value.divider);
      nativeView.setDividerHeight(value.dividerHeight);
    }
  }
  [itemTemplatesProperty.getDefault]() {
    return null;
  }
  [itemTemplatesProperty.setNative](value) {
    this._itemTemplatesInternal = new Array(this._defaultTemplate);
    if (value) {
      this._itemTemplatesInternal = this._itemTemplatesInternal.concat(value);
    }
    if (this.nativeViewProtected) {
      this.nativeViewProtected.setAdapter(new ListViewAdapterClass(this));
      this.refresh();
    }
  }
  [stickyHeaderProperty.setNative](value) {
    if (this.nativeViewProtected && this.nativeViewProtected.getAdapter()) {
      this.nativeViewProtected.setAdapter(new ListViewAdapterClass(this));
    }
    if (value && this.sectioned && this.stickyHeaderTemplate && this.isLoaded) {
      this._setupStickyHeader();
    } else {
      this._cleanupStickyHeader();
    }
  }
  [stickyHeaderTemplateProperty.setNative](value) {
    if (this.nativeViewProtected && this.nativeViewProtected.getAdapter()) {
      this.nativeViewProtected.setAdapter(new ListViewAdapterClass(this));
    }
    this._cleanupStickyHeader();
    if (value && this.stickyHeader && this.sectioned && this.isLoaded) {
      this._setupStickyHeader();
    }
  }
  [sectionedProperty.setNative](value) {
    if (this.nativeViewProtected && this.nativeViewProtected.getAdapter()) {
      this.nativeViewProtected.setAdapter(new ListViewAdapterClass(this));
    }
    if (value && this.stickyHeader && this.stickyHeaderTemplate && this.isLoaded) {
      this._setupStickyHeader();
    } else {
      this._cleanupStickyHeader();
    }
  }
  _setupSearchView() {
    if (this._searchView || !this.showSearch || !this.nativeViewProtected) {
      return;
    }
    this._searchView = new android.widget.SearchView(this.nativeViewProtected.getContext());
    this._searchView.setQueryHint("Search...");
    this._searchView.setIconifiedByDefault(false);
    this._searchView.setSubmitButtonEnabled(false);
    const owner = this;
    this._searchListener = new android.widget.SearchView.OnQueryTextListener({
      onQueryTextChange(newText) {
        const args = {
          eventName: SEARCHCHANGE,
          object: owner,
          text: newText,
          android: owner._searchView
        };
        owner.notify(args);
        return true;
      },
      onQueryTextSubmit(query) {
        const args = {
          eventName: SEARCHCHANGE,
          object: owner,
          text: query,
          android: owner._searchView
        };
        owner.notify(args);
        return true;
      }
    });
    this._searchView.setOnQueryTextListener(this._searchListener);
    this._addSearchToParent();
    if (!this.stickyHeader || !this._stickyHeaderView) {
      this._addSearchPadding();
    }
  }
  _addSearchPadding() {
    if (!this._searchView) {
      return;
    }
    const defaultSearchHeight = 50;
    this.nativeViewProtected.setPadding(0, defaultSearchHeight, 0, 0);
    setTimeout(() => {
      if (this._searchView && this._searchView._wrapper) {
        const searchWrapper = this._searchView._wrapper;
        if (searchWrapper.nativeViewProtected && searchWrapper.nativeViewProtected.getMeasuredHeight() > 0) {
          const measuredHeight = searchWrapper.nativeViewProtected.getMeasuredHeight();
          this.nativeViewProtected.setPadding(0, measuredHeight + 4, 0, 0);
        }
      }
    }, 100);
  }
  _addSearchToParent() {
    if (!this._searchView || !this.parent) {
      return;
    }
    const parentLayout = this.parent;
    const searchView = this._searchView;
    const searchViewWrapper = new class extends View {
      createNativeView() {
        return searchView;
      }
    };
    searchViewWrapper.height = "auto";
    searchViewWrapper.width = { unit: "%", value: 100 };
    searchViewWrapper.verticalAlignment = "top";
    searchViewWrapper.horizontalAlignment = "stretch";
    if (parentLayout instanceof StackLayout) {
      parentLayout.insertChild(searchViewWrapper, 0);
    } else {
      parentLayout._addView(searchViewWrapper);
    }
    if (searchViewWrapper.nativeViewProtected) {
      searchViewWrapper.nativeViewProtected.setZ(SEARCH_VIEW_Z_INDEX);
    }
    this._searchView._wrapper = searchViewWrapper;
  }
  _cleanupSearchView() {
    if (this._searchView) {
      const wrapper = this._searchView._wrapper;
      if (wrapper && wrapper.parent) {
        wrapper.parent._removeView(wrapper);
      }
      if (this._searchListener) {
        this._searchView.setOnQueryTextListener(null);
        this._searchListener = null;
      }
      this._searchView = null;
      if (!this.stickyHeader || !this._stickyHeaderView) {
        this.nativeViewProtected.setPadding(0, 0, 0, 0);
      }
    }
  }
  [showSearchProperty.setNative](value) {
    if (value) {
      if (this.isLoaded && this.nativeViewProtected && this.nativeViewProtected.getAdapter()) {
        this._setupSearchView();
        if (this._stickyHeaderView) {
          this._repositionStickyHeader();
        }
      }
    } else {
      this._cleanupSearchView();
      if (this._stickyHeaderView) {
        this._repositionStickyHeader();
      }
    }
  }
  _repositionStickyHeader() {
    if (!this._stickyHeaderView || !this._stickyHeaderView.nativeViewProtected) {
      return;
    }
    this._stickyHeaderView.nativeViewProtected.setTranslationY(0);
    if (this.showSearch && this._searchView && this._searchView._wrapper) {
      setTimeout(() => {
        const searchWrapper = this._searchView._wrapper;
        if (searchWrapper.nativeViewProtected) {
          const searchHeight = searchWrapper.nativeViewProtected.getMeasuredHeight() || 50;
          this._stickyHeaderView.nativeViewProtected.setTranslationY(searchHeight);
        }
      }, 100);
    }
    if (this.stickyHeader && this._stickyHeaderView) {
      this._addListViewPadding();
    }
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], ListView.prototype, "createNativeView", null);
var ListViewAdapterClass;
function ensureListViewAdapterClass() {
  if (ListViewAdapterClass) {
    return;
  }
  var ListViewAdapter = function(_super) {
    __extends(ListViewAdapter2, _super);
    function ListViewAdapter2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    ListViewAdapter2.prototype.getCount = function() {
      if (!this.owner) {
        return 0;
      }
      var count = 0;
      if (this.owner.sectioned) {
        var sectionCount = this.owner._getSectionCount();
        if (!this.owner.items || sectionCount <= 0) {
          return 0;
        }
        for (var i4 = 0;i4 < sectionCount; i4++) {
          var itemsInSection = this.owner._getItemsInSection(i4) || [];
          if (itemsInSection.length > 0) {
            count += 1;
            count += itemsInSection.length;
          }
        }
      } else {
        var src = this.owner.items;
        count = src && typeof src.length === "number" ? src.length : 0;
      }
      return Math.max(0, count);
    };
    ListViewAdapter2.prototype.getItem = function(i4) {
      if (!this.owner || !this.owner.items) {
        return null;
      }
      var totalCount = this.getCount();
      if (i4 < 0 || i4 >= totalCount) {
        return null;
      }
      if (this.owner.sectioned) {
        var positionInfo = this._getPositionInfo(i4);
        if (positionInfo.isHeader) {
          return this.owner._getSectionData(positionInfo.section);
        } else {
          return this.owner._getDataItemInSection(positionInfo.section, positionInfo.itemIndex);
        }
      } else {
        var src = this.owner.items;
        if (src && typeof src.length === "number" && i4 < src.length) {
          var getItem = src.getItem;
          return getItem ? getItem.call(src, i4) : src[i4];
        }
      }
      return null;
    };
    ListViewAdapter2.prototype._getPositionInfo = function(position) {
      if (!this.owner.sectioned) {
        return { isHeader: false, section: 0, itemIndex: position };
      }
      var currentPosition = 0;
      var sectionCount = this.owner._getSectionCount();
      for (var section = 0;section < sectionCount; section++) {
        var itemsInSection = this.owner._getItemsInSection(section) || [];
        if (itemsInSection.length === 0) {
          continue;
        }
        if (currentPosition === position) {
          return { isHeader: true, section, itemIndex: -1 };
        }
        currentPosition++;
        if (position < currentPosition + itemsInSection.length) {
          var itemIndex = position - currentPosition;
          return { isHeader: false, section, itemIndex };
        }
        currentPosition += itemsInSection.length;
      }
      return { isHeader: false, section: 0, itemIndex: 0 };
    };
    ListViewAdapter2.prototype.getItemId = function(i4) {
      var item = this.getItem(i4);
      var id = i4;
      if (this.owner && item && this.owner.items) {
        id = this.owner.itemIdGenerator(item, i4, this.owner.items);
      }
      return long(id);
    };
    ListViewAdapter2.prototype.hasStableIds = function() {
      return true;
    };
    ListViewAdapter2.prototype.isEnabled = function(position) {
      var totalCount = this.getCount();
      if (totalCount === 0 || position < 0 || position >= totalCount) {
        return false;
      }
      if (this.owner.sectioned) {
        var positionInfo = this._getPositionInfo(position);
        return !positionInfo.isHeader;
      }
      return true;
    };
    ListViewAdapter2.prototype.getViewTypeCount = function() {
      var count = this.owner._itemTemplatesInternal.length;
      if (this.owner.sectioned && this.owner.stickyHeaderTemplate) {
        count += 1;
      }
      return count;
    };
    ListViewAdapter2.prototype.getItemViewType = function(index) {
      if (this.owner.sectioned) {
        var positionInfo = this._getPositionInfo(index);
        if (positionInfo.isHeader) {
          return this.owner._itemTemplatesInternal.length;
        } else {
          var template = this.owner._getItemTemplate(positionInfo.itemIndex);
          return this.owner._itemTemplatesInternal.indexOf(template);
        }
      } else {
        var template = this.owner._getItemTemplate(index);
        return this.owner._itemTemplatesInternal.indexOf(template);
      }
    };
    ListViewAdapter2.prototype.getView = function(index, convertView, parent) {
      if (!this.owner) {
        return null;
      }
      var totalCount = this.getCount();
      if (index < 0 || index >= totalCount) {
        var emptyView = new android.view.View(this.owner._context);
        var layoutParams = new android.view.ViewGroup.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT, 0);
        emptyView.setLayoutParams(layoutParams);
        return emptyView;
      }
      if (index === totalCount - 1) {
        this.owner.notify({
          eventName: LOADMOREITEMS,
          object: this.owner
        });
      }
      if (this.owner.sectioned) {
        var positionInfo = this._getPositionInfo(index);
        if (positionInfo.isHeader) {
          return this._createHeaderView(positionInfo.section, convertView, parent, index);
        } else {
          return this._createItemView(positionInfo.section, positionInfo.itemIndex, convertView, parent);
        }
      } else {
        return this._createItemView(0, index, convertView, parent);
      }
    };
    ListViewAdapter2.prototype._createHeaderView = function(section, convertView, parent, index) {
      if (this.owner._hiddenHeaderPositions.has(index)) {
        var emptyView = new android.view.View(this.owner._context);
        var layoutParams = new android.view.ViewGroup.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT, 0);
        emptyView.setLayoutParams(layoutParams);
        return emptyView;
      }
      var headerView = null;
      var headerViewType = this.owner._itemTemplatesInternal.length;
      if (convertView) {
        var existingData = this.owner._realizedItems.get(convertView);
        if (existingData && existingData.templateKey === "header_".concat(headerViewType)) {
          headerView = existingData.view;
        }
      }
      if (!headerView) {
        if (this.owner.stickyHeaderTemplate) {
          if (typeof this.owner.stickyHeaderTemplate === "string") {
            try {
              headerView = Builder.parse(this.owner.stickyHeaderTemplate, this.owner);
            } catch (error) {
              headerView = new Label;
              headerView.text = "Header Error";
            }
          }
        }
        if (!headerView) {
          headerView = new Label;
          headerView.text = "Section ".concat(section);
        }
        if (!headerView.parent) {
          if (headerView instanceof LayoutBase && !(headerView instanceof ProxyViewContainer)) {
            this.owner._addView(headerView);
            convertView = headerView.nativeViewProtected;
          } else {
            var sp = new StackLayout;
            sp.addChild(headerView);
            this.owner._addView(sp);
            convertView = sp.nativeViewProtected;
          }
        }
        this.owner._realizedItems.set(convertView, {
          view: headerView,
          templateKey: "header_".concat(headerViewType)
        });
      }
      var sectionData = this.owner._getSectionData(section);
      if (sectionData) {
        headerView.bindingContext = sectionData;
      } else {
        headerView.bindingContext = { title: "Section ".concat(section), section };
      }
      return convertView;
    };
    ListViewAdapter2.prototype._createItemView = function(section, itemIndex, convertView, parent) {
      var template = this.owner._getItemTemplate(itemIndex);
      var view;
      if (convertView && this.owner._getKeyFromView(convertView) !== template.key) {
        this.owner._markViewUnused(convertView);
        convertView = this.owner._getAvailableView(template.key);
      }
      if (convertView) {
        view = this.owner._realizedItems.get(convertView).view;
      }
      if (!view) {
        view = template.createView();
      }
      var args = {
        eventName: ITEMLOADING,
        object: this.owner,
        index: itemIndex,
        view,
        android: parent,
        ios: undefined
      };
      if (this.owner.sectioned) {
        args.section = section;
      }
      this.owner.notify(args);
      if (!args.view) {
        args.view = this.owner._getDefaultItemContent(itemIndex);
      }
      if (args.view) {
        if (this.owner._effectiveRowHeight > -1) {
          args.view.height = this.owner.rowHeight;
        } else {
          args.view.height = unsetValue;
        }
        if (this.owner.sectioned) {
          args.view._listViewItemIndex = itemIndex;
          args.view._listViewSectionIndex = section;
        }
        if (this.owner.sectioned) {
          this.owner._prepareItemInSection(args.view, section, itemIndex);
        } else {
          this.owner._prepareItem(args.view, itemIndex);
        }
        if (!args.view.parent) {
          if (args.view instanceof LayoutBase && !(args.view instanceof ProxyViewContainer)) {
            var mt = PercentLength.toDevicePixels(args.view.marginTop, 0, Number.NaN);
            var mb = PercentLength.toDevicePixels(args.view.marginBottom, 0, Number.NaN);
            var ml = PercentLength.toDevicePixels(args.view.marginLeft, 0, Number.NaN);
            var mr = PercentLength.toDevicePixels(args.view.marginRight, 0, Number.NaN);
            var hasMargins = mt > 0 || mb > 0 || ml > 0 || mr > 0;
            if (hasMargins) {
              var outer = new StackLayout;
              outer.addChild(args.view);
              this.owner._addView(outer);
              convertView = outer.nativeViewProtected;
            } else {
              this.owner._addView(args.view);
              convertView = args.view.nativeViewProtected;
            }
          } else {
            var sp = new StackLayout;
            sp.addChild(args.view);
            this.owner._addView(sp);
            convertView = sp.nativeViewProtected;
          }
        }
        this.owner._registerViewToTemplate(template.key, convertView, args.view);
        this.owner._markViewUsed(convertView);
      }
      return convertView;
    };
    __decorate([
      profile
    ], ListViewAdapter2.prototype, "getView", null);
    return ListViewAdapter2;
  }(android.widget.BaseAdapter);
  ListViewAdapterClass = ListViewAdapter;
}
// node_modules/@nativescript/core/ui/page/events.js
var PageEvents = {
  navigatingToEvent: "navigatingTo",
  navigatedToEvent: "navigatedTo",
  navigatingFromEvent: "navigatingFrom",
  navigatedFromEvent: "navigatedFrom"
};

// node_modules/@nativescript/core/ui/page/page-common.js
var PageBase_1;
var PageBase = PageBase_1 = class PageBase2 extends ContentView {
  constructor() {
    super(...arguments);
    this.accessibilityAnnouncePageEnabled = true;
  }
  get navigationContext() {
    return this._navigationContext;
  }
  get actionBar() {
    if (!this._actionBar) {
      this.hasActionBar = true;
      this._actionBar = new ActionBar;
      this._addView(this._actionBar);
    }
    return this._actionBar;
  }
  set actionBar(value) {
    if (!value) {
      throw new Error("ActionBar cannot be null or undefined.");
    }
    if (this._actionBar !== value) {
      if (this._actionBar) {
        this._removeView(this._actionBar);
      }
      this.hasActionBar = true;
      this._actionBar = value;
      this._addView(this._actionBar);
    }
  }
  get androidStatusBarBackground() {
    return this.style.androidStatusBarBackground;
  }
  set androidStatusBarBackground(value) {
    this.style.androidStatusBarBackground = value;
  }
  get page() {
    return this;
  }
  _parentChanged(oldParent) {
    const newParent = this.parent;
    if (newParent && !isFrame(newParent)) {
      throw new Error(`Page can only be nested inside Frame. New parent: ${newParent}`);
    }
    super._parentChanged(oldParent);
  }
  _addChildFromBuilder(name50, value) {
    if (value instanceof ActionBar) {
      this.actionBar = value;
    } else {
      super._addChildFromBuilder(name50, value);
    }
  }
  getKeyframeAnimationWithName(animationName) {
    return this._styleScope.getKeyframeAnimationWithName(animationName);
  }
  get frame() {
    return this.parent;
  }
  createNavigatedData(eventName, isBackNavigation) {
    return {
      eventName,
      object: this,
      context: this.navigationContext,
      isBackNavigation
    };
  }
  onNavigatingTo(context, isBackNavigation, bindingContext) {
    this._navigationContext = context;
    if (isBackNavigation && this._styleScope) {
      this._styleScope.ensureSelectors();
      if (!this._cssState.isSelectorsLatestVersionApplied()) {
        this._onCssStateChange();
      }
    }
    if (!isBackNavigation && bindingContext !== undefined && bindingContext !== null) {
      this.bindingContext = bindingContext;
    }
    this.notify(this.createNavigatedData(PageBase_1.navigatingToEvent, isBackNavigation));
  }
  onNavigatedTo(isBackNavigation) {
    this.notify(this.createNavigatedData(PageBase_1.navigatedToEvent, isBackNavigation));
    if (this.accessibilityAnnouncePageEnabled) {
      this.accessibilityScreenChanged(!!isBackNavigation);
    }
  }
  onNavigatingFrom(isBackNavigation) {
    this.notify(this.createNavigatedData(PageBase_1.navigatingFromEvent, isBackNavigation));
  }
  onNavigatedFrom(isBackNavigation) {
    this.notify(this.createNavigatedData(PageBase_1.navigatedFromEvent, isBackNavigation));
    this._navigationContext = undefined;
  }
  eachChildView(callback) {
    super.eachChildView(callback);
    if (this.hasActionBar) {
      callback(this.actionBar);
    }
  }
  get _childrenCount() {
    return (this.content ? 1 : 0) + (this._actionBar ? 1 : 0);
  }
  accessibilityScreenChanged(refocus) {
    return;
  }
};
PageBase.navigatingToEvent = PageEvents.navigatingToEvent;
PageBase.navigatedToEvent = PageEvents.navigatedToEvent;
PageBase.navigatingFromEvent = PageEvents.navigatingFromEvent;
PageBase.navigatedFromEvent = PageEvents.navigatedFromEvent;
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Boolean, Object]),
  __metadata("design:returntype", undefined)
], PageBase.prototype, "onNavigatingTo", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", undefined)
], PageBase.prototype, "onNavigatedTo", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", undefined)
], PageBase.prototype, "onNavigatingFrom", null);
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", undefined)
], PageBase.prototype, "onNavigatedFrom", null);
PageBase = PageBase_1 = __decorate([
  CSSType("Page")
], PageBase);
PageBase.prototype.recycleNativeView = "never";
var actionBarHiddenProperty = new Property({
  name: "actionBarHidden",
  affectsLayout: __APPLE__,
  valueConverter: booleanConverter
});
actionBarHiddenProperty.register(PageBase);
var backgroundSpanUnderStatusBarProperty = new Property({
  name: "backgroundSpanUnderStatusBar",
  defaultValue: false,
  affectsLayout: __APPLE__,
  valueConverter: booleanConverter
});
backgroundSpanUnderStatusBarProperty.register(PageBase);
var enableSwipeBackNavigationProperty = new Property({
  name: "enableSwipeBackNavigation",
  defaultValue: true,
  valueConverter: booleanConverter
});
enableSwipeBackNavigationProperty.register(PageBase);
var androidStatusBarBackgroundProperty = new CssProperty({
  name: "androidStatusBarBackground",
  cssName: "android-status-bar-background",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
androidStatusBarBackgroundProperty.register(Style);

// node_modules/@nativescript/core/ui/page/index.android.js
class Page extends PageBase {
  createNativeView() {
    const layout2 = new org.nativescript.widgets.GridLayout(this._context);
    layout2.addRowsFromJSON(JSON.stringify([
      { value: 1, type: 0 },
      { value: 1, type: 2 }
    ]));
    return layout2;
  }
  initNativeView() {
    super.initNativeView();
    this.nativeViewProtected.setBackgroundColor(-1);
  }
  _addViewToNativeVisualTree(child, atIndex) {
    if (this.nativeViewProtected && child.nativeViewProtected) {
      if (child instanceof ActionBar) {
        GridLayout.setRow(child, 0);
        child.horizontalAlignment = "stretch";
        child.verticalAlignment = "top";
      } else {
        GridLayout.setRow(child, 1);
      }
    }
    return super._addViewToNativeVisualTree(child, atIndex);
  }
  onLoaded() {
    super.onLoaded();
    if (!this.hasActionBar && this.actionBarHidden !== true) {
      this.actionBar = new ActionBar;
    }
    if (this.hasActionBar) {
      this.updateActionBar();
    }
  }
  updateActionBar() {
    if (this.actionBar) {
      this.actionBar.update();
    }
  }
  [actionBarHiddenProperty.setNative](value) {
    if (!value || this.hasActionBar) {
      this.updateActionBar();
    }
  }
  [androidStatusBarBackgroundProperty.getDefault]() {
    if (SDK_VERSION >= 21) {
      const window2 = this.getClosestWindow();
      return window2.getStatusBarColor();
    }
    return null;
  }
  [androidStatusBarBackgroundProperty.setNative](value) {
    if (SDK_VERSION >= 21) {
      const window2 = this.getClosestWindow();
      const color2 = value instanceof Color ? value.android : value;
      window2.setStatusBarColor(color2);
    }
  }
  accessibilityScreenChanged(refocus = false) {
    if (!isAccessibilityServiceEnabled()) {
      return;
    }
    if (refocus) {
      const lastFocusedView2 = getLastFocusedViewOnPage(this);
      if (lastFocusedView2) {
        const announceView = lastFocusedView2.nativeViewProtected;
        if (announceView) {
          announceView.sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent.TYPE_VIEW_FOCUSED);
          announceView.sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
          return;
        }
      }
    }
    if (this.actionBarHidden || this.accessibilityLabel) {
      this.sendAccessibilityEvent({
        androidAccessibilityEvent: AndroidAccessibilityEvent.WINDOW_STATE_CHANGED
      });
      return;
    }
    this.actionBar.accessibilityScreenChanged();
  }
}
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], Page.prototype, "onLoaded", null);
// node_modules/@nativescript/core/ui/placeholder/index.android.js
var Placeholder_1;
var Placeholder = Placeholder_1 = class Placeholder2 extends View {
  createNativeView() {
    const args = {
      eventName: Placeholder_1.creatingViewEvent,
      object: this,
      view: undefined,
      context: this._context
    };
    this.notify(args);
    return args.view;
  }
};
Placeholder.creatingViewEvent = "creatingView";
Placeholder = Placeholder_1 = __decorate([
  CSSType("Placeholder")
], Placeholder);
// node_modules/@nativescript/core/ui/progress/progress-common.js
var ProgressBase = class ProgressBase2 extends View {
};
ProgressBase = __decorate([
  CSSType("Progress")
], ProgressBase);
ProgressBase.prototype.recycleNativeView = "auto";
var valueProperty = new CoercibleProperty({
  name: "value",
  defaultValue: 0,
  coerceValue: (t3, v) => {
    return v < 0 ? 0 : Math.min(v, t3.maxValue);
  },
  valueConverter: (v) => parseInt(v)
});
valueProperty.register(ProgressBase);
var maxValueProperty = new Property({
  name: "maxValue",
  defaultValue: 100,
  valueChanged: (target, oldValue, newValue) => {
    valueProperty.coerce(target);
  },
  valueConverter: (v) => parseInt(v)
});
maxValueProperty.register(ProgressBase);

// node_modules/@nativescript/core/ui/progress/index.android.js
var R_ATTR_PROGRESS_BAR_STYLE_HORIZONTAL = 16842872;

class Progress extends ProgressBase {
  createNativeView() {
    return new android.widget.ProgressBar(this._context, null, R_ATTR_PROGRESS_BAR_STYLE_HORIZONTAL);
  }
  [valueProperty.getDefault]() {
    return 0;
  }
  [valueProperty.setNative](value) {
    this.nativeViewProtected.setProgress(value);
  }
  [maxValueProperty.getDefault]() {
    return 100;
  }
  [maxValueProperty.setNative](value) {
    this.nativeViewProtected.setMax(value);
  }
  [colorProperty.getDefault]() {
    return null;
  }
  [colorProperty.setNative](value) {
    const progressDrawable = this.nativeViewProtected.getProgressDrawable();
    if (!progressDrawable) {
      return;
    }
    if (value instanceof Color) {
      AndroidHelper.setDrawableColor(value.android, progressDrawable);
    } else {
      AndroidHelper.clearDrawableColor(progressDrawable);
    }
  }
  [backgroundColorProperty.getDefault]() {
    return null;
  }
  [backgroundColorProperty.setNative](value) {
    const progressDrawable = this.nativeViewProtected.getProgressDrawable();
    if (!progressDrawable) {
      return;
    }
    if (progressDrawable instanceof android.graphics.drawable.LayerDrawable && progressDrawable.getNumberOfLayers() > 0) {
      const backgroundDrawable = progressDrawable.getDrawable(0);
      if (backgroundDrawable) {
        if (value instanceof Color) {
          AndroidHelper.setDrawableColor(value.android, backgroundDrawable);
        } else {
          AndroidHelper.clearDrawableColor(backgroundDrawable);
        }
      }
    }
  }
  [backgroundInternalProperty.getDefault]() {
    return null;
  }
  [backgroundInternalProperty.setNative](value) {}
}
// node_modules/@nativescript/core/ui/repeater/index.js
var Repeater = class Repeater2 extends CustomLayoutView {
  constructor() {
    super();
    this._isDirty = false;
    this.itemsLayout = new StackLayout;
  }
  onLoaded() {
    if (this._isDirty) {
      this.refresh();
    }
    super.onLoaded();
  }
  get itemTemplateSelector() {
    return this._itemTemplateSelector;
  }
  set itemTemplateSelector(value) {
    if (typeof value === "string") {
      if (!this._itemTemplateSelectorBindable) {
        this._itemTemplateSelectorBindable = new Label;
      }
      this._itemTemplateSelectorBindable.bind({
        sourceProperty: null,
        targetProperty: "templateKey",
        expression: value
      });
      this._itemTemplateSelector = (item, index, items) => {
        item["$index"] = index;
        if (this._itemTemplateSelectorBindable.bindingContext === item) {
          this._itemTemplateSelectorBindable.bindingContext = null;
        }
        this._itemTemplateSelectorBindable.bindingContext = item;
        return this._itemTemplateSelectorBindable.get("templateKey");
      };
    } else if (typeof value === "function") {
      this._itemTemplateSelector = value;
    }
  }
  _requestRefresh() {
    this._isDirty = true;
    if (this.isLoaded) {
      this.refresh();
    }
  }
  refresh() {
    if (this.itemsLayout) {
      this.itemsLayout.removeChildren();
    }
    if (!this.items) {
      return;
    }
    const length2 = this.items.length;
    for (let i4 = 0;i4 < length2; i4++) {
      const dataItem = this._getDataItem(i4);
      let viewToAdd = null;
      if (this._itemTemplateSelector && this.itemTemplates) {
        const key = this._itemTemplateSelector(dataItem, i4, this.items);
        const length22 = this.itemTemplates.length;
        for (let j2 = 0;j2 < length22; j2++) {
          const template = this.itemTemplates[j2];
          if (template.key === key) {
            viewToAdd = template.createView();
            break;
          }
        }
      }
      if (!viewToAdd) {
        if (__UI_USE_EXTERNAL_RENDERER__) {
          viewToAdd = isFunction(this.itemTemplate) ? this.itemTemplate() : this._getDefaultItemContent(i4);
        } else {
          viewToAdd = this.itemTemplate ? Builder.parse(this.itemTemplate, this) : this._getDefaultItemContent(i4);
        }
      }
      viewToAdd.bindingContext = dataItem;
      this.itemsLayout.addChild(viewToAdd);
    }
    this._isDirty = false;
  }
  _onItemsChanged(data2) {
    this._requestRefresh();
  }
  _getDefaultItemContent(index) {
    const lbl = new Label;
    lbl.bind({
      targetProperty: "text",
      sourceProperty: "$value"
    });
    return lbl;
  }
  _getDataItem(index) {
    const items = this.items;
    return items.getItem ? items.getItem(index) : this.items[index];
  }
  get _childrenCount() {
    return this.itemsLayout ? 1 : 0;
  }
  eachChildView(callback) {
    if (this.itemsLayout) {
      callback(this.itemsLayout);
    }
  }
  onLayout(left, top, right, bottom) {
    const insets = this.getSafeAreaInsets();
    const paddingLeft = this.effectiveBorderLeftWidth + this.effectivePaddingLeft + insets.left;
    const paddingTop = this.effectiveBorderTopWidth + this.effectivePaddingTop + insets.top;
    const paddingRight = this.effectiveBorderRightWidth + this.effectivePaddingRight + insets.right;
    const paddingBottom = this.effectiveBorderBottomWidth + this.effectivePaddingBottom + insets.bottom;
    const childLeft = paddingLeft;
    const childTop = paddingTop;
    const childRight = right - left - paddingRight;
    const childBottom = bottom - top - paddingBottom;
    View.layoutChild(this, this.itemsLayout, childLeft, childTop, childRight, childBottom);
  }
  onMeasure(widthMeasureSpec, heightMeasureSpec) {
    const result = View.measureChild(this, this.itemsLayout, widthMeasureSpec, heightMeasureSpec);
    const width = layout.getMeasureSpecSize(widthMeasureSpec);
    const widthMode = layout.getMeasureSpecMode(widthMeasureSpec);
    const height = layout.getMeasureSpecSize(heightMeasureSpec);
    const heightMode = layout.getMeasureSpecMode(heightMeasureSpec);
    const widthAndState = View.resolveSizeAndState(result.measuredWidth, width, widthMode, 0);
    const heightAndState = View.resolveSizeAndState(result.measuredHeight, height, heightMode, 0);
    this.setMeasuredDimension(widthAndState, heightAndState);
  }
};
Repeater.knownFunctions = ["itemTemplateSelector"];
__decorate([
  profile,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", undefined)
], Repeater.prototype, "onLoaded", null);
Repeater = __decorate([
  CSSType("Repeater"),
  __metadata("design:paramtypes", [])
], Repeater);
Repeater.prototype.recycleNativeView = "auto";
var itemTemplateProperty2 = new Property({
  name: "itemTemplate",
  affectsLayout: true,
  valueChanged: (target) => {
    target._requestRefresh();
  }
});
itemTemplateProperty2.register(Repeater);
var itemTemplatesProperty2 = new Property({
  name: "itemTemplates",
  affectsLayout: true,
  valueConverter: (value) => {
    if (typeof value === "string") {
      if (__UI_USE_XML_PARSER__) {
        return Builder.parseMultipleTemplates(value, null);
      } else {
        return null;
      }
    }
    return value;
  },
  valueChanged: (target) => {
    target._requestRefresh();
  }
});
itemTemplatesProperty2.register(Repeater);
var itemsProperty3 = new Property({
  name: "items",
  affectsLayout: true,
  valueChanged: (target, oldValue, newValue) => {
    if (oldValue instanceof ObservableArray) {
      removeWeakEventListener(oldValue, ObservableArray.changeEvent, target._onItemsChanged, target);
    }
    if (newValue instanceof ObservableArray) {
      addWeakEventListener(newValue, ObservableArray.changeEvent, target._onItemsChanged, target);
    }
    target._requestRefresh();
  }
});
itemsProperty3.register(Repeater);
var itemsLayoutProperty = new Property({
  name: "itemsLayout",
  affectsLayout: true,
  valueChanged: (target, oldValue, newValue) => {
    if (oldValue) {
      target._removeView(oldValue);
      oldValue.removeChildren();
    }
    if (newValue) {
      target._addView(newValue);
    }
    target._requestRefresh();
  }
});
itemsLayoutProperty.register(Repeater);
// node_modules/@nativescript/core/ui/scroll-view/scroll-view-common.js
var ScrollViewBase_1;
var ScrollViewBase = ScrollViewBase_1 = class ScrollViewBase2 extends ContentView {
  constructor() {
    super(...arguments);
    this._addedScrollEvent = false;
  }
  addEventListener(eventName, callback, thisArg, once) {
    const hasExistingScrollListeners = this.hasListeners(ScrollViewBase_1.scrollEvent);
    super.addEventListener(eventName, callback, thisArg, once);
    if (!hasExistingScrollListeners && this.hasListeners(ScrollViewBase_1.scrollEvent)) {
      this._addedScrollEvent = true;
      if (this.nativeViewProtected) {
        this.attachNative();
      }
    }
  }
  removeEventListener(eventName, callback, thisArg) {
    const hasExistingScrollListeners = this.hasListeners(ScrollViewBase_1.scrollEvent);
    super.removeEventListener(eventName, callback, thisArg);
    if (hasExistingScrollListeners && !this.hasListeners(ScrollViewBase_1.scrollEvent)) {
      this._addedScrollEvent = false;
      if (this.nativeViewProtected) {
        this.detachNative();
      }
    }
  }
  initNativeView() {
    super.initNativeView();
    if (this._addedScrollEvent) {
      this.attachNative();
    }
  }
  disposeNativeView() {
    if (this._addedScrollEvent) {
      this.detachNative();
    }
    super.disposeNativeView();
  }
  attachNative() {}
  detachNative() {}
  get horizontalOffset() {
    return 0;
  }
  get verticalOffset() {
    return 0;
  }
  get scrollableWidth() {
    return 0;
  }
  get scrollableHeight() {
    return 0;
  }
};
ScrollViewBase.scrollEvent = "scroll";
ScrollViewBase = ScrollViewBase_1 = __decorate([
  CSSType("ScrollView")
], ScrollViewBase);
var converter3 = makeParser(makeValidator(CoreTypes.Orientation.horizontal, CoreTypes.Orientation.vertical));
var orientationProperty3 = new Property({
  name: "orientation",
  defaultValue: CoreTypes.Orientation.vertical,
  affectsLayout: true,
  valueChanged: (target, oldValue, newValue) => {
    target._onOrientationChanged();
  },
  valueConverter: converter3
});
orientationProperty3.register(ScrollViewBase);
var scrollBarIndicatorVisibleProperty = new Property({
  name: "scrollBarIndicatorVisible",
  defaultValue: true,
  valueConverter: booleanConverter
});
scrollBarIndicatorVisibleProperty.register(ScrollViewBase);
var isScrollEnabledProperty = new Property({
  name: "isScrollEnabled",
  defaultValue: true,
  valueConverter: booleanConverter
});
isScrollEnabledProperty.register(ScrollViewBase);

// node_modules/@nativescript/core/ui/scroll-view/index.android.js
class ScrollView extends ScrollViewBase {
  constructor() {
    super(...arguments);
    this._androidViewId = -1;
    this._lastScrollX = -1;
    this._lastScrollY = -1;
  }
  get horizontalOffset() {
    const nativeView = this.nativeViewProtected;
    if (!nativeView) {
      return 0;
    }
    return nativeView.getScrollX() / layout.getDisplayDensity();
  }
  get verticalOffset() {
    const nativeView = this.nativeViewProtected;
    if (!nativeView) {
      return 0;
    }
    return nativeView.getScrollY() / layout.getDisplayDensity();
  }
  get scrollableWidth() {
    const nativeView = this.nativeViewProtected;
    if (!nativeView || this.orientation !== "horizontal") {
      return 0;
    }
    return nativeView.getScrollableLength() / layout.getDisplayDensity();
  }
  get scrollableHeight() {
    const nativeView = this.nativeViewProtected;
    if (!nativeView || this.orientation !== "vertical") {
      return 0;
    }
    return nativeView.getScrollableLength() / layout.getDisplayDensity();
  }
  [isUserInteractionEnabledProperty.setNative](value) {
    this.nativeViewProtected.setClickable(value);
    this.nativeViewProtected.setFocusable(value);
    this.nativeViewProtected.setScrollEnabled(value);
  }
  [isScrollEnabledProperty.getDefault]() {
    return this.nativeViewProtected.getScrollEnabled();
  }
  [isScrollEnabledProperty.setNative](value) {
    this.nativeViewProtected.setScrollEnabled(value);
  }
  [scrollBarIndicatorVisibleProperty.getDefault]() {
    return true;
  }
  [scrollBarIndicatorVisibleProperty.setNative](value) {
    if (this.orientation === "horizontal") {
      this.nativeViewProtected.setHorizontalScrollBarEnabled(value);
    } else {
      this.nativeViewProtected.setVerticalScrollBarEnabled(value);
    }
  }
  scrollToVerticalOffset(value, animated) {
    const nativeView = this.nativeViewProtected;
    if (nativeView && this.orientation === "vertical" && this.isScrollEnabled) {
      value *= layout.getDisplayDensity();
      if (animated) {
        nativeView.smoothScrollTo(0, value);
      } else {
        nativeView.scrollTo(0, value);
      }
    }
  }
  scrollToHorizontalOffset(value, animated) {
    const nativeView = this.nativeViewProtected;
    if (nativeView && this.orientation === "horizontal" && this.isScrollEnabled) {
      value *= layout.getDisplayDensity();
      if (animated) {
        nativeView.smoothScrollTo(value, 0);
      } else {
        nativeView.scrollTo(value, 0);
      }
    }
  }
  createNativeView() {
    if (this.orientation === "horizontal") {
      return new org.nativescript.widgets.HorizontalScrollView(this._context);
    } else {
      const view = new org.nativescript.widgets.VerticalScrollView(this._context);
      view.setVerticalScrollBarEnabled(true);
      return view;
    }
  }
  initNativeView() {
    super.initNativeView();
    if (this._androidViewId < 0) {
      this._androidViewId = android.view.View.generateViewId();
    }
    this.nativeViewProtected.setId(this._androidViewId);
  }
  _onOrientationChanged() {
    if (this.nativeViewProtected) {
      const parent = this.parent;
      if (parent) {
        parent._removeView(this);
        parent._addView(this);
      }
    }
  }
  attachNative() {
    if (!this.handler) {
      const viewRef = new WeakRef(this);
      this.handler = new android.view.ViewTreeObserver.OnScrollChangedListener({
        onScrollChanged: function() {
          const owner = viewRef.get();
          if (owner) {
            owner._onScrollChanged();
          }
        }
      });
      this.nativeViewProtected.getViewTreeObserver().addOnScrollChangedListener(this.handler);
    }
  }
  _onScrollChanged() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      const newScrollX = nativeView.getScrollX();
      const newScrollY = nativeView.getScrollY();
      if (newScrollX !== this._lastScrollX || newScrollY !== this._lastScrollY) {
        this.notify({
          object: this,
          eventName: ScrollView.scrollEvent,
          scrollX: newScrollX / layout.getDisplayDensity(),
          scrollY: newScrollY / layout.getDisplayDensity()
        });
        this._lastScrollX = newScrollX;
        this._lastScrollY = newScrollY;
      }
    }
  }
  detachNative() {
    if (this.handler) {
      if (this.nativeViewProtected) {
        this.nativeViewProtected.getViewTreeObserver().removeOnScrollChangedListener(this.handler);
      }
      this.handler = null;
    }
  }
}
ScrollView.prototype.recycleNativeView = "never";
// node_modules/@nativescript/core/ui/search-bar/search-bar-common.js
var SearchBarBase = class SearchBarBase2 extends View {
};
SearchBarBase.submitEvent = "submit";
SearchBarBase.clearEvent = "clear";
SearchBarBase = __decorate([
  CSSType("SearchBar")
], SearchBarBase);
SearchBarBase.prototype.recycleNativeView = "auto";
var textProperty3 = new Property({
  name: "text",
  defaultValue: "",
  affectsLayout: __APPLE__
});
textProperty3.register(SearchBarBase);
var hintProperty2 = new Property({
  name: "hint",
  defaultValue: ""
});
hintProperty2.register(SearchBarBase);
var textFieldHintColorProperty = new Property({
  name: "textFieldHintColor",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
textFieldHintColorProperty.register(SearchBarBase);
var textFieldBackgroundColorProperty = new Property({
  name: "textFieldBackgroundColor",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
textFieldBackgroundColorProperty.register(SearchBarBase);
var clearButtonColorProperty = new Property({
  name: "clearButtonColor",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
clearButtonColorProperty.register(SearchBarBase);

// node_modules/@nativescript/core/ui/search-bar/index.android.js
var SEARCHTEXT = Symbol("searchText");
var QUERY = Symbol("query");
var QueryTextListener;
var CloseListener;
function initializeNativeClasses2() {
  if (QueryTextListener) {
    return;
  }
  var CompatQueryTextListenerImpl = function(_super) {
    __extends(CompatQueryTextListenerImpl2, _super);
    function CompatQueryTextListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    CompatQueryTextListenerImpl2.prototype.onQueryTextChange = function(newText) {
      var owner = this.owner;
      textProperty3.nativeValueChange(owner, newText);
      if (newText === "" && this[SEARCHTEXT] !== newText) {
        owner._emit(SearchBarBase.clearEvent);
      }
      this[SEARCHTEXT] = newText;
      this[QUERY] = undefined;
      return true;
    };
    CompatQueryTextListenerImpl2.prototype.onQueryTextSubmit = function(query) {
      var owner = this.owner;
      if (query !== "" && this[QUERY] !== query) {
        owner._emit(SearchBarBase.submitEvent);
      }
      this[QUERY] = query;
      return true;
    };
    CompatQueryTextListenerImpl2 = __decorate([
      Interfaces([androidx.appcompat.widget.SearchView.OnQueryTextListener])
    ], CompatQueryTextListenerImpl2);
    return CompatQueryTextListenerImpl2;
  }(java.lang.Object);
  var CompatCloseListenerImpl = function(_super) {
    __extends(CompatCloseListenerImpl2, _super);
    function CompatCloseListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    CompatCloseListenerImpl2.prototype.onClose = function() {
      this.owner._emit(SearchBarBase.clearEvent);
      return true;
    };
    CompatCloseListenerImpl2 = __decorate([
      Interfaces([androidx.appcompat.widget.SearchView.OnCloseListener])
    ], CompatCloseListenerImpl2);
    return CompatCloseListenerImpl2;
  }(java.lang.Object);
  QueryTextListener = CompatQueryTextListenerImpl;
  CloseListener = CompatCloseListenerImpl;
}
function enableSearchView(nativeView, value) {
  nativeView.setEnabled(value);
  if (!(nativeView instanceof android.view.ViewGroup)) {
    return;
  }
  for (let i4 = 0;i4 < nativeView.getChildCount(); i4++) {
    const child = nativeView.getChildAt(i4);
    enableSearchView(child, value);
  }
}
function enableUserInteractionSearchView(nativeView, value) {
  nativeView.setClickable(value);
  nativeView.setFocusable(value);
  if (!(nativeView instanceof android.view.ViewGroup)) {
    return;
  }
  for (let i4 = 0;i4 < nativeView.getChildCount(); i4++) {
    const child = nativeView.getChildAt(i4);
    enableUserInteractionSearchView(child, value);
  }
}

class SearchBar extends SearchBarBase {
  dismissSoftInput() {
    ad.dismissSoftInput(this.nativeViewProtected);
  }
  focus() {
    const result = super.focus();
    if (result) {
      if (this.nativeViewProtected) {
        const focusedNativeView = this.nativeViewProtected.findFocus();
        if (focusedNativeView) {
          ad.showSoftInput(focusedNativeView);
        }
      }
    }
    return result;
  }
  createNativeView() {
    const nativeView = new androidx.appcompat.widget.SearchView(this._context);
    nativeView.setIconified(false);
    return nativeView;
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    initializeNativeClasses2();
    const queryTextListener = new QueryTextListener(this);
    nativeView.setOnQueryTextListener(queryTextListener);
    nativeView.queryTextListener = queryTextListener;
    const closeListener = new CloseListener(this);
    nativeView.setOnCloseListener(closeListener);
    nativeView.closeListener = closeListener;
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    if (nativeView.closeListener) {
      nativeView.closeListener.owner = null;
    }
    if (nativeView.queryTextListener) {
      nativeView.queryTextListener.owner = null;
    }
    this._searchPlate = null;
    this._searchTextView = null;
    super.disposeNativeView();
  }
  [isEnabledProperty.setNative](value) {
    enableSearchView(this.nativeViewProtected, value);
  }
  [isUserInteractionEnabledProperty.setNative](value) {
    enableUserInteractionSearchView(this.nativeViewProtected, value);
  }
  [backgroundColorProperty.getDefault]() {
    const result = this.nativeViewProtected.getDrawingCacheBackgroundColor();
    return result;
  }
  [backgroundColorProperty.setNative](value) {
    let color2;
    if (typeof value === "number") {
      color2 = value;
    } else {
      color2 = value.android;
    }
    this.nativeViewProtected.setBackgroundColor(color2);
    const searchPlate = this._getSearchPlate();
    searchPlate.setBackgroundColor(color2);
  }
  [colorProperty.getDefault]() {
    const textView = this._getTextView();
    return textView.getCurrentTextColor();
  }
  [colorProperty.setNative](value) {
    const color2 = typeof value === "number" ? value : value.android;
    const textView = this._getTextView();
    textView.setTextColor(color2);
  }
  [fontSizeProperty.getDefault]() {
    return { nativeSize: this._getTextView().getTextSize() };
  }
  [fontSizeProperty.setNative](value) {
    if (typeof value === "number") {
      this._getTextView().setTextSize(value);
    } else {
      this._getTextView().setTextSize(android.util.TypedValue.COMPLEX_UNIT_PX, value.nativeSize);
    }
  }
  [fontInternalProperty.getDefault]() {
    return this._getTextView().getTypeface();
  }
  [fontInternalProperty.setNative](value) {
    this._getTextView().setTypeface(value instanceof Font2 ? value.getAndroidTypeface() : value);
  }
  [backgroundInternalProperty.getDefault]() {
    return null;
  }
  [backgroundInternalProperty.setNative](value) {}
  [textProperty3.getDefault]() {
    return "";
  }
  [textProperty3.setNative](value) {
    const text = value === null || value === undefined ? "" : value.toString();
    this.nativeViewProtected.setQuery(text, false);
  }
  [hintProperty2.getDefault]() {
    return null;
  }
  [hintProperty2.setNative](value) {
    if (value === null || value === undefined) {
      this.nativeViewProtected.setQueryHint(null);
    } else {
      this.nativeViewProtected.setQueryHint(value.toString());
    }
  }
  [textFieldBackgroundColorProperty.getDefault]() {
    const textView = this._getTextView();
    return textView.getBackground();
  }
  [textFieldBackgroundColorProperty.setNative](value) {
    const textView = this._getTextView();
    if (value instanceof Color) {
      textView.setBackgroundColor(value.android);
    } else {
      textView.setBackground(value);
    }
  }
  [textFieldHintColorProperty.getDefault]() {
    const textView = this._getTextView();
    return textView.getCurrentTextColor();
  }
  [textFieldHintColorProperty.setNative](value) {
    const textView = this._getTextView();
    const color2 = value instanceof Color ? value.android : value;
    textView.setHintTextColor(color2);
  }
  [clearButtonColorProperty.setNative](value) {
    if (!this.nativeViewProtected || !value) {
      return;
    }
    try {
      const closeButtonId = this.nativeViewProtected.getContext().getResources().getIdentifier("android:id/search_close_btn", null, null);
      const closeButton = this.nativeViewProtected.findViewById(closeButtonId);
      const color2 = value instanceof Color ? value.android : new Color(value).android;
      if (closeButton) {
        closeButton.setColorFilter(color2);
      }
    } catch (err) {
      console.log("Error setting clear button color:", err);
    }
  }
  _getTextView() {
    if (!this._searchTextView) {
      const pkgName = this.nativeViewProtected.getContext().getPackageName();
      const id = this.nativeViewProtected.getContext().getResources().getIdentifier("search_src_text", "id", pkgName);
      this._searchTextView = this.nativeViewProtected.findViewById(id);
    }
    return this._searchTextView;
  }
  _getSearchPlate() {
    if (!this._searchPlate) {
      const pkgName = this.nativeViewProtected.getContext().getPackageName();
      const id = this.nativeViewProtected.getContext().getResources().getIdentifier("search_plate", "id", pkgName);
      this._searchPlate = this.nativeViewProtected.findViewById(id);
    }
    return this._searchPlate;
  }
}
// node_modules/@nativescript/core/ui/segmented-bar/segmented-bar-common.js
var SegmentedBarItemBase = class SegmentedBarItemBase2 extends ViewBase {
  constructor() {
    super(...arguments);
    this._title = "";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    const strValue = value !== null && value !== undefined ? value.toString() : "";
    if (this._title !== strValue) {
      this._title = strValue;
      this._update();
    }
  }
};
SegmentedBarItemBase = __decorate([
  CSSType("SegmentedBarItem")
], SegmentedBarItemBase);
var SegmentedBarBase = class SegmentedBarBase2 extends View {
  get selectedBackgroundColor() {
    return this.style.selectedBackgroundColor;
  }
  set selectedBackgroundColor(value) {
    this.style.selectedBackgroundColor = value;
  }
  get selectedTextColor() {
    return this.style.selectedTabTextColor;
  }
  set selectedTextColor(value) {
    this.style.selectedTabTextColor = value;
  }
  _addArrayFromBuilder(name50, value) {
    if (name50 === "items") {
      this.items = value;
    }
  }
  _addChildFromBuilder(name50, value) {
    if (name50 === "SegmentedBarItem") {
      const item = value;
      let items = this.items;
      if (!items) {
        items = new Array;
        items.push(item);
        this.items = items;
      } else {
        items.push(item);
        this._addView(item);
      }
      if (this.nativeViewProtected) {
        this[itemsProperty4.setNative](items);
      }
    }
  }
  onItemsChanged(oldItems, newItems) {
    if (oldItems) {
      for (let i4 = 0, count = oldItems.length;i4 < count; i4++) {
        this._removeView(oldItems[i4]);
      }
    }
    if (newItems) {
      for (let i4 = 0, count = newItems.length;i4 < count; i4++) {
        this._addView(newItems[i4]);
      }
    }
  }
  eachChild(callback) {
    const items = this.items;
    if (items) {
      items.forEach((item, i4) => {
        callback(item);
      });
    }
  }
};
SegmentedBarBase.selectedIndexChangedEvent = "selectedIndexChanged";
SegmentedBarBase = __decorate([
  CSSType("SegmentedBar")
], SegmentedBarBase);
SegmentedBarBase.prototype.recycleNativeView = "auto";
var selectedIndexProperty2 = new CoercibleProperty({
  name: "selectedIndex",
  defaultValue: -1,
  valueChanged: (target, oldValue, newValue) => {
    target.notify({
      eventName: SegmentedBarBase.selectedIndexChangedEvent,
      object: target,
      oldIndex: oldValue,
      newIndex: newValue
    });
  },
  coerceValue: (target, value) => {
    const items = target.items;
    if (items) {
      const max2 = items.length - 1;
      if (value < 0) {
        value = 0;
      }
      if (value > max2) {
        value = max2;
      }
    } else {
      value = -1;
    }
    return value;
  },
  valueConverter: (v) => parseInt(v)
});
selectedIndexProperty2.register(SegmentedBarBase);
var itemsProperty4 = new Property({
  name: "items",
  valueChanged: (target, oldValue, newValue) => {
    target.onItemsChanged(oldValue, newValue);
  }
});
itemsProperty4.register(SegmentedBarBase);
var selectedBackgroundColorProperty = new InheritedCssProperty({
  name: "selectedBackgroundColor",
  cssName: "selected-background-color",
  equalityComparer: Color.equals,
  defaultValue: new Color("blue"),
  valueConverter: (v) => new Color(v)
});
selectedBackgroundColorProperty.register(Style);
var selectedTextColorProperty = new InheritedCssProperty({
  name: "selectedTextColor",
  cssName: "selected-text-color",
  equalityComparer: Color.equals,
  defaultValue: new Color("black"),
  valueConverter: (v) => new Color(v)
});
selectedTextColorProperty.register(Style);

// node_modules/@nativescript/core/ui/segmented-bar/index.android.js
var R_ID_TABS = 16908307;
var R_ID_TABCONTENT = 16908305;
var R_ATTR_STATE_SELECTED = 16842913;
var TITLE_TEXT_VIEW_ID = 16908310;
var selectedIndicatorThickness;
var TabHost;
var TabChangeListener;
var TabContentFactory;
function initializeNativeClasses3() {
  if (TabChangeListener) {
    return;
  }
  selectedIndicatorThickness = layout.toDevicePixels(SDK_VERSION >= 21 ? 2 : 5);
  var TabChangeListenerImpl = function(_super) {
    __extends(TabChangeListenerImpl2, _super);
    function TabChangeListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    TabChangeListenerImpl2.prototype.onTabChanged = function(id) {
      var owner = this.owner;
      if (owner) {
        setTimeout(function() {
          owner.setTabColor(id);
        });
        if (owner.shouldChangeSelectedIndex()) {
          owner.selectedIndex = parseInt(id);
        }
      }
    };
    TabChangeListenerImpl2 = __decorate([
      Interfaces([android.widget.TabHost.OnTabChangeListener])
    ], TabChangeListenerImpl2);
    return TabChangeListenerImpl2;
  }(java.lang.Object);
  var TabContentFactoryImpl = function(_super) {
    __extends(TabContentFactoryImpl2, _super);
    function TabContentFactoryImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    TabContentFactoryImpl2.prototype.createTabContent = function(tag) {
      var tv = new android.widget.TextView(this.owner._context);
      var isRtl = this.owner.direction === CoreTypes.LayoutDirection.rtl;
      tv.setVisibility(android.view.View.GONE);
      tv.setMaxLines(1);
      tv.setEllipsize(isRtl ? android.text.TextUtils.TruncateAt.START : android.text.TextUtils.TruncateAt.END);
      return tv;
    };
    TabContentFactoryImpl2 = __decorate([
      Interfaces([android.widget.TabHost.TabContentFactory])
    ], TabContentFactoryImpl2);
    return TabContentFactoryImpl2;
  }(java.lang.Object);
  var TabHostImpl = function(_super) {
    __extends(TabHostImpl2, _super);
    function TabHostImpl2(context, attrs) {
      var _this = _super.call(this, context, attrs) || this;
      return global.__native(_this);
    }
    TabHostImpl2.prototype.onAttachedToWindow = function() {};
    return TabHostImpl2;
  }(android.widget.TabHost);
  TabHost = TabHostImpl;
  TabChangeListener = TabChangeListenerImpl;
  TabContentFactory = TabContentFactoryImpl;
}

class SegmentedBarItem extends SegmentedBarItemBase {
  setupNativeView(tabIndex) {
    const titleTextView = this.parent.nativeViewProtected.getTabWidget().getChildAt(tabIndex).findViewById(TITLE_TEXT_VIEW_ID);
    this.setNativeView(titleTextView);
    if (titleTextView) {
      if (this.titleDirty) {
        this._update();
      }
    }
  }
  _update() {
    const tv = this.nativeViewProtected;
    if (tv) {
      let title = this.title;
      title = title === null || title === undefined ? "" : title;
      tv.setText(title);
      this.titleDirty = false;
    } else {
      this.titleDirty = true;
    }
  }
  [colorProperty.getDefault]() {
    return this.nativeViewProtected.getCurrentTextColor();
  }
  [colorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    this.nativeViewProtected.setTextColor(color2);
  }
  [fontSizeProperty.getDefault]() {
    return { nativeSize: this.nativeViewProtected.getTextSize() };
  }
  [fontSizeProperty.setNative](value) {
    if (typeof value === "number") {
      this.nativeViewProtected.setTextSize(value);
    } else {
      this.nativeViewProtected.setTextSize(android.util.TypedValue.COMPLEX_UNIT_PX, value.nativeSize);
    }
  }
  [fontInternalProperty.getDefault]() {
    return this.nativeViewProtected.getTypeface();
  }
  [fontInternalProperty.setNative](value) {
    this.nativeViewProtected.setTypeface(value instanceof Font2 ? value.getAndroidTypeface() : value);
  }
  [selectedBackgroundColorProperty.getDefault]() {
    const viewGroup = this.nativeViewProtected.getParent();
    return viewGroup.getBackground();
  }
  [selectedBackgroundColorProperty.setNative](value) {
    const nativeView = this.nativeViewProtected;
    const viewGroup = nativeView.getParent();
    if (value instanceof Color) {
      const color2 = value.android;
      const backgroundDrawable = viewGroup.getBackground();
      if (SDK_VERSION > 21 && backgroundDrawable) {
        const newDrawable = AndroidHelper.getCopyOrDrawable(backgroundDrawable, nativeView.getResources());
        AndroidHelper.setDrawableColor(color2, newDrawable);
        viewGroup.setBackground(newDrawable);
      } else {
        const stateDrawable = new android.graphics.drawable.StateListDrawable;
        const colorDrawable = new org.nativescript.widgets.SegmentedBarColorDrawable(color2, selectedIndicatorThickness);
        const arr = Array.create("int", 1);
        arr[0] = R_ATTR_STATE_SELECTED;
        stateDrawable.addState(arr, colorDrawable);
        stateDrawable.setBounds(0, 15, viewGroup.getRight(), viewGroup.getBottom());
        viewGroup.setBackground(stateDrawable);
      }
    } else {
      const backgroundDrawable = AndroidHelper.getCopyOrDrawable(value, nativeView.getResources());
      viewGroup.setBackground(backgroundDrawable);
    }
  }
}

class SegmentedBar extends SegmentedBarBase {
  shouldChangeSelectedIndex() {
    return !this._addingTab;
  }
  createNativeView() {
    initializeNativeClasses3();
    const context = this._context;
    const nativeView = new TabHost(context, null);
    const tabHostLayout = new android.widget.LinearLayout(context);
    tabHostLayout.setOrientation(android.widget.LinearLayout.VERTICAL);
    const tabWidget = new android.widget.TabWidget(context);
    tabWidget.setId(R_ID_TABS);
    tabHostLayout.addView(tabWidget);
    const frame = new android.widget.FrameLayout(context);
    frame.setId(R_ID_TABCONTENT);
    frame.setVisibility(android.view.View.GONE);
    tabHostLayout.addView(frame);
    nativeView.addView(tabHostLayout);
    return nativeView;
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    const listener = new TabChangeListener(this);
    nativeView.setOnTabChangedListener(listener);
    nativeView.listener = listener;
    nativeView.setup();
    this._tabContentFactory = this._tabContentFactory || new TabContentFactory(this);
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    if (nativeView?.listener) {
      nativeView.listener.owner = null;
    }
    super.disposeNativeView();
  }
  onLoaded() {
    super.onLoaded();
    const tabWidget = this.nativeViewProtected.getTabWidget();
    if (tabWidget) {
      tabWidget.setEnabled(tabWidget.isEnabled());
    }
  }
  insertTab(tabItem, index) {
    const tabHost = this.nativeViewProtected;
    const tab = tabHost.newTabSpec(index + "");
    tab.setIndicator(tabItem.title + "");
    tab.setContent(this._tabContentFactory);
    this._addingTab = true;
    tabHost.addTab(tab);
    tabItem.setupNativeView(index);
    this._addingTab = false;
  }
  [selectedIndexProperty2.getDefault]() {
    return -1;
  }
  [selectedIndexProperty2.setNative](value) {
    this.nativeViewProtected.setCurrentTab(value);
  }
  [itemsProperty4.getDefault]() {
    return null;
  }
  [itemsProperty4.setNative](value) {
    this.nativeViewProtected.clearAllTabs();
    const newItems = value;
    if (newItems) {
      newItems.forEach((item, i4, arr) => this.insertTab(item, i4));
    }
    selectedIndexProperty2.coerce(this);
  }
  [isEnabledProperty.setNative](value) {
    const tabWidget = this.nativeViewProtected.getTabWidget();
    if (tabWidget) {
      tabWidget.setEnabled(value);
    }
  }
  setTabColor(index) {
    try {
      const tabWidget = this.nativeViewProtected?.getTabWidget();
      if (tabWidget) {
        const unselectedTextColor = this.getColorForAndroid(this.color ?? "#6e6e6e");
        const selectedTextColor = this.getColorForAndroid(this?.selectedTextColor ?? "#000000");
        const unselectedBackgroundColor = this.getColorForAndroid(this?.backgroundColor ?? "#dbdbdb");
        const selectedBackgroundColor = this.getColorForAndroid(this?.selectedBackgroundColor ?? this?.backgroundColor ?? "blue");
        if (tabWidget) {
          for (let i4 = 0;i4 < tabWidget.getTabCount(); i4++) {
            const view = tabWidget.getChildTabViewAt(i4);
            const item = this.items[i4];
            const textView = item?.nativeViewProtected;
            view.setBackgroundColor(unselectedBackgroundColor);
            if (textView) {
              textView.setTextColor(unselectedTextColor);
            }
            if (index == i4) {
              view.setBackgroundColor(selectedBackgroundColor);
              if (textView) {
                textView.setTextColor(selectedTextColor);
              }
              continue;
            }
          }
        }
      }
    } catch (e3) {
      Trace.error(e3);
    }
  }
  getColorForAndroid(color2) {
    if (typeof color2 === "string") {
      return new Color(color2).android;
    } else if (color2 instanceof Color) {
      return color2.android;
    }
  }
}
// node_modules/@nativescript/core/ui/slider/slider-common.js
var SliderBase = class SliderBase2 extends View {
  constructor() {
    super(...arguments);
    this.accessibilityRole = AccessibilityRole.Adjustable;
  }
  get accessibilityStep() {
    return this.style.accessibilityStep;
  }
  set accessibilityStep(value) {
    this.style.accessibilityStep = value;
  }
};
SliderBase.valueChangeEvent = "valueChange";
SliderBase.accessibilityIncrementEvent = "accessibilityIncrement";
SliderBase.accessibilityDecrementEvent = "accessibilityDecrement";
SliderBase = __decorate([
  CSSType("Slider")
], SliderBase);
SliderBase.prototype.recycleNativeView = "auto";
var valueProperty2 = new CoercibleProperty({
  name: "value",
  defaultValue: 0,
  coerceValue: (target, value) => {
    value = Math.max(value, target.minValue);
    value = Math.min(value, target.maxValue);
    return value;
  },
  valueConverter: (v) => __APPLE__ ? parseFloat(v) : parseInt(v)
});
valueProperty2.register(SliderBase);
var minValueProperty = new Property({
  name: "minValue",
  defaultValue: 0,
  valueChanged: (target, oldValue, newValue) => {
    maxValueProperty2.coerce(target);
    valueProperty2.coerce(target);
  },
  valueConverter: (v) => __APPLE__ ? parseFloat(v) : parseInt(v)
});
minValueProperty.register(SliderBase);
var maxValueProperty2 = new CoercibleProperty({
  name: "maxValue",
  defaultValue: 100,
  coerceValue: (target, value) => {
    const minValue = target.minValue;
    if (value < minValue) {
      value = minValue;
    }
    return value;
  },
  valueChanged: (target, oldValue, newValue) => valueProperty2.coerce(target),
  valueConverter: (v) => __APPLE__ ? parseFloat(v) : parseInt(v)
});
maxValueProperty2.register(SliderBase);

// node_modules/@nativescript/core/ui/slider/index.android.js
var SeekBar;
var SeekBarChangeListener;
function initializeListenerClass() {
  if (!SeekBarChangeListener) {
    var SeekBarChangeListenerImpl = function(_super) {
      __extends(SeekBarChangeListenerImpl2, _super);
      function SeekBarChangeListenerImpl2() {
        var _this = _super.call(this) || this;
        return global.__native(_this);
      }
      SeekBarChangeListenerImpl2.prototype.onProgressChanged = function(seekBar, progress, fromUser) {
        var owner = seekBar.owner;
        if (owner && !owner._supressNativeValue) {
          var newValue = progress + owner.minValue;
          valueProperty2.nativeValueChange(owner, newValue);
        }
      };
      SeekBarChangeListenerImpl2.prototype.onStartTrackingTouch = function(seekBar) {};
      SeekBarChangeListenerImpl2.prototype.onStopTrackingTouch = function(seekBar) {};
      SeekBarChangeListenerImpl2 = __decorate([
        Interfaces([android.widget.SeekBar.OnSeekBarChangeListener])
      ], SeekBarChangeListenerImpl2);
      return SeekBarChangeListenerImpl2;
    }(java.lang.Object);
    SeekBarChangeListener = new SeekBarChangeListenerImpl;
  }
}
function getListener() {
  return SeekBarChangeListener;
}

class Slider extends SliderBase {
  createNativeView() {
    if (!SeekBar) {
      SeekBar = android.widget.SeekBar;
    }
    return new SeekBar(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    nativeView.owner = this;
    initializeListenerClass();
    const listener = getListener();
    nativeView.setOnSeekBarChangeListener(listener);
  }
  disposeNativeView() {
    this.nativeViewProtected.owner = null;
    super.disposeNativeView();
  }
  resetNativeView() {
    super.resetNativeView();
    const nativeView = this.nativeViewProtected;
    nativeView.setMax(100);
    nativeView.setProgress(0);
    nativeView.setKeyProgressIncrement(1);
  }
  setNativeValuesSilently() {
    this._supressNativeValue = true;
    const nativeView = this.nativeViewProtected;
    try {
      nativeView.setMax(this.maxValue - this.minValue);
      nativeView.setProgress(this.value - this.minValue);
    } finally {
      this._supressNativeValue = false;
    }
  }
  [valueProperty2.setNative](value) {
    this.setNativeValuesSilently();
  }
  [minValueProperty.setNative](value) {
    this.setNativeValuesSilently();
  }
  [maxValueProperty2.getDefault]() {
    return 100;
  }
  [maxValueProperty2.setNative](value) {
    this.setNativeValuesSilently();
  }
  [colorProperty.getDefault]() {
    return -1;
  }
  [colorProperty.setNative](value) {
    const drawable = this.nativeViewProtected.getThumb();
    if (value instanceof Color) {
      AndroidHelper.setDrawableColor(value.android, drawable);
    } else {
      AndroidHelper.clearDrawableColor(drawable);
    }
  }
  [backgroundColorProperty.getDefault]() {
    return -1;
  }
  [backgroundColorProperty.setNative](value) {
    const drawable = this.nativeViewProtected.getProgressDrawable();
    if (value instanceof Color) {
      AndroidHelper.setDrawableColor(value.android, drawable);
    } else {
      AndroidHelper.clearDrawableColor(drawable);
    }
  }
  [backgroundInternalProperty.getDefault]() {
    return null;
  }
  [backgroundInternalProperty.setNative](value) {}
}
// node_modules/@nativescript/core/ui/split-view/split-view-common.js
var splitRoleConverter = makeParser(makeValidator("primary", "secondary", "supplementary", "inspector"));
var splitDisplayModeConverter = makeParser(makeValidator("automatic", "secondaryOnly", "oneBesideSecondary", "oneOverSecondary", "twoBesideSecondary", "twoOverSecondary", "twoDisplaceSecondary"));
var splitBehaviorConverter = makeParser(makeValidator("automatic", "tile", "overlay", "displace"));
var ROLE_ORDER = ["primary", "secondary", "supplementary", "inspector"];
var SplitViewBase = class SplitViewBase2 extends LayoutBase {
  static getInstance() {
    return null;
  }
  static getRole(element) {
    return element.splitRole;
  }
  static setRole(element, value) {
    element.splitRole = value;
  }
  onRoleChanged(view, oldValue, newValue) {
    this.requestLayout();
  }
  showPrimary() {}
  hidePrimary() {}
  showSecondary() {}
  hideSecondary() {}
  showSupplementary() {}
  hideSupplementary() {}
  showInspector() {}
  hideInspector() {}
  invalidateChildLayouts(delay = 0) {}
  _roleByIndex(index) {
    return ROLE_ORDER[Math.max(0, Math.min(index, ROLE_ORDER.length - 1))];
  }
};
SplitViewBase = __decorate([
  CSSType("SplitView")
], SplitViewBase);
SplitViewBase.prototype.recycleNativeView = "auto";
var splitRoleProperty = new Property({
  name: "splitRole",
  defaultValue: "primary",
  valueChanged: (target, oldValue, newValue) => {
    const parent = target.parent;
    if (parent instanceof SplitViewBase) {
      parent.onRoleChanged(target, oldValue, newValue);
    }
  },
  valueConverter: splitRoleConverter
});
splitRoleProperty.register(View);
var displayModeProperty = new Property({
  name: "displayMode",
  defaultValue: "automatic",
  affectsLayout: __APPLE__,
  valueConverter: splitDisplayModeConverter
});
displayModeProperty.register(SplitViewBase);
var splitBehaviorProperty = new Property({
  name: "splitBehavior",
  defaultValue: "automatic",
  affectsLayout: __APPLE__,
  valueConverter: splitBehaviorConverter
});
splitBehaviorProperty.register(SplitViewBase);
var preferredPrimaryColumnWidthFractionProperty = new Property({
  name: "preferredPrimaryColumnWidthFraction",
  defaultValue: 0,
  affectsLayout: __APPLE__,
  valueConverter: (v) => Math.max(0, Math.min(1, parseFloat(v)))
});
preferredPrimaryColumnWidthFractionProperty.register(SplitViewBase);
var preferredSupplementaryColumnWidthFractionProperty = new Property({
  name: "preferredSupplementaryColumnWidthFraction",
  defaultValue: 0,
  affectsLayout: __APPLE__,
  valueConverter: (v) => Math.max(0, Math.min(1, parseFloat(v)))
});
preferredSupplementaryColumnWidthFractionProperty.register(SplitViewBase);
var preferredInspectorColumnWidthFractionProperty = new Property({
  name: "preferredInspectorColumnWidthFraction",
  defaultValue: 0,
  affectsLayout: __APPLE__,
  valueConverter: (v) => Math.max(0, Math.min(1, parseFloat(v)))
});
preferredInspectorColumnWidthFractionProperty.register(SplitViewBase);
var navigationBarTintColorProperty = new Property({
  name: "navigationBarTintColor",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
navigationBarTintColorProperty.register(SplitViewBase);
// node_modules/@nativescript/core/ui/switch/switch-common.js
var SwitchBase = class SwitchBase2 extends View {
  _onCheckedPropertyChanged(newValue) {
    if (newValue) {
      this._addVisualState("checked");
    } else {
      this._removeVisualState("checked");
    }
  }
};
SwitchBase.checkedChangeEvent = "checkedChange";
SwitchBase = __decorate([
  CSSType("Switch")
], SwitchBase);
SwitchBase.prototype.recycleNativeView = "auto";
function onCheckedPropertyChanged(target, oldValue, newValue) {
  target._onCheckedPropertyChanged(newValue);
}
var checkedProperty = new Property({
  name: "checked",
  defaultValue: false,
  valueConverter: booleanConverter,
  valueChanged: onCheckedPropertyChanged
});
checkedProperty.register(SwitchBase);
var offBackgroundColorProperty = new Property({
  name: "offBackgroundColor",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
offBackgroundColorProperty.register(SwitchBase);

// node_modules/@nativescript/core/ui/switch/index.android.js
var CheckedChangeListener;
function initializeCheckedChangeListener() {
  if (CheckedChangeListener) {
    return;
  }
  var CheckedChangeListenerImpl = function(_super) {
    __extends(CheckedChangeListenerImpl2, _super);
    function CheckedChangeListenerImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    CheckedChangeListenerImpl2.prototype.onCheckedChanged = function(buttonView, isChecked) {
      var owner = this.owner;
      checkedProperty.nativeValueChange(owner, isChecked);
    };
    CheckedChangeListenerImpl2 = __decorate([
      Interfaces([android.widget.CompoundButton.OnCheckedChangeListener])
    ], CheckedChangeListenerImpl2);
    return CheckedChangeListenerImpl2;
  }(java.lang.Object);
  CheckedChangeListener = CheckedChangeListenerImpl;
}

class Switch extends SwitchBase {
  createNativeView() {
    return new android.widget.Switch(this._context);
  }
  initNativeView() {
    super.initNativeView();
    const nativeView = this.nativeViewProtected;
    initializeCheckedChangeListener();
    const listener = new CheckedChangeListener(this);
    nativeView.setOnCheckedChangeListener(listener);
    nativeView.listener = listener;
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    if (nativeView.listener) {
      nativeView.listener.owner = null;
    }
    super.disposeNativeView();
  }
  setNativeBackgroundColor(value) {
    if (this.nativeViewProtected) {
      const drawable = this.nativeViewProtected.getTrackDrawable();
      if (value instanceof Color) {
        AndroidHelper.setDrawableColor(value.android, drawable, androidx.core.graphics.BlendModeCompat.SRC_OVER);
      } else {
        AndroidHelper.clearDrawableColor(drawable);
      }
    }
  }
  _onCheckedPropertyChanged(newValue) {
    super._onCheckedPropertyChanged(newValue);
    if (this.offBackgroundColor) {
      if (!newValue) {
        this.setNativeBackgroundColor(this.offBackgroundColor);
      } else {
        this.setNativeBackgroundColor(this.backgroundColor);
      }
    }
  }
  [checkedProperty.getDefault]() {
    return false;
  }
  [checkedProperty.setNative](value) {
    this.nativeViewProtected.setChecked(value);
  }
  [colorProperty.getDefault]() {
    return -1;
  }
  [colorProperty.setNative](value) {
    const drawable = this.nativeViewProtected.getThumbDrawable();
    if (value instanceof Color) {
      AndroidHelper.setDrawableColor(value.android, drawable, androidx.core.graphics.BlendModeCompat.SRC_ATOP);
    } else {
      AndroidHelper.clearDrawableColor(drawable);
    }
  }
  [backgroundColorProperty.getDefault]() {
    return -1;
  }
  [backgroundColorProperty.setNative](value) {
    if (!this.offBackgroundColor || this.checked) {
      this.setNativeBackgroundColor(value);
    }
  }
  [backgroundInternalProperty.getDefault]() {
    return null;
  }
  [backgroundInternalProperty.setNative](value) {}
  [offBackgroundColorProperty.getDefault]() {
    return -1;
  }
  [offBackgroundColorProperty.setNative](value) {
    if (!this.checked) {
      this.setNativeBackgroundColor(value);
    }
  }
}
// node_modules/@nativescript/core/ui/tab-view/tab-view-common.js
var TabViewBase_1;
var traceCategory = "TabView";
var TabViewItemBase = class TabViewItemBase2 extends ViewBase {
  constructor() {
    super(...arguments);
    this._title = "";
  }
  get textTransform() {
    return this.style.textTransform;
  }
  set textTransform(value) {
    this.style.textTransform = value;
  }
  _addChildFromBuilder(name50, value) {
    if (value instanceof View) {
      this.view = value;
    }
  }
  get title() {
    return this._title;
  }
  set title(value) {
    if (this._title !== value) {
      this._title = value;
      this._update();
    }
  }
  get view() {
    return this._view;
  }
  set view(value) {
    if (this._view !== value) {
      if (this._view) {
        throw new Error("Changing the view of an already loaded TabViewItem is not currently supported.");
      }
      this._view = value;
      this._addView(value);
    }
  }
  get iconSource() {
    return this._iconSource;
  }
  set iconSource(value) {
    if (this._iconSource !== value) {
      this._iconSource = value;
      this._update();
    }
  }
  eachChild(callback) {
    const view = this._view;
    if (view) {
      callback(view);
    }
  }
  loadView(view) {
    const tabView = this.parent;
    if (tabView && tabView.items) {
      if (this.canBeLoaded) {
        super.loadView(view);
      }
    }
  }
};
TabViewItemBase = __decorate([
  CSSType("TabViewItem")
], TabViewItemBase);
var TabViewBase = TabViewBase_1 = class TabViewBase2 extends View {
  get androidSelectedTabHighlightColor() {
    return this.style.androidSelectedTabHighlightColor;
  }
  set androidSelectedTabHighlightColor(value) {
    this.style.androidSelectedTabHighlightColor = value;
  }
  get tabTextFontSize() {
    return this.style.tabTextFontSize;
  }
  set tabTextFontSize(value) {
    this.style.tabTextFontSize = value;
  }
  get tabTextColor() {
    return this.style.tabTextColor;
  }
  set tabTextColor(value) {
    this.style.tabTextColor = value;
  }
  get tabBackgroundColor() {
    return this.style.tabBackgroundColor;
  }
  set tabBackgroundColor(value) {
    this.style.tabBackgroundColor = value;
  }
  get selectedTabTextColor() {
    return this.style.selectedTabTextColor;
  }
  set selectedTabTextColor(value) {
    this.style.selectedTabTextColor = value;
  }
  _addArrayFromBuilder(name50, value) {
    if (name50 === "items") {
      this.items = value;
    }
  }
  _addChildFromBuilder(name50, value) {
    if (value instanceof TabViewItemBase) {
      if (!this.items) {
        this.items = new Array;
      }
      this.items.push(value);
      this._addView(value);
      selectedIndexProperty3.coerce(this);
    }
  }
  get _selectedView() {
    const selectedIndex = this.selectedIndex;
    return selectedIndex > -1 ? this.items[selectedIndex].view : null;
  }
  get _childrenCount() {
    const items = this.items;
    return items ? items.length : 0;
  }
  eachChild(callback) {
    const items = this.items;
    if (items) {
      items.forEach((item, i4) => {
        callback(item);
      });
    }
  }
  eachChildView(callback) {
    const items = this.items;
    if (items) {
      items.forEach((item, i4) => {
        callback(item.view);
      });
    }
  }
  onItemsChanged(oldItems, newItems) {
    if (oldItems) {
      oldItems.forEach((item) => this._removeView(item));
    }
    if (newItems) {
      newItems.forEach((item) => {
        if (!item.view) {
          throw new Error(`TabViewItem must have a view.`);
        }
        this._addView(item);
      });
    }
  }
  onSelectedIndexChanged(oldIndex, newIndex) {
    this.notify({
      eventName: TabViewBase_1.selectedIndexChangedEvent,
      object: this,
      oldIndex,
      newIndex
    });
  }
};
TabViewBase.selectedIndexChangedEvent = "selectedIndexChanged";
TabViewBase = TabViewBase_1 = __decorate([
  CSSType("TabView")
], TabViewBase);
function traceMissingIcon2(icon) {
  Trace.write("Could not load tab bar icon: " + icon, Trace.categories.Error, Trace.messageType.error);
}
var selectedIndexProperty3 = new CoercibleProperty({
  name: "selectedIndex",
  defaultValue: -1,
  affectsLayout: __APPLE__,
  valueChanged: (target, oldValue, newValue) => {
    target.onSelectedIndexChanged(oldValue, newValue);
  },
  coerceValue: (target, value) => {
    const items = target.items;
    if (items) {
      const max2 = items.length - 1;
      if (value < 0) {
        value = 0;
      }
      if (value > max2) {
        value = max2;
      }
    } else {
      value = -1;
    }
    return value;
  },
  valueConverter: (v) => parseInt(v)
});
selectedIndexProperty3.register(TabViewBase);
var itemsProperty5 = new Property({
  name: "items",
  valueChanged: (target, oldValue, newValue) => {
    target.onItemsChanged(oldValue, newValue);
  }
});
itemsProperty5.register(TabViewBase);
var iosIconRenderingModeProperty2 = new Property({ name: "iosIconRenderingMode", defaultValue: "automatic" });
iosIconRenderingModeProperty2.register(TabViewBase);
var androidIconRenderingModeProperty = new Property({ name: "androidIconRenderingMode", defaultValue: "alwaysOriginal" });
androidIconRenderingModeProperty.register(TabViewBase);
var androidOffscreenTabLimitProperty = new Property({
  name: "androidOffscreenTabLimit",
  defaultValue: 1,
  affectsLayout: __APPLE__,
  valueConverter: (v) => parseInt(v)
});
androidOffscreenTabLimitProperty.register(TabViewBase);
var androidTabsPositionProperty = new Property({ name: "androidTabsPosition", defaultValue: "top" });
androidTabsPositionProperty.register(TabViewBase);
var androidSwipeEnabledProperty = new Property({
  name: "androidSwipeEnabled",
  defaultValue: true,
  valueConverter: booleanConverter
});
androidSwipeEnabledProperty.register(TabViewBase);
var iosBottomAccessoryProperty = new Property({
  name: "iosBottomAccessory"
});
iosBottomAccessoryProperty.register(TabViewBase);
var iosTabBarMinimizeBehaviorProperty = new Property({
  name: "iosTabBarMinimizeBehavior",
  defaultValue: "automatic"
});
iosTabBarMinimizeBehaviorProperty.register(TabViewBase);
var tabTextFontSizeProperty = new CssProperty({
  name: "tabTextFontSize",
  cssName: "tab-text-font-size",
  valueConverter: (v) => parseFloat(v)
});
tabTextFontSizeProperty.register(Style);
var tabTextColorProperty = new CssProperty({
  name: "tabTextColor",
  cssName: "tab-text-color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
tabTextColorProperty.register(Style);
var iconFontFamilyProperty = new CssProperty({
  name: "iconFontFamily",
  cssName: "icon-font-family"
});
iconFontFamilyProperty.register(Style);
var tabBackgroundColorProperty = new CssProperty({
  name: "tabBackgroundColor",
  cssName: "tab-background-color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
tabBackgroundColorProperty.register(Style);
var selectedTabTextColorProperty = new CssProperty({
  name: "selectedTabTextColor",
  cssName: "selected-tab-text-color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
selectedTabTextColorProperty.register(Style);
var androidSelectedTabHighlightColorProperty = new CssProperty({
  name: "androidSelectedTabHighlightColor",
  cssName: "android-selected-tab-highlight-color",
  equalityComparer: Color.equals,
  valueConverter: (v) => new Color(v)
});
androidSelectedTabHighlightColorProperty.register(Style);

// node_modules/@nativescript/core/ui/tab-view/index.android.js
var ACCENT_COLOR = "colorAccent";
var PRIMARY_COLOR = "colorPrimary";
var DEFAULT_ELEVATION2 = 4;
var TABID = "_tabId";
var INDEX = "_index";
var PagerAdapter;
var appResources2;
function makeFragmentName(viewId, id) {
  return "android:viewpager:" + viewId + ":" + id;
}
function getTabById(id) {
  const ref2 = tabs.find((ref3) => {
    const tab = ref3.get();
    return tab && tab._domId === id;
  });
  return ref2 && ref2.get();
}
function initializeNativeClasses4() {
  if (PagerAdapter) {
    return;
  }
  var TabFragmentImplementation = function(_super) {
    __extends(TabFragmentImplementation2, _super);
    function TabFragmentImplementation2() {
      var _this = _super.call(this) || this;
      _this.backgroundBitmap = null;
      return global.__native(_this);
    }
    TabFragmentImplementation2.newInstance = function(tabId, index) {
      var args = new android.os.Bundle;
      args.putInt(TABID, tabId);
      args.putInt(INDEX, index);
      var fragment = new TabFragmentImplementation2;
      fragment.setArguments(args);
      return fragment;
    };
    TabFragmentImplementation2.prototype.onCreate = function(savedInstanceState) {
      _super.prototype.onCreate.call(this, savedInstanceState);
      var args = this.getArguments();
      this.owner = getTabById(args.getInt(TABID));
      this.index = args.getInt(INDEX);
      if (!this.owner) {
        throw new Error("Cannot find TabView");
      }
    };
    TabFragmentImplementation2.prototype.onCreateView = function(inflater, container, savedInstanceState) {
      var tabItem = this.owner.items[this.index];
      return tabItem.view.nativeViewProtected;
    };
    TabFragmentImplementation2.prototype.onDestroyView = function() {
      var hasRemovingParent = this.getRemovingParentFragment();
      if (hasRemovingParent && this.owner.selectedIndex === this.index) {
        var bitmapDrawable = new android.graphics.drawable.BitmapDrawable(appResources2, this.backgroundBitmap);
        this.owner._originalBackground = this.owner.backgroundColor || new Color("White");
        this.owner.nativeViewProtected.setBackground(bitmapDrawable);
        this.backgroundBitmap = null;
      }
      _super.prototype.onDestroyView.call(this);
    };
    TabFragmentImplementation2.prototype.onPause = function() {
      var hasRemovingParent = this.getRemovingParentFragment();
      if (hasRemovingParent && this.owner.selectedIndex === this.index) {
        this.backgroundBitmap = this.loadBitmapFromView(this.owner.nativeViewProtected);
      }
      _super.prototype.onPause.call(this);
    };
    TabFragmentImplementation2.prototype.loadBitmapFromView = function(view) {
      view.setDrawingCacheEnabled(true);
      var bitmap = android.graphics.Bitmap.createBitmap(view.getDrawingCache());
      view.setDrawingCacheEnabled(false);
      return bitmap;
    };
    return TabFragmentImplementation2;
  }(org.nativescript.widgets.FragmentBase);
  const POSITION_UNCHANGED = -1;
  const POSITION_NONE = -2;
  var FragmentPagerAdapter = function(_super) {
    __extends(FragmentPagerAdapter2, _super);
    function FragmentPagerAdapter2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      _this.transactionRunning = false;
      return global.__native(_this);
    }
    FragmentPagerAdapter2.prototype.getCount = function() {
      var items = this.items;
      return items ? items.length : 0;
    };
    FragmentPagerAdapter2.prototype.getPageTitle = function(index) {
      var items = this.items;
      if (index < 0 || index >= items.length) {
        return "";
      }
      return items[index].title;
    };
    FragmentPagerAdapter2.prototype.startUpdate = function(container) {
      if (container.getId() === android.view.View.NO_ID) {
        throw new Error("ViewPager with adapter ".concat(this, " requires a view containerId"));
      }
    };
    FragmentPagerAdapter2.prototype.instantiateItem = function(container, position) {
      var fragmentManager = this.owner._getFragmentManager();
      if (!this.mCurTransaction) {
        this.mCurTransaction = fragmentManager.beginTransaction();
      }
      var itemId = this.getItemId(position);
      var name50 = makeFragmentName(container.getId(), itemId);
      var fragment = fragmentManager.findFragmentByTag(name50);
      if (fragment != null) {
        this.mCurTransaction.attach(fragment);
      } else {
        fragment = TabFragmentImplementation.newInstance(this.owner._domId, position);
        this.mCurTransaction.add(container.getId(), fragment, name50);
      }
      if (fragment !== this.mCurrentPrimaryItem) {
        fragment.setMenuVisibility(false);
        fragment.setUserVisibleHint(false);
      }
      var tabItems = this.owner.items;
      var tabItem = tabItems ? tabItems[position] : null;
      if (tabItem) {
        tabItem.canBeLoaded = true;
      }
      return fragment;
    };
    FragmentPagerAdapter2.prototype.getItemPosition = function(object) {
      return this.items ? POSITION_UNCHANGED : POSITION_NONE;
    };
    FragmentPagerAdapter2.prototype.destroyItem = function(container, position, object) {
      if (!this.mCurTransaction) {
        var fragmentManager = this.owner._getFragmentManager();
        this.mCurTransaction = fragmentManager.beginTransaction();
      }
      var fragment = object;
      this.mCurTransaction.detach(fragment);
      if (this.mCurrentPrimaryItem === fragment) {
        this.mCurrentPrimaryItem = null;
      }
      var tabItems = this.owner.items;
      var tabItem = tabItems ? tabItems[position] : null;
      if (tabItem) {
        tabItem.canBeLoaded = false;
      }
    };
    FragmentPagerAdapter2.prototype.setPrimaryItem = function(container, position, object) {
      var fragment = object;
      if (fragment !== this.mCurrentPrimaryItem) {
        if (this.mCurrentPrimaryItem != null) {
          this.mCurrentPrimaryItem.setMenuVisibility(false);
          this.mCurrentPrimaryItem.setUserVisibleHint(false);
        }
        if (fragment != null) {
          fragment.setMenuVisibility(true);
          fragment.setUserVisibleHint(true);
        }
        this.mCurrentPrimaryItem = fragment;
        this.owner.selectedIndex = position;
        var tab = this.owner;
        var tabItems = tab.items;
        var newTabItem = tabItems ? tabItems[position] : null;
        if (newTabItem) {
          tab._loadUnloadTabItems(tab.selectedIndex);
        }
      }
    };
    FragmentPagerAdapter2.prototype.finishUpdate = function(container) {
      this._commitCurrentTransaction();
    };
    FragmentPagerAdapter2.prototype.isViewFromObject = function(view, object) {
      return object.getView() === view;
    };
    FragmentPagerAdapter2.prototype.saveState = function() {
      this._commitCurrentTransaction();
      return null;
    };
    FragmentPagerAdapter2.prototype.restoreState = function(state, loader) {};
    FragmentPagerAdapter2.prototype.getItemId = function(position) {
      return position;
    };
    FragmentPagerAdapter2.prototype._commitCurrentTransaction = function() {
      if (this.mCurTransaction != null && !this.transactionRunning) {
        this.transactionRunning = true;
        this.mCurTransaction.commitNowAllowingStateLoss();
        this.transactionRunning = false;
        this.mCurTransaction = null;
      }
    };
    return FragmentPagerAdapter2;
  }(androidx.viewpager.widget.PagerAdapter);
  PagerAdapter = FragmentPagerAdapter;
  appResources2 = getNativeApp().getApplicationContext().getResources();
}
function createTabItemSpec(item) {
  const result = new org.nativescript.widgets.TabItemSpec;
  result.title = item.title;
  if (item.iconSource) {
    const addDrawable = (is) => {
      if (is) {
        result.iconDrawable = new android.graphics.drawable.BitmapDrawable(appResources2, is.android);
      } else {
        traceMissingIcon2(item.iconSource);
      }
    };
    if (item.iconSource.indexOf(RESOURCE_PREFIX) === 0) {
      result.iconId = android2.resources.getDrawableId(item.iconSource.slice(RESOURCE_PREFIX.length));
      if (result.iconId === 0) {
        traceMissingIcon2(item.iconSource);
      }
    } else if (isFontIconURI(item.iconSource)) {
      let iconFont = item.style.fontInternal;
      const iconFontFamily = item.iconFontFamily || item.style.iconFontFamily;
      if (iconFontFamily) {
        const baseFont = item.style.fontInternal || Font2.default;
        iconFont = baseFont.withFontFamily(iconFontFamily);
      }
      const is = ImageSource.fromFontIconCodeSync(item.iconSource.slice(FONT_PREFIX.length), iconFont, item.style.color);
      addDrawable(is);
    } else {
      addDrawable(ImageSource.fromFileOrResourceSync(item.iconSource));
    }
  }
  return result;
}
var defaultAccentColor = undefined;
function getDefaultAccentColor(context) {
  if (defaultAccentColor === undefined) {
    defaultAccentColor = android2.resources.getPaletteColor(ACCENT_COLOR, context) || 4281578981;
  }
  return defaultAccentColor;
}

class TabViewItem extends TabViewItemBase {
  get _hasFragments() {
    return true;
  }
  initNativeView() {
    super.initNativeView();
    if (this.nativeViewProtected) {
      this._defaultTransformationMethod = this.nativeViewProtected.getTransformationMethod();
    }
  }
  onLoaded() {
    super.onLoaded();
  }
  resetNativeView() {
    super.resetNativeView();
    if (this.nativeViewProtected) {
      this.nativeViewProtected.setTransformationMethod(this._defaultTransformationMethod);
    }
  }
  disposeNativeView() {
    this.canBeLoaded = false;
    super.disposeNativeView();
  }
  createNativeView() {
    return this.nativeViewProtected;
  }
  _update() {
    const tv = this.nativeViewProtected;
    const tabView = this.parent;
    if (tv && tabView) {
      this.tabItemSpec = createTabItemSpec(this);
      tabView.updateAndroidItemAt(this.index, this.tabItemSpec);
    }
  }
  _getChildFragmentManager() {
    const tabView = this.parent;
    let tabFragment = null;
    const fragmentManager = tabView._getFragmentManager();
    const fragments = fragmentManager.getFragments().toArray();
    for (let i4 = 0;i4 < fragments.length; i4++) {
      if (fragments[i4].index === this.index) {
        tabFragment = fragments[i4];
        break;
      }
    }
    if (!tabFragment) {
      if (Trace.isEnabled()) {
        Trace.write(`Could not get child fragment manager for tab item with index ${this.index}`, traceCategory);
      }
      return tabView._getRootFragmentManager();
    }
    return tabFragment.getChildFragmentManager();
  }
  [fontSizeProperty.getDefault]() {
    return { nativeSize: this.nativeViewProtected.getTextSize() };
  }
  [fontSizeProperty.setNative](value) {
    if (typeof value === "number") {
      this.nativeViewProtected.setTextSize(value);
    } else {
      this.nativeViewProtected.setTextSize(android.util.TypedValue.COMPLEX_UNIT_PX, value.nativeSize);
    }
  }
  [fontInternalProperty.getDefault]() {
    return this.nativeViewProtected.getTypeface();
  }
  [fontInternalProperty.setNative](value) {
    this.nativeViewProtected.setTypeface(value instanceof Font2 ? value.getAndroidTypeface() : value);
  }
  [textTransformProperty.getDefault]() {
    return "default";
  }
  [textTransformProperty.setNative](value) {
    const tv = this.nativeViewProtected;
    if (value === "default") {
      tv.setTransformationMethod(this._defaultTransformationMethod);
      tv.setText(this.title);
    } else {
      const result = getTransformedText(this.title, value);
      tv.setText(result);
      tv.setTransformationMethod(null);
    }
  }
}
function setElevation(grid, tabLayout) {
  const compat = androidx.core.view.ViewCompat;
  if (compat.setElevation) {
    const val = DEFAULT_ELEVATION2 * layout.getDisplayDensity();
    compat.setElevation(grid, val);
    compat.setElevation(tabLayout, val);
  }
}
var tabs = new Array;
function iterateIndexRange(index, eps, lastIndex, callback) {
  const rangeStart = Math.max(0, index - eps);
  const rangeEnd = Math.min(index + eps, lastIndex);
  for (let i4 = rangeStart;i4 <= rangeEnd; i4++) {
    callback(i4);
  }
}

class TabView extends TabViewBase {
  constructor() {
    super();
    this._androidViewId = -1;
    tabs.push(new WeakRef(this));
  }
  get _hasFragments() {
    return true;
  }
  onItemsChanged(oldItems, newItems) {
    super.onItemsChanged(oldItems, newItems);
    if (oldItems) {
      oldItems.forEach((item, i4, arr) => {
        item.index = 0;
        item.tabItemSpec = null;
        item.setNativeView(null);
      });
    }
  }
  createNativeView() {
    initializeNativeClasses4();
    if (Trace.isEnabled()) {
      Trace.write("TabView._createUI(" + this + ");", traceCategory);
    }
    const context = this._context;
    const nativeView = new org.nativescript.widgets.GridLayout(context);
    const viewPager = new org.nativescript.widgets.TabViewPager(context);
    const tabLayout = new org.nativescript.widgets.TabLayout(context);
    const lp = new org.nativescript.widgets.CommonLayoutParams;
    const primaryColor = android2.resources.getPaletteColor(PRIMARY_COLOR, context);
    let accentColor = getDefaultAccentColor(context);
    lp.row = 1;
    if (this.androidTabsPosition === "top") {
      nativeView.addRowsFromJSON(JSON.stringify([
        { value: 1, type: 0 },
        { value: 1, type: 2 }
      ]));
      viewPager.setLayoutParams(lp);
      if (!this.androidSwipeEnabled) {
        viewPager.setSwipePageEnabled(false);
      }
    } else {
      nativeView.addRowsFromJSON(JSON.stringify([
        { value: 1, type: 2 },
        { value: 1, type: 0 }
      ]));
      tabLayout.setLayoutParams(lp);
      viewPager.setSwipePageEnabled(false);
      accentColor = 16777215;
    }
    nativeView.addView(viewPager);
    nativeView.viewPager = viewPager;
    const adapter = new PagerAdapter(this);
    viewPager.setAdapter(adapter);
    viewPager.adapter = adapter;
    nativeView.addView(tabLayout);
    nativeView.tabLayout = tabLayout;
    setElevation(nativeView, tabLayout);
    if (accentColor) {
      tabLayout.setSelectedIndicatorColors([accentColor]);
    }
    if (primaryColor) {
      tabLayout.setBackgroundColor(primaryColor);
    }
    return nativeView;
  }
  initNativeView() {
    super.initNativeView();
    if (this._androidViewId < 0) {
      this._androidViewId = android.view.View.generateViewId();
    }
    const nativeView = this.nativeViewProtected;
    this._tabLayout = nativeView.tabLayout;
    const viewPager = nativeView.viewPager;
    viewPager.setId(this._androidViewId);
    this._viewPager = viewPager;
    this._pagerAdapter = viewPager.adapter;
    this._pagerAdapter.owner = this;
  }
  _loadUnloadTabItems(newIndex) {
    const items = this.items;
    if (!items) {
      return;
    }
    const lastIndex = items.length - 1;
    const offsideItems = this.androidTabsPosition === "top" ? this.androidOffscreenTabLimit : 1;
    const toUnload = [];
    const toLoad = [];
    iterateIndexRange(newIndex, offsideItems, lastIndex, (i4) => toLoad.push(i4));
    items.forEach((item, i4) => {
      const indexOfI = toLoad.indexOf(i4);
      if (indexOfI < 0) {
        toUnload.push(i4);
      }
    });
    toUnload.forEach((index) => {
      const item = items[index];
      if (items[index]) {
        item.unloadView(item.view);
      }
    });
    const newItem = items[newIndex];
    const selectedView = newItem && newItem.view;
    if (selectedView instanceof Frame) {
      selectedView._pushInFrameStackRecursive();
    }
    toLoad.forEach((index) => {
      const item = items[index];
      if (this.isLoaded && items[index]) {
        item.loadView(item.view);
      }
    });
  }
  onLoaded() {
    super.onLoaded();
    if (this._originalBackground) {
      this.backgroundColor = null;
      this.backgroundColor = this._originalBackground;
      this._originalBackground = null;
    }
    this.setAdapterItems(this.items);
  }
  onUnloaded() {
    super.onUnloaded();
    this.setAdapterItems(null);
  }
  disposeNativeView() {
    this._tabLayout.setItems(null, null);
    this._pagerAdapter.owner = null;
    this._pagerAdapter = null;
    this._tabLayout = null;
    this._viewPager = null;
    super.disposeNativeView();
  }
  _onRootViewReset() {
    super._onRootViewReset();
    this.disposeCurrentFragments();
  }
  disposeCurrentFragments() {
    const fragmentManager = this._getFragmentManager();
    const transaction = fragmentManager.beginTransaction();
    const fragments = fragmentManager.getFragments().toArray();
    for (let i4 = 0;i4 < fragments.length; i4++) {
      transaction.remove(fragments[i4]);
    }
    transaction.commitNowAllowingStateLoss();
  }
  shouldUpdateAdapter(items) {
    if (!this._pagerAdapter) {
      return false;
    }
    const currentPagerAdapterItems = this._pagerAdapter.items;
    if (!items && !currentPagerAdapterItems) {
      return false;
    }
    if (!items || !currentPagerAdapterItems) {
      return true;
    }
    if (items.length !== currentPagerAdapterItems.length) {
      return true;
    }
    const matchingItems = currentPagerAdapterItems.filter((currentItem) => {
      return !!items.filter((item) => {
        return item._domId === currentItem._domId;
      })[0];
    });
    if (matchingItems.length !== items.length) {
      return true;
    }
    return false;
  }
  setAdapterItems(items) {
    if (this.shouldUpdateAdapter(items)) {
      this._pagerAdapter.items = items;
      const length2 = items ? items.length : 0;
      if (length2 === 0) {
        this._tabLayout.setItems(null, null);
        this._pagerAdapter.notifyDataSetChanged();
        return;
      }
      const tabItems = new Array;
      items.forEach((item, i4, arr) => {
        const tabItemSpec = createTabItemSpec(item);
        item.index = i4;
        item.tabItemSpec = tabItemSpec;
        tabItems.push(tabItemSpec);
      });
      const tabLayout = this._tabLayout;
      tabLayout.setItems(tabItems, this._viewPager);
      items.forEach((item, i4, arr) => {
        const tv = tabLayout.getTextViewForItemAt(i4);
        item.setNativeView(tv);
      });
      this._pagerAdapter.notifyDataSetChanged();
    }
  }
  getNativeRenderingMode(mode) {
    switch (mode) {
      case "alwaysTemplate":
        return org.nativescript.widgets.TabIconRenderingMode.template;
      default:
      case "alwaysOriginal":
        return org.nativescript.widgets.TabIconRenderingMode.original;
    }
  }
  updateAndroidItemAt(index, spec2) {
    this._tabLayout.updateItemAt(index, spec2);
  }
  [androidOffscreenTabLimitProperty.getDefault]() {
    return this._viewPager.getOffscreenPageLimit();
  }
  [androidOffscreenTabLimitProperty.setNative](value) {
    this._viewPager.setOffscreenPageLimit(value);
  }
  [androidIconRenderingModeProperty.getDefault]() {
    return "alwaysOriginal";
  }
  [androidIconRenderingModeProperty.setNative](value) {
    this._tabLayout.setIconRenderingMode(this.getNativeRenderingMode(value));
  }
  [selectedIndexProperty3.setNative](value) {
    const smoothScroll = this.androidTabsPosition === "top";
    if (Trace.isEnabled()) {
      Trace.write("TabView this._viewPager.setCurrentItem(" + value + ", " + smoothScroll + ");", traceCategory);
    }
    this._viewPager.setCurrentItem(value, smoothScroll);
  }
  [itemsProperty5.getDefault]() {
    return null;
  }
  [itemsProperty5.setNative](value) {
    this.setAdapterItems(value);
    selectedIndexProperty3.coerce(this);
  }
  [tabBackgroundColorProperty.getDefault]() {
    return this._tabLayout.getBackground();
  }
  [tabBackgroundColorProperty.setNative](value) {
    if (value instanceof Color) {
      this._tabLayout.setBackgroundColor(value.android);
    } else {
      this._tabLayout.setBackground(AndroidHelper.getCopyOrDrawable(value, this.nativeViewProtected.getResources()));
    }
  }
  [tabTextFontSizeProperty.getDefault]() {
    return this._tabLayout.getTabTextFontSize();
  }
  [tabTextFontSizeProperty.setNative](value) {
    if (typeof value === "number") {
      this._tabLayout.setTabTextFontSize(value);
    } else {
      this._tabLayout.setTabTextFontSize(value.nativeSize);
    }
  }
  [tabTextColorProperty.getDefault]() {
    return this._tabLayout.getTabTextColor();
  }
  [tabTextColorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    this._tabLayout.setTabTextColor(color2);
  }
  [selectedTabTextColorProperty.getDefault]() {
    return this._tabLayout.getSelectedTabTextColor();
  }
  [selectedTabTextColorProperty.setNative](value) {
    const color2 = value instanceof Color ? value.android : value;
    this._tabLayout.setSelectedTabTextColor(color2);
  }
  [androidSelectedTabHighlightColorProperty.getDefault]() {
    return getDefaultAccentColor(this._context);
  }
  [androidSelectedTabHighlightColorProperty.setNative](value) {
    const tabLayout = this._tabLayout;
    const color2 = value instanceof Color ? value.android : value;
    tabLayout.setSelectedIndicatorColors([color2]);
  }
}
// node_modules/@nativescript/core/ui/text-view/text-view-common.js
class TextViewBase extends EditableTextBase2 {
}
TextViewBase.returnPressEvent = "returnPress";
var WritingToolsBehavior;
(function(WritingToolsBehavior2) {
  WritingToolsBehavior2[WritingToolsBehavior2["Complete"] = 0] = "Complete";
  WritingToolsBehavior2[WritingToolsBehavior2["Default"] = 1] = "Default";
  WritingToolsBehavior2[WritingToolsBehavior2["Limited"] = 2] = "Limited";
  WritingToolsBehavior2[WritingToolsBehavior2["None"] = 3] = "None";
})(WritingToolsBehavior || (WritingToolsBehavior = {}));
var iosWritingToolsBehaviorProperty = new Property({
  name: "iosWritingToolsBehavior",
  defaultValue: WritingToolsBehavior.Default
});
iosWritingToolsBehaviorProperty.register(TextViewBase);
var WritingToolsAllowedInput;
(function(WritingToolsAllowedInput2) {
  WritingToolsAllowedInput2[WritingToolsAllowedInput2["Default"] = 0] = "Default";
  WritingToolsAllowedInput2[WritingToolsAllowedInput2["List"] = 1] = "List";
  WritingToolsAllowedInput2[WritingToolsAllowedInput2["PlainText"] = 2] = "PlainText";
  WritingToolsAllowedInput2[WritingToolsAllowedInput2["RichText"] = 3] = "RichText";
  WritingToolsAllowedInput2[WritingToolsAllowedInput2["Table"] = 4] = "Table";
})(WritingToolsAllowedInput || (WritingToolsAllowedInput = {}));
var iosWritingToolsAllowedInputProperty = new Property({
  name: "iosWritingToolsAllowedInput",
  defaultValue: [WritingToolsAllowedInput.Default]
});
iosWritingToolsAllowedInputProperty.register(TextViewBase);

// node_modules/@nativescript/core/ui/text-view/index.android.js
var TextView_1;
var TextView = TextView_1 = class TextView2 extends TextViewBase {
  _configureEditText(editText) {
    editText.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_NORMAL | android.text.InputType.TYPE_TEXT_FLAG_CAP_SENTENCES | android.text.InputType.TYPE_TEXT_FLAG_MULTI_LINE | android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    editText.setGravity(android.view.Gravity.TOP | android.view.Gravity.START);
  }
  resetNativeView() {
    super.resetNativeView();
    this.nativeTextViewProtected.setGravity(android.view.Gravity.TOP | android.view.Gravity.START);
  }
  _onReturnPress() {
    this.notify({ eventName: TextView_1.returnPressEvent, object: this });
  }
};
TextView = TextView_1 = __decorate([
  CSSType("TextView")
], TextView);
TextView.prototype.recycleNativeView = "auto";
// node_modules/@nativescript/core/ui/transition/page-transition.android.js
var SnapshotViewGroup = function(_super) {
  __extends(SnapshotViewGroup2, _super);
  function SnapshotViewGroup2(context) {
    var _this = _super.call(this, context) || this;
    return global.__native(_this);
  }
  SnapshotViewGroup2.prototype.onMeasure = function() {
    this.setMeasuredDimension(0, 0);
  };
  SnapshotViewGroup2.prototype.onLayout = function() {};
  return SnapshotViewGroup2;
}(android.view.ViewGroup);
var CustomSpringInterpolator = function(_super) {
  __extends(CustomSpringInterpolator2, _super);
  function CustomSpringInterpolator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomSpringInterpolator2.prototype.getInterpolation = function(input) {
    var res = _super.prototype.getInterpolation.call(this, input) * 1.1;
    if (res > 1) {
      return float(1);
    }
    return float(res);
  };
  return CustomSpringInterpolator2;
}(android.view.animation.AnticipateOvershootInterpolator);
var CustomLinearInterpolator = function(_super) {
  __extends(CustomLinearInterpolator2, _super);
  function CustomLinearInterpolator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomLinearInterpolator2.prototype.getInterpolation = function(input) {
    var res = _super.prototype.getInterpolation.call(this, input) * 1.1;
    if (res > 1) {
      return float(1);
    }
    return float(res);
  };
  return CustomLinearInterpolator2;
}(android.view.animation.LinearInterpolator);
// node_modules/@nativescript/core/ui/transition/slide-transition.android.js
var screenWidth = lazy(() => Screen.mainScreen.widthPixels);
var screenHeight = lazy(() => Screen.mainScreen.heightPixels);
// node_modules/@nativescript/core/ui/web-view/web-view-common.js
var WebViewBase_1;
var srcProperty2 = new Property({ name: "src" });
var disableZoomProperty = new Property({ name: "disableZoom", defaultValue: false, valueConverter: booleanConverter });
var WebViewBase = WebViewBase_1 = class WebViewBase2 extends ContainerView {
  _onLoadFinished(url, error) {
    const args = {
      eventName: WebViewBase_1.loadFinishedEvent,
      object: this,
      url,
      navigationType: undefined,
      error
    };
    this.notify(args);
  }
  _onLoadStarted(url, navigationType) {
    const args = {
      eventName: WebViewBase_1.loadStartedEvent,
      object: this,
      url,
      navigationType,
      error: undefined
    };
    this.notify(args);
  }
  get canGoBack() {
    throw new Error("This member is abstract.");
  }
  get canGoForward() {
    throw new Error("This member is abstract.");
  }
  [srcProperty2.getDefault]() {
    return "";
  }
  [srcProperty2.setNative](src) {
    this.stopLoading();
    if (src.indexOf("~/") === 0) {
      let appPath = knownFolders.currentApp().path;
      if (appPath && appPath.indexOf("/") !== 0) {
        appPath = `/${appPath}`;
      }
      src = `file://${appPath}/` + src.substr(2);
    } else if (src.indexOf("/") === 0) {
      src = "file://" + src;
    }
    if (src.toLowerCase().indexOf("file:///") === 0) {
      src = encodeURI(src);
    }
    if (src.toLowerCase().indexOf("http://") === 0 || src.toLowerCase().indexOf("https://") === 0 || src.toLowerCase().indexOf("file:///") === 0) {
      this._loadUrl(src);
    } else {
      this._loadData(src);
    }
  }
};
WebViewBase.loadStartedEvent = "loadStarted";
WebViewBase.loadFinishedEvent = "loadFinished";
WebViewBase = WebViewBase_1 = __decorate([
  CSSType("WebView")
], WebViewBase);
srcProperty2.register(WebViewBase);
disableZoomProperty.register(WebViewBase);

// node_modules/@nativescript/core/ui/web-view/index.android.js
var WebViewClient;
function initializeWebViewClient() {
  if (WebViewClient) {
    return;
  }
  var WebViewClientImpl = function(_super) {
    __extends(WebViewClientImpl2, _super);
    function WebViewClientImpl2(owner) {
      var _this = _super.call(this) || this;
      _this.owner = owner;
      return global.__native(_this);
    }
    WebViewClientImpl2.prototype.shouldOverrideUrlLoading = function(view, target) {
      var url = target instanceof android.webkit.WebResourceRequest ? target.getUrl().toString() : target;
      if (Trace.isEnabled()) {
        Trace.write("WebViewClientClass.shouldOverrideUrlLoading(" + url + ")", Trace.categories.Debug);
      }
      if (!android.webkit.URLUtil.isNetworkUrl(url)) {
        return openUrl(url);
      }
      return false;
    };
    WebViewClientImpl2.prototype.onPageStarted = function(view, url, favicon) {
      _super.prototype.onPageStarted.call(this, view, url, favicon);
      var owner = this.owner;
      if (owner) {
        if (Trace.isEnabled()) {
          Trace.write("WebViewClientClass.onPageStarted(" + url + ", " + favicon + ")", Trace.categories.Debug);
        }
        owner._onLoadStarted(url, undefined);
      }
    };
    WebViewClientImpl2.prototype.onPageFinished = function(view, url) {
      _super.prototype.onPageFinished.call(this, view, url);
      var owner = this.owner;
      if (owner) {
        if (Trace.isEnabled()) {
          Trace.write("WebViewClientClass.onPageFinished(" + url + ")", Trace.categories.Debug);
        }
        owner._onLoadFinished(url, undefined);
      }
    };
    WebViewClientImpl2.prototype.onReceivedError = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var view = args[0];
      if (arguments.length === 4) {
        var errorCode = args[1];
        var description = args[2];
        var failingUrl = args[3];
        _super.prototype.onReceivedError.call(this, view, errorCode, description, failingUrl);
        var owner = this.owner;
        if (owner) {
          if (Trace.isEnabled()) {
            Trace.write("WebViewClientClass.onReceivedError(" + errorCode + ", " + description + ", " + failingUrl + ")", Trace.categories.Debug);
          }
          owner._onLoadFinished(failingUrl, description + "(" + errorCode + ")");
        }
      } else {
        var request2 = args[1];
        var error = args[2];
        _super.prototype.onReceivedError.call(this, view, request2, error);
        var owner = this.owner;
        if (owner) {
          if (Trace.isEnabled()) {
            Trace.write("WebViewClientClass.onReceivedError(" + error.getErrorCode() + ", " + error.getDescription() + ", " + (error.getUrl && error.getUrl()) + ")", Trace.categories.Debug);
          }
          owner._onLoadFinished(error.getUrl && error.getUrl(), error.getDescription() + "(" + error.getErrorCode() + ")");
        }
      }
    };
    return WebViewClientImpl2;
  }(android.webkit.WebViewClient);
  WebViewClient = WebViewClientImpl;
}

class WebView extends WebViewBase {
  createNativeView() {
    const nativeView = new android.webkit.WebView(this._context);
    const settings = nativeView.getSettings();
    settings.setJavaScriptEnabled(true);
    settings.setBuiltInZoomControls(true);
    settings.setAllowFileAccess(true);
    return nativeView;
  }
  initNativeView() {
    super.initNativeView();
    initializeWebViewClient();
    const nativeView = this.nativeViewProtected;
    const client = new WebViewClient(this);
    nativeView.setWebViewClient(client);
    nativeView.client = client;
    this._disableZoom(this.disableZoom);
  }
  disposeNativeView() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      if (nativeView.client) {
        nativeView.client.owner = null;
      }
      nativeView.destroy();
    }
    super.disposeNativeView();
  }
  _disableZoom(value) {
    if (this.nativeView && value) {
      const settings = this.nativeView.getSettings();
      settings.setBuiltInZoomControls(false);
      settings.setSupportZoom(false);
      settings.setDisplayZoomControls(false);
    }
  }
  [disableZoomProperty.setNative](value) {
    this._disableZoom(value);
  }
  _loadUrl(src) {
    const nativeView = this.nativeViewProtected;
    if (!nativeView) {
      return;
    }
    nativeView.loadUrl(src);
  }
  _loadData(src) {
    const nativeView = this.nativeViewProtected;
    if (!nativeView) {
      return;
    }
    const baseUrl = `file:///${knownFolders.currentApp().path}/`;
    nativeView.loadDataWithBaseURL(baseUrl, src, "text/html", "utf-8", null);
  }
  get canGoBack() {
    return this.nativeViewProtected.canGoBack();
  }
  stopLoading() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      nativeView.stopLoading();
    }
  }
  get canGoForward() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      return nativeView.canGoForward();
    }
    return false;
  }
  goBack() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      return nativeView.goBack();
    }
  }
  goForward() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      return nativeView.goForward();
    }
  }
  reload() {
    const nativeView = this.nativeViewProtected;
    if (nativeView) {
      return nativeView.reload();
    }
  }
}

// node_modules/@nativescript/core/ui/index.js
global.alert = alert2;
global.confirm = confirm;
global.prompt = prompt;
global.login = login;
global.action = action;

// node_modules/@nativescript/core/index.js
var AccessibilityEvents;
(function(AccessibilityEvents2) {
  AccessibilityEvents2.accessibilityBlurEvent = accessibilityBlurEvent;
  AccessibilityEvents2.accessibilityFocusEvent = accessibilityFocusEvent;
  AccessibilityEvents2.accessibilityFocusChangedEvent = accessibilityFocusChangedEvent;
  AccessibilityEvents2.accessibilityPerformEscapeEvent = accessibilityPerformEscapeEvent;
})(AccessibilityEvents || (AccessibilityEvents = {}));

// node_modules/esm-env/browser-fallback.js
var browser_fallback_default = typeof window !== "undefined";
// node_modules/esm-env/dev-fallback.js
var node_env = globalThis.process?.env?.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");
// node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
var noop5 = () => {};
function run_all(arr) {
  for (var i4 = 0;i4 < arr.length; i4++) {
    arr[i4]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var MANAGED_EFFECT = 1 << 24;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var CONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var EFFECT_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var EAGER_EFFECT = 1 << 17;
var HEAD_EFFECT = 1 << 18;
var EFFECT_PRESERVED = 1 << 19;
var USER_EFFECT = 1 << 20;
var EFFECT_OFFSCREEN = 1 << 25;
var WAS_MARKED = 1 << 15;
var REACTION_IS_UPDATING = 1 << 21;
var ASYNC2 = 1 << 22;
var ERROR_VALUE = 1 << 23;
var STATE_SYMBOL = Symbol("$state");
var LEGACY_PROPS = Symbol("legacy props");
var LOADING_ATTR_SYMBOL = Symbol("");
var PROXY_PATH_SYMBOL = Symbol("proxy path");
var STALE_REACTION = new class StaleReactionError extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
};
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_FRAGMENT_NODE = 11;

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (dev_fallback_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function component_api_changed(method, component) {
  if (dev_fallback_default) {
    const error = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
function component_api_invalid_new(component, name50) {
  if (dev_fallback_default) {
    const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component} with \`new ${name50}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function props_invalid_value(key) {
  if (dev_fallback_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var TEMPLATE_USE_SVG = 1 << 2;
var TEMPLATE_USE_MATHML = 1 << 3;
var HYDRATION_START = "[";
var HYDRATION_START_ELSE = "[!";
var HYDRATION_END = "]";
var HYDRATION_ERROR = {};
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var ELEMENT_IS_INPUT = 1 << 2;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");
var NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";

// node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function await_waterfall(name50, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name50}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function console_log_state(method) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
function hydration_attribute_changed(attribute, html, value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(get_next_sibling(hydrate_node));
}
function reset2(node) {
  if (!hydrating)
    return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function next(count = 1) {
  if (hydrating) {
    var i4 = count;
    var node = hydrate_node;
    while (i4--) {
      node = get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove2 = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data2 = node.data;
      if (data2 === HYDRATION_END) {
        if (depth === 0)
          return node;
        depth -= 1;
      } else if (data2 === HYDRATION_START || data2 === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = get_next_sibling(node);
    if (remove2)
      node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return node.data;
}

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a3, b2) {
  return a3 != a3 ? b2 == b2 : a3 !== b2 || a3 !== null && typeof a3 === "object" || typeof a3 === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag = false;
var legacy_mode_flag = false;
var tracing_mode_flag = false;
function enable_legacy_mode_flag() {
  legacy_mode_flag = true;
}

// node_modules/svelte/src/internal/shared/warnings.js
var bold2 = "font-weight: bold";
var normal2 = "font-weight: normal";
function state_snapshot_uncloneable(properties3) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_snapshot_uncloneable
%c${properties3 ? `The following properties cannot be cloned with \`$state.snapshot\`  the return value contains the originals:

${properties3}` : "Value cannot be cloned with `$state.snapshot`  the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`, bold2, normal2);
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}

// node_modules/svelte/src/internal/shared/clone.js
var empty2 = [];
function snapshot(value, skip_warning = false, no_tojson = false) {
  if (dev_fallback_default && !skip_warning) {
    const paths = [];
    const copy = clone2(value, new Map, "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path2) => `- <value>${path2}`).join(`
`);
      if (excess > 0)
        uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone2(value, new Map, "", empty2, null, no_tojson);
}
function clone2(value, cloned, path2, paths, original = null, no_tojson = false) {
  if (typeof value === "object" && value !== null) {
    var unwrapped = cloned.get(value);
    if (unwrapped !== undefined)
      return unwrapped;
    if (value instanceof Map)
      return new Map(value);
    if (value instanceof Set)
      return new Set(value);
    if (is_array(value)) {
      var copy = Array(value.length);
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i4 = 0;i4 < value.length; i4 += 1) {
        var element = value[i4];
        if (i4 in value) {
          copy[i4] = clone2(element, cloned, dev_fallback_default ? `${path2}[${i4}]` : path2, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      copy = {};
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key in value) {
        copy[key] = clone2(value[key], cloned, dev_fallback_default ? `${path2}.${key}` : path2, paths, null, no_tojson);
      }
      return copy;
    }
    if (value instanceof Date) {
      return structuredClone(value);
    }
    if (typeof value.toJSON === "function" && !no_tojson) {
      return clone2(value.toJSON(), cloned, dev_fallback_default ? `${path2}.toJSON()` : path2, paths, value);
    }
  }
  if (value instanceof EventTarget) {
    return value;
  }
  try {
    return structuredClone(value);
  } catch (e3) {
    if (dev_fallback_default) {
      paths.push(path2);
    }
    return value;
  }
}

// node_modules/svelte/src/internal/client/dev/tracing.js
var tracing_expressions = null;
function tag(source, label2) {
  source.label = label2;
  tag_proxy(source.v, label2);
  return source;
}
function tag_proxy(value, label2) {
  value?.[PROXY_PATH_SYMBOL]?.(label2);
  return value;
}

// node_modules/svelte/src/internal/shared/dev.js
function get_error(label2) {
  const error = new Error;
  const stack = get_stack();
  if (stack.length === 0) {
    return null;
  }
  stack.unshift(`
`);
  define_property(error, "stack", {
    value: stack.join(`
`)
  });
  define_property(error, "name", {
    value: label2
  });
  return error;
}
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack)
    return [];
  const lines = stack.split(`
`);
  const new_lines = [];
  for (let i4 = 0;i4 < lines.length; i4++) {
    const line = lines[i4];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}

// node_modules/svelte/src/internal/client/context.js
var component_context = null;
function set_component_context(context) {
  component_context = context;
}
var dev_stack = null;
function set_dev_stack(stack) {
  dev_stack = stack;
}
function add_svelte_meta(callback, type, component, line, column, additional) {
  const parent = dev_stack;
  dev_stack = {
    type,
    file: component[FILENAME],
    line,
    column,
    parent,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent;
  }
}
var dev_current_component_function = null;
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component) {
  var context = component_context;
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component !== undefined) {
    context.x = component;
  }
  context.i = true;
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component ?? {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}

// node_modules/svelte/src/internal/client/dom/task.js
var micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks)
        run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}

// node_modules/svelte/src/internal/client/error-handling.js
var adjustments = new WeakMap;
function handle_error(error) {
  var effect = active_effect;
  if (effect === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect));
  }
  if ((effect.f & EFFECT_RAN) === 0) {
    if ((effect.f & BOUNDARY_EFFECT) === 0) {
      if (dev_fallback_default && !effect.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect.b.error(error);
  } else {
    invoke_error_boundary(error, effect);
  }
}
function invoke_error_boundary(error, effect) {
  while (effect !== null) {
    if ((effect.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect.b.error(error);
        return;
      } catch (e3) {
        error = e3;
      }
    }
    effect = effect.parent;
  }
  if (dev_fallback_default && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable)
    return;
  var indent = is_firefox ? "  " : "\t";
  var component_stack = `
${indent}in ${effect.fn?.name || "<unknown>"}`;
  var context = effect.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split(`
`).filter((line) => !line.includes("svelte/src/internal")).join(`
`)
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}

// node_modules/svelte/src/internal/client/reactivity/batch.js
var batches = new Set;
var current_batch = null;
var previous_batch = null;
var batch_values = null;
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;

class Batch {
  committed = false;
  current = new Map;
  previous = new Map;
  #commit_callbacks = new Set;
  #discard_callbacks = new Set;
  #pending = 0;
  #blocking_pending = 0;
  #deferred = null;
  #dirty_effects = new Set;
  #maybe_dirty_effects = new Set;
  skipped_effects = new Set;
  is_fork = false;
  is_deferred() {
    return this.is_fork || this.#blocking_pending > 0;
  }
  process(root_effects) {
    queued_root_effects = [];
    previous_batch = null;
    this.apply();
    var target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const root of root_effects) {
      this.#traverse_effect_tree(root, target);
    }
    if (!this.is_fork) {
      this.#resolve();
    }
    if (this.is_deferred()) {
      this.#defer_effects(target.effects);
      this.#defer_effects(target.render_effects);
    } else {
      previous_batch = this;
      current_batch = null;
      flush_queued_effects(target.render_effects);
      flush_queued_effects(target.effects);
      previous_batch = null;
      this.#deferred?.resolve();
    }
    batch_values = null;
  }
  #traverse_effect_tree(root, target) {
    root.f ^= CLEAN;
    var effect = root.first;
    while (effect !== null) {
      var flags = effect.f;
      var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
      var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
      var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);
      if ((effect.f & BOUNDARY_EFFECT) !== 0 && effect.b?.is_pending()) {
        target = {
          parent: target,
          effect,
          effects: [],
          render_effects: []
        };
      }
      if (!skip && effect.fn !== null) {
        if (is_branch) {
          effect.f ^= CLEAN;
        } else if ((flags & EFFECT) !== 0) {
          target.effects.push(effect);
        } else if (async_mode_flag && (flags & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
          target.render_effects.push(effect);
        } else if (is_dirty(effect)) {
          if ((effect.f & BLOCK_EFFECT) !== 0)
            this.#dirty_effects.add(effect);
          update_effect(effect);
        }
        var child = effect.first;
        if (child !== null) {
          effect = child;
          continue;
        }
      }
      var parent = effect.parent;
      effect = effect.next;
      while (effect === null && parent !== null) {
        if (parent === target.effect) {
          this.#defer_effects(target.effects);
          this.#defer_effects(target.render_effects);
          target = target.parent;
        }
        effect = parent.next;
        parent = parent.parent;
      }
    }
  }
  #defer_effects(effects) {
    for (const e3 of effects) {
      if ((e3.f & DIRTY) !== 0) {
        this.#dirty_effects.add(e3);
      } else if ((e3.f & MAYBE_DIRTY) !== 0) {
        this.#maybe_dirty_effects.add(e3);
      }
      this.#clear_marked(e3.deps);
      set_signal_status(e3, CLEAN);
    }
  }
  #clear_marked(deps) {
    if (deps === null)
      return;
    for (const dep of deps) {
      if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
        continue;
      }
      dep.f ^= WAS_MARKED;
      this.#clear_marked(dep.deps);
    }
  }
  capture(source2, value) {
    if (!this.previous.has(source2)) {
      this.previous.set(source2, value);
    }
    if ((source2.f & ERROR_VALUE) === 0) {
      this.current.set(source2, source2.v);
      batch_values?.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    if (current_batch !== this)
      return;
    current_batch = null;
    batch_values = null;
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (this.#pending === 0) {
      this.process([]);
    }
    this.deactivate();
  }
  discard() {
    for (const fn of this.#discard_callbacks)
      fn(this);
    this.#discard_callbacks.clear();
  }
  #resolve() {
    if (this.#blocking_pending === 0) {
      for (const fn of this.#commit_callbacks)
        fn();
      this.#commit_callbacks.clear();
    }
    if (this.#pending === 0) {
      this.#commit();
    }
  }
  #commit() {
    if (batches.size > 1) {
      this.previous.clear();
      var previous_batch_values = batch_values;
      var is_earlier = true;
      var dummy_target = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const batch of batches) {
        if (batch === this) {
          is_earlier = false;
          continue;
        }
        const sources = [];
        for (const [source2, value] of this.current) {
          if (batch.current.has(source2)) {
            if (is_earlier && value !== batch.current.get(source2)) {
              batch.current.set(source2, value);
            } else {
              continue;
            }
          }
          sources.push(source2);
        }
        if (sources.length === 0) {
          continue;
        }
        const others = [...batch.current.keys()].filter((s3) => !this.current.has(s3));
        if (others.length > 0) {
          var prev_queued_root_effects = queued_root_effects;
          queued_root_effects = [];
          const marked = new Set;
          const checked = new Map;
          for (const source2 of sources) {
            mark_effects(source2, others, marked, checked);
          }
          if (queued_root_effects.length > 0) {
            current_batch = batch;
            batch.apply();
            for (const root of queued_root_effects) {
              batch.#traverse_effect_tree(root, dummy_target);
            }
            batch.deactivate();
          }
          queued_root_effects = prev_queued_root_effects;
        }
      }
      current_batch = null;
      batch_values = previous_batch_values;
    }
    this.committed = true;
    batches.delete(this);
  }
  increment(blocking) {
    this.#pending += 1;
    if (blocking)
      this.#blocking_pending += 1;
  }
  decrement(blocking) {
    this.#pending -= 1;
    if (blocking)
      this.#blocking_pending -= 1;
    this.revive();
  }
  revive() {
    for (const e3 of this.#dirty_effects) {
      this.#maybe_dirty_effects.delete(e3);
      set_signal_status(e3, DIRTY);
      schedule_effect(e3);
    }
    for (const e3 of this.#maybe_dirty_effects) {
      set_signal_status(e3, MAYBE_DIRTY);
      schedule_effect(e3);
    }
    this.flush();
  }
  oncommit(fn) {
    this.#commit_callbacks.add(fn);
  }
  ondiscard(fn) {
    this.#discard_callbacks.add(fn);
  }
  settled() {
    return (this.#deferred ??= deferred()).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new Batch;
      batches.add(current_batch);
      if (!is_flushing_sync) {
        Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    if (!async_mode_flag || !this.is_fork && batches.size === 1)
      return;
    batch_values = new Map(this.current);
    for (const batch of batches) {
      if (batch === this)
        continue;
      for (const [source2, previous] of batch.previous) {
        if (!batch_values.has(source2)) {
          batch_values.set(source2, previous);
        }
      }
    }
  }
}
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return result;
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = dev_fallback_default ? new Set : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1000) {
        if (dev_fallback_default) {
          var updates = new Map;
          for (const source2 of batch.current.keys()) {
            for (const [stack, update2] of source2.updated ?? []) {
              var entry = updates.get(stack);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (dev_fallback_default) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (dev_fallback_default) {
      for (const source2 of source_stacks) {
        source2.updated = null;
      }
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length2 = effects.length;
  if (length2 === 0)
    return;
  var i4 = 0;
  while (i4 < length2) {
    var effect = effects[i4++];
    if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
      eager_block_effects = new Set;
      update_effect(effect);
      if (effect.deps === null && effect.first === null && effect.nodes === null) {
        if (effect.teardown === null && effect.ac === null) {
          unlink_effect(effect);
        } else {
          effect.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e3 of eager_block_effects) {
          if ((e3.f & (DESTROYED | INERT)) !== 0)
            continue;
          const ordered_effects = [e3];
          let ancestor = e3.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j2 = ordered_effects.length - 1;j2 >= 0; j2--) {
            const e4 = ordered_effects[j2];
            if ((e4.f & (DESTROYED | INERT)) !== 0)
              continue;
            update_effect(e4);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value))
    return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags = reaction.f;
      if ((flags & DERIVED) !== 0) {
        mark_effects(reaction, sources, marked, checked);
      } else if ((flags & (ASYNC2 | BLOCK_EFFECT)) !== 0 && (flags & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(reaction);
      }
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== undefined)
    return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(dep, sources, checked)) {
        checked.set(dep, true);
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect = last_scheduled_effect = signal;
  while (effect.parent !== null) {
    effect = effect.parent;
    var flags = effect.f;
    if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0 && (flags & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags & CLEAN) === 0)
        return;
      effect.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect);
}

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start2) {
  let subscribers = 0;
  let version4 = source(0);
  let stop2;
  if (dev_fallback_default) {
    tag(version4, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get2(version4);
      render_effect(() => {
        if (subscribers === 0) {
          stop2 = untrack(() => start2(() => increment(version4)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop2?.();
              stop2 = undefined;
              increment(version4);
            }
          });
        };
      });
    }
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}

class Boundary {
  parent;
  #pending = false;
  #anchor;
  #hydrate_open = hydrating ? hydrate_node : null;
  #props;
  #children;
  #effect;
  #main_effect = null;
  #pending_effect = null;
  #failed_effect = null;
  #offscreen_fragment = null;
  #pending_anchor = null;
  #local_pending_count = 0;
  #pending_count = 0;
  #is_creating_fallback = false;
  #effect_pending = null;
  #effect_pending_subscriber = createSubscriber(() => {
    this.#effect_pending = source(this.#local_pending_count);
    if (dev_fallback_default) {
      tag(this.#effect_pending, "$effect.pending()");
    }
    return () => {
      this.#effect_pending = null;
    };
  });
  constructor(node, props, children) {
    this.#anchor = node;
    this.#props = props;
    this.#children = children;
    this.parent = active_effect.b;
    this.#pending = !!this.#props.pending;
    this.#effect = block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment = this.#hydrate_open;
        hydrate_next();
        const server_rendered_pending = comment.nodeType === COMMENT_NODE && comment.data === HYDRATION_START_ELSE;
        if (server_rendered_pending) {
          this.#hydrate_pending_content();
        } else {
          this.#hydrate_resolved_content();
        }
      } else {
        var anchor = this.#get_anchor();
        try {
          this.#main_effect = branch(() => children(anchor));
        } catch (error) {
          this.error(error);
        }
        if (this.#pending_count > 0) {
          this.#show_pending_snippet();
        } else {
          this.#pending = false;
        }
      }
      return () => {
        this.#pending_anchor?.remove();
      };
    }, flags);
    if (hydrating) {
      this.#anchor = hydrate_node;
    }
  }
  #hydrate_resolved_content() {
    try {
      this.#main_effect = branch(() => this.#children(this.#anchor));
    } catch (error) {
      this.error(error);
    }
    this.#pending = false;
  }
  #hydrate_pending_content() {
    const pending = this.#props.pending;
    if (!pending) {
      return;
    }
    this.#pending_effect = branch(() => pending(this.#anchor));
    Batch.enqueue(() => {
      var anchor = this.#get_anchor();
      this.#main_effect = this.#run(() => {
        Batch.ensure();
        return branch(() => this.#children(anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        pause_effect(this.#pending_effect, () => {
          this.#pending_effect = null;
        });
        this.#pending = false;
      }
    });
  }
  #get_anchor() {
    var anchor = this.#anchor;
    if (this.#pending) {
      this.#pending_anchor = create_text();
      this.#anchor.before(this.#pending_anchor);
      anchor = this.#pending_anchor;
    }
    return anchor;
  }
  is_pending() {
    return this.#pending || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#props.pending;
  }
  #run(fn) {
    var previous_effect = active_effect;
    var previous_reaction = active_reaction;
    var previous_ctx = component_context;
    set_active_effect(this.#effect);
    set_active_reaction(this.#effect);
    set_component_context(this.#effect.ctx);
    try {
      return fn();
    } catch (e3) {
      handle_error(e3);
      return null;
    } finally {
      set_active_effect(previous_effect);
      set_active_reaction(previous_reaction);
      set_component_context(previous_ctx);
    }
  }
  #show_pending_snippet() {
    const pending = this.#props.pending;
    if (this.#main_effect !== null) {
      this.#offscreen_fragment = document.createDocumentFragment();
      this.#offscreen_fragment.append(this.#pending_anchor);
      move_effect(this.#main_effect, this.#offscreen_fragment);
    }
    if (this.#pending_effect === null) {
      this.#pending_effect = branch(() => pending(this.#anchor));
    }
  }
  #update_pending_count(d3) {
    if (!this.has_pending_snippet()) {
      if (this.parent) {
        this.parent.#update_pending_count(d3);
      }
      return;
    }
    this.#pending_count += d3;
    if (this.#pending_count === 0) {
      this.#pending = false;
      if (this.#pending_effect) {
        pause_effect(this.#pending_effect, () => {
          this.#pending_effect = null;
        });
      }
      if (this.#offscreen_fragment) {
        this.#anchor.before(this.#offscreen_fragment);
        this.#offscreen_fragment = null;
      }
    }
  }
  update_pending_count(d3) {
    this.#update_pending_count(d3);
    this.#local_pending_count += d3;
    if (this.#effect_pending) {
      internal_set(this.#effect_pending, this.#local_pending_count);
    }
  }
  get_effect_pending() {
    this.#effect_pending_subscriber();
    return get2(this.#effect_pending);
  }
  error(error) {
    var onerror = this.#props.onerror;
    let failed = this.#props.failed;
    if (this.#is_creating_fallback || !onerror && !failed) {
      throw error;
    }
    if (this.#main_effect) {
      destroy_effect(this.#main_effect);
      this.#main_effect = null;
    }
    if (this.#pending_effect) {
      destroy_effect(this.#pending_effect);
      this.#pending_effect = null;
    }
    if (this.#failed_effect) {
      destroy_effect(this.#failed_effect);
      this.#failed_effect = null;
    }
    if (hydrating) {
      set_hydrate_node(this.#hydrate_open);
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset3 = () => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      this.#local_pending_count = 0;
      if (this.#failed_effect !== null) {
        pause_effect(this.#failed_effect, () => {
          this.#failed_effect = null;
        });
      }
      this.#pending = this.has_pending_snippet();
      this.#main_effect = this.#run(() => {
        this.#is_creating_fallback = false;
        return branch(() => this.#children(this.#anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        this.#pending = false;
      }
    };
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error, reset3);
      calling_on_error = false;
    } catch (error2) {
      invoke_error_boundary(error2, this.#effect && this.#effect.parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        this.#failed_effect = this.#run(() => {
          Batch.ensure();
          this.#is_creating_fallback = true;
          try {
            return branch(() => {
              failed(this.#anchor, () => error, () => reset3);
            });
          } catch (error2) {
            invoke_error_boundary(error2, this.#effect.parent);
            return null;
          } finally {
            this.#is_creating_fallback = false;
          }
        });
      });
    }
  }
}

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(blockers, sync, async, fn) {
  const d3 = is_runes() ? derived : derived_safe_equal;
  if (async.length === 0 && blockers.length === 0) {
    fn(sync.map(d3));
    return;
  }
  var batch = current_batch;
  var parent = active_effect;
  var restore = capture();
  function run2() {
    Promise.all(async.map((expression) => async_derived(expression))).then((result) => {
      restore();
      try {
        fn([...sync.map(d3), ...result]);
      } catch (error) {
        if ((parent.f & DESTROYED) === 0) {
          invoke_error_boundary(error, parent);
        }
      }
      batch?.deactivate();
      unset_context();
    }).catch((error) => {
      invoke_error_boundary(error, parent);
    });
  }
  if (blockers.length > 0) {
    Promise.all(blockers).then(() => {
      restore();
      try {
        return run2();
      } finally {
        batch?.deactivate();
        unset_context();
      }
    });
  } else {
    run2();
  }
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (dev_fallback_default) {
    var previous_dev_stack = dev_stack;
  }
  return function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch)
      previous_batch2?.activate();
    if (dev_fallback_default) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  };
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (dev_fallback_default) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var current_async_effect = null;
function set_from_async_derived(v) {
  current_async_effect = v;
}
var recent_async_deriveds = new Set;
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? active_reaction : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: UNINITIALIZED,
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
function async_derived(fn, location) {
  let parent = active_effect;
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = parent.b;
  var promise = undefined;
  var signal = source(UNINITIALIZED);
  var should_suspend = !active_reaction;
  var deferreds = new Map;
  async_effect(() => {
    if (dev_fallback_default)
      current_async_effect = active_effect;
    var d3 = deferred();
    promise = d3.promise;
    try {
      Promise.resolve(fn()).then(d3.resolve, d3.reject).then(() => {
        if (batch === current_batch && batch.committed) {
          batch.deactivate();
        }
        unset_context();
      });
    } catch (error) {
      d3.reject(error);
      unset_context();
    }
    if (dev_fallback_default)
      current_async_effect = null;
    var batch = current_batch;
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      deferreds.get(batch)?.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d3);
    }
    const handler = (value, error = undefined) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        for (const [b2, d4] of deferreds) {
          deferreds.delete(b2);
          if (b2 === batch)
            break;
          d4.reject(STALE_REACTION);
        }
        if (dev_fallback_default && location !== undefined) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(signal.label, location);
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    };
    d3.promise.then(handler, (e3) => handler(null, e3 || "unknown"));
  });
  teardown(() => {
    for (const d3 of deferreds.values()) {
      d3.reject(STALE_REACTION);
    }
  });
  if (dev_fallback_default) {
    signal.f |= ASYNC2;
  }
  return new Promise((fulfil) => {
    function next2(p2) {
      function go() {
        if (p2 === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p2.then(go, go);
    }
    next2(promise);
  });
}
function derived_safe_equal(fn) {
  const signal = derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i4 = 0;i4 < effects.length; i4 += 1) {
      destroy_effect(effects[i4]);
    }
  }
}
var stack = [];
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? parent : null;
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (dev_fallback_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(new Set);
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    if (!current_batch?.is_fork) {
      derived2.v = value;
    }
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived2, value);
    }
  } else {
    var status = (derived2.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
var eager_effects = new Set;
var old_values = new Map;
function set_eager_effects(v) {
  eager_effects = v;
}
var eager_effects_deferred = false;
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
function state(v, stack2) {
  const s3 = source(v, stack2);
  push_reaction_value(s3);
  return s3;
}
function mutable_source(initial_value, immutable = false, trackable = true) {
  const s3 = source(initial_value);
  if (!immutable) {
    s3.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s3);
  }
  return s3;
}
function set2(source2, value, should_proxy = false) {
  if (active_reaction !== null && (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC2 | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(new_value, source2.label);
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ??= new Map;
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: null, count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(source2);
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect of inspects) {
      if ((effect.f & CLEAN) !== 0) {
        set_signal_status(effect, MAYBE_DIRTY);
      }
      if (is_dirty(effect)) {
        update_effect(effect);
      }
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}
function increment(source2) {
  set2(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  var runes = is_runes();
  var length2 = reactions.length;
  for (var i4 = 0;i4 < length2; i4++) {
    var reaction = reactions[i4];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect)
      continue;
    if (dev_fallback_default && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived2 = reaction;
      batch_values?.delete(derived2);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived2, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(reaction);
      }
      schedule_effect(reaction);
    }
  }
}

// node_modules/svelte/src/internal/client/proxy.js
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = new Map;
  var is_proxied_array = is_array(value);
  var version4 = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version5 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version5);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(value.length, stack2));
    if (dev_fallback_default) {
      value = inspectable_array(value);
    }
  }
  var path2 = "";
  let updating = false;
  function update_path(new_path) {
    if (updating)
      return;
    updating = true;
    path2 = new_path;
    tag(version4, `${path2} version`);
    for (const [prop, source2] of sources) {
      tag(source2, get_label(path2, prop));
    }
    updating = false;
  }
  return new Proxy(value, {
    defineProperty(_3, prop, descriptor) {
      if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
        state_descriptors_fixed();
      }
      var s3 = sources.get(prop);
      if (s3 === undefined) {
        s3 = with_parent(() => {
          var s4 = state(descriptor.value, stack2);
          sources.set(prop, s4);
          if (dev_fallback_default && typeof prop === "string") {
            tag(s4, get_label(path2, prop));
          }
          return s4;
        });
      } else {
        set2(s3, descriptor.value, true);
      }
      return true;
    },
    deleteProperty(target, prop) {
      var s3 = sources.get(prop);
      if (s3 === undefined) {
        if (prop in target) {
          const s4 = with_parent(() => state(UNINITIALIZED, stack2));
          sources.set(prop, s4);
          increment(version4);
          if (dev_fallback_default) {
            tag(s4, get_label(path2, prop));
          }
        }
      } else {
        set2(s3, UNINITIALIZED);
        increment(version4);
      }
      return true;
    },
    get(target, prop, receiver) {
      if (prop === STATE_SYMBOL) {
        return value;
      }
      if (dev_fallback_default && prop === PROXY_PATH_SYMBOL) {
        return update_path;
      }
      var s3 = sources.get(prop);
      var exists = prop in target;
      if (s3 === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
        s3 = with_parent(() => {
          var p2 = proxy(exists ? target[prop] : UNINITIALIZED);
          var s4 = state(p2, stack2);
          if (dev_fallback_default) {
            tag(s4, get_label(path2, prop));
          }
          return s4;
        });
        sources.set(prop, s3);
      }
      if (s3 !== undefined) {
        var v = get2(s3);
        return v === UNINITIALIZED ? undefined : v;
      }
      return Reflect.get(target, prop, receiver);
    },
    getOwnPropertyDescriptor(target, prop) {
      var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
      if (descriptor && "value" in descriptor) {
        var s3 = sources.get(prop);
        if (s3)
          descriptor.value = get2(s3);
      } else if (descriptor === undefined) {
        var source2 = sources.get(prop);
        var value2 = source2?.v;
        if (source2 !== undefined && value2 !== UNINITIALIZED) {
          return {
            enumerable: true,
            configurable: true,
            value: value2,
            writable: true
          };
        }
      }
      return descriptor;
    },
    has(target, prop) {
      if (prop === STATE_SYMBOL) {
        return true;
      }
      var s3 = sources.get(prop);
      var has = s3 !== undefined && s3.v !== UNINITIALIZED || Reflect.has(target, prop);
      if (s3 !== undefined || active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) {
        if (s3 === undefined) {
          s3 = with_parent(() => {
            var p2 = has ? proxy(target[prop]) : UNINITIALIZED;
            var s4 = state(p2, stack2);
            if (dev_fallback_default) {
              tag(s4, get_label(path2, prop));
            }
            return s4;
          });
          sources.set(prop, s3);
        }
        var value2 = get2(s3);
        if (value2 === UNINITIALIZED) {
          return false;
        }
      }
      return has;
    },
    set(target, prop, value2, receiver) {
      var s3 = sources.get(prop);
      var has = prop in target;
      if (is_proxied_array && prop === "length") {
        for (var i4 = value2;i4 < s3.v; i4 += 1) {
          var other_s = sources.get(i4 + "");
          if (other_s !== undefined) {
            set2(other_s, UNINITIALIZED);
          } else if (i4 in target) {
            other_s = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(i4 + "", other_s);
            if (dev_fallback_default) {
              tag(other_s, get_label(path2, i4));
            }
          }
        }
      }
      if (s3 === undefined) {
        if (!has || get_descriptor(target, prop)?.writable) {
          s3 = with_parent(() => state(undefined, stack2));
          if (dev_fallback_default) {
            tag(s3, get_label(path2, prop));
          }
          set2(s3, proxy(value2));
          sources.set(prop, s3);
        }
      } else {
        has = s3.v !== UNINITIALIZED;
        var p2 = with_parent(() => proxy(value2));
        set2(s3, p2);
      }
      var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
      if (descriptor?.set) {
        descriptor.set.call(receiver, value2);
      }
      if (!has) {
        if (is_proxied_array && typeof prop === "string") {
          var ls = sources.get("length");
          var n3 = Number(prop);
          if (Number.isInteger(n3) && n3 >= ls.v) {
            set2(ls, n3 + 1);
          }
        }
        increment(version4);
      }
      return true;
    },
    ownKeys(target) {
      get2(version4);
      var own_keys = Reflect.ownKeys(target).filter((key2) => {
        var source3 = sources.get(key2);
        return source3 === undefined || source3.v !== UNINITIALIZED;
      });
      for (var [key, source2] of sources) {
        if (source2.v !== UNINITIALIZED && !(key in target)) {
          own_keys.push(key);
        }
      }
      return own_keys;
    },
    setPrototypeOf() {
      state_prototype_fixed();
    }
  });
}
function get_label(path2, prop) {
  if (typeof prop === "symbol")
    return `${path2}[Symbol(${prop.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop))
    return `${path2}.${prop}`;
  return /^\d+$/.test(prop) ? `${path2}[${prop}]` : `${path2}['${prop}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {}
  return value;
}
var ARRAY_MUTATING_METHODS = new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop, receiver) {
      var value = Reflect.get(target, prop, receiver);
      if (!ARRAY_MUTATING_METHODS.has(prop)) {
        return value;
      }
      return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index = indexOf.call(this, item, from_index);
    if (index === -1) {
      for (let i4 = from_index ?? 0;i4 < this.length; i4 += 1) {
        if (get_proxied_value(this[i4]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index === -1) {
      for (let i4 = 0;i4 <= (from_index ?? this.length - 1); i4 += 1) {
        if (get_proxied_value(this[i4]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      for (let i4 = 0;i4 < this.length; i4 += 1) {
        if (get_proxied_value(this[i4]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}

// node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== undefined) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = undefined;
    element_prototype.__className = undefined;
    element_prototype.__attributes = null;
    element_prototype.__style = undefined;
    element_prototype.__e = undefined;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = undefined;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
function get_first_child(node) {
  return first_child_getter.call(node);
}
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function child(node, is_text) {
  if (!hydrating) {
    return get_first_child(node);
  }
  var child2 = get_first_child(hydrate_node);
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text = create_text();
    child2?.before(text);
    set_hydrate_node(text);
    return text;
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(node, is_text = false) {
  if (!hydrating) {
    var first = get_first_child(node);
    if (first instanceof Comment && first.data === "")
      return get_next_sibling(first);
    return first;
  }
  if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
    var text = create_text();
    hydrate_node?.before(text);
    set_hydrate_node(text);
    return text;
  }
  return hydrate_node;
}
function sibling2(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
    var text = create_text();
    if (next_sibling === null) {
      last_sibling?.after(text);
    } else {
      next_sibling.before(text);
    }
    set_hydrate_node(text);
    return text;
  }
  set_hydrate_node(next_sibling);
  return next_sibling;
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag)
    return false;
  if (eager_block_effects !== null)
    return false;
  var flags2 = active_effect.f;
  return (flags2 & EFFECT_RAN) !== 0;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function push_effect(effect, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect;
  } else {
    parent_last.next = effect;
    effect.prev = parent_last;
    parent_effect.last = effect;
  }
}
function create_effect(type, fn, sync) {
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) {
    effect.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect);
      effect.f |= EFFECT_RAN;
    } catch (e4) {
      destroy_effect(effect);
      throw e4;
    }
  } else if (fn !== null) {
    schedule_effect(effect);
  }
  var e3 = effect;
  if (sync && e3.deps === null && e3.teardown === null && e3.nodes === null && e3.first === e3.last && (e3.f & EFFECT_PRESERVED) === 0) {
    e3 = e3.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e3 !== null) {
      e3.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e3 !== null) {
    e3.parent = parent;
    if (parent !== null) {
      push_effect(e3, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived2 = active_reaction;
      (derived2.effects ??= []).push(e3);
    }
  }
  return effect;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect, CLEAN);
  effect.teardown = fn;
  return effect;
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function effect_root(fn) {
  Batch.ensure();
  const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect, () => {
          destroy_effect(effect);
          fulfil(undefined);
        });
      } else {
        destroy_effect(effect);
        fulfil(undefined);
      }
    });
  };
}
function async_effect(fn) {
  return create_effect(ASYNC2 | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async = [], blockers = []) {
  flatten(blockers, sync, async, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get2)), true);
  });
}
function block(fn, flags2 = 0) {
  var effect = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect.dev_stack = dev_stack;
  }
  return effect;
}
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
function execute_effect_teardown(effect) {
  var teardown2 = effect.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect = signal.first;
  signal.first = signal.last = null;
  while (effect !== null) {
    const controller = effect.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect.next;
    if ((effect.f & ROOT_EFFECT) !== 0) {
      effect.parent = null;
    } else {
      destroy_effect(effect, remove_dom);
    }
    effect = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect = signal.first;
  while (effect !== null) {
    var next2 = effect.next;
    if ((effect.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect);
    }
    effect = next2;
  }
}
function destroy_effect(effect, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes !== null && effect.nodes.end !== null) {
    remove_effect_dom(effect.nodes.start, effect.nodes.end);
    removed = true;
  }
  destroy_effect_children(effect, remove_dom && !removed);
  remove_reactions(effect, 0);
  set_signal_status(effect, DESTROYED);
  var transitions = effect.nodes && effect.nodes.t;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect);
  var parent = effect.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect);
  }
  if (dev_fallback_default) {
    effect.component_function = null;
  }
  effect.next = effect.prev = effect.teardown = effect.ctx = effect.deps = effect.fn = effect.nodes = effect.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect) {
  var parent = effect.parent;
  var prev = effect.prev;
  var next2 = effect.next;
  if (prev !== null)
    prev.next = next2;
  if (next2 !== null)
    next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect)
      parent.first = next2;
    if (parent.last === effect)
      parent.last = prev;
  }
}
function pause_effect(effect, callback, destroy = true) {
  var transitions = [];
  pause_children(effect, transitions, true);
  var fn = () => {
    if (destroy)
      destroy_effect(effect);
    if (callback)
      callback();
  };
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition of transitions) {
      transition.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect, transitions, local) {
  if ((effect.f & INERT) !== 0)
    return;
  effect.f ^= INERT;
  var t3 = effect.nodes && effect.nodes.t;
  if (t3 !== null) {
    for (const transition of t3) {
      if (transition.is_global || local) {
        transitions.push(transition);
      }
    }
  }
  var child2 = effect.first;
  while (child2 !== null) {
    var sibling3 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0 && (effect.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling3;
  }
}
function resume_effect(effect) {
  resume_children(effect, true);
}
function resume_children(effect, local) {
  if ((effect.f & INERT) === 0)
    return;
  effect.f ^= INERT;
  if ((effect.f & CLEAN) === 0) {
    set_signal_status(effect, DIRTY);
    schedule_effect(effect);
  }
  var child2 = effect.first;
  while (child2 !== null) {
    var sibling3 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling3;
  }
  var t3 = effect.nodes && effect.nodes.t;
  if (t3 !== null) {
    for (const transition of t3) {
      if (transition.is_global || local) {
        transition.in();
      }
    }
  }
}
function move_effect(effect, fragment) {
  if (!effect.nodes)
    return;
  var node = effect.nodes.start;
  var end = effect.nodes.end;
  while (node !== null) {
    var next2 = node === end ? null : get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals = null;

// node_modules/svelte/src/internal/client/runtime.js
var is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
var active_effect = null;
function set_active_effect(effect) {
  active_effect = effect;
}
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length2 = dependencies.length;
      for (var i4 = 0;i4 < length2; i4++) {
        var dependency = dependencies[i4];
        if (is_dirty(dependency)) {
          update_derived(dependency);
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i4 = 0;i4 < reactions.length; i4++) {
    var reaction = reactions[i4];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(reaction, effect, false);
    } else if (effect === reaction) {
      if (root) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(reaction);
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = reaction.fn;
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i4;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i4 = 0;i4 < new_deps.length; i4++) {
          deps[skipped_deps + i4] = new_deps[i4];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i4 = skipped_deps;i4 < deps.length; i4++) {
          (deps[i4].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i4 = 0;i4 < untracked_writes.length; i4++) {
        schedule_possible_effect_self_invalidation(untracked_writes[i4], reaction);
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(...untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index = index_of.call(reactions, signal);
    if (index !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(dependency);
    remove_reactions(dependency, 0);
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null)
    return;
  for (var i4 = start_index;i4 < dependencies.length; i4++) {
    remove_reaction(signal, dependencies[i4]);
  }
}
function update_effect(effect) {
  var flags2 = effect.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect.component_function);
    var previous_stack = dev_stack;
    set_dev_stack(effect.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect);
    } else {
      destroy_effect_children(effect);
    }
    execute_effect_teardown(effect);
    var teardown2 = update_reaction(effect);
    effect.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect.wv = write_version;
    if (dev_fallback_default && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) {
      for (var dep of effect.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
function get2(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (dev_fallback_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace3 = get_error("traced at");
        if (trace3) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === undefined) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace3.stack !== last?.stack) {
            entry.traces.push(trace3);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived2 = signal;
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived && (!batch_values?.has(signal) || current_batch?.is_fork && !effect_tracking())) {
    derived2 = signal;
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
    if (is_updating_effect && effect_tracking() && (derived2.f & CONNECTED) === 0) {
      reconnect(derived2);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function reconnect(derived2) {
  if (derived2.deps === null)
    return;
  derived2.f ^= CONNECTED;
  for (const dep of derived2.deps) {
    (dep.reactions ??= []).push(derived2);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(dep);
    }
  }
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED)
    return true;
  if (derived2.deps === null)
    return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(dep)) {
      return true;
    }
  }
  return false;
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
// node_modules/svelte/src/utils.js
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name50) {
  return PASSIVE_EVENTS.includes(name50);
}
var STATE_CREATION_RUNES = [
  "$state",
  "$state.raw",
  "$derived",
  "$derived.by"
];
var RUNES = [
  ...STATE_CREATION_RUNES,
  "$state.eager",
  "$state.snapshot",
  "$props",
  "$props.id",
  "$bindable",
  "$effect",
  "$effect.pre",
  "$effect.tracking",
  "$effect.root",
  "$effect.pending",
  "$inspect",
  "$inspect().with",
  "$inspect.trace",
  "$host"
];
// node_modules/svelte/src/internal/client/dev/css.js
var all_styles = new Map;
// node_modules/svelte/src/internal/client/dev/elements.js
function add_locations(fn, filename, locations) {
  return (...args) => {
    const dom = fn(...args);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
function assign_location(element, filename, location) {
  element.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(element.firstChild, filename, location[2]);
  }
}
function assign_locations(node, filename, locations) {
  var i4 = 0;
  var depth = 0;
  while (node && i4 < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment = node;
      if (comment.data === HYDRATION_START || comment.data === HYDRATION_START_ELSE)
        depth += 1;
      else if (comment.data[0] === HYDRATION_END)
        depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(node, filename, locations[i4++]);
    }
    node = node.nextSibling;
  }
}
// node_modules/svelte/src/internal/client/dom/elements/events.js
var all_registered_events = new Set;
var root_event_handles = new Set;
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event);
    }
    if (!event.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function event(event_name, dom, handler, capture2, passive) {
  var options = { capture: capture2, passive };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || dom === window || dom === document || dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
var last_propagated_event = null;
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = handler_element.ownerDocument;
  var event_name = event2.type;
  var path2 = event2.composedPath?.() || [];
  var current_target = path2[0] || event2.target;
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path2.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path2.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = path2[path_idx] || event2.target;
  if (current_target === handler_element)
    return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!current_target.disabled || event2.target === current_target)) {
          delegated.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html) {
  var elem = document.createElement("template");
  elem.innerHTML = html.replaceAll("<!>", "<!---->");
  return elem.content;
}

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start2, end) {
  var effect = active_effect;
  if (effect.nodes === null) {
    effect.nodes = { start: start2, end, a: null, t: null };
  }
}
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === undefined) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment)
        node = get_first_child(node);
    }
    var clone3 = use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true);
    if (is_fragment) {
      var start2 = get_first_child(clone3);
      var end = clone3.lastChild;
      assign_nodes(start2, end);
    } else {
      assign_nodes(clone3, clone3);
    }
    return clone3;
  };
}
function append(anchor, dom) {
  if (hydrating) {
    var effect = active_effect;
    if ((effect.f & EFFECT_RAN) === 0 || effect.nodes.end === null) {
      effect.nodes.end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(dom);
}

// node_modules/svelte/src/internal/client/render.js
var should_intro = true;
function mount(component, options) {
  return _mount(component, options);
}
function hydrate(component, options) {
  init_operations();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = get_first_child(target);
    while (anchor && (anchor.nodeType !== COMMENT_NODE || anchor.data !== HYDRATION_START)) {
      anchor = get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(anchor);
    const instance = _mount(component, { ...options, anchor });
    set_hydrating(false);
    return instance;
  } catch (error) {
    if (error instanceof Error && error.message.split(`
`).some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
var document_listeners = new Map;
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = new Set;
  var event_handle = (events2) => {
    for (var i4 = 0;i4 < events2.length; i4++) {
      var event_name = events2[i4];
      if (registered_events.has(event_name))
        continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n3 = document_listeners.get(event_name);
      if (n3 === undefined) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n3 + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component = undefined;
  var unmount = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(anchor_node, {
      pending: () => {}
    }, (anchor_node2) => {
      if (context) {
        push({});
        var ctx = component_context;
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      if (hydrating) {
        assign_nodes(anchor_node2, null);
      }
      should_intro = intro;
      component = Component(anchor_node2, props) || {};
      should_intro = true;
      if (hydrating) {
        active_effect.nodes.end = hydrate_node;
        if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || hydrate_node.data !== HYDRATION_END) {
          hydration_mismatch();
          throw HYDRATION_ERROR;
        }
      }
      if (context) {
        pop();
      }
    });
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n3 = document_listeners.get(event_name);
        if (--n3 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n3);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component, unmount);
  return component;
}
var mounted_components = new WeakMap;
function unmount(component, options) {
  const fn = mounted_components.get(component);
  if (fn) {
    mounted_components.delete(component);
    return fn(options);
  }
  if (dev_fallback_default) {
    if (STATE_SYMBOL in component) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
// node_modules/svelte/src/internal/client/dev/legacy.js
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
function legacy_api() {
  const component = component_context?.function;
  function error(method) {
    component_api_changed(method, component[FILENAME]);
  }
  return {
    $destroy: () => error("$destroy()"),
    $on: () => error("$on(...)"),
    $set: () => error("$set(...)")
  };
}
// node_modules/svelte/src/internal/client/dom/blocks/branches.js
class BranchManager {
  anchor;
  #batches = new Map;
  #onscreen = new Map;
  #offscreen = new Map;
  #outroing = new Set;
  #transition = true;
  constructor(anchor, transition = true) {
    this.anchor = anchor;
    this.#transition = transition;
  }
  #commit = () => {
    var batch = current_batch;
    if (!this.#batches.has(batch))
      return;
    var key = this.#batches.get(batch);
    var onscreen = this.#onscreen.get(key);
    if (onscreen) {
      resume_effect(onscreen);
      this.#outroing.delete(key);
    } else {
      var offscreen = this.#offscreen.get(key);
      if (offscreen) {
        this.#onscreen.set(key, offscreen.effect);
        this.#offscreen.delete(key);
        offscreen.fragment.lastChild.remove();
        this.anchor.before(offscreen.fragment);
        onscreen = offscreen.effect;
      }
    }
    for (const [b2, k2] of this.#batches) {
      this.#batches.delete(b2);
      if (b2 === batch) {
        break;
      }
      const offscreen2 = this.#offscreen.get(k2);
      if (offscreen2) {
        destroy_effect(offscreen2.effect);
        this.#offscreen.delete(k2);
      }
    }
    for (const [k2, effect] of this.#onscreen) {
      if (k2 === key || this.#outroing.has(k2))
        continue;
      const on_destroy = () => {
        const keys = Array.from(this.#batches.values());
        if (keys.includes(k2)) {
          var fragment = document.createDocumentFragment();
          move_effect(effect, fragment);
          fragment.append(create_text());
          this.#offscreen.set(k2, { effect, fragment });
        } else {
          destroy_effect(effect);
        }
        this.#outroing.delete(k2);
        this.#onscreen.delete(k2);
      };
      if (this.#transition || !onscreen) {
        this.#outroing.add(k2);
        pause_effect(effect, on_destroy, false);
      } else {
        on_destroy();
      }
    }
  };
  #discard = (batch) => {
    this.#batches.delete(batch);
    const keys = Array.from(this.#batches.values());
    for (const [k2, branch2] of this.#offscreen) {
      if (!keys.includes(k2)) {
        destroy_effect(branch2.effect);
        this.#offscreen.delete(k2);
      }
    }
  };
  ensure(key, fn) {
    var batch = current_batch;
    var defer = should_defer_append();
    if (fn && !this.#onscreen.has(key) && !this.#offscreen.has(key)) {
      if (defer) {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        this.#offscreen.set(key, {
          effect: branch(() => fn(target)),
          fragment
        });
      } else {
        this.#onscreen.set(key, branch(() => fn(this.anchor)));
      }
    }
    this.#batches.set(batch, key);
    if (defer) {
      for (const [k2, effect] of this.#onscreen) {
        if (k2 === key) {
          batch.skipped_effects.delete(effect);
        } else {
          batch.skipped_effects.add(effect);
        }
      }
      for (const [k2, branch2] of this.#offscreen) {
        if (k2 === key) {
          batch.skipped_effects.delete(branch2.effect);
        } else {
          batch.skipped_effects.add(branch2.effect);
        }
      }
      batch.oncommit(this.#commit);
      batch.ondiscard(this.#discard);
    } else {
      if (hydrating) {
        this.anchor = hydrate_node;
      }
      this.#commit();
    }
  }
}
// node_modules/svelte/src/internal/client/dom/blocks/each.js
function index(_3, i4) {
  return i4;
}
function pause_effects(state2, to_destroy, controlled_anchor) {
  var transitions = [];
  var length2 = to_destroy.length;
  var group;
  var remaining = to_destroy.length;
  for (var i4 = 0;i4 < length2; i4++) {
    let effect = to_destroy[i4];
    pause_effect(effect, () => {
      if (group) {
        group.pending.delete(effect);
        group.done.add(effect);
        if (group.pending.size === 0) {
          var groups = state2.outrogroups;
          destroy_effects(array_from(group.done));
          groups.delete(group);
          if (groups.size === 0) {
            state2.outrogroups = null;
          }
        }
      } else {
        remaining -= 1;
      }
    }, false);
  }
  if (remaining === 0) {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = controlled_anchor;
      var parent_node = anchor.parentNode;
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
    }
    destroy_effects(to_destroy, !fast_path);
  } else {
    group = {
      pending: new Set(to_destroy),
      done: new Set
    };
    (state2.outrogroups ??= new Set).add(group);
  }
}
function destroy_effects(to_destroy, remove_dom = true) {
  for (var i4 = 0;i4 < to_destroy.length; i4++) {
    destroy_effect(to_destroy[i4], remove_dom);
  }
}
var offscreen_anchor;
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = new Map;
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = node;
    anchor = hydrating ? set_hydrate_node(get_first_child(parent_node)) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback = null;
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var first_run = true;
  function commit() {
    state2.fallback = fallback;
    reconcile(state2, array, anchor, flags2, get_key);
    if (fallback !== null) {
      if (array.length === 0) {
        if ((fallback.f & EFFECT_OFFSCREEN) === 0) {
          resume_effect(fallback);
        } else {
          fallback.f ^= EFFECT_OFFSCREEN;
          move(fallback, null, anchor);
        }
      } else {
        pause_effect(fallback, () => {
          fallback = null;
        });
      }
    }
  }
  var effect = block(() => {
    array = get2(each_array);
    var length2 = array.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length2 === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = new Set;
    var batch = current_batch;
    var defer = should_defer_append();
    for (var index2 = 0;index2 < length2; index2 += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.data === HYDRATION_END) {
        anchor = hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value = array[index2];
      var key = get_key(value, index2);
      var item = first_run ? null : items.get(key);
      if (item) {
        if (item.v)
          internal_set(item.v, value);
        if (item.i)
          internal_set(item.i, index2);
        if (defer) {
          batch.skipped_effects.delete(item.e);
        }
      } else {
        item = create_item(items, first_run ? anchor : offscreen_anchor ??= create_text(), value, key, index2, render_fn, flags2, get_collection);
        if (!first_run) {
          item.e.f |= EFFECT_OFFSCREEN;
        }
        items.set(key, item);
      }
      keys.add(key);
    }
    if (length2 === 0 && fallback_fn && !fallback) {
      if (first_run) {
        fallback = branch(() => fallback_fn(anchor));
      } else {
        fallback = branch(() => fallback_fn(offscreen_anchor ??= create_text()));
        fallback.f |= EFFECT_OFFSCREEN;
      }
    }
    if (hydrating && length2 > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key2, item2] of items) {
          if (!keys.has(key2)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.oncommit(commit);
        batch.ondiscard(() => {});
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get2(each_array);
  });
  var state2 = { effect, flags: flags2, items, outrogroups: null, fallback };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function reconcile(state2, array, anchor, flags2, get_key) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length2 = array.length;
  var items = state2.items;
  var current2 = state2.effect.first;
  var seen;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key;
  var effect;
  var i4;
  if (is_animated) {
    for (i4 = 0;i4 < length2; i4 += 1) {
      value = array[i4];
      key = get_key(value, i4);
      effect = items.get(key).e;
      if ((effect.f & EFFECT_OFFSCREEN) === 0) {
        effect.nodes?.a?.measure();
        (to_animate ??= new Set).add(effect);
      }
    }
  }
  for (i4 = 0;i4 < length2; i4 += 1) {
    value = array[i4];
    key = get_key(value, i4);
    effect = items.get(key).e;
    if (state2.outrogroups !== null) {
      for (const group of state2.outrogroups) {
        group.pending.delete(effect);
        group.done.delete(effect);
      }
    }
    if ((effect.f & EFFECT_OFFSCREEN) !== 0) {
      effect.f ^= EFFECT_OFFSCREEN;
      if (effect === current2) {
        move(effect, null, anchor);
      } else {
        var next2 = prev ? prev.next : current2;
        if (effect === state2.effect.last) {
          state2.effect.last = effect.prev;
        }
        if (effect.prev)
          effect.prev.next = effect.next;
        if (effect.next)
          effect.next.prev = effect.prev;
        link(state2, prev, effect);
        link(state2, effect, next2);
        move(effect, next2, anchor);
        prev = effect;
        matched = [];
        stashed = [];
        current2 = prev.next;
        continue;
      }
    }
    if ((effect.f & INERT) !== 0) {
      resume_effect(effect);
      if (is_animated) {
        effect.nodes?.a?.unfix();
        (to_animate ??= new Set).delete(effect);
      }
    }
    if (effect !== current2) {
      if (seen !== undefined && seen.has(effect)) {
        if (matched.length < stashed.length) {
          var start2 = stashed[0];
          var j2;
          prev = start2.prev;
          var a3 = matched[0];
          var b2 = matched[matched.length - 1];
          for (j2 = 0;j2 < matched.length; j2 += 1) {
            move(matched[j2], start2, anchor);
          }
          for (j2 = 0;j2 < stashed.length; j2 += 1) {
            seen.delete(stashed[j2]);
          }
          link(state2, a3.prev, b2.next);
          link(state2, prev, a3);
          link(state2, b2, start2);
          current2 = start2;
          prev = b2;
          i4 -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(effect);
          move(effect, current2, anchor);
          link(state2, effect.prev, effect.next);
          link(state2, effect, prev === null ? state2.effect.first : prev.next);
          link(state2, prev, effect);
          prev = effect;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current2 !== null && current2 !== effect) {
        (seen ??= new Set).add(current2);
        stashed.push(current2);
        current2 = current2.next;
      }
      if (current2 === null) {
        continue;
      }
    }
    if ((effect.f & EFFECT_OFFSCREEN) === 0) {
      matched.push(effect);
    }
    prev = effect;
    current2 = effect.next;
  }
  if (state2.outrogroups !== null) {
    for (const group of state2.outrogroups) {
      if (group.pending.size === 0) {
        destroy_effects(array_from(group.done));
        state2.outrogroups?.delete(group);
      }
    }
    if (state2.outrogroups.size === 0) {
      state2.outrogroups = null;
    }
  }
  if (current2 !== null || seen !== undefined) {
    var to_destroy = [];
    if (seen !== undefined) {
      for (effect of seen) {
        if ((effect.f & INERT) === 0) {
          to_destroy.push(effect);
        }
      }
    }
    while (current2 !== null) {
      if ((current2.f & INERT) === 0 && current2 !== state2.fallback) {
        to_destroy.push(current2);
      }
      current2 = current2.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length2 === 0 ? anchor : null;
      if (is_animated) {
        for (i4 = 0;i4 < destroy_length; i4 += 1) {
          to_destroy[i4].nodes?.a?.measure();
        }
        for (i4 = 0;i4 < destroy_length; i4 += 1) {
          to_destroy[i4].nodes?.a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === undefined)
        return;
      for (effect of to_animate) {
        effect.nodes?.a?.apply();
      }
    });
  }
}
function create_item(items, anchor, value, key, index2, render_fn, flags2, get_collection) {
  var v = (flags2 & EACH_ITEM_REACTIVE) !== 0 ? (flags2 & EACH_ITEM_IMMUTABLE) === 0 ? mutable_source(value, false, false) : source(value) : null;
  var i4 = (flags2 & EACH_INDEX_REACTIVE) !== 0 ? source(index2) : null;
  if (dev_fallback_default && v) {
    v.trace = () => {
      get_collection()[i4?.v ?? index2];
    };
  }
  return {
    v,
    i: i4,
    e: branch(() => {
      render_fn(anchor, v ?? value, i4 ?? index2, get_collection);
      return () => {
        items.delete(key);
      };
    })
  };
}
function move(effect, next2, anchor) {
  if (!effect.nodes)
    return;
  var node = effect.nodes.start;
  var end = effect.nodes.end;
  var dest = next2 && (next2.f & EFFECT_OFFSCREEN) === 0 ? next2.nodes.start : anchor;
  while (node !== null) {
    var next_node = get_next_sibling(node);
    dest.before(node);
    if (node === end) {
      return;
    }
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.effect.first = next2;
  } else {
    prev.next = next2;
  }
  if (next2 === null) {
    state2.effect.last = prev;
  } else {
    next2.prev = prev;
  }
}
// node_modules/svelte/src/internal/client/timing.js
var now = browser_fallback_default ? () => performance.now() : () => Date.now();
var raf = {
  tick: (_3) => (browser_fallback_default ? requestAnimationFrame : noop5)(_3),
  now: () => now(),
  tasks: new Set
};
// node_modules/svelte/src/internal/shared/attributes.js
var replacements = {
  translate: new Map([
    [true, "yes"],
    [false, "no"]
  ])
};
var whitespace = [...` 	
\r\f\v\uFEFF`];

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var CLASS = Symbol("class");
var STYLE = Symbol("style");
var IS_CUSTOM_ELEMENT = Symbol("is custom element");
var IS_HTML = Symbol("is html");
function set_attribute2(element, attribute, value, skip_warning) {
  var attributes = get_attributes(element);
  if (hydrating) {
    attributes[attribute] = element.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element, attribute, value ?? "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value))
    return;
  if (attribute === "loading") {
    element[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element).includes(attribute)) {
    element[attribute] = value;
  } else {
    element.setAttribute(attribute, value);
  }
}
function get_attributes(element) {
  return element.__attributes ??= {
    [IS_CUSTOM_ELEMENT]: element.nodeName.includes("-"),
    [IS_HTML]: element.namespaceURI === NAMESPACE_HTML
  };
}
var setters_cache = new Map;
function get_setters(element) {
  var cache_key = element.getAttribute("is") || element.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters)
    return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key in descriptors) {
      if (descriptors[key].set) {
        setters.push(key);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element, attribute, value) {
  if (!dev_fallback_default)
    return;
  if (attribute === "srcset" && srcset_url_equal(element, value))
    return;
  if (src_url_equal(element.getAttribute(attribute) ?? "", value))
    return;
  hydration_attribute_changed(attribute, element.outerHTML.replace(element.innerHTML, element.innerHTML && "..."), String(value));
}
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element, srcset) {
  var element_urls = split_srcset(element.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(([url, width], i4) => width === element_urls[i4][1] && (src_url_equal(element_urls[i4][0], url) || src_url_equal(url, element_urls[i4][0])));
}
// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
var pending = new Set;
// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
class ResizeObserverSingleton {
  #listeners = new WeakMap;
  #observer;
  #options;
  static entries = new WeakMap;
  constructor(options) {
    this.#options = options;
  }
  observe(element, listener) {
    var listeners = this.#listeners.get(element) || new Set;
    listeners.add(listener);
    this.#listeners.set(element, listeners);
    this.#getObserver().observe(element, this.#options);
    return () => {
      var listeners2 = this.#listeners.get(element);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        this.#listeners.delete(element);
        this.#observer.unobserve(element);
      }
    };
  }
  #getObserver() {
    return this.#observer ?? (this.#observer = new ResizeObserver((entries) => {
      for (var entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of this.#listeners.get(entry.target) || []) {
          listener(entry);
        }
      }
    }));
  }
}
// node_modules/svelte/src/internal/client/reactivity/store.js
var is_store_binding = false;
var IS_UNMOUNTED = Symbol();
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}

// node_modules/svelte/src/internal/client/reactivity/props.js
function prop(props, key, flags2, fallback) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy3 = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = fallback;
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy3 ? untrack(fallback) : fallback;
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key)?.set ?? (is_entry_props && key in props ? (v) => props[key] = v : undefined);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => props[key]);
  } else {
    initial_value = props[key];
  }
  if (initial_value === undefined && fallback !== undefined) {
    initial_value = get_fallback();
    if (setter) {
      if (runes)
        props_invalid_value(key);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = props[key];
      if (value === undefined)
        return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = props[key];
      if (value !== undefined) {
        fallback_value = undefined;
      }
      return value === undefined ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return function(value, mutation) {
      if (arguments.length > 0) {
        if (!runes || !mutation || legacy_parent || is_store_sub) {
          setter(mutation ? getter() : value);
        }
        return value;
      }
      return getter();
    };
  }
  var overridden = false;
  var d3 = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (dev_fallback_default) {
    d3.label = key;
  }
  if (bindable)
    get2(d3);
  var parent_effect = active_effect;
  return function(value, mutation) {
    if (arguments.length > 0) {
      const new_value = mutation ? get2(d3) : runes && bindable ? proxy(value) : value;
      set2(d3, new_value);
      overridden = true;
      if (fallback_value !== undefined) {
        fallback_value = new_value;
      }
      return value;
    }
    if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
      return d3.v;
    }
    return get2(d3);
  };
}
// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
class Svelte4Component {
  #events;
  #instance;
  constructor(options) {
    var sources = new Map;
    var add_source = (key, value) => {
      var s3 = mutable_source(value, false, false);
      sources.set(key, s3);
      return s3;
    };
    const props = new Proxy({ ...options.props || {}, $$events: {} }, {
      get(target, prop2) {
        return get2(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
      },
      has(target, prop2) {
        if (prop2 === LEGACY_PROPS)
          return true;
        get2(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
        return Reflect.has(target, prop2);
      },
      set(target, prop2, value) {
        set2(sources.get(prop2) ?? add_source(prop2, value), value);
        return Reflect.set(target, prop2, value);
      }
    });
    this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: options.intro ?? false,
      recover: options.recover
    });
    if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
      flushSync();
    }
    this.#events = props.$$events;
    for (const key of Object.keys(this.#instance)) {
      if (key === "$set" || key === "$destroy" || key === "$on")
        continue;
      define_property(this, key, {
        get() {
          return this.#instance[key];
        },
        set(value) {
          this.#instance[key] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  $set(props) {
    this.#instance.$set(props);
  }
  $on(event2, callback) {
    this.#events[event2] = this.#events[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    this.#events[event2].push(cb);
    return () => {
      this.#events[event2] = this.#events[event2].filter((fn) => fn !== cb);
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
}

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    $$ctor;
    $$s;
    $$c;
    $$cn = false;
    $$d = {};
    $$r = false;
    $$p_d = {};
    $$l = {};
    $$l_u = new Map;
    $$me;
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name50) {
          return (anchor) => {
            const slot = document.createElement("slot");
            if (name50 !== "default")
              slot.name = name50;
            append(anchor, slot);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name50 of this.$$s) {
          if (name50 in existing_slots) {
            if (name50 === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name50);
              $$slots.default = true;
            } else {
              $$slots[name50] = create_slot(name50);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name50 = this.$$g_p(attribute.name);
          if (!(name50 in this.$$d)) {
            this.$$d[name50] = get_custom_element_value(name50, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== undefined) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            this.$$r = true;
            for (const key of object_keys(this.$$c)) {
              if (!this.$$p_d[key]?.reflect)
                continue;
              this.$$d[key] = this.$$c[key];
              const attribute_value = get_custom_element_value(key, this.$$d[key], this.$$p_d, "toAttribute");
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr = this.$$g_p(attr);
      this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr]: this.$$d[attr] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = undefined;
        }
      });
    }
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find((key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type = props_definition[prop2]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element) {
  const result = {};
  element.childNodes.forEach((node) => {
    result[node.slot || "default"] = true;
  });
  return result;
}
// node_modules/svelte/src/internal/client/dev/console-log.js
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {}
  });
  return objects;
}
// node_modules/svelte/src/index-client.js
if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        get: () => {
          if (value !== undefined) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}

// node_modules/@nativescript-community/svelte-native/dom/index.js
var globalRef = typeof global !== "undefined" ? global : window;
var elementMap = globalRef.__SVELTE_NATIVE_ELEMENT_MAP__ || (globalRef.__SVELTE_NATIVE_ELEMENT_MAP__ = {});
function normalizeElementName(elementName) {
  return `${elementName.toLowerCase()}`;
}

class ViewNode {
  constructor() {
    this.nodeType = null;
    this.childNodes = [];
    this.parentNode = null;
    this.nextSibling = null;
    this.prevSibling = null;
  }
  appendChild(child2) {
    this.childNodes.push(child2);
    child2.parentNode = this;
    return child2;
  }
  insertBefore(child2, ref2) {
    this.childNodes.push(child2);
    return child2;
  }
  removeChild(child2) {
    return child2;
  }
  setAttribute() {}
  getAttribute() {}
  cloneNode() {
    return this;
  }
}
function registerElement(elementName, resolver) {
  elementMap[normalizeElementName(elementName)] = { resolver };
}
function createElement(elementName) {
  const normalized = normalizeElementName(elementName);
  if (elementMap[normalized])
    return elementMap[normalized].resolver();
  return new ViewNode;
}
function installGlobalShims() {
  let snDoc = {
    createElement,
    createTextNode: (t3) => ({ nodeType: 3, text: t3 }),
    createComment: (t3) => ({ nodeType: 8, text: t3 }),
    createDocumentFragment: () => ({ nodeType: 11, childNodes: [] }),
    body: new ViewNode,
    head: new ViewNode
  };
  if (!globalRef.document)
    globalRef.document = snDoc;
  if (typeof window !== "undefined") {
    if (globalRef === window) {} else {
      try {
        globalRef.window = globalRef;
      } catch (e3) {}
    }
  } else {
    globalRef.window = globalRef;
  }
  if (globalRef.__ANDROID__ === undefined)
    globalRef.__ANDROID__ = false;
  if (globalRef.__IOS__ === undefined)
    globalRef.__IOS__ = false;
  return snDoc;
}
function registerNativeElements() {
  const tags = ["page", "actionbar", "stacklayout", "gridlayout", "label", "button", "frame", "tabview", "listview"];
  tags.forEach((tag2) => registerElement(tag2, () => new ViewNode));
}
var initializedDom = false;
function initializeDom() {
  if (initializedDom)
    return;
  initializedDom = true;
  registerNativeElements();
  return installGlobalShims();
}
initializeDom();

// node_modules/@nativescript-community/svelte-native/index.js
global.__onLiveSyncCore = () => {
  Application.getRootView()?._onCssStateChange();
};
function svelteNativeNoFrame(rootElement, data2) {
  if (typeof window !== "undefined" && window.document) {
    console.log("[SvelteNative] Web Preview Mode Activated");
    return new Promise((resolve) => {
      let appRoot = document.getElementById("app-root");
      if (!appRoot) {
        appRoot = document.createElement("div");
        appRoot.id = "app-root";
        document.body.appendChild(appRoot);
      }
      appRoot.innerHTML = "";
      const instance = mount(rootElement, {
        target: appRoot,
        props: data2 || {}
      });
      resolve(instance);
    });
  }
  return new Promise((resolve, reject) => {
    let elementInstance;
    const buildElement = () => {
      let frag = createElement("fragment", window.document);
      console.log("[SvelteNative] buildElement: frag created", frag);
      elementInstance = mount(rootElement, {
        target: frag,
        props: data2 || {}
      });
      console.log("[SvelteNative] buildElement: mount done. childNodes count:", frag.childNodes.length);
      let root = frag.firstChild;
      console.log("[SvelteNative] buildElement: firstChild is", root ? root.constructor.name || root.tagName : "null");
      while (root && (root.nodeType === 8 || root.nodeType === 3 && !root.text?.trim())) {
        console.log("[SvelteNative] skipping node", root.nodeType);
        root = root.nextSibling;
      }
      const result = root ? root.nativeElement || root : frag;
      console.log("[SvelteNative] buildElement: returning", result ? result.constructor.name || result.tagName : "null");
      return result;
    };
    Application.on(Application.launchEvent, () => {
      resolve(elementInstance);
    });
    Application.on(Application.exitEvent, () => {
      unmount(elementInstance);
      elementInstance = null;
    });
    try {
      Application.run({ create: buildElement });
    } catch (e3) {
      reject(e3);
    }
  });
}
initializeDom();

// node_modules/svelte/src/version.js
var PUBLIC_VERSION = "5";

// node_modules/svelte/src/internal/disclose-version.js
if (typeof window !== "undefined") {
  ((window.__svelte ??= {}).v ??= new Set).add(PUBLIC_VERSION);
}

// node_modules/svelte/src/internal/flags/legacy.js
enable_legacy_mode_flag();

// app/components/ConnectionList.svelte
ConnectionList[FILENAME] = "app/components/ConnectionList.svelte";
var root_1 = add_locations(from_html(`
        <!-- svelte-ignore a11y_click_events_have_key_events, a11y_no_static_element_interactions -->
        <gridLayout columns="*, auto" class="connection-item svelte-29xarbly06sed">
            <stackLayout col="0">
                <label class="connection-name svelte-29xarbly06sed"></label>
                <label class="connection-details svelte-29xarbly06sed"></label>
            </stackLayout>
            <label col="1" class="fas" text=""></label>
        </gridLayout>
    `, 1), ConnectionList[FILENAME], [[20, 8, [[21, 12, [[22, 16], [23, 16]]], [25, 12]]]]);
var root_2 = add_locations(from_html(`
        <label text="No connections saved yet." class="p-10"></label>
    `, 1), ConnectionList[FILENAME], [[28, 8]]);
var root = add_locations(from_html(`

<stackLayout class="p-20">
    <label text="Saved Connections" class="h2"></label>
    <!>

    <button text="Add New Connection" class="btn-primary svelte-29xarbly06sed"></button>
</stackLayout>

`, 1), ConnectionList[FILENAME], [[16, 0, [[17, 4], [31, 4]]]]);
function ConnectionList($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ConnectionList);
  let connections = prop($$props, "connections", 19, () => []);
  function connect(conn) {
    console.log(...log_if_contains_state("log", "[ConnectionList] Item tapped:", conn.name));
    if ($$props.onconnect)
      $$props.onconnect(conn);
  }
  function addConnection() {
    console.log("[ConnectionList] Add button tapped");
    if ($$props.onadd)
      $$props.onadd();
  }
  var $$exports = { ...legacy_api() };
  next();
  var fragment = root();
  var stackLayout = sibling2(first_child(fragment));
  var node = sibling2(child(stackLayout), 3);
  add_svelte_meta(() => each(node, 17, connections, index, ($$anchor2, conn) => {
    next();
    var fragment_1 = root_1();
    var node_1 = sibling2(first_child(fragment_1));
    var gridLayout = sibling2(node_1, 2);
    var stackLayout_1 = sibling2(child(gridLayout));
    var label2 = sibling2(child(stackLayout_1));
    var label_1 = sibling2(label2, 2);
    next();
    reset2(stackLayout_1);
    next(3);
    reset2(gridLayout);
    next();
    template_effect(() => {
      set_attribute2(label2, "text", get2(conn).name);
      set_attribute2(label_1, "text", `${get2(conn).user ?? ""}@${get2(conn).host ?? ""}`);
    });
    event("tap", gridLayout, () => connect(get2(conn)));
    append($$anchor2, fragment_1);
  }, ($$anchor2) => {
    next();
    var fragment_2 = root_2();
    next(2);
    append($$anchor2, fragment_2);
  }), "each", ConnectionList, 18, 4);
  var button2 = sibling2(node, 2);
  next();
  reset2(stackLayout);
  next();
  event("tap", button2, addConnection);
  append($$anchor, fragment);
  return pop($$exports);
}
if (undefined) {}
var ConnectionList_default = ConnectionList;

// app/components/Home.svelte
Home[FILENAME] = "app/components/Home.svelte";
var root2 = add_locations(from_html(`

<page>
    <actionBar title="SSH Client"></actionBar>
    <stackLayout class="p-20">
        <!>
        
        <wrapLayout class="footer-container svelte-3oc84ie2vpl4y" orientation="horizontal" horizontalAlignment="center">
            <label text="built with   using " class="footer-text svelte-3oc84ie2vpl4y"></label>
            <!-- svelte-ignore a11y_no_noninteractive_element_interactions, a11y_click_events_have_key_events -->
            <label text="bun" class="link footer-text svelte-3oc84ie2vpl4y"></label>
            <label text=" + " class="footer-text svelte-3oc84ie2vpl4y"></label>
            <!-- svelte-ignore a11y_no_noninteractive_element_interactions, a11y_click_events_have_key_events -->
            <label text="svelte-native" class="link footer-text svelte-3oc84ie2vpl4y"></label>
        </wrapLayout>
    </stackLayout>
</page>

`, 1), Home[FILENAME], [
  [
    40,
    0,
    [
      [41, 4],
      [42, 4, [[45, 8, [[46, 12], [48, 12], [49, 12], [51, 12]]]]]
    ]
  ]
]);
function Home($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Home);
  const SAVED_KEY = "ssh_connections";
  let savedData = exports_index_android4.getString(SAVED_KEY);
  let connections = tag(state(proxy(savedData ? JSON.parse(savedData) : [
    { name: "My VPS", host: "vps.example.com", user: "admin" },
    { name: "Home Lab", host: "192.168.1.100", user: "pi" }
  ])), "connections");
  function save2() {
    exports_index_android4.setString(SAVED_KEY, JSON.stringify(get2(connections)));
    console.log("Connections saved to storage.");
  }
  function addNew() {
    console.log("Adding new dummy connection...");
    set2(connections, [
      ...get2(connections),
      {
        name: "Server " + (get2(connections).length + 1),
        host: "10.0.0." + (get2(connections).length + 1),
        user: "root"
      }
    ], true);
    save2();
  }
  function handleConnect(conn) {
    alert(`Connecting to ${conn.user}@${conn.host}...`);
  }
  function openLink(url) {
    console.log(...log_if_contains_state("log", "Opening URL via Utils:", url));
    exports_index_android3.openUrl(url);
  }
  var $$exports = { ...legacy_api() };
  next();
  var fragment = root2();
  var page = sibling2(first_child(fragment));
  var stackLayout = sibling2(child(page), 3);
  var node = sibling2(child(stackLayout));
  add_svelte_meta(() => ConnectionList_default(node, {
    get connections() {
      return get2(connections);
    },
    onadd: addNew,
    onconnect: handleConnect
  }), "component", Home, 43, 8, { componentTag: "ConnectionList" });
  var wrapLayout = sibling2(node, 2);
  var node_1 = sibling2(child(wrapLayout), 3);
  var label2 = sibling2(node_1, 2);
  var node_2 = sibling2(label2, 4);
  var label_1 = sibling2(node_2, 2);
  next();
  reset2(wrapLayout);
  next();
  reset2(stackLayout);
  next();
  reset2(page);
  next();
  event("tap", label2, () => openLink("https://bun.sh"));
  event("tap", label_1, () => openLink("https://svelte.nativescript.org/"));
  append($$anchor, fragment);
  return pop($$exports);
}
if (undefined) {}
var Home_default = Home;

// app/App.svelte
App[FILENAME] = "app/App.svelte";
var root3 = add_locations(from_html(`<!>

`, 1), App[FILENAME], []);
function App($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, App);
  var $$exports = { ...legacy_api() };
  var fragment = root3();
  var node = first_child(fragment);
  add_svelte_meta(() => Home_default(node, {}), "component", App, 1, 0, { componentTag: "Home" });
  next();
  append($$anchor, fragment);
  return pop($$exports);
}
if (undefined) {}
var App_default = App;

// app/app.ts
svelteNativeNoFrame(App_default, {});
